<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › qib › qib_init.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>qib_init.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, 2007, 2008, 2009, 2010 QLogic Corporation.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;qib.h&quot;</span>
<span class="cp">#include &quot;qib_common.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * min buffers we want to have per context, after driver</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_MIN_USER_CTXT_BUFCNT 7</span>

<span class="cp">#define QLOGIC_IB_R_SOFTWARE_MASK 0xFF</span>
<span class="cp">#define QLOGIC_IB_R_SOFTWARE_SHIFT 24</span>
<span class="cp">#define QLOGIC_IB_R_EMULATOR_MASK (1ULL&lt;&lt;62)</span>

<span class="cm">/*</span>
<span class="cm"> * Number of ctxts we are configured to use (to allow for more pio</span>
<span class="cm"> * buffers per ctxt, etc.)  Zero means use chip value.</span>
<span class="cm"> */</span>
<span class="n">ushort</span> <span class="n">qib_cfgctxts</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">cfgctxts</span><span class="p">,</span> <span class="n">qib_cfgctxts</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cfgctxts</span><span class="p">,</span> <span class="s">&quot;Set max number of contexts to use&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If set, do not write to any regs if avoidable, hack to allow</span>
<span class="cm"> * check for deranged default register values.</span>
<span class="cm"> */</span>
<span class="n">ushort</span> <span class="n">qib_mini_init</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">mini_init</span><span class="p">,</span> <span class="n">qib_mini_init</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mini_init</span><span class="p">,</span> <span class="s">&quot;If set, do minimal diag init&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="n">qib_n_krcv_queues</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">krcvqs</span><span class="p">,</span> <span class="n">qib_n_krcv_queues</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">krcvqs</span><span class="p">,</span> <span class="s">&quot;number of kernel receive queues per IB port&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * qib_wc_pat parameter:</span>
<span class="cm"> *      0 is WC via MTRR</span>
<span class="cm"> *      1 is WC via PAT</span>
<span class="cm"> *      If PAT initialization fails, code reverts back to MTRR</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="n">qib_wc_pat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* default (1) is to use PAT, not MTRR */</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">wc_pat</span><span class="p">,</span> <span class="n">qib_wc_pat</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">wc_pat</span><span class="p">,</span> <span class="s">&quot;enable write-combining via PAT mechanism&quot;</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">qib_cq_wq</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">verify_interrupt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">idr</span> <span class="n">qib_unit_table</span><span class="p">;</span>
<span class="n">u32</span> <span class="n">qib_cpulist_count</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">qib_cpulist</span><span class="p">;</span>

<span class="cm">/* set number of contexts we&#39;ll actually use */</span>
<span class="kt">void</span> <span class="nf">qib_set_ctxtcnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_cfgctxts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span> <span class="o">+</span> <span class="n">num_online_cpus</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">&gt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ctxtcnt</span><span class="p">)</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ctxtcnt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qib_cfgctxts</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ctxtcnt</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qib_cfgctxts</span> <span class="o">&lt;=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ctxtcnt</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">=</span> <span class="n">qib_cfgctxts</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ctxtcnt</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">freectxts</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span> <span class="o">&gt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">-</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common code for creating the receive context array.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qib_create_ctxts</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate full ctxtcnt array, rather than just cfgctxts, because</span>
<span class="cm">	 * cleanup iterates across all possible ctxts.</span>
<span class="cm">	 */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">)</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ctxtcnt</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Unable to allocate ctxtdata array, &quot;</span>
			    <span class="s">&quot;failing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* create (one or more) kctxt */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">skip_kctxt_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">);</span>
		<span class="n">rcd</span> <span class="o">=</span> <span class="n">qib_create_ctxtdata</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Unable to allocate ctxtdata&quot;</span>
				    <span class="s">&quot; for Kernel ctxt, failing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">pkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">QIB_DEFAULT_P_KEY</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">seq_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common code for user and kernel context setup.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="nf">qib_create_ctxtdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ctxt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">;</span>

	<span class="n">rcd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rcd</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">qp_wait_list</span><span class="p">);</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ppd</span> <span class="o">=</span> <span class="n">ppd</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dd</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ctxt</span> <span class="o">=</span> <span class="n">ctxt</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">[</span><span class="n">ctxt</span><span class="p">]</span> <span class="o">=</span> <span class="n">rcd</span><span class="p">;</span>

		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_init_ctxt</span><span class="p">(</span><span class="n">rcd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * To avoid wasting a lot of memory, we allocate 32KB chunks</span>
<span class="cm">		 * of physically contiguous memory, advance through it until</span>
<span class="cm">		 * used up and then allocate more.  Of course, we need</span>
<span class="cm">		 * memory to store those extra pointers, now.  32KB seems to</span>
<span class="cm">		 * be the most that is &quot;safe&quot; under memory pressure</span>
<span class="cm">		 * (creating large files and then copying them over</span>
<span class="cm">		 * NFS while doing lots of MPI jobs).  The OOM killer can</span>
<span class="cm">		 * get invoked, even though we say we can sleep and this can</span>
<span class="cm">		 * cause significant system problems....</span>
<span class="cm">		 */</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_size</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbufs_perchunk</span> <span class="o">=</span>
			<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_size</span> <span class="o">/</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvegrbufsize</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_chunks</span> <span class="o">=</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrcnt</span> <span class="o">+</span>
			<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbufs_perchunk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
			<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbufs_perchunk</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbufs_perchunk</span><span class="p">));</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbufs_perchunk_shift</span> <span class="o">=</span>
			<span class="n">ilog2</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbufs_perchunk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rcd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common code for initializing the physical port structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_init_pportdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
			<span class="n">u8</span> <span class="n">hw_pidx</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dd</span><span class="p">;</span>
	<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hw_pidx</span> <span class="o">=</span> <span class="n">hw_pidx</span><span class="p">;</span>
	<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span> <span class="cm">/* IB port number, not index */</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">sdma_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">state_wait</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">symerr_clear_timer</span><span class="p">);</span>
	<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">symerr_clear_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">qib_clear_symerror_on_linkup</span><span class="p">;</span>
	<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">symerr_clear_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ppd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_pioavailregs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">pidx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">status_page</span><span class="p">;</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span>
		<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_phys</span><span class="p">,</span>
		<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;failed to allocate PIOavail reg area &quot;</span>
			    <span class="s">&quot;in memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We really want L2 cache aligned, but for current CPUs of</span>
<span class="cm">	 * interest, they are the same.</span>
<span class="cm">	 */</span>
	<span class="n">status_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span> <span class="o">+</span>
		 <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">L1_CACHE_BYTES</span> <span class="o">+</span>
		   <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavregs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">L1_CACHE_BYTES</span><span class="p">));</span>
	<span class="cm">/* device status comes first, for backwards compatibility */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">devstatusp</span> <span class="o">=</span> <span class="n">status_page</span><span class="p">;</span>
	<span class="o">*</span><span class="n">status_page</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">statusp</span> <span class="o">=</span> <span class="n">status_page</span><span class="p">;</span>
		<span class="o">*</span><span class="n">status_page</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup buffer to hold freeze and other messages, accessible to</span>
<span class="cm">	 * apps, following statusp.  This is per-unit, not per port.</span>
<span class="cm">	 */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">freezemsg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">status_page</span><span class="p">;</span>
	<span class="o">*</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">freezemsg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* length of msg buffer is &quot;whatever is left&quot; */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">status_page</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">freezelen</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_shadow_tids - allocate the shadow TID array</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> *</span>
<span class="cm"> * allocate the shadow TID array, so we can qib_munlock previous</span>
<span class="cm"> * entries.  It may make more sense to move the pageshadow to the</span>
<span class="cm"> * ctxt data structure, so we only allocate memory for ctxts actually</span>
<span class="cm"> * in use, since we at 8k per ctxt, now.</span>
<span class="cm"> * We don&#39;t want failures here to prevent use of the driver/chip,</span>
<span class="cm"> * so no return value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_shadow_tids</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">addrs</span><span class="p">;</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvtidcnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;failed to allocate shadow page * &quot;</span>
			    <span class="s">&quot;array, no expected sends!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">addrs</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvtidcnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;failed to allocate shadow dma handle &quot;</span>
			    <span class="s">&quot;array, no expected sends!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pageshadow</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">physshadow</span> <span class="o">=</span> <span class="n">addrs</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">bail_free:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
<span class="nl">bail:</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pageshadow</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do initialization for device that is only needed on</span>
<span class="cm"> * first detect, not on resets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">loadtime_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;&gt;</span> <span class="n">QLOGIC_IB_R_SOFTWARE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
	     <span class="n">QLOGIC_IB_R_SOFTWARE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">QIB_CHIP_SWVERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Driver only handles version %d, &quot;</span>
			    <span class="s">&quot;chip swversion is %d (%llx), failng</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">QIB_CHIP_SWVERSION</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;&gt;</span>
				<span class="n">QLOGIC_IB_R_SOFTWARE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="n">QLOGIC_IB_R_SOFTWARE_MASK</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&amp;</span> <span class="n">QLOGIC_IB_R_EMULATOR_MASK</span><span class="p">)</span>
		<span class="n">qib_devinfo</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">boardversion</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">sendctrl_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uctxt_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">qib_diag_trans_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">eep_st_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">eep_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qib_mini_init</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">init_pioavailregs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">init_shadow_tids</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">qib_get_eeprom_info</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/* setup time (don&#39;t start yet) to verify we got interrupt */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">intrchk_timer</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">intrchk_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">verify_interrupt</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">intrchk_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dd</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_after_reset - re-initialize after a reset</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> *</span>
<span class="cm"> * sanity check at least some of the values after reset, and</span>
<span class="cm"> * ensure no receive or transmit (explicitly, in case reset</span>
<span class="cm"> * failed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_after_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure chip does no sends or receives, tail updates, or</span>
<span class="cm">	 * pioavail updates while we re-initialize.  This is mostly</span>
<span class="cm">	 * for the driver data structures, not chip registers.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * ctxt == -1 means &quot;all contexts&quot;. Only really safe for</span>
<span class="cm">		 * _dis_abling things, as here.</span>
<span class="cm">		 */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_rcvctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">QIB_RCVCTRL_CTXT_DIS</span> <span class="o">|</span>
				  <span class="n">QIB_RCVCTRL_INTRAVAIL_DIS</span> <span class="o">|</span>
				  <span class="n">QIB_RCVCTRL_TAILUPD_DIS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* Redundant across ports for some, but no big deal.  */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_SEND_DIS</span> <span class="o">|</span>
			<span class="n">QIB_SENDCTRL_AVAIL_DIS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rcvmask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable PIO send, and update of PIOavail regs to memory.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_SEND_ENB</span> <span class="o">|</span>
			<span class="n">QIB_SENDCTRL_AVAIL_ENB</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable kernel ctxts&#39; receive and receive interrupt.</span>
<span class="cm">	 * Other ctxts done as user opens and inits them.</span>
<span class="cm">	 */</span>
	<span class="n">rcvmask</span> <span class="o">=</span> <span class="n">QIB_RCVCTRL_CTXT_ENB</span> <span class="o">|</span> <span class="n">QIB_RCVCTRL_INTRAVAIL_ENB</span><span class="p">;</span>
	<span class="n">rcvmask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_NODMA_RTAIL</span><span class="p">)</span> <span class="o">?</span>
		  <span class="n">QIB_RCVCTRL_TAILUPD_DIS</span> <span class="o">:</span> <span class="n">QIB_RCVCTRL_TAILUPD_ENB</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="p">)</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_rcvctrl</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ppd</span><span class="p">,</span> <span class="n">rcvmask</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">verify_interrupt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">opaque</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span> <span class="cm">/* being torn down */</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have a lid or any interrupts, let the user know and</span>
<span class="cm">	 * don&#39;t bother checking again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">int_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_intr_fallback</span><span class="p">(</span><span class="n">dd</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No interrupts detected, &quot;</span>
				<span class="s">&quot;not usable.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="cm">/* re-arm the timer to see if fallback works */</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">intrchk_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_piobuf_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">pidx</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">uctxts</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure all buffers are free, and fifos empty.  Buffers</span>
<span class="cm">	 * are common, so only do once for port 0.</span>
<span class="cm">	 *</span>
<span class="cm">	 * After enable and qib_chg_pioavailkernel so we can safely</span>
<span class="cm">	 * enable pioavail updates and PIOENABLE.  After this, packets</span>
<span class="cm">	 * are ready and able to go out.</span>
<span class="cm">	 */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_DISARM_ALL</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_FLUSH</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If not all sendbufs are used, add the one to each of the lower</span>
<span class="cm">	 * numbered contexts.  pbufsctxt and lastctxt_piobuf are</span>
<span class="cm">	 * calculated in chip-specific code because it may cause some</span>
<span class="cm">	 * chip-specific adjustments to be made.</span>
<span class="cm">	 */</span>
	<span class="n">uctxts</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span> <span class="o">-</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ctxts_extrabuf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pbufsctxt</span> <span class="o">?</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">lastctxt_piobuf</span> <span class="o">-</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pbufsctxt</span> <span class="o">*</span> <span class="n">uctxts</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the shadow copies of the piobufavail registers,</span>
<span class="cm">	 * which we compare against the chip registers for now, and</span>
<span class="cm">	 * the in memory DMA&#39;ed copies of the registers.</span>
<span class="cm">	 * By now pioavail updates to memory should have occurred, so</span>
<span class="cm">	 * copy them into our working/shadow registers; this is in</span>
<span class="cm">	 * case something went wrong with abort, but mostly to get the</span>
<span class="cm">	 * initial values of the generation bit correct.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavregs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__le64</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t need to worry about pioavailkernel here</span>
<span class="cm">		 * because we will call qib_chg_pioavailkernel() later</span>
<span class="cm">		 * in initialization, to busy out buffers as needed.</span>
<span class="cm">		 */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">))</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* for debugging sanity */</span>

	<span class="cm">/* after pioavailshadow is setup */</span>
	<span class="n">qib_chg_pioavailkernel</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt2k</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt4k</span><span class="p">,</span>
			       <span class="n">TXCHK_CHG_TYPE_KERN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_initvl15_bufs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qib_init - do the actual initialization sequence on the chip</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> * @reinit: reinitializing, so don&#39;t allocate new memory</span>
<span class="cm"> *</span>
<span class="cm"> * Do the actual initialization sequence on the chip.  This is done</span>
<span class="cm"> * both from the init routine called from the PCI infrastructure, and</span>
<span class="cm"> * when we reset the chip, or detect that it was reset internally,</span>
<span class="cm"> * or it&#39;s administratively re-enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Memory allocation here and in called routines is only done in</span>
<span class="cm"> * the first case (reinit == 0).  We have to be careful, because even</span>
<span class="cm"> * without memory allocation, we need to re-write all the chip registers</span>
<span class="cm"> * TIDs, etc. after the reset or enable has completed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qib_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reinit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">lastfail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">portok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Set linkstate to unknown, so we can watch for a transition. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">QIBL_LINKACTIVE</span> <span class="o">|</span> <span class="n">QIBL_LINKARMED</span> <span class="o">|</span>
				 <span class="n">QIBL_LINKDOWN</span> <span class="o">|</span> <span class="n">QIBL_LINKINIT</span> <span class="o">|</span>
				 <span class="n">QIBL_LINKV</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reinit</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">init_after_reset</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">loadtime_init</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* Bypass most chip-init, to get to device creation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qib_mini_init</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_late_initreg</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* dd-&gt;rcd can be NULL if early init failed */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set up the (kernel) rcvhdr queue and egr TIDs.  If doing</span>
<span class="cm">		 * re-init, the simplest way to handle this is to free</span>
<span class="cm">		 * existing, and re-allocate.</span>
<span class="cm">		 * Need to re-create rest of ctxt 0 ctxtdata as well.</span>
<span class="cm">		 */</span>
		<span class="n">rcd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">lastfail</span> <span class="o">=</span> <span class="n">qib_create_rcvhdrq</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">rcd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lastfail</span><span class="p">)</span>
			<span class="n">lastfail</span> <span class="o">=</span> <span class="n">qib_setup_eagerbufs</span><span class="p">(</span><span class="n">rcd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastfail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;failed to allocate kernel ctxt&#39;s &quot;</span>
				    <span class="s">&quot;rcvhdrq and/or egr bufs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastfail</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">lastfail</span><span class="p">;</span>
		<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="n">mtu</span> <span class="o">=</span> <span class="n">ib_mtu_enum_to_int</span><span class="p">(</span><span class="n">qib_ibmtu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtu</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mtu</span> <span class="o">=</span> <span class="n">QIB_DEFAULT_MTU</span><span class="p">;</span>
			<span class="n">qib_ibmtu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* don&#39;t leave invalid value */</span>
		<span class="p">}</span>
		<span class="cm">/* set max we can ever have for this driver load */</span>
		<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">init_ibmaxlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="mi">2048</span> <span class="o">?</span>
					 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piosize4k</span> <span class="o">:</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piosize2k</span><span class="p">,</span>
					 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvegrbufsize</span> <span class="o">+</span>
					 <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvhdrentsize</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Have to initialize ibmaxlen, but this will normally</span>
<span class="cm">		 * change immediately in qib_set_mtu().</span>
<span class="cm">		 */</span>
		<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">ibmaxlen</span> <span class="o">=</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">init_ibmaxlen</span><span class="p">;</span>
		<span class="n">qib_set_mtu</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span> <span class="n">mtu</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags</span> <span class="o">|=</span> <span class="n">QIBL_IB_LINK_DISABLED</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">lastfail</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_bringup_serdes</span><span class="p">(</span><span class="n">ppd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastfail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_devinfo</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span>
				 <span class="s">&quot;Failed to bringup IB port %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
			<span class="n">lastfail</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETDOWN</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">portok</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">portok</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* none of the ports initialized */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">lastfail</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">lastfail</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETDOWN</span><span class="p">;</span>
		<span class="cm">/* but continue on, so we can debug cause */</span>
	<span class="p">}</span>

	<span class="n">enable_chip</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">init_piobuf_state</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* chip is OK for user apps; mark it as initialized */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Set status even if port serdes is not initialized</span>
<span class="cm">			 * so that diags will work.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">statusp</span> <span class="o">|=</span> <span class="n">QIB_STATUS_CHIP_PRESENT</span> <span class="o">|</span>
				<span class="n">QIB_STATUS_INITTED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">link_speed_enabled</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_HAS_SEND_DMA</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_setup_sdma</span><span class="p">(</span><span class="n">ppd</span><span class="p">);</span>
			<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_timer</span><span class="p">);</span>
			<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">qib_hol_event</span><span class="p">;</span>
			<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ppd</span><span class="p">;</span>
			<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_state</span> <span class="o">=</span> <span class="n">QIB_HOL_UP</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* now we can enable all interrupts from the chip */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_set_intr_state</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Setup to verify we get an interrupt, and fallback</span>
<span class="cm">		 * to an alternate if necessary and possible.</span>
<span class="cm">		 */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">intrchk_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="cm">/* start stats retrieval timer */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">stats_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">ACTIVITY_TIMER</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if ret is non-zero, we probably should do some cleanup here... */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These next two routines are placeholders in case we don&#39;t have per-arch</span>
<span class="cm"> * code for controlling write combining.  If explicit control of write</span>
<span class="cm"> * combining is not available, performance will probably be awful.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">qib_enable_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">qib_disable_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="nf">__qib_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_unit_table</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="nf">qib_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dd</span> <span class="o">=</span> <span class="n">__qib_lookup</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Stop the timers during unit shutdown, or after an error late</span>
<span class="cm"> * in initialization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qib_stop_timers</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">stats_timer</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">stats_timer</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">stats_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">intrchk_timer</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">intrchk_timer</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">intrchk_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_timer</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
			<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_timer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">led_override_timer</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">led_override_timer</span><span class="p">);</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">led_override_timer_active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">symerr_clear_timer</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
			<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">symerr_clear_timer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qib_shutdown_device - shut down a device</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> *</span>
<span class="cm"> * This is called to make the device quiet when we are about to</span>
<span class="cm"> * unload the driver, and also when the device is administratively</span>
<span class="cm"> * disabled.   It does not free any data structures.</span>
<span class="cm"> * Everything it does has to be setup again by qib_init(dd, 1)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qib_shutdown_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pidx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags_lock</span><span class="p">);</span>
		<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">QIBL_LINKDOWN</span> <span class="o">|</span> <span class="n">QIBL_LINKINIT</span> <span class="o">|</span>
				 <span class="n">QIBL_LINKARMED</span> <span class="o">|</span> <span class="n">QIBL_LINKACTIVE</span> <span class="o">|</span>
				 <span class="n">QIBL_LINKV</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags_lock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">statusp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">QIB_STATUS_IB_CONF</span> <span class="o">|</span> <span class="n">QIB_STATUS_IB_READY</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QIB_INITTED</span><span class="p">;</span>

	<span class="cm">/* mask interrupts, but not errors */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_set_intr_state</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_rcvctrl</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span> <span class="n">QIB_RCVCTRL_TAILUPD_DIS</span> <span class="o">|</span>
				   <span class="n">QIB_RCVCTRL_CTXT_DIS</span> <span class="o">|</span>
				   <span class="n">QIB_RCVCTRL_INTRAVAIL_DIS</span> <span class="o">|</span>
				   <span class="n">QIB_RCVCTRL_PKEY_ENB</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Gracefully stop all sends allowing any in progress to</span>
<span class="cm">		 * trickle out first.</span>
<span class="cm">		 */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_CLEAR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enough for anything that&#39;s going to trickle out to have actually</span>
<span class="cm">	 * done so.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_setextled</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* make sure LEDs are off */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_HAS_SEND_DMA</span><span class="p">)</span>
			<span class="n">qib_teardown_sdma</span><span class="p">(</span><span class="n">ppd</span><span class="p">);</span>

		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_AVAIL_DIS</span> <span class="o">|</span>
				    <span class="n">QIB_SENDCTRL_SEND_DIS</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Clear SerdesEnable.</span>
<span class="cm">		 * We can&#39;t count on interrupts since we are stopping.</span>
<span class="cm">		 */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_quiet_serdes</span><span class="p">(</span><span class="n">ppd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">qib_update_eeprom_log</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qib_free_ctxtdata - free a context&#39;s allocated data</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> * @rcd: the ctxtdata structure</span>
<span class="cm"> *</span>
<span class="cm"> * free up any allocated data for a context</span>
<span class="cm"> * This should not touch anything that would affect a simultaneous</span>
<span class="cm"> * re-allocation of context data, because it is called after qib_mutex</span>
<span class="cm"> * is released (and can be called from reinit as well).</span>
<span class="cm"> * It should never change any chip state, or global driver state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_free_ctxtdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq_size</span><span class="p">,</span>
				  <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq_phys</span><span class="p">);</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
					  <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span><span class="p">,</span>
					  <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrqtailaddr_phys</span><span class="p">);</span>
			<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">e</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_chunks</span><span class="p">;</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">[</span><span class="n">e</span><span class="p">];</span>
			<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_size</span><span class="p">;</span>

			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					  <span class="n">base</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">[</span><span class="n">e</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">);</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">);</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">tid_pg_list</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">subctxt_uregbase</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">subctxt_rcvegrbuf</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">subctxt_rcvhdr_base</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform a PIO buffer bandwidth write test, to verify proper system</span>
<span class="cm"> * configuration.  Even when all the setup calls work, occasionally</span>
<span class="cm"> * BIOS or other issues can prevent write combining from working, or</span>
<span class="cm"> * can cause other bandwidth problems to the chip.</span>
<span class="cm"> *</span>
<span class="cm"> * This test simply writes the same buffer over and over again, and</span>
<span class="cm"> * measures close to the peak bandwidth to the chip (not testing</span>
<span class="cm"> * data bandwidth to the wire).   On chips that use an address-based</span>
<span class="cm"> * trigger to send packets to the wire, this is easy.  On chips that</span>
<span class="cm"> * use a count to trigger, we want to make sure that the packet doesn&#39;t</span>
<span class="cm"> * go out on the wire, or trigger flow control checks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qib_verify_pioperf</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pbnum</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">lcnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">piobuf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">msecs</span><span class="p">,</span> <span class="n">emsecs</span><span class="p">;</span>

	<span class="n">piobuf</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_getsendbuf</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">piobuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_devinfo</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span>
			 <span class="s">&quot;No PIObufs for checking perf, skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enough to give us a reasonable test, less than piobuf size, and</span>
<span class="cm">	 * likely multiple of store buffer length.</span>
<span class="cm">	 */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_devinfo</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span>
			 <span class="s">&quot;Couldn&#39;t get memory for checking PIO perf,&quot;</span>
			 <span class="s">&quot; skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">preempt_disable</span><span class="p">();</span>  <span class="cm">/* we want reasonably accurate elapsed time */</span>
	<span class="n">msecs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lcnt</span> <span class="o">&lt;</span> <span class="mi">10000U</span><span class="p">;</span> <span class="n">lcnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* wait until we cross msec boundary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">msecs</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_set_armlaunch</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * length 0, no dwords actually sent</span>
<span class="cm">	 */</span>
	<span class="n">writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">piobuf</span><span class="p">);</span>
	<span class="n">qib_flush_wc</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is only roughly accurate, since even with preempt we</span>
<span class="cm">	 * still take interrupts that could take a while.   Running for</span>
<span class="cm">	 * &gt;= 5 msec seems to get us &quot;close enough&quot; to accurate values.</span>
<span class="cm">	 */</span>
	<span class="n">msecs</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">emsecs</span> <span class="o">=</span> <span class="n">lcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">emsecs</span> <span class="o">&lt;=</span> <span class="mi">5UL</span><span class="p">;</span> <span class="n">lcnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_pio_copy</span><span class="p">(</span><span class="n">piobuf</span> <span class="o">+</span> <span class="mi">64</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">emsecs</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">)</span> <span class="o">-</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* 1 GiB/sec, slightly over IB SDR line rate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lcnt</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">emsecs</span> <span class="o">*</span> <span class="mi">1024U</span><span class="p">))</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span>
			    <span class="s">&quot;Performance problem: bandwidth to PIO buffers is &quot;</span>
			    <span class="s">&quot;only %u MiB/sec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">lcnt</span> <span class="o">/</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">emsecs</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="cm">/* disarm piobuf, so it&#39;s available again */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_DISARM_BUF</span><span class="p">(</span><span class="n">pbnum</span><span class="p">));</span>
	<span class="n">qib_sendbuf_done</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">pbnum</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_set_armlaunch</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">qib_free_devdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_unit_table</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ib_dealloc_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">verbs_dev</span><span class="p">.</span><span class="n">ibdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate our primary per-unit data structure.  Must be done via verbs</span>
<span class="cm"> * allocator, because the verbs cleanup process both does cleanup and</span>
<span class="cm"> * free of the data structure.</span>
<span class="cm"> * &quot;extra&quot; is for chip-specific data.</span>
<span class="cm"> *</span>
<span class="cm"> * Use the idr mechanism to get a unit number for this unit.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="nf">qib_alloc_devdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">extra</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_unit_table</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">)</span> <span class="n">ib_alloc_device</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dd</span><span class="p">)</span> <span class="o">+</span> <span class="n">extra</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_unit_table</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">unit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qib_dev_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_early_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			      <span class="s">&quot;Could not allocate unit ID: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">ib_dealloc_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">verbs_dev</span><span class="p">.</span><span class="n">ibdev</span><span class="p">);</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_cpulist_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">count</span> <span class="o">=</span> <span class="n">num_online_cpus</span><span class="p">();</span>
		<span class="n">qib_cpulist</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">*</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qib_cpulist</span><span class="p">)</span>
			<span class="n">qib_cpulist_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">qib_early_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not alloc cpulist &quot;</span>
				      <span class="s">&quot;info, cpu affinity might be wrong</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">dd</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from freeze mode handlers, and from PCI error</span>
<span class="cm"> * reporting code.  Should be paranoid about state of</span>
<span class="cm"> * system and data structures.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_disable_after_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_INITTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">pidx</span><span class="p">;</span>

		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QIB_INITTED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">;</span>

				<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_PRESENT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">qib_set_linkstate</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span>
						<span class="n">QIB_IB_LINKDOWN_DISABLE</span><span class="p">);</span>
					<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_setextled</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="o">*</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">statusp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QIB_STATUS_IB_READY</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark as having had an error for driver, and also</span>
<span class="cm">	 * for /sys and status word mapped to user programs.</span>
<span class="cm">	 * This marks unit as not usable, until reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">devstatusp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">devstatusp</span> <span class="o">|=</span> <span class="n">QIB_STATUS_HWERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="n">qib_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">qib_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#define DRIVER_LOAD_MSG &quot;QLogic &quot; QIB_DRV_NAME &quot; loaded: &quot;</span>
<span class="cp">#define PFX QIB_DRV_NAME &quot;: &quot;</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">qib_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_PATHSCALE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_QLOGIC_IB_6120</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_QLOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_QLOGIC_IB_7220</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_QLOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_QLOGIC_IB_7322</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">qib_pci_tbl</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">qib_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">QIB_DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">qib_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">qib_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">qib_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">err_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qib_pci_err_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Do all the generic driver unit- and chip-independent memory</span>
<span class="cm"> * allocation and initialization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">qlogic_ib_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_dev_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">qib_cq_wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;qib_cq&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_cq_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail_dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * These must be called before the driver is registered with</span>
<span class="cm">	 * the PCI subsystem.</span>
<span class="cm">	 */</span>
	<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_unit_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_unit_table</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">QIB_DRV_NAME</span> <span class="s">&quot;: idr_pre_get() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail_cq_wq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">QIB_DRV_NAME</span>
		       <span class="s">&quot;: Unable to register driver: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail_unit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* not fatal if it doesn&#39;t work */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qib_init_qibfs</span><span class="p">())</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">QIB_DRV_NAME</span> <span class="s">&quot;: Unable to register ipathfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span> <span class="cm">/* all OK */</span>

<span class="nl">bail_unit:</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_unit_table</span><span class="p">);</span>
<span class="nl">bail_cq_wq:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">qib_cq_wq</span><span class="p">);</span>
<span class="nl">bail_dev:</span>
	<span class="n">qib_dev_cleanup</span><span class="p">();</span>
<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">qlogic_ib_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Do the non-unit driver cleanup, memory free, etc. at unload.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">qlogic_ib_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_exit_qibfs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">QIB_DRV_NAME</span> <span class="s">&quot;: &quot;</span>
			<span class="s">&quot;Unable to cleanup counter filesystem: &quot;</span>
			<span class="s">&quot;error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_driver</span><span class="p">);</span>

	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">qib_cq_wq</span><span class="p">);</span>

	<span class="n">qib_cpulist_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">qib_cpulist</span><span class="p">);</span>

	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qib_unit_table</span><span class="p">);</span>
	<span class="n">qib_dev_cleanup</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">qlogic_ib_cleanup</span><span class="p">);</span>

<span class="cm">/* this can only be called after a successful initialization */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_device_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">**</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* users can&#39;t do anything more with chip */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">statusp</span><span class="p">)</span>
			<span class="o">*</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">statusp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">QIB_STATUS_CHIP_PRESENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_wc_pat</span><span class="p">)</span>
		<span class="n">qib_disable_wc</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span><span class="p">,</span>
				  <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_phys</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pageshadow</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">tmpp</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pageshadow</span><span class="p">;</span>
		<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">tmpd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">physshadow</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ctxt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ctxt</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span><span class="p">;</span> <span class="n">ctxt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ctxt_tidbase</span> <span class="o">=</span> <span class="n">ctxt</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvtidcnt</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">maxtid</span> <span class="o">=</span> <span class="n">ctxt_tidbase</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvtidcnt</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ctxt_tidbase</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxtid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmpp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">tmpd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					       <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">qib_release_user_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">tmpp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">tmpp</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pageshadow</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pageshadow</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">tmpp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free any resources still in use (usually just kernel contexts)</span>
<span class="cm">	 * at unload; we do for ctxtcnt, because that&#39;s what we allocate.</span>
<span class="cm">	 * We acquire lock to be really paranoid that rcd isn&#39;t being</span>
<span class="cm">	 * accessed from some interrupt-related code (that should not happen,</span>
<span class="cm">	 * but best to be sure).</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ctxt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">ctxt</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ctxtcnt</span><span class="p">;</span> <span class="n">ctxt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">ctxt</span><span class="p">];</span>

		<span class="n">tmp</span><span class="p">[</span><span class="n">ctxt</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* debugging paranoia */</span>
		<span class="n">qib_free_ctxtdata</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">rcd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">boardname</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up on unit shutdown, or error during unit load after</span>
<span class="cm"> * successful initialization.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">qib_postinit_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clean up chip-specific stuff.</span>
<span class="cm">	 * We check for NULL here, because it&#39;s outside</span>
<span class="cm">	 * the kregbase check, and we need to call it</span>
<span class="cm">	 * after the free_irq.  Thus it&#39;s possible that</span>
<span class="cm">	 * the function pointers were never initialized.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_cleanup</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">qib_pcie_ddcleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">cleanup_device_data</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">qib_free_devdata</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">qib_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">initfail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_pcie_init</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do device-specific initialiation, function table setup, dd</span>
<span class="cm">	 * allocation, etc.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_QLOGIC_IB_6120</span>:
<span class="cp">#ifdef CONFIG_PCI_MSI</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">qib_init_iba6120_funcs</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">qib_early_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;QLogic PCIE device 0x%x cannot &quot;</span>
		      <span class="s">&quot;work if CONFIG_PCI_MSI is not enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">ent</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_QLOGIC_IB_7220</span>:
		<span class="n">dd</span> <span class="o">=</span> <span class="n">qib_init_iba7220_funcs</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_QLOGIC_IB_7322</span>:
		<span class="n">dd</span> <span class="o">=</span> <span class="n">qib_init_iba7322_funcs</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ent</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">qib_early_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failing on unknown QLogic &quot;</span>
			      <span class="s">&quot;deviceid 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dd</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span> <span class="cm">/* error already printed */</span>

	<span class="cm">/* do the generic initialization */</span>
	<span class="n">initfail</span> <span class="o">=</span> <span class="n">qib_init</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_register_ib_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now ready for use.  this should be cleared whenever we</span>
<span class="cm">	 * detect a reset, or initiate one.  If earlier failure,</span>
<span class="cm">	 * we still create devices, so diags, etc. can be used</span>
<span class="cm">	 * to determine cause of problem.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_mini_init</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">initfail</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">QIB_INITTED</span><span class="p">;</span>

	<span class="n">j</span> <span class="o">=</span> <span class="n">qib_device_create</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to create /dev devices: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="p">);</span>
	<span class="n">j</span> <span class="o">=</span> <span class="n">qibfs_add</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed filesystem setup for counters: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="o">-</span><span class="n">j</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qib_mini_init</span> <span class="o">||</span> <span class="n">initfail</span> <span class="o">||</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_stop_timers</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">ib_wq</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="o">++</span><span class="n">pidx</span><span class="p">)</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_quiet_serdes</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qib_mini_init</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">qibfs_remove</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
			<span class="n">qib_device_remove</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">qib_unregister_ib_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="n">qib_postinit_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">initfail</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">initfail</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_wc_pat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_enable_wc</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Write combining not enabled &quot;</span>
				    <span class="s">&quot;(err %d): performance may be poor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">qib_verify_pioperf</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">qib_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* unregister from IB core */</span>
	<span class="n">qib_unregister_ib_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable the IB link, disable interrupts on the device,</span>
<span class="cm">	 * clear dma engines, etc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_mini_init</span><span class="p">)</span>
		<span class="n">qib_shutdown_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">qib_stop_timers</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/* wait until all of our (qsfp) queue_work() calls complete */</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">ib_wq</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qibfs_remove</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed counters filesystem cleanup: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="o">-</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">qib_device_remove</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">qib_postinit_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qib_create_rcvhdrq - create a receive header queue</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> * @rcd: the context data</span>
<span class="cm"> *</span>
<span class="cm"> * This must be contiguous memory (from an i/o perspective), and must be</span>
<span class="cm"> * DMA&#39;able (which means for some systems, it will go through an IOMMU,</span>
<span class="cm"> * or be forced into a low address range).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qib_create_rcvhdrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">amt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">phys_hdrqtail</span><span class="p">;</span>
		<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">;</span>

		<span class="n">amt</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvhdrcnt</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvhdrentsize</span> <span class="o">*</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">gfp_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ctxt</span> <span class="o">&gt;=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">GFP_USER</span> <span class="o">:</span> <span class="n">GFP_KERNEL</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">amt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq_phys</span><span class="p">,</span>
			<span class="n">gfp_flags</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;attempt to allocate %d bytes &quot;</span>
				    <span class="s">&quot;for ctxt %u rcvhdrq failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">amt</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ctxt</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ctxt</span> <span class="o">&gt;=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span> <span class="o">=</span> <span class="n">vmalloc_user</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bail_free_hdrq</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_NODMA_RTAIL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phys_hdrqtail</span><span class="p">,</span>
				<span class="n">gfp_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bail_free</span><span class="p">;</span>
			<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrqtailaddr_phys</span> <span class="o">=</span> <span class="n">phys_hdrqtail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq_size</span> <span class="o">=</span> <span class="n">amt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* clear for security and sanity on each use */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bail_free:</span>
	<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;attempt to allocate 1 page for ctxt %u &quot;</span>
		    <span class="s">&quot;rcvhdrqtailaddr failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ctxt</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">);</span>
	<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">bail_free_hdrq:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">amt</span><span class="p">,</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span><span class="p">,</span>
			  <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq_phys</span><span class="p">);</span>
	<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">bail:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * allocate eager buffers, both kernel and user contexts.</span>
<span class="cm"> * @rcd: the context we are setting up.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate the eager TID buffers and program them into hip.</span>
<span class="cm"> * They are no longer completely contiguous, we do multiple allocation</span>
<span class="cm"> * calls.  Otherwise we get the OOM code involved, by asking for too</span>
<span class="cm"> * much per call, with disastrous results on some kernels.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qib_setup_eagerbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">e</span><span class="p">,</span> <span class="n">egrcnt</span><span class="p">,</span> <span class="n">egrperchunk</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">egrsize</span><span class="p">,</span> <span class="n">egroff</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * GFP_USER, but without GFP_FS, so buffer cache can be</span>
<span class="cm">	 * coalesced (we hope); otherwise, even at order 4,</span>
<span class="cm">	 * heavy filesystem activity makes these fail, and we can</span>
<span class="cm">	 * use compound pages.</span>
<span class="cm">	 */</span>
	<span class="n">gfp_flags</span> <span class="o">=</span> <span class="n">__GFP_WAIT</span> <span class="o">|</span> <span class="n">__GFP_IO</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">;</span>

	<span class="n">egrcnt</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrcnt</span><span class="p">;</span>
	<span class="n">egroff</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegr_tid_base</span><span class="p">;</span>
	<span class="n">egrsize</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvegrbufsize</span><span class="p">;</span>

	<span class="n">chunk</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_chunks</span><span class="p">;</span>
	<span class="n">egrperchunk</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbufs_perchunk</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="n">chunk</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span> <span class="o">=</span>
			<span class="n">kmalloc</span><span class="p">(</span><span class="n">chunk</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail_rcvegrbuf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_chunks</span><span class="p">;</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">[</span><span class="n">e</span><span class="p">],</span>
					   <span class="n">gfp_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">bail_rcvegrbuf_phys</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegr_phys</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">chunk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chunk</span> <span class="o">&lt;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_chunks</span><span class="p">;</span> <span class="n">chunk</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">[</span><span class="n">chunk</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* clear for security and sanity on each use */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">[</span><span class="n">chunk</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">egrcnt</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">egrperchunk</span><span class="p">;</span> <span class="n">e</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_put_tid</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">e</span> <span class="o">+</span> <span class="n">egroff</span> <span class="o">+</span>
					  <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
					  <span class="p">((</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
					   <span class="n">dd</span><span class="o">-&gt;</span><span class="n">kregbase</span> <span class="o">+</span>
					   <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcvegrbase</span><span class="p">),</span>
					  <span class="n">RCVHQ_RCV_TYPE_EAGER</span><span class="p">,</span> <span class="n">pa</span><span class="p">);</span>
			<span class="n">pa</span> <span class="o">+=</span> <span class="n">egrsize</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cond_resched</span><span class="p">();</span> <span class="cm">/* don&#39;t hog the cpu */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bail_rcvegrbuf_phys:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_chunks</span> <span class="o">&amp;&amp;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">[</span><span class="n">e</span><span class="p">];</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				  <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">[</span><span class="n">e</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span><span class="p">);</span>
	<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf_phys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">bail_rcvegrbuf:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span><span class="p">);</span>
	<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvegrbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">bail:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note: Changes to this routine should be mirrored</span>
<span class="cm"> * for the diagnostics routine qib_remap_ioaddr32().</span>
<span class="cm"> * There is also related code for VL15 buffers in qib_init_7322_variables().</span>
<span class="cm"> * The teardown code that unmaps is in qib_pcie_ddcleanup()</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">init_chip_wc_pat</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vl15buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">qib_kregbase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">qib_piobase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">qib_userbase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">qib_kreglen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">qib_pio2koffset</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobufbase</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">qib_pio4koffset</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobufbase</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">qib_pio2klen</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt2k</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">palign</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">qib_pio4klen</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt4k</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">align4k</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">qib_physaddr</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">physaddr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">qib_piolen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">qib_userlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the old mapping because the kernel will try to reuse the</span>
<span class="cm">	 * old mapping and not create a new mapping with the</span>
<span class="cm">	 * write combining attribute.</span>
<span class="cm">	 */</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">kregbase</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">kregbase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assumes chip address space looks like:</span>
<span class="cm">	 *	- kregs + sregs + cregs + uregs (in any order)</span>
<span class="cm">	 *	- piobufs (2K and 4K bufs in either order)</span>
<span class="cm">	 * or:</span>
<span class="cm">	 *	- kregs + sregs + cregs (in any order)</span>
<span class="cm">	 *	- piobufs (2K and 4K bufs in either order)</span>
<span class="cm">	 *	- uregs</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt4k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_kreglen</span> <span class="o">=</span> <span class="n">qib_pio2koffset</span><span class="p">;</span>
		<span class="n">qib_piolen</span> <span class="o">=</span> <span class="n">qib_pio2klen</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">qib_pio2koffset</span> <span class="o">&lt;</span> <span class="n">qib_pio4koffset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_kreglen</span> <span class="o">=</span> <span class="n">qib_pio2koffset</span><span class="p">;</span>
		<span class="n">qib_piolen</span> <span class="o">=</span> <span class="n">qib_pio4koffset</span> <span class="o">+</span> <span class="n">qib_pio4klen</span> <span class="o">-</span> <span class="n">qib_kreglen</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">qib_kreglen</span> <span class="o">=</span> <span class="n">qib_pio4koffset</span><span class="p">;</span>
		<span class="n">qib_piolen</span> <span class="o">=</span> <span class="n">qib_pio2koffset</span> <span class="o">+</span> <span class="n">qib_pio2klen</span> <span class="o">-</span> <span class="n">qib_kreglen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qib_piolen</span> <span class="o">+=</span> <span class="n">vl15buflen</span><span class="p">;</span>
	<span class="cm">/* Map just the configured ports (not all hw ports) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uregbase</span> <span class="o">&gt;</span> <span class="n">qib_kreglen</span><span class="p">)</span>
		<span class="n">qib_userlen</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ureg_align</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span><span class="p">;</span>

	<span class="cm">/* Sanity checks passed, now create the new mappings */</span>
	<span class="n">qib_kregbase</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">qib_physaddr</span><span class="p">,</span> <span class="n">qib_kreglen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_kregbase</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">qib_piobase</span> <span class="o">=</span> <span class="n">ioremap_wc</span><span class="p">(</span><span class="n">qib_physaddr</span> <span class="o">+</span> <span class="n">qib_kreglen</span><span class="p">,</span> <span class="n">qib_piolen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_piobase</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail_kregbase</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qib_userlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_userbase</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">qib_physaddr</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">uregbase</span><span class="p">,</span>
					       <span class="n">qib_userlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qib_userbase</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail_piobase</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">kregbase</span> <span class="o">=</span> <span class="n">qib_kregbase</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">kregend</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">((</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">qib_kregbase</span> <span class="o">+</span> <span class="n">qib_kreglen</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobase</span> <span class="o">=</span> <span class="n">qib_piobase</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio2kbase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(((</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobase</span><span class="p">)</span> <span class="o">+</span>
		 <span class="n">qib_pio2koffset</span> <span class="o">-</span> <span class="n">qib_kreglen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt4k</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio4kbase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">(((</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobase</span><span class="p">)</span> <span class="o">+</span>
			 <span class="n">qib_pio4koffset</span> <span class="o">-</span> <span class="n">qib_kreglen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qib_userlen</span><span class="p">)</span>
		<span class="cm">/* ureg will now be accessed relative to dd-&gt;userbase */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">userbase</span> <span class="o">=</span> <span class="n">qib_userbase</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bail_piobase:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">qib_piobase</span><span class="p">);</span>
<span class="nl">bail_kregbase:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">qib_kregbase</span><span class="p">);</span>
<span class="nl">bail:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
