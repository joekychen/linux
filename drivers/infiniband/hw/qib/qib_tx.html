<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › qib › qib_tx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>qib_tx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2008, 2009, 2010 QLogic Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>

<span class="cp">#include &quot;qib.h&quot;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">qib_hol_timeout_ms</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">hol_timeout_ms</span><span class="p">,</span> <span class="n">qib_hol_timeout_ms</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hol_timeout_ms</span><span class="p">,</span>
		 <span class="s">&quot;duration of user app suspension after link failure&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="n">qib_sdma_fetch_arb</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">fetch_arb</span><span class="p">,</span> <span class="n">qib_sdma_fetch_arb</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fetch_arb</span><span class="p">,</span> <span class="s">&quot;IBA7220: change SDMA descriptor arbitration&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * qib_disarm_piobufs - cancel a range of PIO buffers</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> * @first: the first PIO buffer to cancel</span>
<span class="cm"> * @cnt: the number of PIO buffers to cancel</span>
<span class="cm"> *</span>
<span class="cm"> * Cancel a range of PIO buffers. Used at user process close,</span>
<span class="cm"> * in case it died while writing to a PIO buffer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_disarm_piobufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">last</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio_need_disarm</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_DISARM_BUF</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called by a user process when it sees the DISARM_BUFS event</span>
<span class="cm"> * bit is set.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qib_disarm_piobufs_ifneeded</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">last</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">pio_base</span> <span class="o">+</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">piocnt</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t need uctxt_lock here, since user has called in to us.</span>
<span class="cm">	 * Clear at start in case more interrupts set bits while we</span>
<span class="cm">	 * are disarming</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * subctxt_cnt is 0 if not shared, so do base</span>
<span class="cm">		 * separately, first, then remaining subctxt, if any</span>
<span class="cm">		 */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">_QIB_EVENT_DISARM_BUFS_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">subctxt_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">_QIB_EVENT_DISARM_BUFS_BIT</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">pio_base</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_clear_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio_need_disarm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">n</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ppd</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_DISARM_BUF</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="nf">is_sdma_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">pidx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span> <span class="o">+</span> <span class="n">pidx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">sdma_state</span><span class="p">.</span><span class="n">first_sendbuf</span> <span class="o">&amp;&amp;</span>
		    <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">sdma_state</span><span class="p">.</span><span class="n">last_sendbuf</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ppd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if send buffer is being used by a user context.</span>
<span class="cm"> * Sets  _QIB_EVENT_DISARM_BUFS_BIT in user_event_mask as a side effect</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_ctxt</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">bufn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ctxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uctxt_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ctxt</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">;</span> <span class="n">ctxt</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span><span class="p">;</span> <span class="n">ctxt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">[</span><span class="n">ctxt</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcd</span> <span class="o">||</span> <span class="n">bufn</span> <span class="o">&lt;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">pio_base</span> <span class="o">||</span>
		    <span class="n">bufn</span> <span class="o">&gt;=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">pio_base</span> <span class="o">+</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">piocnt</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * subctxt_cnt is 0 if not shared, so do base</span>
<span class="cm">			 * separately, first, then remaining subctxt, if any</span>
<span class="cm">			 */</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">_QIB_EVENT_DISARM_BUFS_BIT</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">subctxt_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">_QIB_EVENT_DISARM_BUFS_BIT</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uctxt_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disarm a set of send buffers.  If the buffer might be actively being</span>
<span class="cm"> * written to, mark the buffer to be disarmed later when it is not being</span>
<span class="cm"> * written to.</span>
<span class="cm"> *</span>
<span class="cm"> * This should only be called from the IRQ error handler.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_disarm_piobufs_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">,</span> <span class="o">*</span><span class="n">pppd</span><span class="p">[</span><span class="n">QIB_MAX_IB_PORTS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pppd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">which</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the buffer is owned by the DMA hardware,</span>
<span class="cm">		 * reset the DMA engine.</span>
<span class="cm">		 */</span>
		<span class="n">ppd</span> <span class="o">=</span> <span class="n">is_sdma_buf</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pppd</span><span class="p">[</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">]</span> <span class="o">=</span> <span class="n">ppd</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the kernel is writing the buffer or the buffer is</span>
<span class="cm">		 * owned by a user process, we can&#39;t clear it yet.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio_writing</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailkernel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">find_ctxt</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio_need_disarm</span><span class="p">);</span>
			<span class="n">which</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">which</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_DISARM_BUF</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* do cancel_sends once per port that had sdma piobufs in error */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pppd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">qib_cancel_sends</span><span class="p">(</span><span class="n">pppd</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * update_send_bufs - update shadow copy of the PIO availability map</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> *</span>
<span class="cm"> * called whenever our local copy indicates we have run out of send buffers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_send_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">piobregs</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavregs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the generation (check) bits have changed, then we update the</span>
<span class="cm">	 * busy bit for the corresponding PIO buffer.  This algorithm will</span>
<span class="cm">	 * modify positions to the value they already have in some cases</span>
<span class="cm">	 * (i.e., no change), but it&#39;s faster than changing only the bits</span>
<span class="cm">	 * that have changed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We would like to do this atomicly, to avoid spinlocks in the</span>
<span class="cm">	 * critical send path, but that&#39;s not really possible, given the</span>
<span class="cm">	 * type of changes, and that this routine could be called on</span>
<span class="cm">	 * multiple cpu&#39;s simultaneously, so we lock in this routine only,</span>
<span class="cm">	 * to avoid conflicting updates; all we change is the shadow, and</span>
<span class="cm">	 * it&#39;s a single 64 bit memory location, so by definition the update</span>
<span class="cm">	 * is atomic in terms of what other cpu&#39;s can see in testing the</span>
<span class="cm">	 * bits.  The spin_lock overhead isn&#39;t too bad, since it only</span>
<span class="cm">	 * happens when all buffers are in use, so only cpu overhead, not</span>
<span class="cm">	 * latency or bandwidth is affected.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">piobregs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">pchbusy</span><span class="p">,</span> <span class="n">pchg</span><span class="p">,</span> <span class="n">piov</span><span class="p">,</span> <span class="n">pnew</span><span class="p">;</span>

		<span class="n">piov</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">pchg</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailkernel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span>
			<span class="o">~</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">piov</span><span class="p">);</span>
		<span class="n">pchbusy</span> <span class="o">=</span> <span class="n">pchg</span> <span class="o">&lt;&lt;</span> <span class="n">QLOGIC_IB_SENDPIOAVAIL_BUSY_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pchg</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pchbusy</span> <span class="o">&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">pnew</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pchbusy</span><span class="p">;</span>
			<span class="n">pnew</span> <span class="o">|=</span> <span class="n">piov</span> <span class="o">&amp;</span> <span class="n">pchbusy</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnew</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Debugging code and stats updates if no pio buffers available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">no_send_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">upd_pio_shadow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* not atomic, but if we lose a stat count in a while, that&#39;s OK */</span>
	<span class="n">qib_stats</span><span class="p">.</span><span class="n">sps_nopiobufs</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Common code for normal driver send buffer allocation, and reserved</span>
<span class="cm"> * allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * Do appropriate marking as busy, etc.</span>
<span class="cm"> * Returns buffer pointer if one is found, otherwise NULL.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">qib_getsendbuf_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pbufnum</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">first</span><span class="p">,</span> <span class="n">u32</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">updated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nbufs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_PRESENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">nbufs</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* number in range to check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">upd_pio_shadow</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">update_shadow:</span>
		<span class="cm">/*</span>
<span class="cm">		 * Minor optimization.  If we had no buffers on last call,</span>
<span class="cm">		 * start out by doing the update; continue and do scan even</span>
<span class="cm">		 * if no buffers were updated, to be paranoid.</span>
<span class="cm">		 */</span>
		<span class="n">update_send_bufs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="n">updated</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * While test_and_set_bit() is atomic, we do that and then the</span>
<span class="cm">	 * change_bit(), and the pair is not.  See if this is the cause</span>
<span class="cm">	 * of the remaining armlaunch errors.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_pio</span> <span class="o">&gt;=</span> <span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_pio</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_pio</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
		<span class="cm">/* adjust to min possible  */</span>
		<span class="n">nbufs</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbufs</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="o">!</span><span class="n">first</span> <span class="o">?</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span> <span class="o">:</span> <span class="n">first</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_set_bit</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shadow</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* flip generation bit */</span>
		<span class="n">__change_bit</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">shadow</span><span class="p">);</span>
		<span class="cm">/* remember that the buffer can be written to now */</span>
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio_writing</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="cm">/* first == last on VL15, avoid */</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_pio</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">nbufs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updated</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * First time through; shadow exhausted, but may be</span>
<span class="cm">			 * buffers available, try an update and then rescan.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">update_shadow</span><span class="p">;</span>
		<span class="n">no_send_bufs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt2k</span><span class="p">)</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio2kbase</span> <span class="o">+</span>
				<span class="n">i</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">palign</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt2k</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt4k</span> <span class="o">||</span> <span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">piovl15base</span><span class="p">)</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio4kbase</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt2k</span><span class="p">)</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">align4k</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">piovl15base</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt2k</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">piobcnt4k</span><span class="p">))</span> <span class="o">*</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">align4k</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pbufnum</span><span class="p">)</span>
			<span class="o">*</span><span class="n">pbufnum</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">upd_pio_shadow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Record that the caller is finished writing to the buffer so we don&#39;t</span>
<span class="cm"> * disarm it while it is being written and disarm it now if needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_sendbuf_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio_writing</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_clear_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio_need_disarm</span><span class="p">))</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_DISARM_BUF</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qib_chg_pioavailkernel - change which send buffers are available for kernel</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> * @start: the starting send buffer number</span>
<span class="cm"> * @len: the number of send buffers</span>
<span class="cm"> * @avail: true if the buffers are available for kernel use, false otherwise</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_chg_pioavailkernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">start</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="n">u32</span> <span class="n">avail</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ostart</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

	<span class="cm">/* There are two bits per send buffer (busy and generation) */</span>
	<span class="n">start</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Set or clear the busy bit in the shadow. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * The BUSY bit will never be set, because we disarm</span>
<span class="cm">			 * the user buffers before we hand them back to the</span>
<span class="cm">			 * kernel.  We do have to make sure the generation</span>
<span class="cm">			 * bit is set correctly in shadow, since it could</span>
<span class="cm">			 * have changed many times while allocated to user.</span>
<span class="cm">			 * We can&#39;t use the bitmap functions on the full</span>
<span class="cm">			 * dma array because it is always little-endian, so</span>
<span class="cm">			 * we have to flip to host-order first.</span>
<span class="cm">			 * BITS_PER_LONG is slightly wrong, since it&#39;s</span>
<span class="cm">			 * always 64 bits per register in chip...</span>
<span class="cm">			 * We only work on 64 bit kernels, so that&#39;s OK.</span>
<span class="cm">			 */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
			<span class="n">__clear_bit</span><span class="p">(</span><span class="n">QLOGIC_IB_SENDPIOAVAIL_BUSY_SHIFT</span> <span class="o">+</span> <span class="n">start</span><span class="p">,</span>
				    <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">);</span>
			<span class="n">dma</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
				<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailregs_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">((</span><span class="n">QLOGIC_IB_SENDPIOAVAIL_CHECK_SHIFT</span> <span class="o">+</span>
				      <span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">))</span>
				<span class="n">__set_bit</span><span class="p">(</span><span class="n">QLOGIC_IB_SENDPIOAVAIL_CHECK_SHIFT</span> <span class="o">+</span>
					  <span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">__clear_bit</span><span class="p">(</span><span class="n">QLOGIC_IB_SENDPIOAVAIL_CHECK_SHIFT</span>
					    <span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">);</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailkernel</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span><span class="p">)</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">QLOGIC_IB_SENDPIOAVAIL_BUSY_SHIFT</span><span class="p">,</span>
				  <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailshadow</span><span class="p">);</span>
			<span class="n">__clear_bit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavailkernel</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span><span class="p">)</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_pio</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">last_pio</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">min_kernel_pio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_txchk_change</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ostart</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">avail</span><span class="p">,</span> <span class="n">rcd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush all sends that might be in the ready to send state, as well as any</span>
<span class="cm"> * that are in the process of being sent.  Used whenever we need to be</span>
<span class="cm"> * sure the send side is idle.  Cleans up all buffer state by canceling</span>
<span class="cm"> * all pio buffers, and issuing an abort, which cleans up anything in the</span>
<span class="cm"> * launch fifo.  The cancel is superfluous on some chip versions, but</span>
<span class="cm"> * it&#39;s safer to always do it.</span>
<span class="cm"> * PIOAvail bits are updated by the chip as if a normal send had happened.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_cancel_sends</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ctxt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">last</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell PSM to disarm buffers again before trying to reuse them.</span>
<span class="cm">	 * We need to be sure the rcd doesn&#39;t change out from under us</span>
<span class="cm">	 * while we do so.  We hold the two locks sequentially.  We might</span>
<span class="cm">	 * needlessly set some need_disarm bits as a result, if the</span>
<span class="cm">	 * context is closed after we release the uctxt_lock, but that&#39;s</span>
<span class="cm">	 * fairly benign, and safer than nesting the locks.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ctxt</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">first_user_ctxt</span><span class="p">;</span> <span class="n">ctxt</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cfgctxts</span><span class="p">;</span> <span class="n">ctxt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">rcd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rcd</span><span class="p">[</span><span class="n">ctxt</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span> <span class="o">&amp;&amp;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">ppd</span> <span class="o">==</span> <span class="n">ppd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">pio_base</span> <span class="o">+</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">piocnt</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * subctxt_cnt is 0 if not shared, so do base</span>
<span class="cm">				 * separately, first, then remaining subctxt,</span>
<span class="cm">				 * if any</span>
<span class="cm">				 */</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">_QIB_EVENT_DISARM_BUFS_BIT</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">subctxt_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
					<span class="n">set_bit</span><span class="p">(</span><span class="n">_QIB_EVENT_DISARM_BUFS_BIT</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">user_event_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">pio_base</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">__set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pio_need_disarm</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_HAS_SEND_DMA</span><span class="p">))</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">ppd</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_DISARM_ALL</span> <span class="o">|</span>
				    <span class="n">QIB_SENDCTRL_FLUSH</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Force an update of in-memory copy of the pioavail registers, when</span>
<span class="cm"> * needed for any of a variety of reasons.</span>
<span class="cm"> * If already off, this routine is a nop, on the assumption that the</span>
<span class="cm"> * caller (or set of callers) will &quot;do the right thing&quot;.</span>
<span class="cm"> * This is a per-device operation, so just the first port.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_force_pio_avail_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_sendctrl</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">QIB_SENDCTRL_AVAIL_BLIP</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">qib_hol_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Cancel sends when the link goes DOWN so that we aren&#39;t doing it</span>
<span class="cm">	 * at INIT when we might be trying to send SMI packets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags</span> <span class="o">&amp;</span> <span class="n">QIBL_IB_AUTONEG_INPROG</span><span class="p">))</span>
		<span class="n">qib_cancel_sends</span><span class="p">(</span><span class="n">ppd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Link is at INIT.</span>
<span class="cm"> * We start the HoL timer so we can detect stuck packets blocking SMP replies.</span>
<span class="cm"> * Timer may already be running, so use mod_timer, not add_timer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_hol_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_state</span> <span class="o">!=</span> <span class="n">QIB_HOL_INIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_state</span> <span class="o">=</span> <span class="n">QIB_HOL_INIT</span><span class="p">;</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_timer</span><span class="p">,</span>
			  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">qib_hol_timeout_ms</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Link is up, continue any user processes, and ensure timer</span>
<span class="cm"> * is a nop, if running.  Let timer keep running, if set; it</span>
<span class="cm"> * will nop when it sees the link is up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_hol_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_state</span> <span class="o">=</span> <span class="n">QIB_HOL_UP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is only called via the timer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">qib_hol_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>

	<span class="cm">/* If hardware error, etc, skip. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_INITTED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_state</span> <span class="o">!=</span> <span class="n">QIB_HOL_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Try to flush sends in case a stuck packet is blocking</span>
<span class="cm">		 * SMP replies.</span>
<span class="cm">		 */</span>
		<span class="n">qib_hol_down</span><span class="p">(</span><span class="n">ppd</span><span class="p">);</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">hol_timer</span><span class="p">,</span>
			  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">qib_hol_timeout_ms</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
