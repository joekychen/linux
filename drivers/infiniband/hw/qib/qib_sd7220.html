<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › qib › qib_sd7220.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>qib_sd7220.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, 2007, 2008, 2009, 2010 QLogic Corporation.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * This file contains all of the code that is specific to the SerDes</span>
<span class="cm"> * on the QLogic_IB 7220 chip.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>

<span class="cp">#include &quot;qib.h&quot;</span>
<span class="cp">#include &quot;qib_7220.h&quot;</span>

<span class="cp">#define SD7220_FW_NAME &quot;qlogic/sd7220.fw&quot;</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="n">SD7220_FW_NAME</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Same as in qib_iba7220.c, but just the registers needed here.</span>
<span class="cm"> * Could move whole set to qib_7220.h, but decided better to keep</span>
<span class="cm"> * local.</span>
<span class="cm"> */</span>
<span class="cp">#define KREG_IDX(regname) (QIB_7220_##regname##_OFFS / sizeof(u64))</span>
<span class="cp">#define kr_hwerrclear KREG_IDX(HwErrClear)</span>
<span class="cp">#define kr_hwerrmask KREG_IDX(HwErrMask)</span>
<span class="cp">#define kr_hwerrstatus KREG_IDX(HwErrStatus)</span>
<span class="cp">#define kr_ibcstatus KREG_IDX(IBCStatus)</span>
<span class="cp">#define kr_ibserdesctrl KREG_IDX(IBSerDesCtrl)</span>
<span class="cp">#define kr_scratch KREG_IDX(Scratch)</span>
<span class="cp">#define kr_xgxs_cfg KREG_IDX(XGXSCfg)</span>
<span class="cm">/* these are used only here, not in qib_iba7220.c */</span>
<span class="cp">#define kr_ibsd_epb_access_ctrl KREG_IDX(ibsd_epb_access_ctrl)</span>
<span class="cp">#define kr_ibsd_epb_transaction_reg KREG_IDX(ibsd_epb_transaction_reg)</span>
<span class="cp">#define kr_pciesd_epb_transaction_reg KREG_IDX(pciesd_epb_transaction_reg)</span>
<span class="cp">#define kr_pciesd_epb_access_ctrl KREG_IDX(pciesd_epb_access_ctrl)</span>
<span class="cp">#define kr_serdes_ddsrxeq0 KREG_IDX(SerDes_DDSRXEQ0)</span>

<span class="cm">/*</span>
<span class="cm"> * The IBSerDesMappTable is a memory that holds values to be stored in</span>
<span class="cm"> * various SerDes registers by IBC.</span>
<span class="cm"> */</span>
<span class="cp">#define kr_serdes_maptable KREG_IDX(IBSerDesMappTable)</span>

<span class="cm">/*</span>
<span class="cm"> * Below used for sdnum parameter, selecting one of the two sections</span>
<span class="cm"> * used for PCIe, or the single SerDes used for IB.</span>
<span class="cm"> */</span>
<span class="cp">#define PCIE_SERDES0 0</span>
<span class="cp">#define PCIE_SERDES1 1</span>

<span class="cm">/*</span>
<span class="cm"> * The EPB requires addressing in a particular form. EPB_LOC() is intended</span>
<span class="cm"> * to make #definitions a little more readable.</span>
<span class="cm"> */</span>
<span class="cp">#define EPB_ADDR_SHF 8</span>
<span class="cp">#define EPB_LOC(chn, elt, reg) \</span>
<span class="cp">	(((elt &amp; 0xf) | ((chn &amp; 7) &lt;&lt; 4) | ((reg &amp; 0x3f) &lt;&lt; 9)) &lt;&lt; \</span>
<span class="cp">	 EPB_ADDR_SHF)</span>
<span class="cp">#define EPB_IB_QUAD0_CS_SHF (25)</span>
<span class="cp">#define EPB_IB_QUAD0_CS (1U &lt;&lt;  EPB_IB_QUAD0_CS_SHF)</span>
<span class="cp">#define EPB_IB_UC_CS_SHF (26)</span>
<span class="cp">#define EPB_PCIE_UC_CS_SHF (27)</span>
<span class="cp">#define EPB_GLOBAL_WR (1U &lt;&lt; (EPB_ADDR_SHF + 8))</span>

<span class="cm">/* Forward declarations. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sdnum</span><span class="p">,</span> <span class="n">u32</span> <span class="n">loc</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_sd_trimdone_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">qib_sd_trimdone_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_sd_setvals</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_sd_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_sd_dactrim</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_internal_presets</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="cm">/* Tweak the register (CMUCTRL5) that contains the TRIMSELF controls */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_sd_trimself</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">epb_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sdnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">claim</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_sd7220_ib_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qib_sd7220_ib_vfy</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Below keeps track of whether the &quot;once per power-on&quot; initialization has</span>
<span class="cm"> * been done, because uC code Version 1.32.17 or higher allows the uC to</span>
<span class="cm"> * be reset at will, and Automatic Equalization may require it. So the</span>
<span class="cm"> * state of the reset &quot;pin&quot;, is no longer valid. Instead, we check for the</span>
<span class="cm"> * actual uC code having been loaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_ibsd_ucode_loaded</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">serdes_first_init_done</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qib_sd7220_ib_vfy</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">fw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">serdes_first_init_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">serdes_first_init_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* repeat #define for local use. &quot;Real&quot; #define is in qib_iba7220.c */</span>
<span class="cp">#define QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR      0x0000004000000000ULL</span>
<span class="cp">#define IB_MPREG5 (EPB_LOC(6, 0, 0xE) | (1L &lt;&lt; EPB_IB_UC_CS_SHF))</span>
<span class="cp">#define IB_MPREG6 (EPB_LOC(6, 0, 0xF) | (1U &lt;&lt; EPB_IB_UC_CS_SHF))</span>
<span class="cp">#define UC_PAR_CLR_D 8</span>
<span class="cp">#define UC_PAR_CLR_M 0xC</span>
<span class="cp">#define IB_CTRL2(chn) (EPB_LOC(chn, 7, 3) | EPB_IB_QUAD0_CS)</span>
<span class="cp">#define START_EQ1(chan) EPB_LOC(chan, 7, 0x27)</span>

<span class="kt">void</span> <span class="nf">qib_sd7220_clr_ibpar</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* clear, then re-enable parity errs */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">IB_MPREG6</span><span class="p">,</span>
		<span class="n">UC_PAR_CLR_D</span><span class="p">,</span> <span class="n">UC_PAR_CLR_M</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed clearing IBSerDes Parity err</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">IB_MPREG6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">UC_PAR_CLR_M</span><span class="p">);</span>

	<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_hwerrclear</span><span class="p">,</span>
		<span class="n">QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR</span><span class="p">);</span>
	<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
<span class="nl">bail:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After a reset or other unusual event, the epb interface may need</span>
<span class="cm"> * to be re-synchronized, between the host and the uC.</span>
<span class="cm"> * returns &lt;0 for failure to resync within IBSD_RESYNC_TRIES (not expected)</span>
<span class="cm"> */</span>
<span class="cp">#define IBSD_RESYNC_TRIES 3</span>
<span class="cp">#define IB_PGUDP(chn) (EPB_LOC((chn), 2, 1) | EPB_IB_QUAD0_CS)</span>
<span class="cp">#define IB_CMUDONE(chn) (EPB_LOC((chn), 7, 0xF) | EPB_IB_QUAD0_CS)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_resync_ibepb</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="n">tries</span><span class="p">,</span> <span class="n">chn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">loc</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">chn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">IBSD_RESYNC_TRIES</span><span class="p">);</span> <span class="o">++</span><span class="n">tries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="n">IB_PGUDP</span><span class="p">(</span><span class="n">chn</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed read in resync</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mh">0xF0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mh">0x55</span> <span class="o">&amp;&amp;</span> <span class="n">tries</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;unexpected pattern in resync</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pat</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">^</span> <span class="mh">0xA5</span><span class="p">;</span> <span class="cm">/* alternate F0 and 55 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">pat</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed write in resync</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed re-read in resync</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">pat</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed compare1 in resync</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="n">IB_CMUDONE</span><span class="p">(</span><span class="n">chn</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed CMUDONE rd in resync</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0x70</span><span class="p">)</span> <span class="o">!=</span> <span class="p">((</span><span class="n">chn</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x40</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Bad CMUDONE value %02X, chn %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">ret</span><span class="p">,</span> <span class="n">chn</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">chn</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>  <span class="cm">/* Success */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Localize the stuff that should be done to change IB uC reset</span>
<span class="cm"> * returns &lt;0 for errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_ibsd_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">assert_rst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rst_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">rst_val</span> <span class="o">=</span> <span class="n">qib_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_ibserdesctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">assert_rst</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Vendor recommends &quot;interrupting&quot; uC before reset, to</span>
<span class="cm">		 * minimize possible glitches.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">sdepb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">epb_access</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">rst_val</span> <span class="o">|=</span> <span class="mi">1ULL</span><span class="p">;</span>
		<span class="cm">/* Squelch possible parity error from _asserting_ reset */</span>
		<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_hwerrmask</span><span class="p">,</span>
			       <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">hwerrmask</span> <span class="o">&amp;</span>
			       <span class="o">~</span><span class="n">QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR</span><span class="p">);</span>
		<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_ibserdesctrl</span><span class="p">,</span> <span class="n">rst_val</span><span class="p">);</span>
		<span class="cm">/* flush write, delay to ensure it took effect */</span>
		<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="cm">/* once it&#39;s reset, can remove interrupt */</span>
		<span class="n">epb_access</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">sdepb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Before we de-assert reset, we need to deal with</span>
<span class="cm">		 * possible glitch on the Parity-error line.</span>
<span class="cm">		 * Suppress it around the reset, both in chip-level</span>
<span class="cm">		 * hwerrmask and in IB uC control reg. uC will allow</span>
<span class="cm">		 * it again during startup.</span>
<span class="cm">		 */</span>
		<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">rst_val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1ULL</span><span class="p">);</span>
		<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_hwerrmask</span><span class="p">,</span>
			       <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">hwerrmask</span> <span class="o">&amp;</span>
			       <span class="o">~</span><span class="n">QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_resync_ibepb</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;unable to re-sync IB EPB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* set uC control regs to suppress parity errs */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">IB_MPREG5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="cm">/* IB uC code past Version 1.32.17 allow suppression of wdog */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">IB_MPREG6</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span>
			<span class="mh">0x80</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to set WDOG disable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_ibserdesctrl</span><span class="p">,</span> <span class="n">rst_val</span><span class="p">);</span>
		<span class="cm">/* flush write, delay for startup */</span>
		<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* clear, then re-enable parity errs */</span>
		<span class="n">qib_sd7220_clr_ibpar</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">qib_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_hwerrstatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;IBUC Parity still set after RST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">hwerrmask</span> <span class="o">&amp;=</span>
				<span class="o">~</span><span class="n">QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_hwerrmask</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">hwerrmask</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qib_sd_trimdone_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">where</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">chn</span><span class="p">,</span> <span class="n">baduns</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">where</span><span class="p">)</span>
		<span class="n">where</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>

	<span class="cm">/* give time for reset to settle out in EPB */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_resync_ibepb</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;not able to re-sync IB EPB (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>

	<span class="cm">/* Do &quot;sacrificial read&quot; to get EPB in sane state after reset */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">IB_CTRL2</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed TRIMDONE 1st read, (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>

	<span class="cm">/* Check/show &quot;summary&quot; Trim-done bit in IBCStatus */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">qib_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_ibcstatus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)))</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;IBCS TRIMDONE clear (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Do &quot;dummy read/mod/wr&quot; to get EPB in sane state after reset</span>
<span class="cm">	 * The default value for MPREG6 is 0.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">IB_MPREG6</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed Dummy RMW, (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">baduns</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">chn</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">chn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">chn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read CTRL reg for each channel to check TRIMDONE */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span>
			<span class="n">IB_CTRL2</span><span class="p">(</span><span class="n">chn</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed checking TRIMDONE, chn %d&quot;</span>
				    <span class="s">&quot; (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chn</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">probe</span><span class="p">;</span>

			<span class="n">baduns</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chn</span><span class="p">);</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;TRIMDONE cleared on chn %d (%02X).&quot;</span>
				<span class="s">&quot; (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chn</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
			<span class="n">probe</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span>
				<span class="n">IB_PGUDP</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;probe is %d (%02X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">probe</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
			<span class="n">probe</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span>
				<span class="n">IB_CTRL2</span><span class="p">(</span><span class="n">chn</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;re-read: %d (%02X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">probe</span><span class="p">,</span> <span class="n">probe</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span>
				<span class="n">IB_CTRL2</span><span class="p">(</span><span class="n">chn</span><span class="p">),</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span>
					<span class="s">&quot;Err on TRIMDONE rewrite1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chn</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">chn</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">chn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read CTRL reg for each channel to check TRIMDONE */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">baduns</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">chn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span>
				<span class="s">&quot;Reseting TRIMDONE on chn %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">chn</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span>
				<span class="n">IB_CTRL2</span><span class="p">(</span><span class="n">chn</span><span class="p">),</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed re-setting &quot;</span>
					<span class="s">&quot;TRIMDONE, chn %d (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">chn</span><span class="p">,</span> <span class="n">where</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Below is portion of IBA7220-specific bringup_serdes() that actually</span>
<span class="cm"> * deals with registers and memory within the SerDes itself.</span>
<span class="cm"> * Post IB uC code version 1.32.17, was_reset being 1 is not really</span>
<span class="cm"> * informative, so we double-check.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qib_sd7220_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* default to failure */</span>
	<span class="kt">int</span> <span class="n">first_reset</span><span class="p">,</span> <span class="n">was_reset</span><span class="p">;</span>

	<span class="cm">/* SERDES MPU reset recorded in D0 */</span>
	<span class="n">was_reset</span> <span class="o">=</span> <span class="p">(</span><span class="n">qib_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_ibserdesctrl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* entered with reset not asserted, we need to do it */</span>
		<span class="n">qib_ibsd_reset</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">qib_sd_trimdone_monitor</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Driver-reload&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">SD7220_FW_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to load IB SERDES image</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Substitute our deduced value for was_reset */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_ibsd_ucode_loaded</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">first_reset</span> <span class="o">=</span> <span class="o">!</span><span class="n">ret</span><span class="p">;</span> <span class="cm">/* First reset if IBSD uCode not yet loaded */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Alter some regs per vendor latest doc, reset-defaults</span>
<span class="cm">	 * are not right for IB.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd_early</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to set IB SERDES early defaults</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set DAC manual trim IB.</span>
<span class="cm">	 * We only do this once after chip has been reset (usually</span>
<span class="cm">	 * same as once per system boot).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd_dactrim</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed IB SERDES DAC trim</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set various registers (DDS and RXEQ) that will be</span>
<span class="cm">	 * controlled by IBC (in 1.2 mode) to reasonable preset values</span>
<span class="cm">	 * Calling the &quot;internal&quot; version avoids the &quot;check for needed&quot;</span>
<span class="cm">	 * and &quot;trimdone monitor&quot; that might be counter-productive.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_internal_presets</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to set IB SERDES presets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd_trimself</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to set IB SERDES TRIMSELF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Load image, then try to verify */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="cm">/* Assume success */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">vfy</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">trim_done</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_ib_load</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to load IB SERDES image</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Loaded image, try to verify */</span>
			<span class="n">vfy</span> <span class="o">=</span> <span class="n">qib_sd7220_ib_vfy</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vfy</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;SERDES PRAM VFY failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
			<span class="p">}</span> <span class="cm">/* end if verified */</span>
		<span class="p">}</span> <span class="cm">/* end if loaded */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Loaded and verified. Almost good...</span>
<span class="cm">		 * hold &quot;success&quot; in ret</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Prev steps all worked, continue bringup</span>
<span class="cm">		 * De-assert RESET to uC, only in first reset, to allow</span>
<span class="cm">		 * trimming.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Since our default setup sets START_EQ1 to</span>
<span class="cm">		 * PRESET, we need to clear that for this very first run.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">START_EQ1</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed clearing START_EQ1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">qib_ibsd_reset</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this is not the first reset, trimdone should be set</span>
<span class="cm">		 * already. We may need to check about this.</span>
<span class="cm">		 */</span>
		<span class="n">trim_done</span> <span class="o">=</span> <span class="n">qib_sd_trimdone_poll</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Whether or not trimdone succeeded, we need to put the</span>
<span class="cm">		 * uC back into reset to avoid a possible fight with the</span>
<span class="cm">		 * IBC state-machine.</span>
<span class="cm">		 */</span>
		<span class="n">qib_ibsd_reset</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trim_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;No TRIMDONE seen</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * DEBUG: check each time we reset if trimdone bits have</span>
<span class="cm">		 * gotten cleared, and re-set them.</span>
<span class="cm">		 */</span>
		<span class="n">qib_sd_trimdone_monitor</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;First-reset&quot;</span><span class="p">);</span>
		<span class="cm">/* Remember so we do not re-do the load, dactrim, etc. */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">serdes_first_init_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * setup for channel training and load values for</span>
<span class="cm">	 * RxEq and DDS in tables used by IBC in IB1.2 mode</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qib_sd_setvals</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="nl">bail:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="cm">/* start relock timer regardless, but start at 1 second */</span>
	<span class="n">set_7220_relock_poll</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define EPB_ACC_REQ 1</span>
<span class="cp">#define EPB_ACC_GNT 0x100</span>
<span class="cp">#define EPB_DATA_MASK 0xFF</span>
<span class="cp">#define EPB_RD (1ULL &lt;&lt; 24)</span>
<span class="cp">#define EPB_TRANS_RDY (1ULL &lt;&lt; 31)</span>
<span class="cp">#define EPB_TRANS_ERR (1ULL &lt;&lt; 30)</span>
<span class="cp">#define EPB_TRANS_TRIES 5</span>

<span class="cm">/*</span>
<span class="cm"> * query, claim, release ownership of the EPB (External Parallel Bus)</span>
<span class="cm"> * for a specified SERDES.</span>
<span class="cm"> * the &quot;claim&quot; parameter is &gt;0 to claim, &lt;0 to release, 0 to query.</span>
<span class="cm"> * Returns &lt;0 for errors, &gt;0 if we had ownership, else 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">epb_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sdnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">claim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">acc</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">accval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">owned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">oct_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sdnum</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_7220_SERDES</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The IB SERDES &quot;ownership&quot; is fairly simple. A single each</span>
<span class="cm">		 * request/grant.</span>
<span class="cm">		 */</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">kr_ibsd_epb_access_ctrl</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCIE_SERDES0</span>:
	<span class="k">case</span> <span class="n">PCIE_SERDES1</span>:
		<span class="cm">/* PCIe SERDES has two &quot;octants&quot;, need to select which */</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">kr_pciesd_epb_access_ctrl</span><span class="p">;</span>
		<span class="n">oct_sel</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sdnum</span> <span class="o">-</span> <span class="n">PCIE_SERDES0</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure any outstanding transaction was seen */</span>
	<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>

	<span class="n">accval</span> <span class="o">=</span> <span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">acc</span><span class="p">);</span>

	<span class="n">owned</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">accval</span> <span class="o">&amp;</span> <span class="n">EPB_ACC_GNT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">claim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Need to release */</span>
		<span class="n">u64</span> <span class="n">pollval</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The only writeable bits are the request and CS.</span>
<span class="cm">		 * Both should be clear</span>
<span class="cm">		 */</span>
		<span class="n">u64</span> <span class="n">newval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">newval</span><span class="p">);</span>
		<span class="cm">/* First read after write is not trustworthy */</span>
		<span class="n">pollval</span> <span class="o">=</span> <span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">acc</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">pollval</span> <span class="o">=</span> <span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">acc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pollval</span> <span class="o">&amp;</span> <span class="n">EPB_ACC_GNT</span><span class="p">)</span>
			<span class="n">owned</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">claim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Need to claim */</span>
		<span class="n">u64</span> <span class="n">pollval</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">newval</span> <span class="o">=</span> <span class="n">EPB_ACC_REQ</span> <span class="o">|</span> <span class="n">oct_sel</span><span class="p">;</span>
		<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">newval</span><span class="p">);</span>
		<span class="cm">/* First read after write is not trustworthy */</span>
		<span class="n">pollval</span> <span class="o">=</span> <span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">acc</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">pollval</span> <span class="o">=</span> <span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">acc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pollval</span> <span class="o">&amp;</span> <span class="n">EPB_ACC_GNT</span><span class="p">))</span>
			<span class="n">owned</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">owned</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lemma to deal with race condition of write..read to epb regs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">epb_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u64</span> <span class="n">i_val</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">o_vp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transval</span><span class="p">;</span>

	<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">i_val</span><span class="p">);</span>
	<span class="cm">/* Throw away first read, as RDY bit may be stale */</span>
	<span class="n">transval</span> <span class="o">=</span> <span class="n">qib_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">tries</span> <span class="o">=</span> <span class="n">EPB_TRANS_TRIES</span><span class="p">;</span> <span class="n">tries</span><span class="p">;</span> <span class="o">--</span><span class="n">tries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transval</span> <span class="o">=</span> <span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transval</span> <span class="o">&amp;</span> <span class="n">EPB_TRANS_RDY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transval</span> <span class="o">&amp;</span> <span class="n">EPB_TRANS_ERR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">o_vp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">o_vp</span> <span class="o">=</span> <span class="n">transval</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tries</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * qib_sd7220_reg_mod - modify SERDES register</span>
<span class="cm"> * @dd: the qlogic_ib device</span>
<span class="cm"> * @sdnum: which SERDES to access</span>
<span class="cm"> * @loc: location - channel, element, register, as packed by EPB_LOC() macro.</span>
<span class="cm"> * @wd: Write Data - value to set in register</span>
<span class="cm"> * @mask: ones where data should be spliced into reg.</span>
<span class="cm"> *</span>
<span class="cm"> * Basic register read/modify/write, with un-needed acesses elided. That is,</span>
<span class="cm"> * a mask of zero will prevent write, while a mask of 0xFF will prevent read.</span>
<span class="cm"> * returns current (presumed, if a write was done) contents of selected</span>
<span class="cm"> * register, or &lt;0 if errors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd7220_reg_mod</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sdnum</span><span class="p">,</span> <span class="n">u32</span> <span class="n">loc</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">wd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">trans</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">owned</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sdnum</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_7220_SERDES</span>:
		<span class="n">trans</span> <span class="o">=</span> <span class="n">kr_ibsd_epb_transaction_reg</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCIE_SERDES0</span>:
	<span class="k">case</span> <span class="n">PCIE_SERDES1</span>:
		<span class="n">trans</span> <span class="o">=</span> <span class="n">kr_pciesd_epb_transaction_reg</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * All access is locked in software (vs other host threads) and</span>
<span class="cm">	 * hardware (vs uC access).</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">sdepb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">owned</span> <span class="o">=</span> <span class="n">epb_access</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">sdnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owned</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">sdepb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tries</span> <span class="o">=</span> <span class="n">EPB_TRANS_TRIES</span><span class="p">;</span> <span class="n">tries</span><span class="p">;</span> <span class="o">--</span><span class="n">tries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transval</span> <span class="o">=</span> <span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transval</span> <span class="o">&amp;</span> <span class="n">EPB_TRANS_RDY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="cm">/* to make read-skip work */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Not a pure write, so need to read.</span>
<span class="cm">			 * loc encodes chip-select as well as address</span>
<span class="cm">			 */</span>
			<span class="n">transval</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">|</span> <span class="n">EPB_RD</span><span class="p">;</span>
			<span class="n">tries</span> <span class="o">=</span> <span class="n">epb_trans</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">transval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transval</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Not a pure read, so need to write.</span>
<span class="cm">			 */</span>
			<span class="n">wd</span> <span class="o">=</span> <span class="p">(</span><span class="n">wd</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">transval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">);</span>
			<span class="n">transval</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">|</span> <span class="p">(</span><span class="n">wd</span> <span class="o">&amp;</span> <span class="n">EPB_DATA_MASK</span><span class="p">);</span>
			<span class="n">tries</span> <span class="o">=</span> <span class="n">epb_trans</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">transval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transval</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* else, failed to see ready, what error-handling? */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release bus. Failure is an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epb_access</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">sdnum</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">transval</span> <span class="o">&amp;</span> <span class="n">EPB_DATA_MASK</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">sdepb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define EPB_ROM_R (2)</span>
<span class="cp">#define EPB_ROM_W (1)</span>
<span class="cm">/*</span>
<span class="cm"> * Below, all uC-related, use appropriate UC_CS, depending</span>
<span class="cm"> * on which SerDes is used.</span>
<span class="cm"> */</span>
<span class="cp">#define EPB_UC_CTL EPB_LOC(6, 0, 0)</span>
<span class="cp">#define EPB_MADDRL EPB_LOC(6, 0, 2)</span>
<span class="cp">#define EPB_MADDRH EPB_LOC(6, 0, 3)</span>
<span class="cp">#define EPB_ROMDATA EPB_LOC(6, 0, 4)</span>
<span class="cp">#define EPB_RAMDATA EPB_LOC(6, 0, 5)</span>

<span class="cm">/* Transfer date to/from uC Program RAM of IB or PCIe SerDes */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd7220_ram_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sdnum</span><span class="p">,</span> <span class="n">u32</span> <span class="n">loc</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rd_notwr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">trans</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transval</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">csbit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">owned</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sofar</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>

	<span class="cm">/* Pick appropriate transaction reg and &quot;Chip select&quot; for this serdes */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sdnum</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_7220_SERDES</span>:
		<span class="n">csbit</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">EPB_IB_UC_CS_SHF</span><span class="p">;</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">kr_ibsd_epb_transaction_reg</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCIE_SERDES0</span>:
	<span class="k">case</span> <span class="n">PCIE_SERDES1</span>:
		<span class="cm">/* PCIe SERDES has uC &quot;chip select&quot; in different bit, too */</span>
		<span class="n">csbit</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">EPB_PCIE_UC_CS_SHF</span><span class="p">;</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">kr_pciesd_epb_transaction_reg</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">rd_notwr</span> <span class="o">?</span> <span class="s">&quot;Rd&quot;</span> <span class="o">:</span> <span class="s">&quot;Wr&quot;</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">sdepb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">owned</span> <span class="o">=</span> <span class="n">epb_access</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">sdnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owned</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">sdepb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * In future code, we may need to distinguish several address ranges,</span>
<span class="cm">	 * and select various memories based on this. For now, just trim</span>
<span class="cm">	 * &quot;loc&quot; (location including address and memory select) to</span>
<span class="cm">	 * &quot;addr&quot; (address within memory). we will only support PRAM</span>
<span class="cm">	 * The memory is 8KB.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">&amp;</span> <span class="mh">0x1FFF</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tries</span> <span class="o">=</span> <span class="n">EPB_TRANS_TRIES</span><span class="p">;</span> <span class="n">tries</span><span class="p">;</span> <span class="o">--</span><span class="n">tries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transval</span> <span class="o">=</span> <span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transval</span> <span class="o">&amp;</span> <span class="n">EPB_TRANS_RDY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sofar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Every &quot;memory&quot; access is doubly-indirect.</span>
<span class="cm">		 * We set two bytes of address, then read/write</span>
<span class="cm">		 * one or mores bytes of data.</span>
<span class="cm">		 */</span>

		<span class="cm">/* First, we set control to &quot;Read&quot; or &quot;Write&quot; */</span>
		<span class="n">transval</span> <span class="o">=</span> <span class="n">csbit</span> <span class="o">|</span> <span class="n">EPB_UC_CTL</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">rd_notwr</span> <span class="o">?</span> <span class="n">EPB_ROM_R</span> <span class="o">:</span> <span class="n">EPB_ROM_W</span><span class="p">);</span>
		<span class="n">tries</span> <span class="o">=</span> <span class="n">epb_trans</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">transval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transval</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sofar</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sofar</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Only set address at start of chunk */</span>
				<span class="kt">int</span> <span class="n">addrbyte</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">sofar</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
				<span class="n">transval</span> <span class="o">=</span> <span class="n">csbit</span> <span class="o">|</span> <span class="n">EPB_MADDRH</span> <span class="o">|</span> <span class="n">addrbyte</span><span class="p">;</span>
				<span class="n">tries</span> <span class="o">=</span> <span class="n">epb_trans</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">transval</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">transval</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">addrbyte</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">sofar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
				<span class="n">transval</span> <span class="o">=</span> <span class="n">csbit</span> <span class="o">|</span> <span class="n">EPB_MADDRL</span> <span class="o">|</span> <span class="n">addrbyte</span><span class="p">;</span>
				<span class="n">tries</span> <span class="o">=</span> <span class="n">epb_trans</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">transval</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">transval</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rd_notwr</span><span class="p">)</span>
				<span class="n">transval</span> <span class="o">=</span> <span class="n">csbit</span> <span class="o">|</span> <span class="n">EPB_ROMDATA</span> <span class="o">|</span> <span class="n">EPB_RD</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">transval</span> <span class="o">=</span> <span class="n">csbit</span> <span class="o">|</span> <span class="n">EPB_ROMDATA</span> <span class="o">|</span> <span class="n">buf</span><span class="p">[</span><span class="n">sofar</span><span class="p">];</span>
			<span class="n">tries</span> <span class="o">=</span> <span class="n">epb_trans</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">transval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transval</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rd_notwr</span><span class="p">)</span>
				<span class="n">buf</span><span class="p">[</span><span class="n">sofar</span><span class="p">]</span> <span class="o">=</span> <span class="n">transval</span> <span class="o">&amp;</span> <span class="n">EPB_DATA_MASK</span><span class="p">;</span>
			<span class="o">++</span><span class="n">sofar</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Finally, clear control-bit for Read or Write */</span>
		<span class="n">transval</span> <span class="o">=</span> <span class="n">csbit</span> <span class="o">|</span> <span class="n">EPB_UC_CTL</span><span class="p">;</span>
		<span class="n">tries</span> <span class="o">=</span> <span class="n">epb_trans</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">transval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">sofar</span><span class="p">;</span>
	<span class="cm">/* Release bus. Failure is an error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">epb_access</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">sdnum</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">sdepb_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tries</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PROG_CHUNK 64</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd7220_prog_ld</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sdnum</span><span class="p">,</span>
			      <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">sofar</span><span class="p">,</span> <span class="n">req</span><span class="p">;</span>

	<span class="n">sofar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sofar</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">sofar</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">&gt;</span> <span class="n">PROG_CHUNK</span><span class="p">)</span>
			<span class="n">req</span> <span class="o">=</span> <span class="n">PROG_CHUNK</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">qib_sd7220_ram_xfer</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">sdnum</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">sofar</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">img</span> <span class="o">+</span> <span class="n">sofar</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sofar</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sofar</span> <span class="o">+=</span> <span class="n">req</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sofar</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define VFY_CHUNK 64</span>
<span class="cp">#define SD_PRAM_ERROR_LIMIT 42</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd7220_prog_vfy</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sdnum</span><span class="p">,</span>
			       <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">sofar</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">errors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">readback</span><span class="p">[</span><span class="n">VFY_CHUNK</span><span class="p">];</span>

	<span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sofar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sofar</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">sofar</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req</span> <span class="o">&gt;</span> <span class="n">VFY_CHUNK</span><span class="p">)</span>
			<span class="n">req</span> <span class="o">=</span> <span class="n">VFY_CHUNK</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">qib_sd7220_ram_xfer</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">sdnum</span><span class="p">,</span> <span class="n">sofar</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="n">readback</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* failed in read itself */</span>
			<span class="n">sofar</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">readback</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">img</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="n">sofar</span><span class="p">])</span>
				<span class="o">++</span><span class="n">errors</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sofar</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">errors</span> <span class="o">?</span> <span class="o">-</span><span class="n">errors</span> <span class="o">:</span> <span class="n">sofar</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">qib_sd7220_ib_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">qib_sd7220_prog_ld</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">qib_sd7220_ib_vfy</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">qib_sd7220_prog_vfy</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * IRQ not set up at this point in init, so we poll.</span>
<span class="cm"> */</span>
<span class="cp">#define IB_SERDES_TRIM_DONE (1ULL &lt;&lt; 11)</span>
<span class="cp">#define TRIM_TMO (30)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd_trimdone_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">trim_tmo</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Default to failure, so IBC will not start</span>
<span class="cm">	 * without IB_SERDES_TRIM_DONE.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">trim_tmo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">trim_tmo</span> <span class="o">&lt;</span> <span class="n">TRIM_TMO</span><span class="p">;</span> <span class="o">++</span><span class="n">trim_tmo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">qib_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_ibcstatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">IB_SERDES_TRIM_DONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trim_tmo</span> <span class="o">&gt;=</span> <span class="n">TRIM_TMO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;No TRIMDONE in %d tries</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">trim_tmo</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define TX_FAST_ELT (9)</span>

<span class="cm">/*</span>
<span class="cm"> * Set the &quot;negotiation&quot; values for SERDES. These are used by the IB1.2</span>
<span class="cm"> * link negotiation. Macros below are attempt to keep the values a</span>
<span class="cm"> * little more human-editable.</span>
<span class="cm"> * First, values related to Drive De-emphasis Settings.</span>
<span class="cm"> */</span>

<span class="cp">#define NUM_DDS_REGS 6</span>
<span class="cp">#define DDS_REG_MAP 0x76A910 </span><span class="cm">/* LSB-first list of regs (in elt 9) to mod */</span><span class="cp"></span>

<span class="cp">#define DDS_VAL(amp_d, main_d, ipst_d, ipre_d, amp_s, main_s, ipst_s, ipre_s) \</span>
<span class="cp">	{ { ((amp_d &amp; 0x1F) &lt;&lt; 1) | 1, ((amp_s &amp; 0x1F) &lt;&lt; 1) | 1, \</span>
<span class="cp">	  (main_d &lt;&lt; 3) | 4 | (ipre_d &gt;&gt; 2), \</span>
<span class="cp">	  (main_s &lt;&lt; 3) | 4 | (ipre_s &gt;&gt; 2), \</span>
<span class="cp">	  ((ipst_d &amp; 0xF) &lt;&lt; 1) | ((ipre_d &amp; 3) &lt;&lt; 6) | 0x21, \</span>
<span class="cp">	  ((ipst_s &amp; 0xF) &lt;&lt; 1) | ((ipre_s &amp; 3) &lt;&lt; 6) | 0x21 } }</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dds_init</span> <span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">reg_vals</span><span class="p">[</span><span class="n">NUM_DDS_REGS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">dds_init_vals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/*       DDR(FDR)       SDR(HDR)   */</span>
	<span class="cm">/* Vendor recommends below for 3m cable */</span>
<span class="cp">#define DDS_3M 0</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">29</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="cm">/* Vendor recommends below for 1m cable */</span>
<span class="cp">#define DDS_1M 13</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">27</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
	<span class="n">DDS_VAL</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Now the RXEQ section of the table.</span>
<span class="cm"> */</span>
<span class="cm">/* Hardware packs an element number and register address thus: */</span>
<span class="cp">#define RXEQ_INIT_RDESC(elt, addr) (((elt) &amp; 0xF) | ((addr) &lt;&lt; 4))</span>
<span class="cp">#define RXEQ_VAL(elt, adr, val0, val1, val2, val3) \</span>
<span class="cp">	{RXEQ_INIT_RDESC((elt), (adr)), {(val0), (val1), (val2), (val3)} }</span>

<span class="cp">#define RXEQ_VAL_ALL(elt, adr, val)  \</span>
<span class="cp">	{RXEQ_INIT_RDESC((elt), (adr)), {(val), (val), (val), (val)} }</span>

<span class="cp">#define RXEQ_SDR_DFELTH 0</span>
<span class="cp">#define RXEQ_SDR_TLTH 0</span>
<span class="cp">#define RXEQ_SDR_G1CNT_Z1CNT 0x11</span>
<span class="cp">#define RXEQ_SDR_ZCNT 23</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rxeq_init</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">rdesc</span><span class="p">;</span>      <span class="cm">/* in form used in SerDesDDSRXEQ */</span>
	<span class="n">u8</span>  <span class="n">rdata</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="n">rxeq_init_vals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Set Rcv Eq. to Preset node */</span>
	<span class="n">RXEQ_VAL_ALL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x27</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">),</span>
	<span class="cm">/* Set DFELTHFDR/HDR thresholds */</span>
	<span class="n">RXEQ_VAL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* FDR, was 0, 1, 2, 3 */</span>
	<span class="n">RXEQ_VAL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* HDR */</span>
	<span class="cm">/* Set TLTHFDR/HDR theshold */</span>
	<span class="n">RXEQ_VAL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span>    <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="cm">/* FDR, was 0, 2, 4, 6 */</span>
	<span class="n">RXEQ_VAL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="cm">/* HDR, was  0, 1, 2, 3 */</span>
	<span class="cm">/* Set Preamp setting 2 (ZFR/ZCNT) */</span>
	<span class="n">RXEQ_VAL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x1B</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="cm">/* FDR, was 12, 16, 20, 24 */</span>
	<span class="n">RXEQ_VAL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x1C</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="cm">/* HDR, was 12, 16, 20, 24 */</span>
	<span class="cm">/* Set Preamp DC gain and Setting 1 (GFR/GHR) */</span>
	<span class="n">RXEQ_VAL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x1E</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="cm">/* FDR, was 16, 17, 18, 20 */</span>
	<span class="n">RXEQ_VAL</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mh">0x1F</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="cm">/* HDR, was 16, 17, 18, 20 */</span>
	<span class="cm">/* Toggle RELOCK (in VCDL_CTRL0) to lock to data */</span>
	<span class="n">RXEQ_VAL_ALL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="cm">/* Set D5 High */</span>
	<span class="n">RXEQ_VAL_ALL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="cm">/* Set D5 Low */</span>
<span class="p">};</span>

<span class="cm">/* There are 17 values from vendor, but IBC only accesses the first 16 */</span>
<span class="cp">#define DDS_ROWS (16)</span>
<span class="cp">#define RXEQ_ROWS ARRAY_SIZE(rxeq_init_vals)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd_setvals</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">midx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_idx</span><span class="p">;</span>     <span class="cm">/* Minimum index for this portion of table */</span>
	<span class="kt">uint32_t</span> <span class="n">dds_reg_map</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">taddr</span><span class="p">,</span> <span class="o">*</span><span class="n">iaddr</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">sdctl</span><span class="p">;</span>

	<span class="n">taddr</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">kregbase</span> <span class="o">+</span> <span class="n">kr_serdes_maptable</span><span class="p">;</span>
	<span class="n">iaddr</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">kregbase</span> <span class="o">+</span> <span class="n">kr_serdes_ddsrxeq0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Init the DDS section of the table.</span>
<span class="cm">	 * Each &quot;row&quot; of the table provokes NUM_DDS_REG writes, to the</span>
<span class="cm">	 * registers indicated in DDS_REG_MAP.</span>
<span class="cm">	 */</span>
	<span class="n">sdctl</span> <span class="o">=</span> <span class="n">qib_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_ibserdesctrl</span><span class="p">);</span>
	<span class="n">sdctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1f</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">NUM_DDS_REGS</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">sdctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1f</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">RXEQ_ROWS</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">);</span>
	<span class="n">qib_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_ibserdesctrl</span><span class="p">,</span> <span class="n">sdctl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Iterate down table within loop for each register to store.</span>
<span class="cm">	 */</span>
	<span class="n">dds_reg_map</span> <span class="o">=</span> <span class="n">DDS_REG_MAP</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">NUM_DDS_REGS</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">((</span><span class="n">dds_reg_map</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">TX_FAST_ELT</span><span class="p">;</span>
		<span class="n">writeq</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">iaddr</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>
		<span class="n">mmiowb</span><span class="p">();</span>
		<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
		<span class="n">dds_reg_map</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">midx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">midx</span> <span class="o">&lt;</span> <span class="n">DDS_ROWS</span><span class="p">;</span> <span class="o">++</span><span class="n">midx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">taddr</span> <span class="o">+</span> <span class="p">((</span><span class="n">midx</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">dds_init_vals</span><span class="p">[</span><span class="n">midx</span><span class="p">].</span><span class="n">reg_vals</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
			<span class="n">writeq</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>
			<span class="n">mmiowb</span><span class="p">();</span>
			<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
		<span class="p">}</span> <span class="cm">/* End inner for (vals for this reg, each row) */</span>
	<span class="p">}</span> <span class="cm">/* end outer for (regs to be stored) */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Init the RXEQ section of the table.</span>
<span class="cm">	 * This runs in a different order, as the pattern of</span>
<span class="cm">	 * register references is more complex, but there are only</span>
<span class="cm">	 * four &quot;data&quot; values per register.</span>
<span class="cm">	 */</span>
	<span class="n">min_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span> <span class="cm">/* RXEQ indices pick up where DDS left off */</span>
	<span class="n">taddr</span> <span class="o">+=</span> <span class="mh">0x100</span><span class="p">;</span> <span class="cm">/* RXEQ data is in second half of table */</span>
	<span class="cm">/* Iterate through RXEQ register addresses */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">RXEQ_ROWS</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">didx</span><span class="p">;</span> <span class="cm">/* &quot;destination&quot; */</span>
		<span class="kt">int</span> <span class="n">vidx</span><span class="p">;</span>

		<span class="cm">/* didx is offset by min_idx to address RXEQ range of regs */</span>
		<span class="n">didx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">min_idx</span><span class="p">;</span>
		<span class="cm">/* Store the next RXEQ register address */</span>
		<span class="n">writeq</span><span class="p">(</span><span class="n">rxeq_init_vals</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">rdesc</span><span class="p">,</span> <span class="n">iaddr</span> <span class="o">+</span> <span class="n">didx</span><span class="p">);</span>
		<span class="n">mmiowb</span><span class="p">();</span>
		<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
		<span class="cm">/* Iterate through RXEQ values */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vidx</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">vidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">rxeq_init_vals</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">rdata</span><span class="p">[</span><span class="n">vidx</span><span class="p">];</span>
			<span class="n">writeq</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">taddr</span> <span class="o">+</span> <span class="p">(</span><span class="n">vidx</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>
			<span class="n">mmiowb</span><span class="p">();</span>
			<span class="n">qib_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">kr_scratch</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="cm">/* end outer for (Reg-writes for RXEQ) */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define CMUCTRL5 EPB_LOC(7, 0, 0x15)</span>
<span class="cp">#define RXHSCTRL0(chan) EPB_LOC(chan, 6, 0)</span>
<span class="cp">#define VCDL_DAC2(chan) EPB_LOC(chan, 6, 5)</span>
<span class="cp">#define VCDL_CTRL0(chan) EPB_LOC(chan, 6, 6)</span>
<span class="cp">#define VCDL_CTRL2(chan) EPB_LOC(chan, 6, 8)</span>
<span class="cp">#define START_EQ2(chan) EPB_LOC(chan, 7, 0x28)</span>

<span class="cm">/*</span>
<span class="cm"> * Repeat a &quot;store&quot; across all channels of the IB SerDes.</span>
<span class="cm"> * Although nominally it inherits the &quot;read value&quot; of the last</span>
<span class="cm"> * channel it modified, the only really useful return is &lt;0 for</span>
<span class="cm"> * failure, &gt;= 0 for success. The parameter &#39;loc&#39; is assumed to</span>
<span class="cm"> * be the location in some channel of the register to be modified</span>
<span class="cm"> * The caller can specify use of the &quot;gang write&quot; option of EPB,</span>
<span class="cm"> * in which case we use the specified channel data for any fields</span>
<span class="cm"> * not explicitely written.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ibsd_mod_allchnls</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chnl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">loc</span> <span class="o">&amp;</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Our caller has assured us that we can set all four</span>
<span class="cm">		 * channels at once. Trust that. If mask is not 0xFF,</span>
<span class="cm">		 * we will read the _specified_ channel for our starting</span>
<span class="cm">		 * value.</span>
<span class="cm">		 */</span>
		<span class="n">loc</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">EPB_IB_QUAD0_CS_SHF</span><span class="p">);</span>
		<span class="n">chnl</span> <span class="o">=</span> <span class="p">(</span><span class="n">loc</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">EPB_ADDR_SHF</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span>
						 <span class="n">loc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">sloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">&gt;&gt;</span> <span class="n">EPB_ADDR_SHF</span><span class="p">;</span>

				<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;pre-read failed: elt %d,&quot;</span>
					    <span class="s">&quot; addr 0x%X, chnl %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="p">(</span><span class="n">sloc</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">),</span>
					    <span class="p">(</span><span class="n">sloc</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="n">chnl</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">loc</span> <span class="o">&amp;=</span>  <span class="o">~</span><span class="p">(</span><span class="mi">7</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="n">EPB_ADDR_SHF</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">sloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">&gt;&gt;</span> <span class="n">EPB_ADDR_SHF</span><span class="p">;</span>

			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Global WR failed: elt %d,&quot;</span>
				    <span class="s">&quot; addr 0x%X, val %02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">sloc</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">),</span> <span class="p">(</span><span class="n">sloc</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Clear &quot;channel&quot; and set CS so we can simply iterate */</span>
	<span class="n">loc</span> <span class="o">&amp;=</span>  <span class="o">~</span><span class="p">(</span><span class="mi">7</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="n">EPB_ADDR_SHF</span><span class="p">));</span>
	<span class="n">loc</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">EPB_IB_QUAD0_CS_SHF</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chnl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chnl</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">chnl</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">|</span> <span class="p">(</span><span class="n">chnl</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="n">EPB_ADDR_SHF</span><span class="p">));</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">cloc</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">sloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">&gt;&gt;</span> <span class="n">EPB_ADDR_SHF</span><span class="p">;</span>

			<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Write failed: elt %d,&quot;</span>
				    <span class="s">&quot; addr 0x%X, chnl %d, val 0x%02X,&quot;</span>
				    <span class="s">&quot; mask 0x%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">sloc</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">),</span> <span class="p">(</span><span class="n">sloc</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="n">chnl</span><span class="p">,</span>
				    <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the Tx values normally modified by IBC in IB1.2 mode to default</span>
<span class="cm"> * values, as gotten from first row of init table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_dds_vals</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dds_init</span> <span class="o">*</span><span class="n">ddi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">regmap</span><span class="p">;</span>

	<span class="n">regmap</span> <span class="o">=</span> <span class="n">DDS_REG_MAP</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">NUM_DDS_REGS</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">regmap</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">);</span>
		<span class="n">regmap</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">reg_vals</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="cm">/* Vendor says RMW not needed for these regs, use 0xFF mask */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">EPB_LOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">reg</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the Rx values normally modified by IBC in IB1.2 mode to default</span>
<span class="cm"> * values, as gotten from selected column of init table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_rxeq_vals</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vsel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ridx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">rxeq_init_vals</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ridx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ridx</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">ridx</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">elt</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">loc</span><span class="p">;</span>

		<span class="n">elt</span> <span class="o">=</span> <span class="n">rxeq_init_vals</span><span class="p">[</span><span class="n">ridx</span><span class="p">].</span><span class="n">rdesc</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">rxeq_init_vals</span><span class="p">[</span><span class="n">ridx</span><span class="p">].</span><span class="n">rdesc</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="n">EPB_LOC</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">elt</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">rxeq_init_vals</span><span class="p">[</span><span class="n">ridx</span><span class="p">].</span><span class="n">rdata</span><span class="p">[</span><span class="n">vsel</span><span class="p">];</span>
		<span class="cm">/* mask of 0xFF, because hardware does full-byte store. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the default values (row 0) for DDR Driver Demphasis.</span>
<span class="cm"> * we do this initially and whenever we turn off IB-1.2</span>
<span class="cm"> *</span>
<span class="cm"> * The &quot;default&quot; values for Rx equalization are also stored to</span>
<span class="cm"> * SerDes registers. Formerly (and still default), we used set 2.</span>
<span class="cm"> * For experimenting with cables and link-partners, we allow changing</span>
<span class="cm"> * that via a module parameter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">qib_rxeq_set</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">rxeq_default_set</span><span class="p">,</span> <span class="n">qib_rxeq_set</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span>
		   <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">rxeq_default_set</span><span class="p">,</span>
		 <span class="s">&quot;Which set [0..3] of Rx Equalization values is default&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_internal_presets</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_dds_vals</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dds_init_vals</span> <span class="o">+</span> <span class="n">DDS_3M</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to set default DDS values</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_rxeq_vals</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">qib_rxeq_set</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to set default RXEQ values</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">qib_sd7220_presets</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">presets_needed</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">presets_needed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Assert uC reset, so we don&#39;t clash with it. */</span>
	<span class="n">qib_ibsd_reset</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">qib_sd_trimdone_monitor</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;link-down&quot;</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">qib_internal_presets</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd_trimself</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">CMUCTRL5</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">EPB_IB_QUAD0_CS_SHF</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">qib_sd7220_reg_mod</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_7220_SERDES</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd_early</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">RXHSCTRL0</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mh">0xD4</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">START_EQ1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">START_EQ2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define BACTRL(chnl) EPB_LOC(chnl, 6, 0x0E)</span>
<span class="cp">#define LDOUTCTRL1(chnl) EPB_LOC(chnl, 7, 6)</span>
<span class="cp">#define RXHSSTATUS(chnl) EPB_LOC(chnl, 6, 0xF)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">qib_sd_dactrim</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">VCDL_DAC2</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mh">0x2D</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/* more fine-tuning of what will be default */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">VCDL_CTRL2</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0xF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">BACTRL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">LDOUTCTRL1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">RXHSSTATUS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delay for max possible number of steps, with slop.</span>
<span class="cm">	 * Each step is about 4usec.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">415</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">LDOUTCTRL1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define RELOCK_FIRST_MS 3</span>
<span class="cp">#define RXLSPPM(chan) EPB_LOC(chan, 0, 2)</span>
<span class="kt">void</span> <span class="nf">toggle_7220_rclkrls</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">RXLSPPM</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">EPB_GLOBAL_WR</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;RCLKRLS failed to clear D7</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* And again for good measure */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">qib_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;RCLKRLS failed to clear D7</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ibsd_mod_allchnls</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Now reset xgxs and IBC to complete the recovery */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">f_xgxs_reset</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Shut down the timer that polls for relock occasions, if needed</span>
<span class="cm"> * this is &quot;hooked&quot; from qib_7220_quiet_serdes(), which is called</span>
<span class="cm"> * just before qib_shutdown_device() in qib_driver.c shuts down all</span>
<span class="cm"> * the other timers</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">shutdown_7220_relock_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">relock_timer_active</span><span class="p">)</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">qib_relock_by_timer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">relock_by_timer</span><span class="p">,</span> <span class="n">qib_relock_by_timer</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span>
		   <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">relock_by_timer</span><span class="p">,</span> <span class="s">&quot;Allow relock attempt if link not up&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">qib_run_relock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_chip_specific</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeoff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check link-training state for &quot;stuck&quot; state, when down.</span>
<span class="cm">	 * if found, try relock and schedule another try at</span>
<span class="cm">	 * exponentially growing delay, maxed at one second.</span>
<span class="cm">	 * if not stuck, our work is done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_INITTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="n">QIBL_IB_AUTONEG_INPROG</span> <span class="o">|</span> <span class="n">QIBL_LINKINIT</span> <span class="o">|</span> <span class="n">QIBL_LINKARMED</span> <span class="o">|</span>
	     <span class="n">QIBL_LINKACTIVE</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qib_relock_by_timer</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">lflags</span> <span class="o">&amp;</span> <span class="n">QIBL_IB_LINK_DISABLED</span><span class="p">))</span>
				<span class="n">toggle_7220_rclkrls</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* re-set timer for next check */</span>
		<span class="n">timeoff</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_interval</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeoff</span> <span class="o">&gt;</span> <span class="n">HZ</span><span class="p">)</span>
			<span class="n">timeoff</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_interval</span> <span class="o">=</span> <span class="n">timeoff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">timeoff</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeoff</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_7220_relock_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ibup</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_chip_specific</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">cspec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ibup</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We are now up, relax timer to 1 second interval */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_interval</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Transition to down, (re-)set timer to short interval. */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>

		<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">RELOCK_FIRST_MS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* If timer has not yet been started, do so. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer_active</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">);</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">qib_run_relock</span><span class="p">;</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dd</span><span class="p">;</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_interval</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>
			<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_interval</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">relock_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
