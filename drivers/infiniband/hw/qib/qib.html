<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › qib › qib.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>qib.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _QIB_KERNEL_H</span>
<span class="cp">#define _QIB_KERNEL_H</span>
<span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, 2007, 2008, 2009, 2010 QLogic Corporation.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This header file is the base header file for qlogic_ib kernel code</span>
<span class="cm"> * qib_user.h serves a similar purpose for user code.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#include &quot;qib_common.h&quot;</span>
<span class="cp">#include &quot;qib_verbs.h&quot;</span>

<span class="cm">/* only s/w major version of QLogic_IB we can handle */</span>
<span class="cp">#define QIB_CHIP_VERS_MAJ 2U</span>

<span class="cm">/* don&#39;t care about this except printing */</span>
<span class="cp">#define QIB_CHIP_VERS_MIN 0U</span>

<span class="cm">/* The Organization Unique Identifier (Mfg code), and its position in GUID */</span>
<span class="cp">#define QIB_OUI 0x001175</span>
<span class="cp">#define QIB_OUI_LSB 40</span>

<span class="cm">/*</span>
<span class="cm"> * per driver stats, either not device nor port-specific, or</span>
<span class="cm"> * summed over all of the devices and ports.</span>
<span class="cm"> * They are described by name via ipathfs filesystem, so layout</span>
<span class="cm"> * and number of elements can change without breaking compatibility.</span>
<span class="cm"> * If members are added or deleted qib_statnames[] in qib_fs.c must</span>
<span class="cm"> * change to match.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qlogic_ib_stats</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">sps_ints</span><span class="p">;</span> <span class="cm">/* number of interrupts handled */</span>
	<span class="n">__u64</span> <span class="n">sps_errints</span><span class="p">;</span> <span class="cm">/* number of error interrupts */</span>
	<span class="n">__u64</span> <span class="n">sps_txerrs</span><span class="p">;</span> <span class="cm">/* tx-related packet errors */</span>
	<span class="n">__u64</span> <span class="n">sps_rcverrs</span><span class="p">;</span> <span class="cm">/* non-crc rcv packet errors */</span>
	<span class="n">__u64</span> <span class="n">sps_hwerrs</span><span class="p">;</span> <span class="cm">/* hardware errors reported (parity, etc.) */</span>
	<span class="n">__u64</span> <span class="n">sps_nopiobufs</span><span class="p">;</span> <span class="cm">/* no pio bufs avail from kernel */</span>
	<span class="n">__u64</span> <span class="n">sps_ctxts</span><span class="p">;</span> <span class="cm">/* number of contexts currently open */</span>
	<span class="n">__u64</span> <span class="n">sps_lenerrs</span><span class="p">;</span> <span class="cm">/* number of kernel packets where RHF != LRH len */</span>
	<span class="n">__u64</span> <span class="n">sps_buffull</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">sps_hdrfull</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">qlogic_ib_stats</span> <span class="n">qib_stats</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="n">qib_pci_err_handler</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">qib_driver</span><span class="p">;</span>

<span class="cp">#define QIB_CHIP_SWVERSION QIB_CHIP_VERS_MAJ</span>
<span class="cm">/*</span>
<span class="cm"> * First-cut critierion for &quot;device is active&quot; is</span>
<span class="cm"> * two thousand dwords combined Tx, Rx traffic per</span>
<span class="cm"> * 5-second interval. SMA packets are 64 dwords,</span>
<span class="cm"> * and occur &quot;a few per second&quot;, presumably each way.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_TRAFFIC_ACTIVE_THRESHOLD (2000)</span>

<span class="cm">/*</span>
<span class="cm"> * Struct used to indicate which errors are logged in each of the</span>
<span class="cm"> * error-counters that are logged to EEPROM. A counter is incremented</span>
<span class="cm"> * _once_ (saturating at 255) for each event with any bits set in</span>
<span class="cm"> * the error or hwerror register masks below.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_EEP_LOG_CNT (4)</span>
<span class="k">struct</span> <span class="n">qib_eep_log_mask</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">errs_to_log</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hwerrs_to_log</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Below contains all data related to a single context (formerly called port).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">rcvegrbuf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">rcvegrbuf_phys</span><span class="p">;</span>
	<span class="cm">/* rcvhdrq base, needs mmap before useful */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rcvhdrq</span><span class="p">;</span>
	<span class="cm">/* kernel virtual address where hdrqtail is updated */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">rcvhdrtail_kvaddr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * temp buffer for expected send setup, allocated at open, instead</span>
<span class="cm">	 * of each setup call</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tid_pg_list</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Shared page for kernel to signal user processes that send buffers</span>
<span class="cm">	 * need disarming.  The process should call QIB_CMD_DISARM_BUFS</span>
<span class="cm">	 * or QIB_CMD_ACK_EVENT with IPATH_EVENT_DISARM_BUFS set.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">user_event_mask</span><span class="p">;</span>
	<span class="cm">/* when waiting for rcv or pioavail */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * rcvegr bufs base, physical, must fit</span>
<span class="cm">	 * in 44 bits so 32 bit programs mmap64 44 bit works)</span>
<span class="cm">	 */</span>
	<span class="n">dma_addr_t</span> <span class="n">rcvegr_phys</span><span class="p">;</span>
	<span class="cm">/* mmap of hdrq, must fit in 44 bits */</span>
	<span class="n">dma_addr_t</span> <span class="n">rcvhdrq_phys</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rcvhdrqtailaddr_phys</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * number of opens (including slave sub-contexts) on this instance</span>
<span class="cm">	 * (ignoring forks, dup, etc. for now)</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * how much space to leave at start of eager TID entries for</span>
<span class="cm">	 * protocol use, on each TID</span>
<span class="cm">	 */</span>
	<span class="cm">/* instead of calculating it */</span>
	<span class="kt">unsigned</span> <span class="n">ctxt</span><span class="p">;</span>
	<span class="cm">/* non-zero if ctxt is being shared. */</span>
	<span class="n">u16</span> <span class="n">subctxt_cnt</span><span class="p">;</span>
	<span class="cm">/* non-zero if ctxt is being shared. */</span>
	<span class="n">u16</span> <span class="n">subctxt_id</span><span class="p">;</span>
	<span class="cm">/* number of eager TID entries. */</span>
	<span class="n">u16</span> <span class="n">rcvegrcnt</span><span class="p">;</span>
	<span class="cm">/* index of first eager TID entry. */</span>
	<span class="n">u16</span> <span class="n">rcvegr_tid_base</span><span class="p">;</span>
	<span class="cm">/* number of pio bufs for this ctxt (all procs, if shared) */</span>
	<span class="n">u32</span> <span class="n">piocnt</span><span class="p">;</span>
	<span class="cm">/* first pio buffer for this ctxt */</span>
	<span class="n">u32</span> <span class="n">pio_base</span><span class="p">;</span>
	<span class="cm">/* chip offset of PIO buffers for this ctxt */</span>
	<span class="n">u32</span> <span class="n">piobufs</span><span class="p">;</span>
	<span class="cm">/* how many alloc_pages() chunks in rcvegrbuf_pages */</span>
	<span class="n">u32</span> <span class="n">rcvegrbuf_chunks</span><span class="p">;</span>
	<span class="cm">/* how many egrbufs per chunk */</span>
	<span class="n">u16</span> <span class="n">rcvegrbufs_perchunk</span><span class="p">;</span>
	<span class="cm">/* ilog2 of above */</span>
	<span class="n">u16</span> <span class="n">rcvegrbufs_perchunk_shift</span><span class="p">;</span>
	<span class="cm">/* order for rcvegrbuf_pages */</span>
	<span class="kt">size_t</span> <span class="n">rcvegrbuf_size</span><span class="p">;</span>
	<span class="cm">/* rcvhdrq size (for freeing) */</span>
	<span class="kt">size_t</span> <span class="n">rcvhdrq_size</span><span class="p">;</span>
	<span class="cm">/* per-context flags for fileops/intr communication */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>
	<span class="cm">/* next expected TID to check when looking for free */</span>
	<span class="n">u32</span> <span class="n">tidcursor</span><span class="p">;</span>
	<span class="cm">/* WAIT_RCV that timed out, no interrupt */</span>
	<span class="n">u32</span> <span class="n">rcvwait_to</span><span class="p">;</span>
	<span class="cm">/* WAIT_PIO that timed out, no interrupt */</span>
	<span class="n">u32</span> <span class="n">piowait_to</span><span class="p">;</span>
	<span class="cm">/* WAIT_RCV already happened, no wait */</span>
	<span class="n">u32</span> <span class="n">rcvnowait</span><span class="p">;</span>
	<span class="cm">/* WAIT_PIO already happened, no wait */</span>
	<span class="n">u32</span> <span class="n">pionowait</span><span class="p">;</span>
	<span class="cm">/* total number of polled urgent packets */</span>
	<span class="n">u32</span> <span class="n">urgent</span><span class="p">;</span>
	<span class="cm">/* saved total number of polled urgent packets for poll edge trigger */</span>
	<span class="n">u32</span> <span class="n">urgent_poll</span><span class="p">;</span>
	<span class="cm">/* pid of process using this ctxt */</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">subpid</span><span class="p">[</span><span class="n">QLOGIC_IB_MAX_SUBCTXT</span><span class="p">];</span>
	<span class="cm">/* same size as task_struct .comm[], command that opened context */</span>
	<span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="cm">/* pkeys set by this use of this ctxt */</span>
	<span class="n">u16</span> <span class="n">pkeys</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* so file ops can get at unit */</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="cm">/* so funcs that need physical port can get it easily */</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">;</span>
	<span class="cm">/* A page of memory for rcvhdrhead, rcvegrhead, rcvegrtail * N */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">subctxt_uregbase</span><span class="p">;</span>
	<span class="cm">/* An array of pages for the eager receive buffers * N */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">subctxt_rcvegrbuf</span><span class="p">;</span>
	<span class="cm">/* An array of pages for the eager header queue entries * N */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">subctxt_rcvhdr_base</span><span class="p">;</span>
	<span class="cm">/* The version of the library which opened this ctxt */</span>
	<span class="n">u32</span> <span class="n">userversion</span><span class="p">;</span>
	<span class="cm">/* Bitmask of active slaves */</span>
	<span class="n">u32</span> <span class="n">active_slaves</span><span class="p">;</span>
	<span class="cm">/* Type of packets or conditions we want to poll for */</span>
	<span class="n">u16</span> <span class="n">poll_type</span><span class="p">;</span>
	<span class="cm">/* receive packet sequence counter */</span>
	<span class="n">u8</span> <span class="n">seq_cnt</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">redirect_seq_cnt</span><span class="p">;</span>
	<span class="cm">/* ctxt rcvhdrq head offset */</span>
	<span class="n">u32</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pkt_count</span><span class="p">;</span>
	<span class="cm">/* lookaside fields */</span>
	<span class="k">struct</span> <span class="n">qib_qp</span> <span class="o">*</span><span class="n">lookaside_qp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">lookaside_qpn</span><span class="p">;</span>
	<span class="cm">/* QPs waiting for context processing */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">qp_wait_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qib_sge_state</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">qib_sdma_txreq</span> <span class="p">{</span>
	<span class="kt">int</span>                 <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>                 <span class="n">sg_count</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>          <span class="n">addr</span><span class="p">;</span>
	<span class="kt">void</span>              <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_sdma_txreq</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">u16</span>                 <span class="n">start_idx</span><span class="p">;</span>  <span class="cm">/* sdma private */</span>
	<span class="n">u16</span>                 <span class="n">next_descq_idx</span><span class="p">;</span>  <span class="cm">/* sdma private */</span>
	<span class="k">struct</span> <span class="n">list_head</span>    <span class="n">list</span><span class="p">;</span>       <span class="cm">/* sdma private */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qib_sdma_desc</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">qw</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qib_verbs_txreq</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_sdma_txreq</span>   <span class="n">txreq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_qp</span>           <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_swqe</span>         <span class="o">*</span><span class="n">wqe</span><span class="p">;</span>
	<span class="n">u32</span>                     <span class="n">dwords</span><span class="p">;</span>
	<span class="n">u16</span>                     <span class="n">hdr_dwords</span><span class="p">;</span>
	<span class="n">u16</span>                     <span class="n">hdr_inx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_pio_header</span>	<span class="o">*</span><span class="n">align_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_mregion</span>	<span class="o">*</span><span class="n">mr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_sge_state</span>    <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define QIB_SDMA_TXREQ_F_USELARGEBUF  0x1</span>
<span class="cp">#define QIB_SDMA_TXREQ_F_HEADTOHOST   0x2</span>
<span class="cp">#define QIB_SDMA_TXREQ_F_INTREQ       0x4</span>
<span class="cp">#define QIB_SDMA_TXREQ_F_FREEBUF      0x8</span>
<span class="cp">#define QIB_SDMA_TXREQ_F_FREEDESC     0x10</span>

<span class="cp">#define QIB_SDMA_TXREQ_S_OK        0</span>
<span class="cp">#define QIB_SDMA_TXREQ_S_SENDERROR 1</span>
<span class="cp">#define QIB_SDMA_TXREQ_S_ABORTED   2</span>
<span class="cp">#define QIB_SDMA_TXREQ_S_SHUTDOWN  3</span>

<span class="cm">/*</span>
<span class="cm"> * Get/Set IB link-level config parameters for f_get/set_ib_cfg()</span>
<span class="cm"> * Mostly for MADs that set or query link parameters, also ipath</span>
<span class="cm"> * config interfaces</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_IB_CFG_LIDLMC 0 </span><span class="cm">/* LID (LS16b) and Mask (MS16b) */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_LWID_ENB 2 </span><span class="cm">/* allowed Link-width */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_LWID 3 </span><span class="cm">/* currently active Link-width */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_SPD_ENB 4 </span><span class="cm">/* allowed Link speeds */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_SPD 5 </span><span class="cm">/* current Link spd */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_RXPOL_ENB 6 </span><span class="cm">/* Auto-RX-polarity enable */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_LREV_ENB 7 </span><span class="cm">/* Auto-Lane-reversal enable */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_LINKLATENCY 8 </span><span class="cm">/* Link Latency (IB1.2 only) */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_HRTBT 9 </span><span class="cm">/* IB heartbeat off/enable/auto; DDR/QDR only */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_OP_VLS 10 </span><span class="cm">/* operational VLs */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_VL_HIGH_CAP 11 </span><span class="cm">/* num of VL high priority weights */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_VL_LOW_CAP 12 </span><span class="cm">/* num of VL low priority weights */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_OVERRUN_THRESH 13 </span><span class="cm">/* IB overrun threshold */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_PHYERR_THRESH 14 </span><span class="cm">/* IB PHY error threshold */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_LINKDEFAULT 15 </span><span class="cm">/* IB link default (sleep/poll) */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_PKEYS 16 </span><span class="cm">/* update partition keys */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_MTU 17 </span><span class="cm">/* update MTU in IBC */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_LSTATE 18 </span><span class="cm">/* update linkcmd and linkinitcmd in IBC */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_VL_HIGH_LIMIT 19</span>
<span class="cp">#define QIB_IB_CFG_PMA_TICKS 20 </span><span class="cm">/* PMA sample tick resolution */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_CFG_PORT 21 </span><span class="cm">/* switch port we are connected to */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * for CFG_LSTATE: LINKCMD in upper 16 bits, LINKINITCMD in lower 16</span>
<span class="cm"> * IB_LINKINITCMD_POLL and SLEEP are also used as set/get values for</span>
<span class="cm"> * QIB_IB_CFG_LINKDEFAULT cmd</span>
<span class="cm"> */</span>
<span class="cp">#define   IB_LINKCMD_DOWN   (0 &lt;&lt; 16)</span>
<span class="cp">#define   IB_LINKCMD_ARMED  (1 &lt;&lt; 16)</span>
<span class="cp">#define   IB_LINKCMD_ACTIVE (2 &lt;&lt; 16)</span>
<span class="cp">#define   IB_LINKINITCMD_NOP     0</span>
<span class="cp">#define   IB_LINKINITCMD_POLL    1</span>
<span class="cp">#define   IB_LINKINITCMD_SLEEP   2</span>
<span class="cp">#define   IB_LINKINITCMD_DISABLE 3</span>

<span class="cm">/*</span>
<span class="cm"> * valid states passed to qib_set_linkstate() user call</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_IB_LINKDOWN         0</span>
<span class="cp">#define QIB_IB_LINKARM          1</span>
<span class="cp">#define QIB_IB_LINKACTIVE       2</span>
<span class="cp">#define QIB_IB_LINKDOWN_ONLY    3</span>
<span class="cp">#define QIB_IB_LINKDOWN_SLEEP   4</span>
<span class="cp">#define QIB_IB_LINKDOWN_DISABLE 5</span>

<span class="cm">/*</span>
<span class="cm"> * These 7 values (SDR, DDR, and QDR may be ORed for auto-speed</span>
<span class="cm"> * negotiation) are used for the 3rd argument to path_f_set_ib_cfg</span>
<span class="cm"> * with cmd QIB_IB_CFG_SPD_ENB, by direct calls or via sysfs.  They</span>
<span class="cm"> * are also the the possible values for qib_link_speed_enabled and active</span>
<span class="cm"> * The values were chosen to match values used within the IB spec.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_IB_SDR 1</span>
<span class="cp">#define QIB_IB_DDR 2</span>
<span class="cp">#define QIB_IB_QDR 4</span>

<span class="cp">#define QIB_DEFAULT_MTU 4096</span>

<span class="cm">/* max number of IB ports supported per HCA */</span>
<span class="cp">#define QIB_MAX_IB_PORTS 2</span>

<span class="cm">/*</span>
<span class="cm"> * Possible IB config parameters for f_get/set_ib_table()</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_IB_TBL_VL_HIGH_ARB 1 </span><span class="cm">/* Get/set VL high priority weights */</span><span class="cp"></span>
<span class="cp">#define QIB_IB_TBL_VL_LOW_ARB 2 </span><span class="cm">/* Get/set VL low priority weights */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Possible &quot;operations&quot; for f_rcvctrl(ppd, op, ctxt)</span>
<span class="cm"> * these are bits so they can be combined, e.g.</span>
<span class="cm"> * QIB_RCVCTRL_INTRAVAIL_ENB | QIB_RCVCTRL_CTXT_ENB</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_RCVCTRL_TAILUPD_ENB 0x01</span>
<span class="cp">#define QIB_RCVCTRL_TAILUPD_DIS 0x02</span>
<span class="cp">#define QIB_RCVCTRL_CTXT_ENB 0x04</span>
<span class="cp">#define QIB_RCVCTRL_CTXT_DIS 0x08</span>
<span class="cp">#define QIB_RCVCTRL_INTRAVAIL_ENB 0x10</span>
<span class="cp">#define QIB_RCVCTRL_INTRAVAIL_DIS 0x20</span>
<span class="cp">#define QIB_RCVCTRL_PKEY_ENB 0x40  </span><span class="cm">/* Note, default is enabled */</span><span class="cp"></span>
<span class="cp">#define QIB_RCVCTRL_PKEY_DIS 0x80</span>
<span class="cp">#define QIB_RCVCTRL_BP_ENB 0x0100</span>
<span class="cp">#define QIB_RCVCTRL_BP_DIS 0x0200</span>
<span class="cp">#define QIB_RCVCTRL_TIDFLOW_ENB 0x0400</span>
<span class="cp">#define QIB_RCVCTRL_TIDFLOW_DIS 0x0800</span>

<span class="cm">/*</span>
<span class="cm"> * Possible &quot;operations&quot; for f_sendctrl(ppd, op, var)</span>
<span class="cm"> * these are bits so they can be combined, e.g.</span>
<span class="cm"> * QIB_SENDCTRL_BUFAVAIL_ENB | QIB_SENDCTRL_ENB</span>
<span class="cm"> * Some operations (e.g. DISARM, ABORT) are known to</span>
<span class="cm"> * be &quot;one-shot&quot;, so do not modify shadow.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_SENDCTRL_DISARM       (0x1000)</span>
<span class="cp">#define QIB_SENDCTRL_DISARM_BUF(bufn) ((bufn) | QIB_SENDCTRL_DISARM)</span>
	<span class="cm">/* available (0x2000) */</span>
<span class="cp">#define QIB_SENDCTRL_AVAIL_DIS    (0x4000)</span>
<span class="cp">#define QIB_SENDCTRL_AVAIL_ENB    (0x8000)</span>
<span class="cp">#define QIB_SENDCTRL_AVAIL_BLIP  (0x10000)</span>
<span class="cp">#define QIB_SENDCTRL_SEND_DIS    (0x20000)</span>
<span class="cp">#define QIB_SENDCTRL_SEND_ENB    (0x40000)</span>
<span class="cp">#define QIB_SENDCTRL_FLUSH       (0x80000)</span>
<span class="cp">#define QIB_SENDCTRL_CLEAR      (0x100000)</span>
<span class="cp">#define QIB_SENDCTRL_DISARM_ALL (0x200000)</span>

<span class="cm">/*</span>
<span class="cm"> * These are the generic indices for requesting per-port</span>
<span class="cm"> * counter values via the f_portcntr function.  They</span>
<span class="cm"> * are always returned as 64 bit values, although most</span>
<span class="cm"> * are 32 bit counters.</span>
<span class="cm"> */</span>
<span class="cm">/* send-related counters */</span>
<span class="cp">#define QIBPORTCNTR_PKTSEND         0U</span>
<span class="cp">#define QIBPORTCNTR_WORDSEND        1U</span>
<span class="cp">#define QIBPORTCNTR_PSXMITDATA      2U</span>
<span class="cp">#define QIBPORTCNTR_PSXMITPKTS      3U</span>
<span class="cp">#define QIBPORTCNTR_PSXMITWAIT      4U</span>
<span class="cp">#define QIBPORTCNTR_SENDSTALL       5U</span>
<span class="cm">/* receive-related counters */</span>
<span class="cp">#define QIBPORTCNTR_PKTRCV          6U</span>
<span class="cp">#define QIBPORTCNTR_PSRCVDATA       7U</span>
<span class="cp">#define QIBPORTCNTR_PSRCVPKTS       8U</span>
<span class="cp">#define QIBPORTCNTR_RCVEBP          9U</span>
<span class="cp">#define QIBPORTCNTR_RCVOVFL         10U</span>
<span class="cp">#define QIBPORTCNTR_WORDRCV         11U</span>
<span class="cm">/* IB link related error counters */</span>
<span class="cp">#define QIBPORTCNTR_RXLOCALPHYERR   12U</span>
<span class="cp">#define QIBPORTCNTR_RXVLERR         13U</span>
<span class="cp">#define QIBPORTCNTR_ERRICRC         14U</span>
<span class="cp">#define QIBPORTCNTR_ERRVCRC         15U</span>
<span class="cp">#define QIBPORTCNTR_ERRLPCRC        16U</span>
<span class="cp">#define QIBPORTCNTR_BADFORMAT       17U</span>
<span class="cp">#define QIBPORTCNTR_ERR_RLEN        18U</span>
<span class="cp">#define QIBPORTCNTR_IBSYMBOLERR     19U</span>
<span class="cp">#define QIBPORTCNTR_INVALIDRLEN     20U</span>
<span class="cp">#define QIBPORTCNTR_UNSUPVL         21U</span>
<span class="cp">#define QIBPORTCNTR_EXCESSBUFOVFL   22U</span>
<span class="cp">#define QIBPORTCNTR_ERRLINK         23U</span>
<span class="cp">#define QIBPORTCNTR_IBLINKDOWN      24U</span>
<span class="cp">#define QIBPORTCNTR_IBLINKERRRECOV  25U</span>
<span class="cp">#define QIBPORTCNTR_LLI             26U</span>
<span class="cm">/* other error counters */</span>
<span class="cp">#define QIBPORTCNTR_RXDROPPKT       27U</span>
<span class="cp">#define QIBPORTCNTR_VL15PKTDROP     28U</span>
<span class="cp">#define QIBPORTCNTR_ERRPKEY         29U</span>
<span class="cp">#define QIBPORTCNTR_KHDROVFL        30U</span>
<span class="cm">/* sampling counters (these are actually control registers) */</span>
<span class="cp">#define QIBPORTCNTR_PSINTERVAL      31U</span>
<span class="cp">#define QIBPORTCNTR_PSSTART         32U</span>
<span class="cp">#define QIBPORTCNTR_PSSTAT          33U</span>

<span class="cm">/* how often we check for packet activity for &quot;power on hours (in seconds) */</span>
<span class="cp">#define ACTIVITY_TIMER 5</span>

<span class="cp">#define MAX_NAME_SIZE 64</span>
<span class="k">struct</span> <span class="n">qib_msix_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="n">msix</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_NAME_SIZE</span><span class="p">];</span>
	<span class="n">cpumask_var_t</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Below is an opaque struct. Each chip (device) can maintain</span>
<span class="cm"> * private data needed for its operation, but not germane to the</span>
<span class="cm"> * rest of the driver.  For convenience, we define another that</span>
<span class="cm"> * is chip-specific, per-port</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_chip_specific</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">qib_chipport_specific</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">qib_sdma_states</span> <span class="p">{</span>
	<span class="n">qib_sdma_state_s00_hw_down</span><span class="p">,</span>
	<span class="n">qib_sdma_state_s10_hw_start_up_wait</span><span class="p">,</span>
	<span class="n">qib_sdma_state_s20_idle</span><span class="p">,</span>
	<span class="n">qib_sdma_state_s30_sw_clean_up_wait</span><span class="p">,</span>
	<span class="n">qib_sdma_state_s40_hw_clean_up_wait</span><span class="p">,</span>
	<span class="n">qib_sdma_state_s50_hw_halt_wait</span><span class="p">,</span>
	<span class="n">qib_sdma_state_s99_running</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">qib_sdma_events</span> <span class="p">{</span>
	<span class="n">qib_sdma_event_e00_go_hw_down</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e10_go_hw_start</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e20_hw_started</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e30_go_running</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e40_sw_cleaned</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e50_hw_cleaned</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e60_hw_halted</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e70_go_idle</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e7220_err_halted</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e7322_err_halted</span><span class="p">,</span>
	<span class="n">qib_sdma_event_e90_timer_tick</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">qib_sdma_state_names</span><span class="p">[];</span>
<span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">qib_sdma_event_names</span><span class="p">[];</span>

<span class="k">struct</span> <span class="n">sdma_set_state_action</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">op_enable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">op_intenable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">op_halt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">op_drain</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">go_s99_running_tofalse</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">go_s99_running_totrue</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">qib_sdma_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span>          <span class="n">kref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>    <span class="n">comp</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">qib_sdma_states</span> <span class="n">current_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sdma_set_state_action</span> <span class="o">*</span><span class="n">set_state_action</span><span class="p">;</span>
	<span class="kt">unsigned</span>             <span class="n">current_op</span><span class="p">;</span>
	<span class="kt">unsigned</span>             <span class="n">go_s99_running</span><span class="p">;</span>
	<span class="kt">unsigned</span>             <span class="n">first_sendbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span>             <span class="n">last_sendbuf</span><span class="p">;</span> <span class="cm">/* really last +1 */</span>
	<span class="cm">/* debugging/devel */</span>
	<span class="k">enum</span> <span class="n">qib_sdma_states</span> <span class="n">previous_state</span><span class="p">;</span>
	<span class="kt">unsigned</span>             <span class="n">previous_op</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">qib_sdma_events</span> <span class="n">last_event</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">xmit_wait</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">counter</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cache</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">psxmitdata</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">psrcvdata</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">psxmitpkts</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">psrcvpkts</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">psxmitwait</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">counter_cache</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The structure below encapsulates data relevant to a physical IB Port.</span>
<span class="cm"> * Current chips support only one such port, but the separation</span>
<span class="cm"> * clarifies things a bit. Note that to conform to IB conventions,</span>
<span class="cm"> * port-numbers are one-based. The first or only port is port1.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_ibport</span> <span class="n">ibport_data</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_chippport_specific</span> <span class="o">*</span><span class="n">cpspec</span><span class="p">;</span> <span class="cm">/* chip-specific per-port */</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">pport_kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">sl2vl_kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span> <span class="n">diagc_kobj</span><span class="p">;</span>

	<span class="cm">/* GUID for this interface, in network order */</span>
	<span class="n">__be64</span> <span class="n">guid</span><span class="p">;</span>

	<span class="cm">/* QIB_POLL, etc. link-state specific flags, per port */</span>
	<span class="n">u32</span> <span class="n">lflags</span><span class="p">;</span>
	<span class="cm">/* qib_lflags driver is waiting for */</span>
	<span class="n">u32</span> <span class="n">state_wanted</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lflags_lock</span><span class="p">;</span>

	<span class="cm">/* ref count for each pkey */</span>
	<span class="n">atomic_t</span> <span class="n">pkeyrefs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * this address is mapped readonly into user processes so they can</span>
<span class="cm">	 * get status cheaply, whenever they want.  One qword of status per port</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">statusp</span><span class="p">;</span>

	<span class="cm">/* SendDMA related entries */</span>

	<span class="cm">/* read mostly */</span>
	<span class="k">struct</span> <span class="n">qib_sdma_desc</span> <span class="o">*</span><span class="n">sdma_descq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_sdma_state</span> <span class="n">sdma_state</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>       <span class="n">sdma_descq_phys</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">__le64</span> <span class="o">*</span><span class="n">sdma_head_dma</span><span class="p">;</span> <span class="cm">/* DMA&#39;ed by chip */</span>
	<span class="n">dma_addr_t</span>       <span class="n">sdma_head_phys</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">sdma_descq_cnt</span><span class="p">;</span>

	<span class="cm">/* read/write using lock */</span>
	<span class="n">spinlock_t</span>            <span class="n">sdma_lock</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>      <span class="n">sdma_activelist</span><span class="p">;</span>
	<span class="n">u64</span>                   <span class="n">sdma_descq_added</span><span class="p">;</span>
	<span class="n">u64</span>                   <span class="n">sdma_descq_removed</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">sdma_descq_tail</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">sdma_descq_head</span><span class="p">;</span>
	<span class="n">u8</span>                    <span class="n">sdma_generation</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">sdma_sw_clean_up_task</span>
		<span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

	<span class="n">wait_queue_head_t</span> <span class="n">state_wait</span><span class="p">;</span> <span class="cm">/* for state_wanted */</span>

	<span class="cm">/* HoL blocking for SMP replies */</span>
	<span class="kt">unsigned</span>          <span class="n">hol_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">hol_timer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Shadow copies of registers; size indicates read access size.</span>
<span class="cm">	 * Most of them are readonly, but some are write-only register,</span>
<span class="cm">	 * where we manipulate the bits in the shadow copy, and then write</span>
<span class="cm">	 * the shadow copy to qlogic_ib.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We deliberately make most of these 32 bits, since they have</span>
<span class="cm">	 * restricted range.  For any that we read, we won&#39;t to generate 32</span>
<span class="cm">	 * bit accesses, since Opteron will generate 2 separate 32 bit HT</span>
<span class="cm">	 * transactions for a 64 bit read, and we want to avoid unnecessary</span>
<span class="cm">	 * bus transactions.</span>
<span class="cm">	 */</span>

	<span class="cm">/* This is the 64 bit group */</span>
	<span class="cm">/* last ibcstatus.  opaque outside chip-specific code */</span>
	<span class="n">u64</span> <span class="n">lastibcstat</span><span class="p">;</span>

	<span class="cm">/* these are the &quot;32 bit&quot; regs */</span>

	<span class="cm">/*</span>
<span class="cm">	 * the following two are 32-bit bitmasks, but {test,clear,set}_bit</span>
<span class="cm">	 * all expect bit fields to be &quot;unsigned long&quot;</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p_rcvctrl</span><span class="p">;</span> <span class="cm">/* shadow per-port rcvctrl */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p_sendctrl</span><span class="p">;</span> <span class="cm">/* shadow per-port sendctrl */</span>

	<span class="n">u32</span> <span class="n">ibmtu</span><span class="p">;</span> <span class="cm">/* The MTU programmed for this unit */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Current max size IB packet (in bytes) including IB headers, that</span>
<span class="cm">	 * we can send. Changes when ibmtu changes.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ibmaxlen</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * ibmaxlen at init time, limited by chip and by receive buffer</span>
<span class="cm">	 * size.  Not changed after init.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">init_ibmaxlen</span><span class="p">;</span>
	<span class="cm">/* LID programmed for this instance */</span>
	<span class="n">u16</span> <span class="n">lid</span><span class="p">;</span>
	<span class="cm">/* list of pkeys programmed; 0 if not set */</span>
	<span class="n">u16</span> <span class="n">pkeys</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* LID mask control */</span>
	<span class="n">u8</span> <span class="n">lmc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">link_width_supported</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">link_speed_supported</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">link_width_enabled</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">link_speed_enabled</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">link_width_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">link_speed_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">vls_supported</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">vls_operational</span><span class="p">;</span>
	<span class="cm">/* Rx Polarity inversion (compensate for ~tx on partner) */</span>
	<span class="n">u8</span> <span class="n">rx_pol_inv</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">hw_pidx</span><span class="p">;</span>     <span class="cm">/* physical port index */</span>
	<span class="n">u8</span> <span class="n">port</span><span class="p">;</span>        <span class="cm">/* IB port number and index into dd-&gt;pports - 1 */</span>

	<span class="n">u8</span> <span class="n">delay_mult</span><span class="p">;</span>

	<span class="cm">/* used to override LED behavior */</span>
	<span class="n">u8</span> <span class="n">led_override</span><span class="p">;</span>  <span class="cm">/* Substituted for normal value, if non-zero */</span>
	<span class="n">u16</span> <span class="n">led_override_timeoff</span><span class="p">;</span> <span class="cm">/* delta to next timer event */</span>
	<span class="n">u8</span> <span class="n">led_override_vals</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* Alternates per blink-frame */</span>
	<span class="n">u8</span> <span class="n">led_override_phase</span><span class="p">;</span> <span class="cm">/* Just counts, LSB picks from vals[] */</span>
	<span class="n">atomic_t</span> <span class="n">led_override_timer_active</span><span class="p">;</span>
	<span class="cm">/* Used to flash LEDs in override mode */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">led_override_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xmit_wait</span> <span class="n">cong_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">symerr_clear_timer</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Observers. Not to be taken lightly, possibly not to ship. */</span>
<span class="cm">/*</span>
<span class="cm"> * If a diag read or write is to (bottom &lt;= offset &lt;= top),</span>
<span class="cm"> * the &quot;hoook&quot; is called, allowing, e.g. shadows to be</span>
<span class="cm"> * updated in sync with the driver. struct diag_observer</span>
<span class="cm"> * is the &quot;visible&quot; part.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">diag_observer</span><span class="p">;</span>

<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">diag_hook</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">diag_observer</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">offs</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u64</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">only_32</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">diag_observer</span> <span class="p">{</span>
	<span class="n">diag_hook</span> <span class="n">hook</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bottom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">top</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">qib_register_observer</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">diag_observer</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>

<span class="cm">/* Only declared here, not defined. Private to diags */</span>
<span class="k">struct</span> <span class="n">diag_observer_list_elt</span><span class="p">;</span>

<span class="cm">/* device data struct now contains only &quot;general per-device&quot; info.</span>
<span class="cm"> * fields related to a physical IB port are in a qib_pportdata struct,</span>
<span class="cm"> * described above) while fields only used by a particular chip-type are in</span>
<span class="cm"> * a qib_chipdata struct, whose contents are opaque to this file.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_ibdev</span> <span class="n">verbs_dev</span><span class="p">;</span>     <span class="cm">/* must be first */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="cm">/* pointers to related structs for this device */</span>
	<span class="cm">/* pci access data structure */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">user_cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">diag_cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">user_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">diag_device</span><span class="p">;</span>

	<span class="cm">/* mem-mapped pointer to base of chip regs */</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">kregbase</span><span class="p">;</span>
	<span class="cm">/* end of mem-mapped chip space excluding sendbuf and user regs */</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">kregend</span><span class="p">;</span>
	<span class="cm">/* physical address of chip for io_remap, etc. */</span>
	<span class="n">resource_size_t</span> <span class="n">physaddr</span><span class="p">;</span>
	<span class="cm">/* qib_cfgctxts pointers */</span>
	<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">**</span><span class="n">rcd</span><span class="p">;</span> <span class="cm">/* Receive Context Data */</span>

	<span class="cm">/* qib_pportdata, points to array of (physical) port-specific</span>
<span class="cm">	 * data structs, indexed by pidx (0..n-1)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_chip_specific</span> <span class="o">*</span><span class="n">cspec</span><span class="p">;</span> <span class="cm">/* chip-specific */</span>

	<span class="cm">/* kvirt address of 1st 2k pio buffer */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio2kbase</span><span class="p">;</span>
	<span class="cm">/* kvirt address of 1st 4k pio buffer */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pio4kbase</span><span class="p">;</span>
	<span class="cm">/* mem-mapped pointer to base of PIO buffers (if using WC PAT) */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">piobase</span><span class="p">;</span>
	<span class="cm">/* mem-mapped pointer to base of user chip regs (if using WC PAT) */</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">userbase</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">piovl15base</span><span class="p">;</span> <span class="cm">/* base of VL15 buffers, if not WC */</span>
	<span class="cm">/*</span>
<span class="cm">	 * points to area where PIOavail registers will be DMA&#39;ed.</span>
<span class="cm">	 * Has to be on a page of it&#39;s own, because the page will be</span>
<span class="cm">	 * mapped into user program space.  This copy is *ONLY* ever</span>
<span class="cm">	 * written by DMA, not by the driver!  Need a copy per device</span>
<span class="cm">	 * when we get to multiple devices</span>
<span class="cm">	 */</span>
	<span class="k">volatile</span> <span class="n">__le64</span> <span class="o">*</span><span class="n">pioavailregs_dma</span><span class="p">;</span> <span class="cm">/* DMA&#39;ed by chip */</span>
	<span class="cm">/* physical address where updates occur */</span>
	<span class="n">dma_addr_t</span> <span class="n">pioavailregs_phys</span><span class="p">;</span>

	<span class="cm">/* device-specific implementations of functions needed by</span>
<span class="cm">	 * common code. Contrary to previous consensus, we can&#39;t</span>
<span class="cm">	 * really just point to a device-specific table, because we</span>
<span class="cm">	 * may need to &quot;bend&quot;, e.g. *_f_put_tid</span>
<span class="cm">	 */</span>
	<span class="cm">/* fallback to alternate interrupt type if possible */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_intr_fallback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* hard reset chip */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_quiet_serdes</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_bringup_serdes</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_early_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_clear_tids</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_put_tid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="n">__iomem</span><span class="o">*</span><span class="p">,</span>
				<span class="n">u32</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_setextled</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="cm">/* fill out chip-specific fields */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_get_base_info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_base_info</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* free irq */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_free_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">qib_message_header</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">f_get_msgheader</span><span class="p">)</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_config_ctxts</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_get_ib_cfg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_set_ib_cfg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_set_ib_loopback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_get_ib_table</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_set_ib_table</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">f_iblink_state</span><span class="p">)(</span><span class="n">u64</span><span class="p">);</span>
	<span class="n">u8</span> <span class="p">(</span><span class="o">*</span><span class="n">f_ibphys_portstate</span><span class="p">)(</span><span class="n">u64</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_xgxs_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* per chip actions needed for IB Link up/down changes */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_ib_updown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">f_getsendbuf</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* Read/modify/write of GPIO pins (potentially chip-specific */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_gpio_mod</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">out</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dir</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">mask</span><span class="p">);</span>
	<span class="cm">/* Enable writes to config EEPROM (if supported) */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_eeprom_wen</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wen</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * modify rcvctrl shadow[s] and write to appropriate chip-regs.</span>
<span class="cm">	 * see above QIB_RCVCTRL_xxx_ENB/DIS for operations.</span>
<span class="cm">	 * (ctxt == -1) means &quot;all contexts&quot;, only meaningful for</span>
<span class="cm">	 * clearing. Could remove if chip_spec shutdown properly done.</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_rcvctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">ctxt</span><span class="p">);</span>
	<span class="cm">/* Read/modify/write sendctrl appropriately for op and port. */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sendctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="n">op</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_set_intr_state</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_set_armlaunch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_wantpiobuf_intr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_late_initreg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_init_sdma_regs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u16</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sdma_gethead</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sdma_busy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sdma_update_tail</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sdma_set_desc_cnt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sdma_sendctrl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sdma_hw_clean_up</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sdma_hw_start_up</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_sdma_init_early</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_set_cntr_sample</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_update_usrhead</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">f_hdrqempty</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u64</span> <span class="p">(</span><span class="o">*</span><span class="n">f_portcntr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">f_read_cntrs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="p">,</span>
		<span class="n">u64</span> <span class="o">**</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">f_read_portcntrs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">**</span><span class="p">,</span> <span class="n">u64</span> <span class="o">**</span><span class="p">);</span>
	<span class="n">u32</span> <span class="p">(</span><span class="o">*</span><span class="n">f_setpbc_control</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_initvl15_bufs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_init_ctxt</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_txchk_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f_writescratch</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_tempsense_rd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">regnum</span><span class="p">);</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">boardname</span><span class="p">;</span> <span class="cm">/* human readable board info */</span>

	<span class="cm">/* template for writing TIDs  */</span>
	<span class="n">u64</span> <span class="n">tidtemplate</span><span class="p">;</span>
	<span class="cm">/* value to write to free TIDs */</span>
	<span class="n">u64</span> <span class="n">tidinvalid</span><span class="p">;</span>

	<span class="cm">/* number of registers used for pioavail */</span>
	<span class="n">u32</span> <span class="n">pioavregs</span><span class="p">;</span>
	<span class="cm">/* device (not port) flags, basically device capabilities */</span>
	<span class="n">u32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* last buffer for user use */</span>
	<span class="n">u32</span> <span class="n">lastctxt_piobuf</span><span class="p">;</span>

	<span class="cm">/* saturating counter of (non-port-specific) device interrupts */</span>
	<span class="n">u32</span> <span class="n">int_counter</span><span class="p">;</span>

	<span class="cm">/* pio bufs allocated per ctxt */</span>
	<span class="n">u32</span> <span class="n">pbufsctxt</span><span class="p">;</span>
	<span class="cm">/* if remainder on bufs/ctxt, ctxts &lt; extrabuf get 1 extra */</span>
	<span class="n">u32</span> <span class="n">ctxts_extrabuf</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * number of ctxts configured as max; zero is set to number chip</span>
<span class="cm">	 * supports, less gives more pio bufs/ctxt, etc.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">cfgctxts</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * number of ctxts available for PSM open</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">freectxts</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * hint that we should update pioavailshadow before</span>
<span class="cm">	 * looking for a PIO buffer</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">upd_pio_shadow</span><span class="p">;</span>

	<span class="cm">/* internal debugging stats */</span>
	<span class="n">u32</span> <span class="n">maxpkts_call</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">avgpkts_call</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nopiobufs</span><span class="p">;</span>

	<span class="cm">/* PCI Vendor ID (here for NodeInfo) */</span>
	<span class="n">u16</span> <span class="n">vendorid</span><span class="p">;</span>
	<span class="cm">/* PCI Device ID (here for NodeInfo) */</span>
	<span class="n">u16</span> <span class="n">deviceid</span><span class="p">;</span>
	<span class="cm">/* for write combining settings */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wc_cookie</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wc_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wc_len</span><span class="p">;</span>

	<span class="cm">/* shadow copy of struct page *&#39;s for exp tid pages */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pageshadow</span><span class="p">;</span>
	<span class="cm">/* shadow copy of dma handles for exp tid pages */</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">physshadow</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">egrtidbase</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">sendctrl_lock</span><span class="p">;</span> <span class="cm">/* protect changes to sendctrl shadow */</span>
	<span class="cm">/* around rcd and (user ctxts) ctxt_cnt use (intr vs free) */</span>
	<span class="n">spinlock_t</span> <span class="n">uctxt_lock</span><span class="p">;</span> <span class="cm">/* rcd and user context changes */</span>
	<span class="cm">/*</span>
<span class="cm">	 * per unit status, see also portdata statusp</span>
<span class="cm">	 * mapped readonly into user processes so they can get unit and</span>
<span class="cm">	 * IB link status cheaply</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">devstatusp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">freezemsg</span><span class="p">;</span> <span class="cm">/* freeze msg if hw error put chip in freeze */</span>
	<span class="n">u32</span> <span class="n">freezelen</span><span class="p">;</span> <span class="cm">/* max length of freezemsg */</span>
	<span class="cm">/* timer used to prevent stats overflow, error throttling, etc. */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">stats_timer</span><span class="p">;</span>

	<span class="cm">/* timer to verify interrupts work, and fallback if possible */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">intrchk_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ureg_align</span><span class="p">;</span> <span class="cm">/* user register alignment */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Protects pioavailshadow, pioavailkernel, pio_need_disarm, and</span>
<span class="cm">	 * pio_writing.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span> <span class="n">pioavail_lock</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * index of last buffer to optimize search for next</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">last_pio</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * min kernel pio buffer to optimize search</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">min_kernel_pio</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Shadow copies of registers; size indicates read access size.</span>
<span class="cm">	 * Most of them are readonly, but some are write-only register,</span>
<span class="cm">	 * where we manipulate the bits in the shadow copy, and then write</span>
<span class="cm">	 * the shadow copy to qlogic_ib.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We deliberately make most of these 32 bits, since they have</span>
<span class="cm">	 * restricted range.  For any that we read, we won&#39;t to generate 32</span>
<span class="cm">	 * bit accesses, since Opteron will generate 2 separate 32 bit HT</span>
<span class="cm">	 * transactions for a 64 bit read, and we want to avoid unnecessary</span>
<span class="cm">	 * bus transactions.</span>
<span class="cm">	 */</span>

	<span class="cm">/* This is the 64 bit group */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pioavailshadow</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="cm">/* bitmap of send buffers available for the kernel to use with PIO. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pioavailkernel</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="cm">/* bitmap of send buffers which need to be disarmed. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pio_need_disarm</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="cm">/* bitmap of send buffers which are being written to. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pio_writing</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="cm">/* kr_revision shadow */</span>
	<span class="n">u64</span> <span class="n">revision</span><span class="p">;</span>
	<span class="cm">/* Base GUID for device (from eeprom, network order) */</span>
	<span class="n">__be64</span> <span class="n">base_guid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * kr_sendpiobufbase value (chip offset of pio buffers), and the</span>
<span class="cm">	 * base of the 2KB buffer s(user processes only use 2K)</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">piobufbase</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pio2k_bufbase</span><span class="p">;</span>

	<span class="cm">/* these are the &quot;32 bit&quot; regs */</span>

	<span class="cm">/* number of GUIDs in the flash for this interface */</span>
	<span class="n">u32</span> <span class="n">nguid</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * the following two are 32-bit bitmasks, but {test,clear,set}_bit</span>
<span class="cm">	 * all expect bit fields to be &quot;unsigned long&quot;</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rcvctrl</span><span class="p">;</span> <span class="cm">/* shadow per device rcvctrl */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sendctrl</span><span class="p">;</span> <span class="cm">/* shadow per device sendctrl */</span>

	<span class="cm">/* value we put in kr_rcvhdrcnt */</span>
	<span class="n">u32</span> <span class="n">rcvhdrcnt</span><span class="p">;</span>
	<span class="cm">/* value we put in kr_rcvhdrsize */</span>
	<span class="n">u32</span> <span class="n">rcvhdrsize</span><span class="p">;</span>
	<span class="cm">/* value we put in kr_rcvhdrentsize */</span>
	<span class="n">u32</span> <span class="n">rcvhdrentsize</span><span class="p">;</span>
	<span class="cm">/* kr_ctxtcnt value */</span>
	<span class="n">u32</span> <span class="n">ctxtcnt</span><span class="p">;</span>
	<span class="cm">/* kr_pagealign value */</span>
	<span class="n">u32</span> <span class="n">palign</span><span class="p">;</span>
	<span class="cm">/* number of &quot;2KB&quot; PIO buffers */</span>
	<span class="n">u32</span> <span class="n">piobcnt2k</span><span class="p">;</span>
	<span class="cm">/* size in bytes of &quot;2KB&quot; PIO buffers */</span>
	<span class="n">u32</span> <span class="n">piosize2k</span><span class="p">;</span>
	<span class="cm">/* max usable size in dwords of a &quot;2KB&quot; PIO buffer before going &quot;4KB&quot; */</span>
	<span class="n">u32</span> <span class="n">piosize2kmax_dwords</span><span class="p">;</span>
	<span class="cm">/* number of &quot;4KB&quot; PIO buffers */</span>
	<span class="n">u32</span> <span class="n">piobcnt4k</span><span class="p">;</span>
	<span class="cm">/* size in bytes of &quot;4KB&quot; PIO buffers */</span>
	<span class="n">u32</span> <span class="n">piosize4k</span><span class="p">;</span>
	<span class="cm">/* kr_rcvegrbase value */</span>
	<span class="n">u32</span> <span class="n">rcvegrbase</span><span class="p">;</span>
	<span class="cm">/* kr_rcvtidbase value */</span>
	<span class="n">u32</span> <span class="n">rcvtidbase</span><span class="p">;</span>
	<span class="cm">/* kr_rcvtidcnt value */</span>
	<span class="n">u32</span> <span class="n">rcvtidcnt</span><span class="p">;</span>
	<span class="cm">/* kr_userregbase */</span>
	<span class="n">u32</span> <span class="n">uregbase</span><span class="p">;</span>
	<span class="cm">/* shadow the control register contents */</span>
	<span class="n">u32</span> <span class="n">control</span><span class="p">;</span>

	<span class="cm">/* chip address space used by 4k pio buffers */</span>
	<span class="n">u32</span> <span class="n">align4k</span><span class="p">;</span>
	<span class="cm">/* size of each rcvegrbuffer */</span>
	<span class="n">u16</span> <span class="n">rcvegrbufsize</span><span class="p">;</span>
	<span class="cm">/* log2 of above */</span>
	<span class="n">u16</span> <span class="n">rcvegrbufsize_shift</span><span class="p">;</span>
	<span class="cm">/* localbus width (1, 2,4,8,16,32) from config space  */</span>
	<span class="n">u32</span> <span class="n">lbus_width</span><span class="p">;</span>
	<span class="cm">/* localbus speed in MHz */</span>
	<span class="n">u32</span> <span class="n">lbus_speed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unit</span><span class="p">;</span> <span class="cm">/* unit # of this chip */</span>

	<span class="cm">/* start of CHIP_SPEC move to chipspec, but need code changes */</span>
	<span class="cm">/* low and high portions of MSI capability/vector */</span>
	<span class="n">u32</span> <span class="n">msi_lo</span><span class="p">;</span>
	<span class="cm">/* saved after PCIe init for restore after reset */</span>
	<span class="n">u32</span> <span class="n">msi_hi</span><span class="p">;</span>
	<span class="cm">/* MSI data (vector) saved for restore */</span>
	<span class="n">u16</span> <span class="n">msi_data</span><span class="p">;</span>
	<span class="cm">/* so we can rewrite it after a chip reset */</span>
	<span class="n">u32</span> <span class="n">pcibar0</span><span class="p">;</span>
	<span class="cm">/* so we can rewrite it after a chip reset */</span>
	<span class="n">u32</span> <span class="n">pcibar1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rhdrhead_intr_off</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * ASCII serial number, from flash, large enough for original</span>
<span class="cm">	 * all digit strings, and longer QLogic serial number format</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">serial</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="cm">/* human readable board version */</span>
	<span class="n">u8</span> <span class="n">boardversion</span><span class="p">[</span><span class="mi">96</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">lbus_info</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="cm">/* human readable localbus info */</span>
	<span class="cm">/* chip major rev, from qib_revision */</span>
	<span class="n">u8</span> <span class="n">majrev</span><span class="p">;</span>
	<span class="cm">/* chip minor rev, from qib_revision */</span>
	<span class="n">u8</span> <span class="n">minrev</span><span class="p">;</span>

	<span class="cm">/* Misc small ints */</span>
	<span class="cm">/* Number of physical ports available */</span>
	<span class="n">u8</span> <span class="n">num_pports</span><span class="p">;</span>
	<span class="cm">/* Lowest context number which can be used by user processes */</span>
	<span class="n">u8</span> <span class="n">first_user_ctxt</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">n_krcv_queues</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">qpn_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">skip_kctxt_mask</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">rhf_offset</span><span class="p">;</span> <span class="cm">/* offset of RHF within receive header entry */</span>

	<span class="cm">/*</span>
<span class="cm">	 * GPIO pins for twsi-connected devices, and device code for eeprom</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">gpio_sda_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">gpio_scl_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">twsi_eeprom_dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">board_atten</span><span class="p">;</span>

	<span class="cm">/* Support (including locks) for EEPROM logging of errors and time */</span>
	<span class="cm">/* control access to actual counters, timer */</span>
	<span class="n">spinlock_t</span> <span class="n">eep_st_lock</span><span class="p">;</span>
	<span class="cm">/* control high-level access to EEPROM */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">eep_lock</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">traffic_wds</span><span class="p">;</span>
	<span class="cm">/* active time is kept in seconds, but logged in hours */</span>
	<span class="n">atomic_t</span> <span class="n">active_time</span><span class="p">;</span>
	<span class="cm">/* Below are nominal shadow of EEPROM, new since last EEPROM update */</span>
	<span class="kt">uint8_t</span> <span class="n">eep_st_errs</span><span class="p">[</span><span class="n">QIB_EEP_LOG_CNT</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">eep_st_new_errs</span><span class="p">[</span><span class="n">QIB_EEP_LOG_CNT</span><span class="p">];</span>
	<span class="kt">uint16_t</span> <span class="n">eep_hrs</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * masks for which bits of errs, hwerrs that cause</span>
<span class="cm">	 * each of the counters to increment.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">qib_eep_log_mask</span> <span class="n">eep_st_masks</span><span class="p">[</span><span class="n">QIB_EEP_LOG_CNT</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">qib_diag_client</span> <span class="o">*</span><span class="n">diag_client</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">qib_diag_trans_lock</span><span class="p">;</span> <span class="cm">/* protect diag observer ops */</span>
	<span class="k">struct</span> <span class="n">diag_observer_list_elt</span> <span class="o">*</span><span class="n">diag_observer_list</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">psxmitwait_supported</span><span class="p">;</span>
	<span class="cm">/* cycle length of PS* counters in HW (in picoseconds) */</span>
	<span class="n">u16</span> <span class="n">psxmitwait_check_rate</span><span class="p">;</span>
	<span class="cm">/* high volume overflow errors defered to tasklet */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">error_tasklet</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* hol_state values */</span>
<span class="cp">#define QIB_HOL_UP       0</span>
<span class="cp">#define QIB_HOL_INIT     1</span>

<span class="cp">#define QIB_SDMA_SENDCTRL_OP_ENABLE    (1U &lt;&lt; 0)</span>
<span class="cp">#define QIB_SDMA_SENDCTRL_OP_INTENABLE (1U &lt;&lt; 1)</span>
<span class="cp">#define QIB_SDMA_SENDCTRL_OP_HALT      (1U &lt;&lt; 2)</span>
<span class="cp">#define QIB_SDMA_SENDCTRL_OP_CLEANUP   (1U &lt;&lt; 3)</span>
<span class="cp">#define QIB_SDMA_SENDCTRL_OP_DRAIN     (1U &lt;&lt; 4)</span>

<span class="cm">/* operation types for f_txchk_change() */</span>
<span class="cp">#define TXCHK_CHG_TYPE_DIS1  3</span>
<span class="cp">#define TXCHK_CHG_TYPE_ENAB1 2</span>
<span class="cp">#define TXCHK_CHG_TYPE_KERN  1</span>
<span class="cp">#define TXCHK_CHG_TYPE_USER  0</span>

<span class="cp">#define QIB_CHASE_TIME msecs_to_jiffies(145)</span>
<span class="cp">#define QIB_CHASE_DIS_TIME msecs_to_jiffies(160)</span>

<span class="cm">/* Private data for file operations */</span>
<span class="k">struct</span> <span class="n">qib_filedata</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">subctxt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tidcursor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">qib_user_sdma_queue</span> <span class="o">*</span><span class="n">pq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rec_cpu_num</span><span class="p">;</span> <span class="cm">/* for cpu affinity; -1 if none */</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">qib_dev_list</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">qib_devs_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">qib_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">u32</span> <span class="n">qib_cpulist_count</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">qib_cpulist</span><span class="p">;</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">qib_wc_pat</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">qib_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">init_chip_wc_pat</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_enable_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_disable_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_count_units</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">npresentp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nupp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_count_active_units</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">qib_cdev_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">minor</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		  <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">cdev</span> <span class="o">**</span><span class="n">cdevp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">**</span><span class="n">devp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_cdev_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cdev</span> <span class="o">**</span><span class="n">cdevp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">**</span><span class="n">devp</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_dev_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_dev_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">qib_diag_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_diag_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_handle_e_ibstatuschanged</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_sdma_update_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span> <span class="cm">/* hold sdma_lock */</span>

<span class="kt">int</span> <span class="n">qib_decode_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">blen</span><span class="p">,</span> <span class="n">u64</span> <span class="n">err</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_bad_intrstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_handle_urcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>

<span class="cm">/* clean up any per-chip chip-specific stuff */</span>
<span class="kt">void</span> <span class="n">qib_chip_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* clean up any chip type-specific stuff */</span>
<span class="kt">void</span> <span class="n">qib_chip_done</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* check to see if we have to force ordering for write combining */</span>
<span class="kt">int</span> <span class="n">qib_unordered_wc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_pio_copy</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">qib_disarm_piobufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_disarm_piobufs_ifneeded</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_disarm_piobufs_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_cancel_sends</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">qib_create_rcvhdrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_setup_eagerbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_set_ctxtcnt</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_create_ctxts</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">qib_create_ctxtdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_init_pportdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_free_ctxtdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>

<span class="n">u32</span> <span class="n">qib_kreceive</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_reset_device</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_wait_linkstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_set_linkstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_set_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_set_lid</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_hol_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_hol_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_hol_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_hol_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_disable_after_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_set_uevent_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="p">);</span>

<span class="cm">/* for use in system calls, where we want to know device type, etc. */</span>
<span class="cp">#define ctxt_fp(fp) \</span>
<span class="cp">	(((struct qib_filedata *)(fp)-&gt;private_data)-&gt;rcd)</span>
<span class="cp">#define subctxt_fp(fp) \</span>
<span class="cp">	(((struct qib_filedata *)(fp)-&gt;private_data)-&gt;subctxt)</span>
<span class="cp">#define tidcursor_fp(fp) \</span>
<span class="cp">	(((struct qib_filedata *)(fp)-&gt;private_data)-&gt;tidcursor)</span>
<span class="cp">#define user_sdma_queue_fp(fp) \</span>
<span class="cp">	(((struct qib_filedata *)(fp)-&gt;private_data)-&gt;pq)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="nf">dd_from_ppd</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="nf">dd_from_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_ibdev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_devdata</span><span class="p">,</span> <span class="n">verbs_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="nf">dd_from_ibdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">ibdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dd_from_dev</span><span class="p">(</span><span class="n">to_idev</span><span class="p">(</span><span class="n">ibdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="nf">ppd_from_ibp</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_ibport</span> <span class="o">*</span><span class="n">ibp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ibp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_pportdata</span><span class="p">,</span> <span class="n">ibport_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">qib_ibport</span> <span class="o">*</span><span class="nf">to_iport</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">ibdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">dd_from_ibdev</span><span class="p">(</span><span class="n">ibdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">pidx</span> <span class="o">=</span> <span class="n">port</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* IB number port from 1, hdw from 0 */</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pidx</span> <span class="o">&gt;=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">num_pports</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">ibport_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * values for dd-&gt;flags (_device_ related flags) and</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_HAS_LINK_LATENCY  0x1 </span><span class="cm">/* supports link latency (IB 1.2) */</span><span class="cp"></span>
<span class="cp">#define QIB_INITTED           0x2 </span><span class="cm">/* chip and driver up and initted */</span><span class="cp"></span>
<span class="cp">#define QIB_DOING_RESET       0x4  </span><span class="cm">/* in the middle of doing chip reset */</span><span class="cp"></span>
<span class="cp">#define QIB_PRESENT           0x8  </span><span class="cm">/* chip accesses can be done */</span><span class="cp"></span>
<span class="cp">#define QIB_PIO_FLUSH_WC      0x10 </span><span class="cm">/* Needs Write combining flush for PIO */</span><span class="cp"></span>
<span class="cp">#define QIB_HAS_THRESH_UPDATE 0x40</span>
<span class="cp">#define QIB_HAS_SDMA_TIMEOUT  0x80</span>
<span class="cp">#define QIB_USE_SPCL_TRIG     0x100 </span><span class="cm">/* SpecialTrigger launch enabled */</span><span class="cp"></span>
<span class="cp">#define QIB_NODMA_RTAIL       0x200 </span><span class="cm">/* rcvhdrtail register DMA enabled */</span><span class="cp"></span>
<span class="cp">#define QIB_HAS_INTX          0x800 </span><span class="cm">/* Supports INTx interrupts */</span><span class="cp"></span>
<span class="cp">#define QIB_HAS_SEND_DMA      0x1000 </span><span class="cm">/* Supports Send DMA */</span><span class="cp"></span>
<span class="cp">#define QIB_HAS_VLSUPP        0x2000 </span><span class="cm">/* Supports multiple VLs; PBC different */</span><span class="cp"></span>
<span class="cp">#define QIB_HAS_HDRSUPP       0x4000 </span><span class="cm">/* Supports header suppression */</span><span class="cp"></span>
<span class="cp">#define QIB_BADINTR           0x8000 </span><span class="cm">/* severe interrupt problems */</span><span class="cp"></span>
<span class="cp">#define QIB_DCA_ENABLED       0x10000 </span><span class="cm">/* Direct Cache Access enabled */</span><span class="cp"></span>
<span class="cp">#define QIB_HAS_QSFP          0x20000 </span><span class="cm">/* device (card instance) has QSFP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * values for ppd-&gt;lflags (_ib_port_ related flags)</span>
<span class="cm"> */</span>
<span class="cp">#define QIBL_LINKV             0x1 </span><span class="cm">/* IB link state valid */</span><span class="cp"></span>
<span class="cp">#define QIBL_LINKDOWN          0x8 </span><span class="cm">/* IB link is down */</span><span class="cp"></span>
<span class="cp">#define QIBL_LINKINIT          0x10 </span><span class="cm">/* IB link level is up */</span><span class="cp"></span>
<span class="cp">#define QIBL_LINKARMED         0x20 </span><span class="cm">/* IB link is ARMED */</span><span class="cp"></span>
<span class="cp">#define QIBL_LINKACTIVE        0x40 </span><span class="cm">/* IB link is ACTIVE */</span><span class="cp"></span>
<span class="cm">/* leave a gap for more IB-link state */</span>
<span class="cp">#define QIBL_IB_AUTONEG_INPROG 0x1000 </span><span class="cm">/* non-IBTA DDR/QDR neg active */</span><span class="cp"></span>
<span class="cp">#define QIBL_IB_AUTONEG_FAILED 0x2000 </span><span class="cm">/* non-IBTA DDR/QDR neg failed */</span><span class="cp"></span>
<span class="cp">#define QIBL_IB_LINK_DISABLED  0x4000 </span><span class="cm">/* Linkdown-disable forced,</span>
<span class="cm">				       * Do not try to bring up */</span><span class="cp"></span>
<span class="cp">#define QIBL_IB_FORCE_NOTIFY   0x8000 </span><span class="cm">/* force notify on next ib change */</span><span class="cp"></span>

<span class="cm">/* IB dword length mask in PBC (lower 11 bits); same for all chips */</span>
<span class="cp">#define QIB_PBC_LENGTH_MASK                     ((1 &lt;&lt; 11) - 1)</span>


<span class="cm">/* ctxt_flag bit offsets */</span>
		<span class="cm">/* waiting for a packet to arrive */</span>
<span class="cp">#define QIB_CTXT_WAITING_RCV   2</span>
		<span class="cm">/* master has not finished initializing */</span>
<span class="cp">#define QIB_CTXT_MASTER_UNINIT 4</span>
		<span class="cm">/* waiting for an urgent packet to arrive */</span>
<span class="cp">#define QIB_CTXT_WAITING_URG 5</span>

<span class="cm">/* free up any allocated data at closes */</span>
<span class="kt">void</span> <span class="n">qib_free_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_chg_pioavailkernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
			    <span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">qib_init_iba7322_funcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">qib_init_iba7220_funcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">qib_init_iba6120_funcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
					   <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_free_devdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">qib_alloc_devdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">extra</span><span class="p">);</span>

<span class="cp">#define QIB_TWSI_NO_DEV 0xFF</span>
<span class="cm">/* Below qib_twsi_ functions must be called with eep_lock held */</span>
<span class="kt">int</span> <span class="n">qib_twsi_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_twsi_blk_rd</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_twsi_blk_wr</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">,</span>
		    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_get_eeprom_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_update_eeprom_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_inc_eeprom_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">eidx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">incr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_dump_lookup_output_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_force_pio_avail_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_clear_symerror_on_linkup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Set LED override, only the two LSBs have &quot;public&quot; meaning, but</span>
<span class="cm"> * any non-zero value substitutes them for the Link and LinkTrain</span>
<span class="cm"> * LED states.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_LED_PHYS 1 </span><span class="cm">/* Physical (linktraining) GREEN LED */</span><span class="cp"></span>
<span class="cp">#define QIB_LED_LOG 2  </span><span class="cm">/* Logical (link) YELLOW LED */</span><span class="cp"></span>
<span class="kt">void</span> <span class="n">qib_set_led_override</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/* send dma routines */</span>
<span class="kt">int</span> <span class="n">qib_setup_sdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_teardown_sdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">__qib_sdma_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_sdma_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_sdma_verbs_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_sge_state</span> <span class="o">*</span><span class="p">,</span>
			<span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_verbs_txreq</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* ppd-&gt;sdma_lock should be locked before calling this. */</span>
<span class="kt">int</span> <span class="n">qib_sdma_make_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>

<span class="cm">/* must be called under qib_sdma_lock */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">qib_sdma_descq_freecnt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">sdma_descq_cnt</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">ppd</span><span class="o">-&gt;</span><span class="n">sdma_descq_added</span> <span class="o">-</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">sdma_descq_removed</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__qib_sdma_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ppd</span><span class="o">-&gt;</span><span class="n">sdma_state</span><span class="p">.</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">qib_sdma_state_s99_running</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">qib_sdma_running</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__qib_sdma_process_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">qib_sdma_events</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_sdma_process_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">qib_sdma_events</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * number of words used for protocol header if not set by qib_userinit();</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_DFLT_RCVHDRSIZE 9</span>

<span class="cm">/*</span>
<span class="cm"> * We need to be able to handle an IB header of at least 24 dwords.</span>
<span class="cm"> * We need the rcvhdrq large enough to handle largest IB header, but</span>
<span class="cm"> * still have room for a 2KB MTU standard IB packet.</span>
<span class="cm"> * Additionally, some processor/memory controller combinations</span>
<span class="cm"> * benefit quite strongly from having the DMA&#39;ed data be cacheline</span>
<span class="cm"> * aligned and a cacheline multiple, so we set the size to 32 dwords</span>
<span class="cm"> * (2 64-byte primary cachelines for pretty much all processors of</span>
<span class="cm"> * interest).  The alignment hurts nothing, other than using somewhat</span>
<span class="cm"> * more memory.</span>
<span class="cm"> */</span>
<span class="cp">#define QIB_RCVHDR_ENTSIZE 32</span>

<span class="kt">int</span> <span class="n">qib_get_user_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_release_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_eeprom_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_eeprom_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">qib_getsendbuf_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_sendbuf_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">qib_clear_rcvhdrtail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0ULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">qib_get_rcvhdrtail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * volatile because it&#39;s a DMA target from the chip, routine is</span>
<span class="cm">	 * inlined, and don&#39;t want register caching or reordering.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span>
		<span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">__le64</span> <span class="o">*</span><span class="p">)</span><span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrtail_kvaddr</span><span class="p">));</span> <span class="cm">/* DMA&#39;ed */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">qib_get_hdrqtail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">qib_ctxtdata</span> <span class="o">*</span><span class="n">rcd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">dd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hdrqtail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">QIB_NODMA_RTAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="o">*</span><span class="n">rhf_addr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">seq</span><span class="p">;</span>

		<span class="n">rhf_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">rcvhdrq</span> <span class="o">+</span>
			<span class="n">rcd</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">rhf_offset</span><span class="p">;</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">qib_hdrget_seq</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">);</span>
		<span class="n">hdrqtail</span> <span class="o">=</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">==</span> <span class="n">rcd</span><span class="o">-&gt;</span><span class="n">seq_cnt</span><span class="p">)</span>
			<span class="n">hdrqtail</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">hdrqtail</span> <span class="o">=</span> <span class="n">qib_get_rcvhdrtail</span><span class="p">(</span><span class="n">rcd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hdrqtail</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sysfs interface.</span>
<span class="cm"> */</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ib_qib_version</span><span class="p">[];</span>

<span class="kt">int</span> <span class="n">qib_device_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_device_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">qib_create_port_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">ibdev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">port_num</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_verbs_register_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_verbs_unregister_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* Hook for sysfs read of QSFP */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">qib_qsfp_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_pportdata</span> <span class="o">*</span><span class="n">ppd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="n">qib_init_qibfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">__exit</span> <span class="n">qib_exit_qibfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">qibfs_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qibfs_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">qib_pcie_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_pcie_ddinit</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_pcie_ddcleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_pcie_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qib_msix_entry</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">qib_reinit_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_enable_intx</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_nomsi</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_nomsix</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_pcie_getcmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">qib_pcie_reenable</span><span class="p">(</span><span class="k">struct</span> <span class="n">qib_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * dma_addr wrappers - all 0&#39;s invalid for hw</span>
<span class="cm"> */</span>
<span class="n">dma_addr_t</span> <span class="n">qib_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			  <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">qib_get_unit_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Flush write combining store buffers (if present) and perform a write</span>
<span class="cm"> * barrier.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_X86_64)</span>
<span class="cp">#define qib_flush_wc() asm volatile(&quot;sfence&quot; : : : &quot;memory&quot;)</span>
<span class="cp">#else</span>
<span class="cp">#define qib_flush_wc() wmb() </span><span class="cm">/* no reorder around wc flush */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/* global module parameter variables */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">qib_ibmtu</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ushort</span> <span class="n">qib_cfgctxts</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ushort</span> <span class="n">qib_num_cfg_vls</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">ushort</span> <span class="n">qib_mini_init</span><span class="p">;</span> <span class="cm">/* If set, do few (ideally 0) writes to chip */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">qib_n_krcv_queues</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">qib_sdma_fetch_arb</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">qib_compat_ddr_negotiate</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">qib_special_trigger</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">qib_mutex</span><span class="p">;</span>

<span class="cm">/* Number of seconds before our card status check...  */</span>
<span class="cp">#define STATUS_TIMEOUT 60</span>

<span class="cp">#define QIB_DRV_NAME            &quot;ib_qib&quot;</span>
<span class="cp">#define QIB_USER_MINOR_BASE     0</span>
<span class="cp">#define QIB_TRACE_MINOR         127</span>
<span class="cp">#define QIB_DIAGPKT_MINOR       128</span>
<span class="cp">#define QIB_DIAG_MINOR_BASE     129</span>
<span class="cp">#define QIB_NMINORS             255</span>

<span class="cp">#define PCI_VENDOR_ID_PATHSCALE 0x1fc1</span>
<span class="cp">#define PCI_VENDOR_ID_QLOGIC 0x1077</span>
<span class="cp">#define PCI_DEVICE_ID_QLOGIC_IB_6120 0x10</span>
<span class="cp">#define PCI_DEVICE_ID_QLOGIC_IB_7220 0x7220</span>
<span class="cp">#define PCI_DEVICE_ID_QLOGIC_IB_7322 0x7322</span>

<span class="cm">/*</span>
<span class="cm"> * qib_early_err is used (only!) to print early errors before devdata is</span>
<span class="cm"> * allocated, or when dd-&gt;pcidev may not be valid, and at the tail end of</span>
<span class="cm"> * cleanup when devdata may have been freed, etc.  qib_dev_porterr is</span>
<span class="cm"> * the same as qib_dev_err, but is used when the message really needs</span>
<span class="cm"> * the IB port# to be definitive as to what&#39;s happening..</span>
<span class="cm"> * All of these go to the trace log, and the trace log entry is done</span>
<span class="cm"> * first to avoid possible serial port delays from printk.</span>
<span class="cm"> */</span>
<span class="cp">#define qib_early_err(dev, fmt, ...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		dev_err(dev, fmt, ##__VA_ARGS__); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define qib_dev_err(dd, fmt, ...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		dev_err(&amp;(dd)-&gt;pcidev-&gt;dev, &quot;%s: &quot; fmt, \</span>
<span class="cp">			qib_get_unit_name((dd)-&gt;unit), ##__VA_ARGS__); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define qib_dev_porterr(dd, port, fmt, ...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		dev_err(&amp;(dd)-&gt;pcidev-&gt;dev, &quot;%s: IB%u:%u &quot; fmt, \</span>
<span class="cp">			qib_get_unit_name((dd)-&gt;unit), (dd)-&gt;unit, (port), \</span>
<span class="cp">			##__VA_ARGS__); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define qib_devinfo(pcidev, fmt, ...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		dev_info(&amp;(pcidev)-&gt;dev, fmt, ##__VA_ARGS__); \</span>
<span class="cp">	} while (0)</span>

<span class="cm">/*</span>
<span class="cm"> * this is used for formatting hw error messages...</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">qib_hwerror_msgs</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define QLOGIC_IB_HWE_MSG(a, b) { .mask = a, .msg = b }</span>

<span class="cm">/* in qib_intr.c... */</span>
<span class="kt">void</span> <span class="n">qib_format_hwerrors</span><span class="p">(</span><span class="n">u64</span> <span class="n">hwerrs</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">qib_hwerror_msgs</span> <span class="o">*</span><span class="n">hwerrmsgs</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">nhwerrmsgs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">lmsg</span><span class="p">);</span>
<span class="cp">#endif                          </span><span class="cm">/* _QIB_KERNEL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
