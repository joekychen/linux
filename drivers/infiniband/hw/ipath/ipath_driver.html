<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › ipath › ipath_driver.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ipath_driver.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, 2007, 2008 QLogic Corporation. All rights reserved.</span>
<span class="cm"> * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &quot;ipath_kernel.h&quot;</span>
<span class="cp">#include &quot;ipath_verbs.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ipath_update_pio_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ipath_get_unit_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">iname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">iname</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">iname</span><span class="p">,</span> <span class="s">&quot;infinipath%u&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">iname</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DRIVER_LOAD_MSG &quot;QLogic &quot; IPATH_DRV_NAME &quot; loaded: &quot;</span>
<span class="cp">#define PFX IPATH_DRV_NAME &quot;: &quot;</span>

<span class="cm">/*</span>
<span class="cm"> * The size has to be longer than this string, so we can append</span>
<span class="cm"> * board/chip information to it in the init code.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">ib_ipath_version</span><span class="p">[]</span> <span class="o">=</span> <span class="n">IPATH_IDSTR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">idr</span> <span class="n">unit_table</span><span class="p">;</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ipath_devs_lock</span><span class="p">);</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ipath_dev_list</span><span class="p">);</span>

<span class="n">wait_queue_head_t</span> <span class="n">ipath_state_wait</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="n">ipath_debug</span> <span class="o">=</span> <span class="n">__IPATH_INFO</span><span class="p">;</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">ipath_debug</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;mask for debug prints&quot;</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ipath_debug</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="n">ipath_mtu4096</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* max 4KB IB mtu by default, if supported */</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">mtu4096</span><span class="p">,</span> <span class="n">ipath_mtu4096</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mtu4096</span><span class="p">,</span> <span class="s">&quot;enable MTU of 4096 bytes, if supported&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">ipath_hol_timeout_ms</span> <span class="o">=</span> <span class="mi">13000</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">hol_timeout_ms</span><span class="p">,</span> <span class="n">ipath_hol_timeout_ms</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hol_timeout_ms</span><span class="p">,</span>
	<span class="s">&quot;duration of user app suspension after link failure&quot;</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="n">ipath_linkrecovery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">linkrecovery</span><span class="p">,</span> <span class="n">ipath_linkrecovery</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">linkrecovery</span><span class="p">,</span> <span class="s">&quot;enable workaround for link recovery issue&quot;</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;QLogic &lt;support@qlogic.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;QLogic InfiniPath driver&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Table to translate the LINKTRAININGSTATE portion of</span>
<span class="cm"> * IBCStatus to a human-readable form.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ipath_ibcstatus_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Disabled&quot;</span><span class="p">,</span>
	<span class="s">&quot;LinkUp&quot;</span><span class="p">,</span>
	<span class="s">&quot;PollActive&quot;</span><span class="p">,</span>
	<span class="s">&quot;PollQuiet&quot;</span><span class="p">,</span>
	<span class="s">&quot;SleepDelay&quot;</span><span class="p">,</span>
	<span class="s">&quot;SleepQuiet&quot;</span><span class="p">,</span>
	<span class="s">&quot;LState6&quot;</span><span class="p">,</span>		<span class="cm">/* unused */</span>
	<span class="s">&quot;LState7&quot;</span><span class="p">,</span>		<span class="cm">/* unused */</span>
	<span class="s">&quot;CfgDebounce&quot;</span><span class="p">,</span>
	<span class="s">&quot;CfgRcvfCfg&quot;</span><span class="p">,</span>
	<span class="s">&quot;CfgWaitRmt&quot;</span><span class="p">,</span>
	<span class="s">&quot;CfgIdle&quot;</span><span class="p">,</span>
	<span class="s">&quot;RecovRetrain&quot;</span><span class="p">,</span>
	<span class="s">&quot;CfgTxRevLane&quot;</span><span class="p">,</span>		<span class="cm">/* unused before IBA7220 */</span>
	<span class="s">&quot;RecovWaitRmt&quot;</span><span class="p">,</span>
	<span class="s">&quot;RecovIdle&quot;</span><span class="p">,</span>
	<span class="cm">/* below were added for IBA7220 */</span>
	<span class="s">&quot;CfgEnhanced&quot;</span><span class="p">,</span>
	<span class="s">&quot;CfgTest&quot;</span><span class="p">,</span>
	<span class="s">&quot;CfgWaitRmtTest&quot;</span><span class="p">,</span>
	<span class="s">&quot;CfgWaitCfgEnhanced&quot;</span><span class="p">,</span>
	<span class="s">&quot;SendTS_T&quot;</span><span class="p">,</span>
	<span class="s">&quot;SendTstIdles&quot;</span><span class="p">,</span>
	<span class="s">&quot;RcvTS_T&quot;</span><span class="p">,</span>
	<span class="s">&quot;SendTst_TS1s&quot;</span><span class="p">,</span>
	<span class="s">&quot;LTState18&quot;</span><span class="p">,</span> <span class="s">&quot;LTState19&quot;</span><span class="p">,</span> <span class="s">&quot;LTState1A&quot;</span><span class="p">,</span> <span class="s">&quot;LTState1B&quot;</span><span class="p">,</span>
	<span class="s">&quot;LTState1C&quot;</span><span class="p">,</span> <span class="s">&quot;LTState1D&quot;</span><span class="p">,</span> <span class="s">&quot;LTState1E&quot;</span><span class="p">,</span> <span class="s">&quot;LTState1F&quot;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="n">ipath_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">ipath_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* Only needed for registration, nothing else needs this info */</span>
<span class="cp">#define PCI_VENDOR_ID_PATHSCALE 0x1fc1</span>
<span class="cp">#define PCI_DEVICE_ID_INFINIPATH_HT 0xd</span>

<span class="cm">/* Number of seconds before our card status check...  */</span>
<span class="cp">#define STATUS_TIMEOUT 60</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">ipath_pci_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_PATHSCALE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_INFINIPATH_HT</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">ipath_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">ipath_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">IPATH_DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ipath_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ipath_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">ipath_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">ipath_driver_attr_groups</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">read_bars</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="o">*</span><span class="n">bar0</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">bar1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_BASE_ADDRESS_0</span><span class="p">,</span> <span class="n">bar0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;failed to read bar0 before enable: &quot;</span>
			      <span class="s">&quot;error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_BASE_ADDRESS_1</span><span class="p">,</span> <span class="n">bar1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;failed to read bar1 before enable: &quot;</span>
			      <span class="s">&quot;error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Read bar0 %x bar1 %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">bar0</span><span class="p">,</span> <span class="o">*</span><span class="n">bar1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_free_devdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit_table</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="nf">ipath_alloc_devdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit_table</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit_table</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPATH_DRV_NAME</span>
		       <span class="s">&quot;: Could not allocate unit ID: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">ipath_free_devdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>
		<span class="n">dd</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipath_dev_list</span><span class="p">);</span>

<span class="nl">bail_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">dd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="nf">__ipath_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit_table</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="nf">ipath_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dd</span> <span class="o">=</span> <span class="n">__ipath_lookup</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ipath_count_units</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">npresentp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nupp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">maxportsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nunits</span><span class="p">,</span> <span class="n">npresent</span><span class="p">,</span> <span class="n">nup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maxports</span><span class="p">;</span>

	<span class="n">nunits</span> <span class="o">=</span> <span class="n">npresent</span> <span class="o">=</span> <span class="n">nup</span> <span class="o">=</span> <span class="n">maxports</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipath_dev_list</span><span class="p">,</span> <span class="n">ipath_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nunits</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_PRESENT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">)</span>
			<span class="n">npresent</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lid</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IPATH_DISABLED</span> <span class="o">|</span> <span class="n">IPATH_LINKDOWN</span>
					 <span class="o">|</span> <span class="n">IPATH_LINKUNK</span><span class="p">)))</span>
			<span class="n">nup</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cfgports</span> <span class="o">&gt;</span> <span class="n">maxports</span><span class="p">)</span>
			<span class="n">maxports</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cfgports</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_devs_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">npresentp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">npresentp</span> <span class="o">=</span> <span class="n">npresent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nupp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nupp</span> <span class="o">=</span> <span class="n">nup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxportsp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">maxportsp</span> <span class="o">=</span> <span class="n">maxports</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nunits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These next two routines are placeholders in case we don&#39;t have per-arch</span>
<span class="cm"> * code for controlling write combining.  If explicit control of write</span>
<span class="cm"> * combining is not available, performance will probably be awful.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">ipath_enable_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">ipath_disable_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform a PIO buffer bandwidth write test, to verify proper system</span>
<span class="cm"> * configuration.  Even when all the setup calls work, occasionally</span>
<span class="cm"> * BIOS or other issues can prevent write combining from working, or</span>
<span class="cm"> * can cause other bandwidth problems to the chip.</span>
<span class="cm"> *</span>
<span class="cm"> * This test simply writes the same buffer over and over again, and</span>
<span class="cm"> * measures close to the peak bandwidth to the chip (not testing</span>
<span class="cm"> * data bandwidth to the wire).   On chips that use an address-based</span>
<span class="cm"> * trigger to send packets to the wire, this is easy.  On chips that</span>
<span class="cm"> * use a count to trigger, we want to make sure that the packet doesn&#39;t</span>
<span class="cm"> * go out on the wire, or trigger flow control checks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_verify_pioperf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">pbnum</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">lcnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">piobuf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">msecs</span><span class="p">,</span> <span class="n">emsecs</span><span class="p">;</span>

	<span class="n">piobuf</span> <span class="o">=</span> <span class="n">ipath_getpiobuf</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">piobuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;No PIObufs for checking perf, skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enough to give us a reasonable test, less than piobuf size, and</span>
<span class="cm">	 * likely multiple of store buffer length.</span>
<span class="cm">	 */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">cnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Couldn&#39;t get memory for checking PIO perf,&quot;</span>
			<span class="s">&quot; skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">preempt_disable</span><span class="p">();</span>  <span class="cm">/* we want reasonably accurate elapsed time */</span>
	<span class="n">msecs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lcnt</span> <span class="o">&lt;</span> <span class="mi">10000U</span><span class="p">;</span> <span class="n">lcnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* wait until we cross msec boundary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">msecs</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ipath_disable_armlaunch</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * length 0, no dwords actually sent, and mark as VL15</span>
<span class="cm">	 * on chips where that may matter (due to IB flowcontrol)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_HAS_PBC_CNT</span><span class="p">))</span>
		<span class="n">writeq</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">,</span> <span class="n">piobuf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">piobuf</span><span class="p">);</span>
	<span class="n">ipath_flush_wc</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * this is only roughly accurate, since even with preempt we</span>
<span class="cm">	 * still take interrupts that could take a while.   Running for</span>
<span class="cm">	 * &gt;= 5 msec seems to get us &quot;close enough&quot; to accurate values</span>
<span class="cm">	 */</span>
	<span class="n">msecs</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">emsecs</span> <span class="o">=</span> <span class="n">lcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">emsecs</span> <span class="o">&lt;=</span> <span class="mi">5UL</span><span class="p">;</span> <span class="n">lcnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__iowrite32_copy</span><span class="p">(</span><span class="n">piobuf</span> <span class="o">+</span> <span class="mi">64</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">emsecs</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">)</span> <span class="o">-</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* 1 GiB/sec, slightly over IB SDR line rate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lcnt</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">emsecs</span> <span class="o">*</span> <span class="mi">1024U</span><span class="p">))</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span>
			<span class="s">&quot;Performance problem: bandwidth to PIO buffers is &quot;</span>
			<span class="s">&quot;only %u MiB/sec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">lcnt</span> <span class="o">/</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">emsecs</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;PIO buffer bandwidth %u MiB/sec is OK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">lcnt</span> <span class="o">/</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">emsecs</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="cm">/* disarm piobuf, so it&#39;s available again */</span>
	<span class="n">ipath_disarm_piobufs</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">pbnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ipath_enable_armlaunch</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cleanup_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">ipath_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">bar0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bar1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dd</span> <span class="o">=</span> <span class="n">ipath_alloc_devdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPATH_DRV_NAME</span>
		       <span class="s">&quot;: Could not allocate devdata: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;initializing unit #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This can happen iff:</span>
<span class="cm">		 *</span>
<span class="cm">		 * We did a chip reset, and then failed to reprogram the</span>
<span class="cm">		 * BAR, or the chip reset due to an internal error.  We then</span>
<span class="cm">		 * unloaded the driver and reloaded it.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Both reset cases set the BAR back to initial state.  For</span>
<span class="cm">		 * the latter case, the AER sticky error bit at offset 0x718</span>
<span class="cm">		 * should be set, but the Linux kernel doesn&#39;t yet know</span>
<span class="cm">		 * about that, it appears.  If the original BAR was retained</span>
<span class="cm">		 * in the kernel data structures, this may be OK.</span>
<span class="cm">		 */</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;enable unit %d failed: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail_devdata</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;regbase (0) %llx len %d irq %d, vend %x/%x &quot;</span>
		   <span class="s">&quot;driver_data %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span>
		   <span class="n">ent</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">);</span>

	<span class="n">read_bars</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bar0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bar1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bar1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">bar0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BAR is 0 (probable RESET), &quot;</span>
				 <span class="s">&quot;rewriting as %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_write_config_dword</span><span class="p">(</span>
				<span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_BASE_ADDRESS_0</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;rewrite of BAR0 &quot;</span>
					      <span class="s">&quot;failed: err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bail_disable</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_write_config_dword</span><span class="p">(</span>
				<span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_BASE_ADDRESS_1</span><span class="p">,</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;rewrite of BAR1 &quot;</span>
					      <span class="s">&quot;failed: err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bail_disable</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;BAR is 0 (probable RESET), &quot;</span>
				      <span class="s">&quot;not usable until reboot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bail_disable</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IPATH_DRV_NAME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_request_regions unit %u fails: &quot;</span>
			 <span class="s">&quot;err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail_disable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if the 64 bit setup fails, try 32 bit.  Some systems</span>
<span class="cm">		 * do not setup 64 bit maps on systems with 2GB or less</span>
<span class="cm">		 * memory installed.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Unable to set DMA mask for unit %u: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail_regions</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;No 64bit DMA mask, used 32 bit mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Unable to set DMA consistent mask &quot;</span>
					<span class="s">&quot;for unit %u: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Unable to set DMA consistent mask &quot;</span>
				<span class="s">&quot;for unit %u: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save BARs to rewrite after device reset.  Save all 64 bits of</span>
<span class="cm">	 * BAR, just in case.</span>
<span class="cm">	 */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pcibar0</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pcibar1</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_deviceid</span> <span class="o">=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>	<span class="cm">/* save for later use */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_vendorid</span> <span class="o">=</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">;</span>

	<span class="cm">/* setup the chip-specific functions, as early as possible. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCI_DEVICE_ID_INFINIPATH_HT</span>:
		<span class="n">ipath_init_iba6110_funcs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Found unknown QLogic deviceid 0x%x, &quot;</span>
			      <span class="s">&quot;failing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">start</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;BAR %d %pR, len %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">j</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;No valid address in BAR 0!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail_regions</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pcirev</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>

<span class="cp">#if defined(__powerpc__)</span>
	<span class="cm">/* There isn&#39;t a generic way to specify writethrough mappings */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">=</span> <span class="n">__ioremap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="p">(</span><span class="n">_PAGE_NO_CACHE</span><span class="o">|</span><span class="n">_PAGE_WRITETHRU</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Unable to map io addr %llx to kvirt, failing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">addr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail_iounmap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregend</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">((</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_physaddr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>	<span class="cm">/* used for io_remap, etc. */</span>
	<span class="cm">/* for user mmap */</span>
	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;mapped io addr %llx to kregbase %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">addr</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_bus</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to setup config space; &quot;</span>
			      <span class="s">&quot;continuing anyway</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * set up our interrupt handler; IRQF_SHARED probably not needed,</span>
<span class="cm">	 * since MSI interrupts shouldn&#39;t be shared but won&#39;t  hurt for now.</span>
<span class="cm">	 * check 0 irq after we return from chip-specific bus setup, since</span>
<span class="cm">	 * that can affect this due to setup</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_irq</span><span class="p">)</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;irq is 0, BIOS error?  Interrupts won&#39;t &quot;</span>
			      <span class="s">&quot;work</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_irq</span><span class="p">,</span> <span class="n">ipath_intr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
				  <span class="n">IPATH_DRV_NAME</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t setup irq handler, &quot;</span>
				      <span class="s">&quot;irq=%d: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail_iounmap</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ipath_init_chip</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* do the chip-specific init */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bail_irqsetup</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ipath_enable_wc</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Write combining not enabled &quot;</span>
			      <span class="s">&quot;(err %d): performance may be poor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ipath_verify_pioperf</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">ipath_device_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>
	<span class="n">ipathfs_add_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">ipath_user_add</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">ipath_diag_add</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">ipath_register_ib_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

<span class="nl">bail_irqsetup:</span>
	<span class="n">cleanup_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_irq</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_free_irq</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_cleanup</span><span class="p">)</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

<span class="nl">bail_iounmap:</span>
	<span class="n">iounmap</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">);</span>

<span class="nl">bail_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">bail_disable:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">bail_devdata:</span>
	<span class="n">ipath_free_devdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">**</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_statusp</span> <span class="o">&amp;</span> <span class="n">IPATH_STATUS_CHIP_PRESENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* can&#39;t do anything more with chip; needs re-init */</span>
		<span class="o">*</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_statusp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IPATH_STATUS_CHIP_PRESENT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if we haven&#39;t already cleaned up before these are</span>
<span class="cm">			 * to ensure any register reads/writes &quot;fail&quot; until</span>
<span class="cm">			 * re-init</span>
<span class="cm">			 */</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uregbase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sregbase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cregbase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ipath_disable_wc</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_spectriggerhit</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%lu special trigger hits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_spectriggerhit</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">,</span>
				  <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_phys</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_dummy_hdrq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_size</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_dummy_hdrq</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_dummy_hdrq_phys</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_dummy_hdrq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pageshadow</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">tmpp</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pageshadow</span><span class="p">;</span>
		<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">tmpd</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_physshadow</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Unlocking any expTID pages still &quot;</span>
			   <span class="s">&quot;locked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cfgports</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">port_tidbase</span> <span class="o">=</span> <span class="n">port</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvtidcnt</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">maxtid</span> <span class="o">=</span> <span class="n">port_tidbase</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvtidcnt</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">port_tidbase</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxtid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmpp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">tmpd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">ipath_release_user_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">tmpp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_pageunlocks</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
			<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;There were still %u expTID &quot;</span>
				   <span class="s">&quot;entries locked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_pagelocks</span> <span class="o">||</span>
		    <span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_pageunlocks</span><span class="p">)</span>
			<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;%llu pages locked, %llu &quot;</span>
				   <span class="s">&quot;unlocked via ipath_m{un}lock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				   <span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_pagelocks</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				   <span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_pageunlocks</span><span class="p">);</span>

		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Free shadow page tid array at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pageshadow</span><span class="p">);</span>
		<span class="n">tmpp</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pageshadow</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pageshadow</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">tmpp</span><span class="p">);</span>

		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_egrtidbase</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * free any resources still in use (usually just kernel ports)</span>
<span class="cm">	 * at unload; we do for portcnt, because that&#39;s what we allocate.</span>
<span class="cm">	 * We acquire lock to be really paranoid that ipath_pd isn&#39;t being</span>
<span class="cm">	 * accessed from some interrupt-related code (that should not happen,</span>
<span class="cm">	 * but best to be sure).</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_portcnt</span><span class="p">;</span> <span class="n">port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
		<span class="n">tmp</span><span class="p">[</span><span class="n">port</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* debugging paranoia */</span>
		<span class="n">ipath_free_pddata</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">ipath_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;removing, pdev=%p, dd=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * disable the IB link early, to be sure no new packets arrive, which</span>
<span class="cm">	 * complicates the shutdown process</span>
<span class="cm">	 */</span>
	<span class="n">ipath_shutdown_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">ib_wq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">verbs_dev</span><span class="p">)</span>
		<span class="n">ipath_unregister_ib_device</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">verbs_dev</span><span class="p">);</span>

	<span class="n">ipath_diag_remove</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">ipath_user_remove</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">ipathfs_remove_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">ipath_device_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>

	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Releasing pci memory regions, dd %p, &quot;</span>
		   <span class="s">&quot;unit %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">);</span>

	<span class="n">cleanup_device</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * turn off rcv, send, and interrupts for all ports, all drivers</span>
<span class="cm">	 * should also hard reset the chip here?</span>
<span class="cm">	 * free up port 0 (kernel) rcvhdr, egr bufs, and eventually tid bufs</span>
<span class="cm">	 * for all versions of the driver, if they were allocated</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;unit %u free irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_irq</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_free_irq</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;irq is 0, not doing free_irq &quot;</span>
			  <span class="s">&quot;for unit %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * we check for NULL here, because it&#39;s outside</span>
<span class="cm">	 * the kregbase check, and we need to call it</span>
<span class="cm">	 * after the free_irq.	Thus it&#39;s possible that</span>
<span class="cm">	 * the function pointers were never initialized.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_cleanup</span><span class="p">)</span>
		<span class="cm">/* clean up chip-specific stuff */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_cleanup</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Unmapping kregbase %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">((</span><span class="k">volatile</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;calling pci_disable_device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">ipath_free_devdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* general driver use */</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ipath_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ipath_pioavail_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_disarm_piobufs - cancel a range of PIO buffers</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @first: the first PIO buffer to cancel</span>
<span class="cm"> * @cnt: the number of PIO buffers to cancel</span>
<span class="cm"> *</span>
<span class="cm"> * cancel a range of PIO buffers, used when they might be armed, but</span>
<span class="cm"> * not triggered.  Used at init to ensure buffer state, and also user</span>
<span class="cm"> * process close, in case it died while writing to a PIO buffer</span>
<span class="cm"> * Also after errors.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_disarm_piobufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">first</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">PKT</span><span class="p">,</span> <span class="s">&quot;disarm %u PIObufs first=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The disarm-related bits are write-only, so it</span>
<span class="cm">		 * is ok to OR them in with our copy of sendctrl</span>
<span class="cm">		 * while we hold the lock.</span>
<span class="cm">		 */</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_sendctrl</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">|</span> <span class="n">INFINIPATH_S_DISARM</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">INFINIPATH_S_DISARMPIOBUF_SHIFT</span><span class="p">));</span>
		<span class="cm">/* can&#39;t disarm bufs back-to-back per iba7220 spec */</span>
		<span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_scratch</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* on some older chips, update may not happen after cancel */</span>
	<span class="n">ipath_force_pio_avail_update</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_wait_linkstate - wait for an IB link state change to occur</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @state: the state to wait for</span>
<span class="cm"> * @msecs: the number of milliseconds to wait</span>
<span class="cm"> *</span>
<span class="cm"> * wait up to msecs milliseconds for IB link state change to occur for</span>
<span class="cm"> * now, take the easy polling route.  Currently used only by</span>
<span class="cm"> * ipath_set_linkstate.  Returns 0 if state reached, otherwise</span>
<span class="cm"> * -ETIMEDOUT state can have multiple states set, for any of several</span>
<span class="cm"> * transitions.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ipath_wait_linkstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_state_wanted</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">ipath_state_wait</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">),</span>
					 <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">msecs</span><span class="p">));</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_state_wanted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Didn&#39;t reach linkstate %s within %u&quot;</span>
			   <span class="s">&quot; ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="cm">/* test INIT ahead of DOWN, both can be set */</span>
			   <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">IPATH_LINKINIT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;INIT&quot;</span> <span class="o">:</span>
			   <span class="p">((</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">IPATH_LINKDOWN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;DOWN&quot;</span> <span class="o">:</span>
			    <span class="p">((</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">IPATH_LINKARMED</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ARM&quot;</span> <span class="o">:</span> <span class="s">&quot;ACTIVE&quot;</span><span class="p">)),</span>
			   <span class="n">msecs</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcstatus</span><span class="p">);</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;ibcc=%llx ibcstatus=%llx (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ipath_read_kreg64</span><span class="p">(</span>
				   <span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcctrl</span><span class="p">),</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">val</span><span class="p">,</span>
			   <span class="n">ipath_ibcstatus_str</span><span class="p">[</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ibcs_lts_mask</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">decode_sdma_errs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">ipath_err_t</span> <span class="n">err</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">blen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
		<span class="n">ipath_err_t</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">errs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMAGENMISMATCH</span><span class="p">,</span> <span class="s">&quot;SDmaGenMismatch&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMAOUTOFBOUND</span><span class="p">,</span> <span class="s">&quot;SDmaOutOfBound&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMATAILOUTOFBOUND</span><span class="p">,</span> <span class="s">&quot;SDmaTailOutOfBound&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMABASE</span><span class="p">,</span> <span class="s">&quot;SDmaBase&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMA1STDESC</span><span class="p">,</span> <span class="s">&quot;SDma1stDesc&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMARPYTAG</span><span class="p">,</span> <span class="s">&quot;SDmaRpyTag&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMADWEN</span><span class="p">,</span> <span class="s">&quot;SDmaDwEn&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMAMISSINGDW</span><span class="p">,</span> <span class="s">&quot;SDmaMissingDw&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMAUNEXPDATA</span><span class="p">,</span> <span class="s">&quot;SDmaUnexpData&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMADESCADDRMISALIGN</span><span class="p">,</span> <span class="s">&quot;SDmaDescAddrMisalign&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SENDBUFMISUSE</span><span class="p">,</span> <span class="s">&quot;SendBufMisuse&quot;</span> <span class="p">},</span>
		<span class="p">{</span> <span class="n">INFINIPATH_E_SDMADISABLED</span><span class="p">,</span> <span class="s">&quot;SDmaDisabled&quot;</span> <span class="p">},</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">expected</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">errs</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="n">errs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">err</span> <span class="o">!=</span> <span class="n">INFINIPATH_E_SDMADISABLED</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">IPATH_SDMA_ABORTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">errs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">err</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">expected</span><span class="p">)</span>
			<span class="n">bidx</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">bidx</span><span class="p">,</span> <span class="n">blen</span> <span class="o">-</span> <span class="n">bidx</span><span class="p">,</span>
					 <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">errs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decode the error status into strings, deciding whether to always</span>
<span class="cm"> * print * it or not depending on &quot;normal packet errors&quot; vs everything</span>
<span class="cm"> * else.   Return 1 if &quot;real&quot; errors, otherwise 0 if only packet</span>
<span class="cm"> * errors, so caller can decide what to print with the string.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ipath_decode_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">blen</span><span class="p">,</span>
	<span class="n">ipath_err_t</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iserr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_PKTERRS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">INFINIPATH_E_PKTERRS</span><span class="p">))</span>
			<span class="n">iserr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// if only packet errors.</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipath_debug</span> <span class="o">&amp;</span> <span class="n">__IPATH_ERRPKTDBG</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_REBP</span><span class="p">)</span>
				<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;EBP &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RVCRC</span><span class="p">)</span>
				<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;VCRC &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RICRC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;CRC &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>clear for check below, so only once</p></td><td class="code"><div class="highlight"><pre>				<span class="n">err</span> <span class="o">&amp;=</span> <span class="n">INFINIPATH_E_RICRC</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RSHORTPKTLEN</span><span class="p">)</span>
				<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rshortpktlen &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SDROPPEDDATAPKT</span><span class="p">)</span>
				<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;sdroppeddatapkt &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SPKTLEN</span><span class="p">)</span>
				<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;spktlen &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RICRC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">err</span><span class="o">&amp;</span><span class="p">(</span><span class="n">INFINIPATH_E_RVCRC</span><span class="o">|</span><span class="n">INFINIPATH_E_REBP</span><span class="p">)))</span>
			<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;CRC &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iserr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RHDRLEN</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rhdrlen &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RBADTID</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rbadtid &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RBADVERSION</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rbadversion &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RHDR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rhdr &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SENDSPECIALTRIGGER</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;sendspecialtrigger &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RLONGPKTLEN</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rlongpktlen &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RMAXPKTLEN</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rmaxpktlen &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RMINPKTLEN</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rminpktlen &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SMINPKTLEN</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;sminpktlen &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RFORMATERR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rformaterr &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RUNSUPVL</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;runsupvl &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RUNEXPCHAR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;runexpchar &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RIBFLOW</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;ribflow &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SUNDERRUN</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;sunderrun &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SPIOARMLAUNCH</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;spioarmlaunch &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SUNEXPERRPKTNUM</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;sunexperrpktnum &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SDROPPEDSMPPKT</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;sdroppedsmppkt &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SMAXPKTLEN</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;smaxpktlen &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SUNSUPVL</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;sunsupVL &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_INVALIDADDR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;invalidaddr &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RRCVEGRFULL</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rcvegrfull &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RRCVHDRFULL</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;rcvhdrfull &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_IBSTATUSCHANGED</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;ibcstatuschg &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RIBLOSTLINK</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;riblostlink &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_HARDWARE</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;hardware &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_RESET</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;reset &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_SDMAERRS</span><span class="p">)</span>
		<span class="n">decode_sdma_errs</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_E_INVALIDEEPCMD</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;invalideepromcmd &quot;</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">iserr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_rhf_errstring - decode RHF errors</span>
<span class="cm"> * @err: the err number</span>
<span class="cm"> * @msg: the output buffer</span>
<span class="cm"> * @len: the length of the output buffer</span>
<span class="cm"> *</span>
<span class="cm"> * only used one place now, may want more later</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_rhf_errstring</span><span class="p">(</span><span class="n">u32</span> <span class="n">err</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if no errors, and so don&#39;t need to check what&#39;s first */</span>
	<span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_ICRCERR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;icrcerr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_VCRCERR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;vcrcerr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_PARITYERR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;parityerr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_LENERR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;lenerr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_MTUERR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;mtuerr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_IHDRERR</span><span class="p">)</span>
		<span class="cm">/* infinipath hdr checksum error */</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;ipathhdrerr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_TIDERR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;tiderr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_MKERR</span><span class="p">)</span>
		<span class="cm">/* bad port, offset, etc. */</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;invalid ipathhdr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_IBERR</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;iberr &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_L_SWA</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;swA &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_L_SWB</span><span class="p">)</span>
		<span class="n">strlcat</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">&quot;swB &quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_get_egrbuf - get an eager buffer</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @bufnum: the eager buffer to get</span>
<span class="cm"> *</span>
<span class="cm"> * must only be called if ipath_pd[port] is known to be allocated</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ipath_get_egrbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bufnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_port0_skbinfo</span> <span class="o">?</span>
		<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_port0_skbinfo</span><span class="p">[</span><span class="n">bufnum</span><span class="p">].</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_alloc_skb - allocate an skb and buffer with possible constraints</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @gfp_mask: the sk_buff SFP mask</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">ipath_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only fully supported way to handle this is to allocate lots</span>
<span class="cm">	 * extra, align as needed, and then do skb_reserve().  That wastes</span>
<span class="cm">	 * a lot of memory...  I&#39;ll have to hack this into infinipath_copy</span>
<span class="cm">	 * also.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need 2 extra bytes for ipath_ether data sent in the</span>
<span class="cm">	 * key header.  In order to keep everything dword aligned,</span>
<span class="cm">	 * we&#39;ll reserve 4 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_4BYTE_TID</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We need a 2KB multiple alignment, and there is no way</span>
<span class="cm">		 * to do it except to allocate extra and then skb_reserve</span>
<span class="cm">		 * enough to bring it up to the right alignment.</span>
<span class="cm">		 */</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="mi">2047</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">__dev_alloc_skb</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Failed to allocate skbuff, length %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_4BYTE_TID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">una</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mi">2047</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">una</span><span class="p">)</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2048</span> <span class="o">-</span> <span class="n">una</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_rcv_hdrerr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">eflags</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">l</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">etail</span><span class="p">,</span>
			     <span class="n">__le32</span> <span class="o">*</span><span class="n">rhf_addr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ipath_message_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">emsg</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

	<span class="n">get_rhf_errstring</span><span class="p">(</span><span class="n">eflags</span><span class="p">,</span> <span class="n">emsg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">emsg</span><span class="p">);</span>
	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">PKT</span><span class="p">,</span> <span class="s">&quot;RHFerrs %x hdrqtail=%x typ=%u &quot;</span>
		   <span class="s">&quot;tlen=%x opcode=%x egridx=%x: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">eflags</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span>
		   <span class="n">ipath_hdrget_rcv_type</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">),</span>
		   <span class="n">ipath_hdrget_length_in_bytes</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">),</span>
		   <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bth</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">,</span>
		   <span class="n">etail</span><span class="p">,</span> <span class="n">emsg</span><span class="p">);</span>

	<span class="cm">/* Count local link integrity errors. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INFINIPATH_RHF_H_ICRCERR</span> <span class="o">|</span> <span class="n">INFINIPATH_RHF_H_VCRCERR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span> <span class="o">&gt;&gt;</span>
			<span class="n">INFINIPATH_IBCC_PHYERRTHRESHOLD_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">INFINIPATH_IBCC_PHYERRTHRESHOLD_MASK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lli_counter</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lli_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lli_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ipath_kreceive - receive a packet</span>
<span class="cm"> * @pd: the infinipath port</span>
<span class="cm"> *</span>
<span class="cm"> * called from interrupt handler for errors or receive interrupt</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_kreceive</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_dd</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="o">*</span><span class="n">rhf_addr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ebuf</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">rsize</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrentsize</span><span class="p">;</span>	<span class="cm">/* words */</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">maxcnt</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrcnt</span> <span class="o">*</span> <span class="n">rsize</span><span class="p">;</span>	<span class="cm">/* words */</span>
	<span class="n">u32</span> <span class="n">etail</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">hdrqtail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_message_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eflags</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">etype</span><span class="p">,</span> <span class="n">tlen</span><span class="p">,</span> <span class="n">pkttot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">updegr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reloop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">u64</span> <span class="n">totcalls</span><span class="p">;</span>	<span class="cm">/* stats, may eventually remove */</span>
	<span class="kt">int</span> <span class="n">last</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_head</span><span class="p">;</span>
	<span class="n">rhf_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rhf_offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_NODMA_RTAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">ipath_hdrget_seq</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_seq_cnt</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="n">hdrqtail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hdrqtail</span> <span class="o">=</span> <span class="n">ipath_get_rcvhdrtail</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">hdrqtail</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">reloop:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">!</span><span class="n">last</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="o">!</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_get_msgheader</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">rhf_addr</span><span class="p">);</span>
		<span class="n">eflags</span> <span class="o">=</span> <span class="n">ipath_hdrget_err_flags</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">);</span>
		<span class="n">etype</span> <span class="o">=</span> <span class="n">ipath_hdrget_rcv_type</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">);</span>
		<span class="cm">/* total length */</span>
		<span class="n">tlen</span> <span class="o">=</span> <span class="n">ipath_hdrget_length_in_bytes</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">);</span>
		<span class="n">ebuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_NODMA_RTAIL</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">ipath_hdrget_use_egr_buf</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">)</span> <span class="o">:</span>
		    <span class="p">(</span><span class="n">etype</span> <span class="o">!=</span> <span class="n">RCVHQ_RCV_TYPE_EXPECTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It turns out that the chip uses an eager buffer</span>
<span class="cm">			 * for all non-expected packets, whether it &quot;needs&quot;</span>
<span class="cm">			 * one or not.  So always get the index, but don&#39;t</span>
<span class="cm">			 * set ebuf (so we try to copy data) unless the</span>
<span class="cm">			 * length requires it.</span>
<span class="cm">			 */</span>
			<span class="n">etail</span> <span class="o">=</span> <span class="n">ipath_hdrget_index</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">);</span>
			<span class="n">updegr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tlen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hdr</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">etype</span> <span class="o">==</span> <span class="n">RCVHQ_RCV_TYPE_NON_KD</span><span class="p">)</span>
				<span class="n">ebuf</span> <span class="o">=</span> <span class="n">ipath_get_egrbuf</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">etail</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * both tiderr and ipathhdrerr are set for all plain IB</span>
<span class="cm">		 * packets; only ipathhdrerr should be set.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">etype</span> <span class="o">!=</span> <span class="n">RCVHQ_RCV_TYPE_NON_KD</span> <span class="o">&amp;&amp;</span>
		    <span class="n">etype</span> <span class="o">!=</span> <span class="n">RCVHQ_RCV_TYPE_ERROR</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ipath_hdrget_ipath_ver</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">iph</span><span class="p">.</span><span class="n">ver_port_tid_offset</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">IPS_PROTO_VERSION</span><span class="p">)</span>
			<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">PKT</span><span class="p">,</span> <span class="s">&quot;Bad InfiniPath protocol version &quot;</span>
				   <span class="s">&quot;%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">etype</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">eflags</span><span class="p">))</span>
			<span class="n">ipath_rcv_hdrerr</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">eflags</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">etail</span><span class="p">,</span> <span class="n">rhf_addr</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">etype</span> <span class="o">==</span> <span class="n">RCVHQ_RCV_TYPE_NON_KD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ipath_ib_rcv</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">verbs_dev</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">,</span> <span class="n">ebuf</span><span class="p">,</span> <span class="n">tlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lli_counter</span><span class="p">)</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lli_counter</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">etype</span> <span class="o">==</span> <span class="n">RCVHQ_RCV_TYPE_EAGER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bth</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">qp</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bth</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>
			<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">PKT</span><span class="p">,</span> <span class="s">&quot;typ %x, opcode %x (eager, &quot;</span>
				   <span class="s">&quot;qp=%x), len %x; ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">etype</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">qp</span><span class="p">,</span> <span class="n">tlen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">etype</span> <span class="o">==</span> <span class="n">RCVHQ_RCV_TYPE_EXPECTED</span><span class="p">)</span>
			<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Bug: Expected TID, opcode %x; ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">bth</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * error packet, type of error unknown.</span>
<span class="cm">			 * Probably type 3, but we don&#39;t know, so don&#39;t</span>
<span class="cm">			 * even try to print the opcode, etc.</span>
<span class="cm">			 * Usually caused by a &quot;bad packet&quot;, that has no</span>
<span class="cm">			 * BTH, when the LRH says it should.</span>
<span class="cm">			 */</span>
			<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">ERRPKT</span><span class="p">,</span> <span class="s">&quot;Error Pkt, but no eflags! egrbuf&quot;</span>
				  <span class="s">&quot; %x, len %x hdrq+%x rhf: %Lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">etail</span><span class="p">,</span> <span class="n">tlen</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				  <span class="n">le64_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le64</span> <span class="o">*</span><span class="p">)</span> <span class="n">rhf_addr</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ipath_debug</span> <span class="o">&amp;</span> <span class="n">__IPATH_ERRPKTDBG</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">dw</span> <span class="o">=</span> <span class="n">rsize</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rsize</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">tlen</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">))</span>
					<span class="n">dw</span> <span class="o">=</span> <span class="n">tlen</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">;</span>
				<span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">hdr</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;EPkt rcvhdr(%x dw):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">dw</span><span class="p">);</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dw</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%8x%s&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
						<span class="p">(</span><span class="n">j</span><span class="o">%</span><span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">l</span> <span class="o">+=</span> <span class="n">rsize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">maxcnt</span><span class="p">)</span>
			<span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rhf_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span> <span class="o">+</span>
			<span class="n">l</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rhf_offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_NODMA_RTAIL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">ipath_hdrget_seq</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_seq_cnt</span> <span class="o">&gt;</span> <span class="mi">13</span><span class="p">)</span>
				<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_seq_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_seq_cnt</span><span class="p">)</span>
				<span class="n">last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">hdrqtail</span><span class="p">)</span>
			<span class="n">last</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * update head regs on last packet, and every 16 packets.</span>
<span class="cm">		 * Reduce bus traffic, while still trying to prevent</span>
<span class="cm">		 * rcvhdrq overflows, for when the queue is nearly full</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">lval</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>

			<span class="cm">/* request IBA6120 and 7220 interrupt only on last */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
				<span class="n">lval</span> <span class="o">|=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rhdrhead_intr_off</span><span class="p">;</span>
			<span class="n">ipath_write_ureg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ur_rcvhdrhead</span><span class="p">,</span> <span class="n">lval</span><span class="p">,</span>
				<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">updegr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ipath_write_ureg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">ur_rcvegrindexhead</span><span class="p">,</span>
						 <span class="n">etail</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">);</span>
				<span class="n">updegr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rhdrhead_intr_off</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reloop</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_NODMA_RTAIL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* IBA6110 workaround; we can have a race clearing chip</span>
<span class="cm">		 * interrupt with another interrupt about to be delivered,</span>
<span class="cm">		 * and can clear it before it is delivered on the GPIO</span>
<span class="cm">		 * workaround.  By doing the extra check here for the</span>
<span class="cm">		 * in-memory tail register updating while we were doing</span>
<span class="cm">		 * earlier packets, we &quot;almost&quot; guarantee we have covered</span>
<span class="cm">		 * that case.</span>
<span class="cm">		 */</span>
		<span class="n">u32</span> <span class="n">hqtail</span> <span class="o">=</span> <span class="n">ipath_get_rcvhdrtail</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hqtail</span> <span class="o">!=</span> <span class="n">hdrqtail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hdrqtail</span> <span class="o">=</span> <span class="n">hqtail</span><span class="p">;</span>
			<span class="n">reloop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* loop 1 extra time at most */</span>
			<span class="k">goto</span> <span class="n">reloop</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pkttot</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_head</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pkttot</span> <span class="o">&gt;</span> <span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_maxpkts_call</span><span class="p">)</span>
		<span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_maxpkts_call</span> <span class="o">=</span> <span class="n">pkttot</span><span class="p">;</span>
	<span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_port0pkts</span> <span class="o">+=</span> <span class="n">pkttot</span><span class="p">;</span>
	<span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_avgpkts_call</span> <span class="o">=</span>
		<span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_port0pkts</span> <span class="o">/</span> <span class="o">++</span><span class="n">totcalls</span><span class="p">;</span>

<span class="nl">bail:</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_update_pio_bufs - update shadow copy of the PIO availability map</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> *</span>
<span class="cm"> * called whenever our local copy indicates we have run out of send buffers</span>
<span class="cm"> * NOTE: This can be called from interrupt context by some code</span>
<span class="cm"> * and from non-interrupt context by ipath_getpiobuf().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_update_pio_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">piobregs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavregs</span><span class="p">;</span>

	<span class="cm">/* If the generation (check) bits have changed, then we update the</span>
<span class="cm">	 * busy bit for the corresponding PIO buffer.  This algorithm will</span>
<span class="cm">	 * modify positions to the value they already have in some cases</span>
<span class="cm">	 * (i.e., no change), but it&#39;s faster than changing only the bits</span>
<span class="cm">	 * that have changed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We would like to do this atomicly, to avoid spinlocks in the</span>
<span class="cm">	 * critical send path, but that&#39;s not really possible, given the</span>
<span class="cm">	 * type of changes, and that this routine could be called on</span>
<span class="cm">	 * multiple cpu&#39;s simultaneously, so we lock in this routine only,</span>
<span class="cm">	 * to avoid conflicting updates; all we change is the shadow, and</span>
<span class="cm">	 * it&#39;s a single 64 bit memory location, so by definition the update</span>
<span class="cm">	 * is atomic in terms of what other cpu&#39;s can see in testing the</span>
<span class="cm">	 * bits.  The spin_lock overhead isn&#39;t too bad, since it only</span>
<span class="cm">	 * happens when all buffers are in use, so only cpu overhead, not</span>
<span class="cm">	 * latency or bandwidth is affected.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Update shadow pioavail, but regs_dma NULL!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipath_debug</span> <span class="o">&amp;</span> <span class="n">__IPATH_VERBDBG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* only if packet debug and verbose */</span>
		<span class="k">volatile</span> <span class="n">__le64</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">;</span>

		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">PKT</span><span class="p">,</span> <span class="s">&quot;Refill avail, dma0=%llx shad0=%lx, &quot;</span>
			   <span class="s">&quot;d1=%llx s1=%lx, d2=%llx s2=%lx, d3=%llx &quot;</span>
			   <span class="s">&quot;s3=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			   <span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			   <span class="n">shadow</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
			   <span class="n">shadow</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
			   <span class="n">shadow</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piobregs</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">ipath_cdbg</span><span class="p">(</span>
				<span class="n">PKT</span><span class="p">,</span> <span class="s">&quot;2nd group, dma4=%llx shad4=%lx, &quot;</span>
				<span class="s">&quot;d5=%llx s5=%lx, d6=%llx s6=%lx, &quot;</span>
				<span class="s">&quot;d7=%llx s7=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
				<span class="n">shadow</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
				<span class="n">shadow</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">6</span><span class="p">]),</span>
				<span class="n">shadow</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">7</span><span class="p">]),</span>
				<span class="n">shadow</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">piobregs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">pchbusy</span><span class="p">,</span> <span class="n">pchg</span><span class="p">,</span> <span class="n">piov</span><span class="p">,</span> <span class="n">pnew</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Chip Errata: bug 6641; even and odd qwords&gt;3 are swapped</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_SWAP_PIOBUFS</span><span class="p">))</span>
			<span class="n">piov</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">[</span><span class="n">i</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">piov</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">pchg</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailkernel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span>
			<span class="o">~</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">piov</span><span class="p">);</span>
		<span class="n">pchbusy</span> <span class="o">=</span> <span class="n">pchg</span> <span class="o">&lt;&lt;</span> <span class="n">INFINIPATH_SENDPIOAVAIL_BUSY_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pchg</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pchbusy</span> <span class="o">&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">pnew</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pchbusy</span><span class="p">;</span>
			<span class="n">pnew</span> <span class="o">|=</span> <span class="n">piov</span> <span class="o">&amp;</span> <span class="n">pchbusy</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pnew</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * used to force update of pioavailshadow if we can&#39;t get a pio buffer.</span>
<span class="cm"> * Needed primarily due to exitting freeze mode after recovering</span>
<span class="cm"> * from errors.  Done lazily, because it&#39;s safer (known to not</span>
<span class="cm"> * be writing pio buffers).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_reset_availshadow</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">im</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavregs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="n">oldval</span><span class="p">;</span>
		<span class="cm">/* deal with 6110 chip bug on high register #s */</span>
		<span class="n">im</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_SWAP_PIOBUFS</span><span class="p">))</span> <span class="o">?</span>
			<span class="n">i</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">[</span><span class="n">im</span><span class="p">]);</span>
		<span class="cm">/*</span>
<span class="cm">		 * busy out the buffers not in the kernel avail list,</span>
<span class="cm">		 * without changing the generation bits.</span>
<span class="cm">		 */</span>
		<span class="n">oldval</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">|</span>
			<span class="p">((</span><span class="o">~</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailkernel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span>
			<span class="n">INFINIPATH_SENDPIOAVAIL_BUSY_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="mh">0xaaaaaaaaaaaaaaaaULL</span><span class="p">);</span> <span class="cm">/* All BUSY bits in qword */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldval</span> <span class="o">!=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;shadow[%d] was %Lx, now %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">oldval</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_setrcvhdrsize - set the receive header size</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @rhdrsize: the receive header size</span>
<span class="cm"> *</span>
<span class="cm"> * called from user init code, and also layered driver init</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ipath_setrcvhdrsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">rhdrsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_RCVHDRSZ_SET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrsize</span> <span class="o">!=</span> <span class="n">rhdrsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Error: can&#39;t set protocol header &quot;</span>
				 <span class="s">&quot;size %u, already %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">rhdrsize</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrsize</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Reuse same protocol header &quot;</span>
				   <span class="s">&quot;size %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrsize</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rhdrsize</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrentsize</span> <span class="o">-</span>
			       <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Error: can&#39;t set protocol header size %u &quot;</span>
			  <span class="s">&quot;(&gt; max %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rhdrsize</span><span class="p">,</span>
			  <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrentsize</span> <span class="o">-</span>
			  <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">|=</span> <span class="n">IPATH_RCVHDRSZ_SET</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrsize</span> <span class="o">=</span> <span class="n">rhdrsize</span><span class="p">;</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_rcvhdrsize</span><span class="p">,</span>
				 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrsize</span><span class="p">);</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Set protocol header size to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrsize</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * debugging code and stats updates if no pio buffers available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">no_pio_bufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="o">*</span><span class="n">dma</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le64</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">;</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_upd_pio_shadow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * not atomic, but if we lose a stat count in a while, that&#39;s OK</span>
<span class="cm">	 */</span>
	<span class="n">ipath_stats</span><span class="p">.</span><span class="n">sps_nopiobufs</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_consec_nopiobuf</span> <span class="o">%</span> <span class="mi">100000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ipath_force_pio_avail_update</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span> <span class="cm">/* at start */</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;%u tries no piobufavail ts%lx; dmacopy: &quot;</span>
			<span class="s">&quot;%llx %llx %llx %llx</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;ipath  shadow:  %lx %lx %lx %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_consec_nopiobuf</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">get_cycles</span><span class="p">(),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
			<span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="cm">/*</span>
<span class="cm">		 * 4 buffers per byte, 4 registers above, cover rest</span>
<span class="cm">		 * below</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt2k</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt4k</span><span class="p">)</span> <span class="o">&gt;</span>
		    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">shadow</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
			<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;2nd group: dmacopy: &quot;</span>
				  <span class="s">&quot;%llx %llx %llx %llx</span><span class="se">\n</span><span class="s">&quot;</span>
				  <span class="s">&quot;ipath  shadow:  %lx %lx %lx %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">6</span><span class="p">]),</span>
				  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">dma</span><span class="p">[</span><span class="mi">7</span><span class="p">]),</span>
				  <span class="n">shadow</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">shadow</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

		<span class="cm">/* at end, so update likely happened */</span>
		<span class="n">ipath_reset_availshadow</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * common code for normal driver pio buffer allocation, and reserved</span>
<span class="cm"> * allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * do appropriate marking as busy, etc.</span>
<span class="cm"> * returns buffer number if one found (&gt;=0), negative number is error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">ipath_getpiobuf_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pbufnum</span><span class="p">,</span> <span class="n">u32</span> <span class="n">first</span><span class="p">,</span> <span class="n">u32</span> <span class="n">last</span><span class="p">,</span> <span class="n">u32</span> <span class="n">firsti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">updated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">piobcnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">shadow</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">piobcnt</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_upd_pio_shadow</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Minor optimization.  If we had no buffers on last call,</span>
<span class="cm">		 * start out by doing the update; continue and do scan even</span>
<span class="cm">		 * if no buffers were updated, to be paranoid</span>
<span class="cm">		 */</span>
		<span class="n">ipath_update_pio_bufs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="n">updated</span><span class="o">++</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">firsti</span><span class="p">;</span>
<span class="nl">rescan:</span>
	<span class="cm">/*</span>
<span class="cm">	 * while test_and_set_bit() is atomic, we do that and then the</span>
<span class="cm">	 * change_bit(), and the pair is not.  See if this is the cause</span>
<span class="cm">	 * of the remaining armlaunch errors.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">piobcnt</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">last</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__test_and_set_bit</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shadow</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* flip generation bit */</span>
		<span class="n">__change_bit</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">shadow</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">piobcnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">updated</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * first time through; shadow exhausted, but may be</span>
<span class="cm">			 * buffers available, try an update and then rescan.</span>
<span class="cm">			 */</span>
			<span class="n">ipath_update_pio_bufs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
			<span class="n">updated</span><span class="o">++</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">updated</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">piobcnt</span> <span class="o">&lt;=</span>
			<span class="p">((</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span>
			<span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_S_UPDTHRESH_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">INFINIPATH_S_UPDTHRESH_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * for chips supporting and using the update</span>
<span class="cm">			 * threshold we need to force an update of the</span>
<span class="cm">			 * in-memory copy if the count is less than the</span>
<span class="cm">			 * thershold, then check one more time.</span>
<span class="cm">			 */</span>
			<span class="n">ipath_force_pio_avail_update</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
			<span class="n">ipath_update_pio_bufs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
			<span class="n">updated</span><span class="o">++</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">no_pio_bufs</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt2k</span><span class="p">)</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pio2kbase</span> <span class="o">+</span>
					       <span class="n">i</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_palign</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
				<span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pio4kbase</span> <span class="o">+</span>
				 <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt2k</span><span class="p">)</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_4kalign</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pbufnum</span><span class="p">)</span>
			<span class="o">*</span><span class="n">pbufnum</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_getpiobuf - find an available pio buffer</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @plen: the size of the PIO buffer needed in 32-bit words</span>
<span class="cm"> * @pbufnum: the buffer number is placed here</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="nf">ipath_getpiobuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">plen</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">pbufnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pnum</span><span class="p">,</span> <span class="n">nbufs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first</span><span class="p">,</span> <span class="n">lasti</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">IPATH_SMALLBUF_DWORDS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt2k</span><span class="p">;</span>
		<span class="n">lasti</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lastpioindexl</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lasti</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lastpioindex</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nbufs</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt2k</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt4k</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">ipath_getpiobuf_range</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnum</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">nbufs</span><span class="p">,</span> <span class="n">lasti</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set next starting place.  It&#39;s just an optimization,</span>
<span class="cm">		 * it doesn&#39;t matter who wins on this, so no locking</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">IPATH_SMALLBUF_DWORDS</span><span class="p">)</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lastpioindexl</span> <span class="o">=</span> <span class="n">pnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lastpioindex</span> <span class="o">=</span> <span class="n">pnum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_upd_pio_shadow</span><span class="p">)</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_upd_pio_shadow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_consec_nopiobuf</span><span class="p">)</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_consec_nopiobuf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Return piobuf%u %uk @ %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">pnum</span><span class="p">,</span> <span class="p">(</span><span class="n">pnum</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt2k</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pbufnum</span><span class="p">)</span>
			<span class="o">*</span><span class="n">pbufnum</span> <span class="o">=</span> <span class="n">pnum</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_chg_pioavailkernel - change which send buffers are available for kernel</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @start: the starting send buffer number</span>
<span class="cm"> * @len: the number of send buffers</span>
<span class="cm"> * @avail: true if the buffers are available for kernel use, false otherwise</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_chg_pioavailkernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">start</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">end</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* There are two bits per send buffer (busy and generation) */</span>
	<span class="n">start</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Set or clear the busy bit in the shadow. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">im</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * the BUSY bit will never be set, because we disarm</span>
<span class="cm">			 * the user buffers before we hand them back to the</span>
<span class="cm">			 * kernel.  We do have to make sure the generation</span>
<span class="cm">			 * bit is set correctly in shadow, since it could</span>
<span class="cm">			 * have changed many times while allocated to user.</span>
<span class="cm">			 * We can&#39;t use the bitmap functions on the full</span>
<span class="cm">			 * dma array because it is always little-endian, so</span>
<span class="cm">			 * we have to flip to host-order first.</span>
<span class="cm">			 * BITS_PER_LONG is slightly wrong, since it&#39;s</span>
<span class="cm">			 * always 64 bits per register in chip...</span>
<span class="cm">			 * We only work on 64 bit kernels, so that&#39;s OK.</span>
<span class="cm">			 */</span>
			<span class="cm">/* deal with 6110 chip bug on high register #s */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
			<span class="n">im</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_SWAP_PIOBUFS</span><span class="p">))</span> <span class="o">?</span>
				<span class="n">i</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">__clear_bit</span><span class="p">(</span><span class="n">INFINIPATH_SENDPIOAVAIL_BUSY_SHIFT</span>
				<span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">);</span>
			<span class="n">dma</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailregs_dma</span><span class="p">[</span><span class="n">im</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">((</span><span class="n">INFINIPATH_SENDPIOAVAIL_CHECK_SHIFT</span>
				<span class="o">+</span> <span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="n">BITS_PER_LONG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dma</span><span class="p">))</span>
				<span class="n">__set_bit</span><span class="p">(</span><span class="n">INFINIPATH_SENDPIOAVAIL_CHECK_SHIFT</span>
					<span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">__clear_bit</span><span class="p">(</span><span class="n">INFINIPATH_SENDPIOAVAIL_CHECK_SHIFT</span>
					<span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">);</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailkernel</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">INFINIPATH_SENDPIOAVAIL_BUSY_SHIFT</span><span class="p">,</span>
				<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailshadow</span><span class="p">);</span>
			<span class="n">__clear_bit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailkernel</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioupd_thresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt2k</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt4k</span><span class="p">);</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">bitmap_weight</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioavailkernel</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_pioavail_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When moving buffers from kernel to user, if number assigned to</span>
<span class="cm">	 * the user is less than the pio update threshold, and threshold</span>
<span class="cm">	 * is supported (cnt was computed &gt; 0), drop the update threshold</span>
<span class="cm">	 * so we update at least once per allocated number of buffers.</span>
<span class="cm">	 * In any case, if the kernel buffers are less than the threshold,</span>
<span class="cm">	 * drop the threshold.  We don&#39;t bother increasing it, having once</span>
<span class="cm">	 * decreased it, since it would typically just cycle back and forth.</span>
<span class="cm">	 * If we don&#39;t decrease below buffers in use, we can wait a long</span>
<span class="cm">	 * time for an update, until some other context uses PIO buffers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avail</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioupd_thresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioupd_thresh</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Decreased pio update threshold to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioupd_thresh</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">INFINIPATH_S_UPDTHRESH_MASK</span>
			<span class="o">&lt;&lt;</span> <span class="n">INFINIPATH_S_UPDTHRESH_SHIFT</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">|=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pioupd_thresh</span>
			<span class="o">&lt;&lt;</span> <span class="n">INFINIPATH_S_UPDTHRESH_SHIFT</span><span class="p">;</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_sendctrl</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_create_rcvhdrq - create a receive header queue</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @pd: the port data</span>
<span class="cm"> *</span>
<span class="cm"> * this must be contiguous memory (from an i/o perspective), and must be</span>
<span class="cm"> * DMA&#39;able (which means for some systems, it will go through an IOMMU,</span>
<span class="cm"> * or be forced into a low address range).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ipath_create_rcvhdrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_addr_t</span> <span class="n">phys_hdrqtail</span><span class="p">;</span>
		<span class="n">gfp_t</span> <span class="n">gfp_flags</span> <span class="o">=</span> <span class="n">GFP_USER</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrcnt</span> <span class="o">*</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvhdrentsize</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">amt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_phys</span><span class="p">,</span>
			<span class="n">gfp_flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;attempt to allocate %d bytes &quot;</span>
				      <span class="s">&quot;for port %u rcvhdrq failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">amt</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_NODMA_RTAIL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phys_hdrqtail</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;attempt to allocate 1 page &quot;</span>
					<span class="s">&quot;for port %u rcvhdrqtailaddr &quot;</span>
					<span class="s">&quot;failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">amt</span><span class="p">,</span>
					<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">,</span>
					<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_phys</span><span class="p">);</span>
				<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrqtailaddr_phys</span> <span class="o">=</span> <span class="n">phys_hdrqtail</span><span class="p">;</span>
			<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;port %d hdrtailaddr, %llx &quot;</span>
				   <span class="s">&quot;physical</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">phys_hdrqtail</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_size</span> <span class="o">=</span> <span class="n">amt</span><span class="p">;</span>

		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;%d pages at %p (phys %lx) size=%lu &quot;</span>
			   <span class="s">&quot;for port %u rcvhdr Q</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">amt</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_phys</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_size</span><span class="p">,</span>
			   <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;reuse port %d rcvhdrq @%p %llx phys; &quot;</span>
			   <span class="s">&quot;hdrtailaddr@%p %llx physical</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_phys</span><span class="p">,</span>
			   <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			   <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrqtailaddr_phys</span><span class="p">);</span>

	<span class="cm">/* clear for security and sanity on each use */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * tell chip each time we init it, even if we are re-using previous</span>
<span class="cm">	 * memory (we zero the register at process close)</span>
<span class="cm">	 */</span>
	<span class="n">ipath_write_kreg_port</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_rcvhdrtailaddr</span><span class="p">,</span>
			      <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrqtailaddr_phys</span><span class="p">);</span>
	<span class="n">ipath_write_kreg_port</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_rcvhdraddr</span><span class="p">,</span>
			      <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_phys</span><span class="p">);</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Flush all sends that might be in the ready to send state, as well as any</span>
<span class="cm"> * that are in the process of being sent.   Used whenever we need to be</span>
<span class="cm"> * sure the send side is idle.  Cleans up all buffer state by canceling</span>
<span class="cm"> * all pio buffers, and issuing an abort, which cleans up anything in the</span>
<span class="cm"> * launch fifo.  The cancel is superfluous on some chip versions, but</span>
<span class="cm"> * it&#39;s safer to always do it.</span>
<span class="cm"> * PIOAvail bits are updated by the chip as if normal send had happened.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_cancel_sends</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">restore_sendctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_IB_AUTONEG_INPROG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Ignore while in autonegotiation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we have SDMA, and it&#39;s not disabled, we have to kick off the</span>
<span class="cm">	 * abort state machine, provided we aren&#39;t already aborting.</span>
<span class="cm">	 * If we are in the process of aborting SDMA (!DISABLED, but ABORTING),</span>
<span class="cm">	 * we skip the rest of this routine. It is already &quot;in progress&quot;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_HAS_SEND_DMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">skip_cancel</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">statp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_status</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">skip_cancel</span> <span class="o">=</span>
			<span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">IPATH_SDMA_ABORTING</span><span class="p">,</span> <span class="n">statp</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPATH_SDMA_DISABLED</span><span class="p">,</span> <span class="n">statp</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skip_cancel</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Cancelling all in-progress send buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* skip armlaunch errs for a while */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lastcancel</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The abort bit is auto-clearing.  We also don&#39;t want pioavail</span>
<span class="cm">	 * update happening during this, and we don&#39;t want any other</span>
<span class="cm">	 * sends going out, so turn those off for the duration.  We read</span>
<span class="cm">	 * the scratch register to be sure that cancels and the abort</span>
<span class="cm">	 * have taken effect in the chip.  Otherwise two parts are same</span>
<span class="cm">	 * as ipath_force_pio_avail_update()</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">INFINIPATH_S_PIOBUFAVAILUPD</span>
		<span class="o">|</span> <span class="n">INFINIPATH_S_PIOENABLE</span><span class="p">);</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_sendctrl</span><span class="p">,</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">|</span> <span class="n">INFINIPATH_S_ABORT</span><span class="p">);</span>
	<span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_scratch</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* disarm all send buffers */</span>
	<span class="n">ipath_disarm_piobufs</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt2k</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_piobcnt4k</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_HAS_SEND_DMA</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IPATH_SDMA_DISARMED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">restore_sendctrl</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* else done by caller later if needed */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">|=</span> <span class="n">INFINIPATH_S_PIOBUFAVAILUPD</span> <span class="o">|</span>
			<span class="n">INFINIPATH_S_PIOENABLE</span><span class="p">;</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_sendctrl</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span><span class="p">);</span>
		<span class="cm">/* and again, be sure all have hit the chip */</span>
		<span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_scratch</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_HAS_SEND_DMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPATH_SDMA_DISABLED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_status</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">IPATH_SDMA_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* only wait so long for intr */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_abort_intr_timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_reset_wait</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IPATH_SDMA_SHUTDOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_status</span><span class="p">))</span>
			<span class="n">tasklet_hi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_abort_task</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">bail:</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Force an update of in-memory copy of the pioavail registers, when</span>
<span class="cm"> * needed for any of a variety of reasons.  We read the scratch register</span>
<span class="cm"> * to make it highly likely that the update will have happened by the</span>
<span class="cm"> * time we return.  If already off (as in cancel_sends above), this</span>
<span class="cm"> * routine is a nop, on the assumption that the caller will &quot;do the</span>
<span class="cm"> * right thing&quot;.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_force_pio_avail_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_S_PIOBUFAVAILUPD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_sendctrl</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">INFINIPATH_S_PIOBUFAVAILUPD</span><span class="p">);</span>
		<span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_scratch</span><span class="p">);</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_sendctrl</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span><span class="p">);</span>
		<span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_scratch</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_set_ib_lstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">linkcmd</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">linitcmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mod_wd</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">what</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;NOP&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">INFINIPATH_IBCC_LINKCMD_DOWN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;DOWN&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">INFINIPATH_IBCC_LINKCMD_ARMED</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ARMED&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">INFINIPATH_IBCC_LINKCMD_ACTIVE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ACTIVE&quot;</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linitcmd</span> <span class="o">==</span> <span class="n">INFINIPATH_IBCC_LINKINITCMD_DISABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are told to disable, note that so link-recovery</span>
<span class="cm">		 * code does not attempt to bring us back up.</span>
<span class="cm">		 */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">|=</span> <span class="n">IPATH_IB_LINK_DISABLED</span><span class="p">;</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">linitcmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Any other linkinitcmd will lead to LINKDOWN and then</span>
<span class="cm">		 * to INIT (if all is well), so clear flag to let</span>
<span class="cm">		 * link-recovery code attempt to bring us back up.</span>
<span class="cm">		 */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IPATH_IB_LINK_DISABLED</span><span class="p">;</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">mod_wd</span> <span class="o">=</span> <span class="p">(</span><span class="n">linkcmd</span> <span class="o">&lt;&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ibcc_lc_shift</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">linitcmd</span> <span class="o">&lt;&lt;</span> <span class="n">INFINIPATH_IBCC_LINKINITCMD_SHIFT</span><span class="p">);</span>
	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span>
		<span class="s">&quot;Moving unit %u to %s (initcmd=0x%x), current ltstate is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_unit</span><span class="p">,</span> <span class="n">what</span><span class="p">[</span><span class="n">linkcmd</span><span class="p">],</span> <span class="n">linitcmd</span><span class="p">,</span>
		<span class="n">ipath_ibcstatus_str</span><span class="p">[</span><span class="n">ipath_ib_linktrstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span>
			<span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcstatus</span><span class="p">))]);</span>

	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcctrl</span><span class="p">,</span>
			 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span> <span class="o">|</span> <span class="n">mod_wd</span><span class="p">);</span>
	<span class="cm">/* read from chip so write is flushed */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcstatus</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ipath_set_linkstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">newstate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">lstate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">newstate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IPATH_IB_LINKDOWN_ONLY</span>:
		<span class="n">ipath_set_ib_lstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">INFINIPATH_IBCC_LINKCMD_DOWN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* don&#39;t wait */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPATH_IB_LINKDOWN</span>:
		<span class="n">ipath_set_ib_lstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">INFINIPATH_IBCC_LINKCMD_DOWN</span><span class="p">,</span>
					<span class="n">INFINIPATH_IBCC_LINKINITCMD_POLL</span><span class="p">);</span>
		<span class="cm">/* don&#39;t wait */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPATH_IB_LINKDOWN_SLEEP</span>:
		<span class="n">ipath_set_ib_lstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">INFINIPATH_IBCC_LINKCMD_DOWN</span><span class="p">,</span>
					<span class="n">INFINIPATH_IBCC_LINKINITCMD_SLEEP</span><span class="p">);</span>
		<span class="cm">/* don&#39;t wait */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPATH_IB_LINKDOWN_DISABLE</span>:
		<span class="n">ipath_set_ib_lstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">INFINIPATH_IBCC_LINKCMD_DOWN</span><span class="p">,</span>
					<span class="n">INFINIPATH_IBCC_LINKINITCMD_DISABLE</span><span class="p">);</span>
		<span class="cm">/* don&#39;t wait */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPATH_IB_LINKARM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_LINKARMED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span>
		      <span class="p">(</span><span class="n">IPATH_LINKINIT</span> <span class="o">|</span> <span class="n">IPATH_LINKACTIVE</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ipath_set_ib_lstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">INFINIPATH_IBCC_LINKCMD_ARMED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since the port can transition to ACTIVE by receiving</span>
<span class="cm">		 * a non VL 15 packet, wait for either state.</span>
<span class="cm">		 */</span>
		<span class="n">lstate</span> <span class="o">=</span> <span class="n">IPATH_LINKARMED</span> <span class="o">|</span> <span class="n">IPATH_LINKACTIVE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPATH_IB_LINKACTIVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_LINKACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_LINKARMED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ipath_set_ib_lstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">INFINIPATH_IBCC_LINKCMD_ACTIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lstate</span> <span class="o">=</span> <span class="n">IPATH_LINKACTIVE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPATH_IB_LINK_LOOPBACK</span>:
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Enabling IB local loopback</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span> <span class="o">|=</span> <span class="n">INFINIPATH_IBCC_LOOPBACK</span><span class="p">;</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcctrl</span><span class="p">,</span>
				 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span><span class="p">);</span>

		<span class="cm">/* turn heartbeat off, as it causes loopback to fail */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_set_ib_cfg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IPATH_IB_CFG_HRTBT</span><span class="p">,</span>
				       <span class="n">IPATH_IB_HRTBT_OFF</span><span class="p">);</span>
		<span class="cm">/* don&#39;t wait */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPATH_IB_LINK_EXTERNAL</span>:
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Disabling IB local loopback (normal)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_set_ib_cfg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IPATH_IB_CFG_HRTBT</span><span class="p">,</span>
				       <span class="n">IPATH_IB_HRTBT_ON</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INFINIPATH_IBCC_LOOPBACK</span><span class="p">;</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcctrl</span><span class="p">,</span>
				 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span><span class="p">);</span>
		<span class="cm">/* don&#39;t wait */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Heartbeat can be explicitly enabled by the user via</span>
<span class="cm">	 * &quot;hrtbt_enable&quot; &quot;file&quot;, and if disabled, trying to enable here</span>
<span class="cm">	 * will have no effect.  Implicit changes (heartbeat off when</span>
<span class="cm">	 * loopback on, and vice versa) are included to ease testing.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">IPATH_IB_LINK_HRTBT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_set_ib_cfg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IPATH_IB_CFG_HRTBT</span><span class="p">,</span>
			<span class="n">IPATH_IB_HRTBT_ON</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IPATH_IB_LINK_NO_HRTBT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_set_ib_cfg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IPATH_IB_CFG_HRTBT</span><span class="p">,</span>
			<span class="n">IPATH_IB_HRTBT_OFF</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Invalid linkstate 0x%x requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">newstate</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ipath_wait_linkstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">lstate</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_set_mtu - set the MTU</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @arg: the new MTU</span>
<span class="cm"> *</span>
<span class="cm"> * we can handle &quot;any&quot; incoming size, the issue here is whether we</span>
<span class="cm"> * need to restrict our outgoing size.   For now, we don&#39;t do any</span>
<span class="cm"> * sanity checking on this, and we don&#39;t deal with what happens to</span>
<span class="cm"> * programs that are already running when the size changes.</span>
<span class="cm"> * NOTE: changing the MTU will usually cause the IBC to go back to</span>
<span class="cm"> * link INIT state...</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ipath_set_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">piosize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * mtu is IB data payload max.  It&#39;s the largest power of 2 less</span>
<span class="cm">	 * than piosize (or even larger, since it only really controls the</span>
<span class="cm">	 * largest we can receive; we can send the max of the mtu and</span>
<span class="cm">	 * piosize).  We check that it&#39;s one of the valid IB sizes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">!=</span> <span class="mi">256</span> <span class="o">&amp;&amp;</span> <span class="n">arg</span> <span class="o">!=</span> <span class="mi">512</span> <span class="o">&amp;&amp;</span> <span class="n">arg</span> <span class="o">!=</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="n">arg</span> <span class="o">!=</span> <span class="mi">2048</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">arg</span> <span class="o">!=</span> <span class="mi">4096</span> <span class="o">||</span> <span class="o">!</span><span class="n">ipath_mtu4096</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Trying to set invalid mtu %u, failing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmtu</span> <span class="o">==</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="cm">/* same as current */</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">piosize</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmtu</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">piosize</span> <span class="o">-</span> <span class="n">IPATH_PIO_MAXIBHDR</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Only if it&#39;s not the initial value (or reset to it) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piosize</span> <span class="o">!=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_init_ibmaxlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="n">piosize</span> <span class="o">&amp;&amp;</span> <span class="n">arg</span> <span class="o">&lt;=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_init_ibmaxlen</span><span class="p">)</span>
				<span class="n">piosize</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_init_ibmaxlen</span><span class="p">;</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span> <span class="o">=</span> <span class="n">piosize</span><span class="p">;</span>
			<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">+</span> <span class="n">IPATH_PIO_MAXIBHDR</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">piosize</span> <span class="o">=</span> <span class="n">arg</span> <span class="o">+</span> <span class="n">IPATH_PIO_MAXIBHDR</span><span class="p">;</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;ibmaxlen was 0x%x, setting to 0x%x &quot;</span>
			   <span class="s">&quot;(mtu 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span><span class="p">,</span> <span class="n">piosize</span><span class="p">,</span>
			   <span class="n">arg</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span> <span class="o">=</span> <span class="n">piosize</span><span class="p">;</span>
		<span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">ibc</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span><span class="p">,</span> <span class="n">ibdw</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * update our housekeeping variables, and set IBC max</span>
<span class="cm">		 * size, same as init code; max IBC is max we allow in</span>
<span class="cm">		 * buffer, less the qword pbc, plus 1 for ICRC, in dwords</span>
<span class="cm">		 */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span> <span class="o">=</span> <span class="n">piosize</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="n">ibdw</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ibc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">INFINIPATH_IBCC_MAXPKTLEN_MASK</span> <span class="o">&lt;&lt;</span>
			 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ibcc_mpl_shift</span><span class="p">);</span>
		<span class="n">ibc</span> <span class="o">|=</span> <span class="n">ibdw</span> <span class="o">&lt;&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ibcc_mpl_shift</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span> <span class="o">=</span> <span class="n">ibc</span><span class="p">;</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcctrl</span><span class="p">,</span>
				 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibcctrl</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_tidtemplate</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ipath_set_lid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">lmc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lid</span> <span class="o">=</span> <span class="n">lid</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lmc</span> <span class="o">=</span> <span class="n">lmc</span><span class="p">;</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_set_ib_cfg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IPATH_IB_CFG_LIDLMC</span><span class="p">,</span> <span class="n">lid</span> <span class="o">|</span>
		<span class="p">(</span><span class="o">~</span><span class="p">((</span><span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">lmc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;We got a lid: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lid</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * ipath_write_kreg_port - write a device&#39;s per-port 64-bit kernel register</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @regno: the register number to write</span>
<span class="cm"> * @port: the port containing the register</span>
<span class="cm"> * @value: the value to write</span>
<span class="cm"> *</span>
<span class="cm"> * Registers that vary with the chip implementation constants (port)</span>
<span class="cm"> * use this routine.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_write_kreg_port</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">ipath_kreg</span> <span class="n">regno</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="n">port</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">where</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_portcnt</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">regno</span> <span class="o">==</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_rcvhdraddr</span> <span class="o">||</span>
	     <span class="n">regno</span> <span class="o">==</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_rcvhdrtailaddr</span><span class="p">))</span>
		<span class="n">where</span> <span class="o">=</span> <span class="n">regno</span> <span class="o">+</span> <span class="n">port</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">where</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Following deal with the &quot;obviously simple&quot; task of overriding the state</span>
<span class="cm"> * of the LEDS, which normally indicate link physical and logical status.</span>
<span class="cm"> * The complications arise in dealing with different hardware mappings</span>
<span class="cm"> * and the board-dependent routine being called from interrupts.</span>
<span class="cm"> * and then there&#39;s the requirement to _flash_ them.</span>
<span class="cm"> */</span>
<span class="cp">#define LED_OVER_FREQ_SHIFT 8</span>
<span class="cp">#define LED_OVER_FREQ_MASK (0xFF&lt;&lt;LED_OVER_FREQ_SHIFT)</span>
<span class="cm">/* Below is &quot;non-zero&quot; to force override, but both actual LEDs are off */</span>
<span class="cp">#define LED_OVER_BOTH_OFF (8)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_run_led_override</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeoff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pidx</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">lstate</span><span class="p">,</span> <span class="n">ltstate</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_INITTED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pidx</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_phase</span><span class="o">++</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_vals</span><span class="p">[</span><span class="n">pidx</span><span class="p">];</span>
	<span class="n">timeoff</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timeoff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * below potentially restores the LED values per current status,</span>
<span class="cm">	 * should also possibly setup the traffic-blink register,</span>
<span class="cm">	 * but leave that to per-chip functions.</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_ibcstatus</span><span class="p">);</span>
	<span class="n">ltstate</span> <span class="o">=</span> <span class="n">ipath_ib_linktrstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">lstate</span> <span class="o">=</span> <span class="n">ipath_ib_linkstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_setextled</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">lstate</span><span class="p">,</span> <span class="n">ltstate</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeoff</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ipath_set_led_override</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeoff</span><span class="p">,</span> <span class="n">freq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_INITTED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* First check if we are blinking. If not, use 1HZ polling */</span>
	<span class="n">timeoff</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">freq</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">LED_OVER_FREQ_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">LED_OVER_FREQ_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For blink, set each phase from one nybble of val */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">timeoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">HZ</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="n">freq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Non-blink set both phases the same. */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timeoff</span> <span class="o">=</span> <span class="n">timeoff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the timer has not already been started, do so. Use a &quot;quick&quot;</span>
<span class="cm">	 * timeout so the function will be called soon, to look at our request.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer_active</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Need to start timer */</span>
		<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span>
						 <span class="n">ipath_run_led_override</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dd</span><span class="p">;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer_active</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_shutdown_device - shut down a device</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> *</span>
<span class="cm"> * This is called to make the device quiet when we are about to</span>
<span class="cm"> * unload the driver, and also when the device is administratively</span>
<span class="cm"> * disabled.   It does not free any data structures.</span>
<span class="cm"> * Everything it does has to be setup again by ipath_init_chip(dd,1)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_shutdown_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Shutting down the device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ipath_hol_up</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span> <span class="cm">/* make sure user processes aren&#39;t suspended */</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">|=</span> <span class="n">IPATH_LINKUNK</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IPATH_INITTED</span> <span class="o">|</span> <span class="n">IPATH_LINKDOWN</span> <span class="o">|</span>
			     <span class="n">IPATH_LINKINIT</span> <span class="o">|</span> <span class="n">IPATH_LINKARMED</span> <span class="o">|</span>
			     <span class="n">IPATH_LINKACTIVE</span><span class="p">);</span>
	<span class="o">*</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_statusp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IPATH_STATUS_IB_CONF</span> <span class="o">|</span>
				<span class="n">IPATH_STATUS_IB_READY</span><span class="p">);</span>

	<span class="cm">/* mask interrupts, but not errors */</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_intmask</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_rcvctrl</span><span class="p">,</span>
			 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rcvctrl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_HAS_SEND_DMA</span><span class="p">)</span>
		<span class="n">teardown_sdma</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * gracefully stop all sends allowing any in progress to trickle out</span>
<span class="cm">	 * first.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_sendctrl</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl</span><span class="p">);</span>
	<span class="cm">/* flush it */</span>
	<span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_scratch</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sendctrl_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * enough for anything that&#39;s going to trickle out to have actually</span>
<span class="cm">	 * done so.</span>
<span class="cm">	 */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_setextled</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* make sure LEDs are off */</span>

	<span class="n">ipath_set_ib_lstate</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">INFINIPATH_IBCC_LINKINITCMD_DISABLE</span><span class="p">);</span>
	<span class="n">ipath_cancel_sends</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we are shutting down, so tell components that care.  We don&#39;t do</span>
<span class="cm">	 * this on just a link state change, much like ethernet, a cable</span>
<span class="cm">	 * unplug, etc. doesn&#39;t change driver state</span>
<span class="cm">	 */</span>
	<span class="n">signal_ib_event</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">IB_EVENT_PORT_ERR</span><span class="p">);</span>

	<span class="cm">/* disable IBC */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INFINIPATH_C_LINKENABLE</span><span class="p">;</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_control</span><span class="p">,</span>
			 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_control</span> <span class="o">|</span> <span class="n">INFINIPATH_C_FREEZEMODE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * clear SerdesEnable and turn the leds off; do this here because</span>
<span class="cm">	 * we are unloading, so don&#39;t count on interrupts to move along</span>
<span class="cm">	 * Turn the LEDs off explicitly for the same reason.</span>
<span class="cm">	 */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_quiet_serdes</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="cm">/* stop all the timers that might still be running */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_timer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_stats_timer_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_stats_timer</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_stats_timer_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_intrchk_timer</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_intrchk_timer</span><span class="p">);</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_intrchk_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer_active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * clear all interrupts and errors, so that the next time the driver</span>
<span class="cm">	 * is loaded or device is enabled, we know that whatever is set</span>
<span class="cm">	 * happened while we were unloaded</span>
<span class="cm">	 */</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_hwerrclear</span><span class="p">,</span>
			 <span class="o">~</span><span class="mi">0ULL</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">INFINIPATH_HWE_MEMBISTFAILED</span><span class="p">);</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_errorclear</span><span class="p">,</span> <span class="o">-</span><span class="mi">1LL</span><span class="p">);</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_intclear</span><span class="p">,</span> <span class="o">-</span><span class="mi">1LL</span><span class="p">);</span>

	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Flush time and errors to EEPROM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ipath_update_eeprom_log</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_free_pddata - free a port&#39;s allocated data</span>
<span class="cm"> * @dd: the infinipath device</span>
<span class="cm"> * @pd: the portdata structure</span>
<span class="cm"> *</span>
<span class="cm"> * free up any allocated data for a port</span>
<span class="cm"> * This should not touch anything that would affect a simultaneous</span>
<span class="cm"> * re-allocation of port data, because it is called after ipath_mutex</span>
<span class="cm"> * is released (and can be called from reinit as well).</span>
<span class="cm"> * It should never change any chip state, or global driver state.</span>
<span class="cm"> * (The only exception to global state is freeing the port0 port0_skbs.)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_free_pddata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;free closed port %d rcvhdrq @ %p &quot;</span>
			   <span class="s">&quot;(size=%lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_size</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_size</span><span class="p">,</span>
				  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq_phys</span><span class="p">);</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
					 <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">,</span>
					 <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrqtailaddr_phys</span><span class="p">);</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">e</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf_chunks</span><span class="p">;</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf</span><span class="p">[</span><span class="n">e</span><span class="p">];</span>
			<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf_size</span><span class="p">;</span>

			<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;egrbuf free(%p, %lu), &quot;</span>
				   <span class="s">&quot;chunk %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">size</span><span class="p">,</span>
				   <span class="n">e</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf_chunks</span><span class="p">);</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
				<span class="n">base</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf_phys</span><span class="p">[</span><span class="n">e</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf</span><span class="p">);</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf_phys</span><span class="p">);</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf_phys</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvegrbuf_chunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_port0_skbinfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">e</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ipath_skbinfo</span> <span class="o">*</span><span class="n">skbinfo</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_port0_skbinfo</span><span class="p">;</span>

		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_port0_skbinfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;free closed port %d &quot;</span>
			   <span class="s">&quot;ipath_port0_skbinfo @ %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_port</span><span class="p">,</span>
			   <span class="n">skbinfo</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_p0_rcvegrcnt</span><span class="p">;</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skbinfo</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">skbinfo</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">phys</span><span class="p">,</span>
						 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ibmaxlen</span><span class="p">,</span>
						 <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skbinfo</span><span class="p">[</span><span class="n">e</span><span class="p">].</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">skbinfo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_tid_pg_list</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">subport_uregbase</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">subport_rcvegrbuf</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">subport_rcvhdr_base</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">infinipath_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipath_debug</span> <span class="o">&amp;</span> <span class="n">__IPATH_DBG</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">DRIVER_LOAD_MSG</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">ib_ipath_version</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * These must be called before the driver is registered with</span>
<span class="cm">	 * the PCI subsystem.</span>
<span class="cm">	 */</span>
	<span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit_table</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPATH_DRV_NAME</span> <span class="s">&quot;: idr_pre_get() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPATH_DRV_NAME</span>
		       <span class="s">&quot;: Unable to register driver: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail_unit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">ipath_init_ipathfs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">IPATH_DRV_NAME</span> <span class="s">&quot;: Unable to create &quot;</span>
		       <span class="s">&quot;ipathfs: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail_pci</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>

<span class="nl">bail_pci:</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_driver</span><span class="p">);</span>

<span class="nl">bail_unit:</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit_table</span><span class="p">);</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">infinipath_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipath_exit_ipathfs</span><span class="p">();</span>

	<span class="n">ipath_cdbg</span><span class="p">(</span><span class="n">VERBOSE</span><span class="p">,</span> <span class="s">&quot;Unregistering pci driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipath_driver</span><span class="p">);</span>

	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unit_table</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_reset_device - reset the chip if possible</span>
<span class="cm"> * @unit: the device to reset</span>
<span class="cm"> *</span>
<span class="cm"> * Whether or not reset is successful, we attempt to re-initialize the chip</span>
<span class="cm"> * (that is, much like a driver unload/reload).  We clear the INITTED flag</span>
<span class="cm"> * so that the various entry points will fail until we reinitialize.  For</span>
<span class="cm"> * now, we only allow this if no user ports are open that use chip resources</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ipath_reset_device</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">ipath_lookup</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Need to stop LED timer, _then_ shut off LEDs */</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override_timer_active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Shut off LEDs after we are sure timer is not running */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_led_override</span> <span class="o">=</span> <span class="n">LED_OVER_BOTH_OFF</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_setextled</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Reset on unit %u requested</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_PRESENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Invalid unit number %u or &quot;</span>
			 <span class="s">&quot;not initialized or not present</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cfgports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_cnt</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;unit %u port %d is in use &quot;</span>
				  <span class="s">&quot;(PID %u cmd %s), can&#39;t reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">unit</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				  <span class="n">pid_nr</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_pid</span><span class="p">),</span>
				  <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_comm</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_HAS_SEND_DMA</span><span class="p">)</span>
		<span class="n">teardown_sdma</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>

	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IPATH_INITTED</span><span class="p">;</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_intmask</span><span class="p">,</span> <span class="mi">0ULL</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_f_reset</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Reinitializing unit %u after reset attempt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">unit</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ipath_init_chip</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ipath_dev_err</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="s">&quot;Reinitialize unit %u after &quot;</span>
			      <span class="s">&quot;reset failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Reinitialized unit %u after &quot;</span>
			 <span class="s">&quot;resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>

<span class="nl">bail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * send a signal to all the processes that have the driver open</span>
<span class="cm"> * through the normal interfaces (i.e., everything other than diags</span>
<span class="cm"> * interface).  Returns number of signalled processes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ipath_signal_procs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">any</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cfgports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_cnt</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_pid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;context %d in use &quot;</span>
			  <span class="s">&quot;(PID %u), sending signal %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">i</span><span class="p">,</span> <span class="n">pid_nr</span><span class="p">(</span><span class="n">pid</span><span class="p">),</span> <span class="n">sig</span><span class="p">);</span>
		<span class="n">kill_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">any</span><span class="o">++</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">sub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sub</span> <span class="o">&lt;</span> <span class="n">INFINIPATH_MAX_SUBPORT</span><span class="p">;</span> <span class="n">sub</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pid</span> <span class="o">=</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_pd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_subpid</span><span class="p">[</span><span class="n">sub</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sub-context &quot;</span>
				<span class="s">&quot;%d:%d in use (PID %u), sending &quot;</span>
				<span class="s">&quot;signal %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">pid_nr</span><span class="p">(</span><span class="n">pid</span><span class="p">),</span> <span class="n">sig</span><span class="p">);</span>
			<span class="n">kill_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">any</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uctxt_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">any</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_hol_signal_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipath_signal_procs</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">SIGSTOP</span><span class="p">))</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Stopped some processes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ipath_cancel_sends</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">ipath_hol_signal_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipath_signal_procs</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">SIGCONT</span><span class="p">))</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Continued some processes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * link is down, stop any users processes, and flush pending sends</span>
<span class="cm"> * to prevent HoL blocking, then start the HoL timer that</span>
<span class="cm"> * periodically continues, then stop procs, so they can detect</span>
<span class="cm"> * link down if they want, and do something about it.</span>
<span class="cm"> * Timer may already be running, so use mod_timer, not add_timer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_hol_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_state</span> <span class="o">=</span> <span class="n">IPATH_HOL_DOWN</span><span class="p">;</span>
	<span class="n">ipath_hol_signal_down</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_next</span> <span class="o">=</span> <span class="n">IPATH_HOL_DOWNCONT</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
		<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">ipath_hol_timeout_ms</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_timer</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_timer</span><span class="p">.</span><span class="n">expires</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * link is up, continue any user processes, and ensure timer</span>
<span class="cm"> * is a nop, if running.  Let timer keep running, if set; it</span>
<span class="cm"> * will nop when it sees the link is up</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_hol_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ipath_hol_signal_up</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_state</span> <span class="o">=</span> <span class="n">IPATH_HOL_UP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * toggle the running/not running state of user proceses</span>
<span class="cm"> * to prevent HoL blocking on chip resources, but still allow</span>
<span class="cm"> * user processes to do link down special case handling.</span>
<span class="cm"> * Should only be called via the timer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_hol_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">)</span><span class="n">opaque</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_next</span> <span class="o">==</span> <span class="n">IPATH_HOL_DOWNSTOP</span>
		<span class="o">&amp;&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_state</span> <span class="o">!=</span> <span class="n">IPATH_HOL_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_next</span> <span class="o">=</span> <span class="n">IPATH_HOL_DOWNCONT</span><span class="p">;</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Stopping processes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ipath_hol_signal_down</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* may do &quot;extra&quot; if also in ipath_hol_up() */</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_next</span> <span class="o">=</span> <span class="n">IPATH_HOL_DOWNSTOP</span><span class="p">;</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;Continuing processes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ipath_hol_signal_up</span><span class="p">(</span><span class="n">dd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_state</span> <span class="o">==</span> <span class="n">IPATH_HOL_UP</span><span class="p">)</span>
		<span class="n">ipath_dbg</span><span class="p">(</span><span class="s">&quot;link&#39;s up, don&#39;t resched timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span>
			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">ipath_hol_timeout_ms</span><span class="p">);</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_timer</span><span class="p">,</span>
			<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_hol_timer</span><span class="p">.</span><span class="n">expires</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ipath_set_rx_pol_inv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_pol_inv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_pol_inv</span> <span class="o">&gt;</span> <span class="n">INFINIPATH_XGXS_RX_POL_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rx_pol_inv</span> <span class="o">!=</span> <span class="n">new_pol_inv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rx_pol_inv</span> <span class="o">=</span> <span class="n">new_pol_inv</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_xgxsconfig</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">INFINIPATH_XGXS_RX_POL_MASK</span> <span class="o">&lt;&lt;</span>
			 <span class="n">INFINIPATH_XGXS_RX_POL_SHIFT</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rx_pol_inv</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			<span class="n">INFINIPATH_XGXS_RX_POL_SHIFT</span><span class="p">;</span>
		<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_xgxsconfig</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Disable and enable the armlaunch error.  Used for PIO bandwidth testing on</span>
<span class="cm"> * the 7220, which is count-based, rather than trigger-based.  Safe for the</span>
<span class="cm"> * driver check, since it&#39;s at init.   Not completely safe when used for</span>
<span class="cm"> * user-mode checking, since some error checking can be lost, but not</span>
<span class="cm"> * particularly risky, and only has problematic side-effects in the face of</span>
<span class="cm"> * very buggy user code.  There is no reference counting, but that&#39;s also</span>
<span class="cm"> * fine, given the intended use.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ipath_enable_armlaunch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_lasterror</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INFINIPATH_E_SPIOARMLAUNCH</span><span class="p">;</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_errorclear</span><span class="p">,</span>
		<span class="n">INFINIPATH_E_SPIOARMLAUNCH</span><span class="p">);</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_errormask</span> <span class="o">|=</span> <span class="n">INFINIPATH_E_SPIOARMLAUNCH</span><span class="p">;</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_errormask</span><span class="p">,</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_errormask</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ipath_disable_armlaunch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* so don&#39;t re-enable if already set */</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_maskederrs</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INFINIPATH_E_SPIOARMLAUNCH</span><span class="p">;</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_errormask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INFINIPATH_E_SPIOARMLAUNCH</span><span class="p">;</span>
	<span class="n">ipath_write_kreg</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregs</span><span class="o">-&gt;</span><span class="n">kr_errormask</span><span class="p">,</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_errormask</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">infinipath_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">infinipath_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
