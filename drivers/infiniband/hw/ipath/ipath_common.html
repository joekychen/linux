<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › ipath › ipath_common.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ipath_common.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, 2007, 2008 QLogic Corporation. All rights reserved.</span>
<span class="cm"> * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _IPATH_COMMON_H</span>
<span class="cp">#define _IPATH_COMMON_H</span>

<span class="cm">/*</span>
<span class="cm"> * This file contains defines, structures, etc. that are used</span>
<span class="cm"> * to communicate between kernel and user code.</span>
<span class="cm"> */</span>


<span class="cm">/* This is the IEEE-assigned OUI for QLogic Inc. InfiniPath */</span>
<span class="cp">#define IPATH_SRC_OUI_1 0x00</span>
<span class="cp">#define IPATH_SRC_OUI_2 0x11</span>
<span class="cp">#define IPATH_SRC_OUI_3 0x75</span>

<span class="cm">/* version of protocol header (known to chip also). In the long run,</span>
<span class="cm"> * we should be able to generate and accept a range of version numbers;</span>
<span class="cm"> * for now we only accept one, and it&#39;s compiled in.</span>
<span class="cm"> */</span>
<span class="cp">#define IPS_PROTO_VERSION 2</span>

<span class="cm">/*</span>
<span class="cm"> * These are compile time constants that you may want to enable or disable</span>
<span class="cm"> * if you are trying to debug problems with code or performance.</span>
<span class="cm"> * IPATH_VERBOSE_TRACING define as 1 if you want additional tracing in</span>
<span class="cm"> * fastpath code</span>
<span class="cm"> * IPATH_TRACE_REGWRITES define as 1 if you want register writes to be</span>
<span class="cm"> * traced in faspath code</span>
<span class="cm"> * _IPATH_TRACING define as 0 if you want to remove all tracing in a</span>
<span class="cm"> * compilation unit</span>
<span class="cm"> * _IPATH_DEBUGGING define as 0 if you want to remove debug prints</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The value in the BTH QP field that InfiniPath uses to differentiate</span>
<span class="cm"> * an infinipath protocol IB packet vs standard IB transport</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_KD_QP 0x656b79</span>

<span class="cm">/*</span>
<span class="cm"> * valid states passed to ipath_set_linkstate() user call</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_IB_LINKDOWN		0</span>
<span class="cp">#define IPATH_IB_LINKARM		1</span>
<span class="cp">#define IPATH_IB_LINKACTIVE		2</span>
<span class="cp">#define IPATH_IB_LINKDOWN_ONLY		3</span>
<span class="cp">#define IPATH_IB_LINKDOWN_SLEEP		4</span>
<span class="cp">#define IPATH_IB_LINKDOWN_DISABLE	5</span>
<span class="cp">#define IPATH_IB_LINK_LOOPBACK	6 </span><span class="cm">/* enable local loopback */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_LINK_EXTERNAL	7 </span><span class="cm">/* normal, disable local loopback */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_LINK_NO_HRTBT	8 </span><span class="cm">/* disable Heartbeat, e.g. for loopback */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_LINK_HRTBT	9 </span><span class="cm">/* enable heartbeat, normal, non-loopback */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * These 3 values (SDR and DDR may be ORed for auto-speed</span>
<span class="cm"> * negotiation) are used for the 3rd argument to path_f_set_ib_cfg</span>
<span class="cm"> * with cmd IPATH_IB_CFG_SPD_ENB, by direct calls or via sysfs.  They</span>
<span class="cm"> * are also the the possible values for ipath_link_speed_enabled and active</span>
<span class="cm"> * The values were chosen to match values used within the IB spec.</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_IB_SDR 1</span>
<span class="cp">#define IPATH_IB_DDR 2</span>

<span class="cm">/*</span>
<span class="cm"> * stats maintained by the driver.  For now, at least, this is global</span>
<span class="cm"> * to all minor devices.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">infinipath_stats</span> <span class="p">{</span>
	<span class="cm">/* number of interrupts taken */</span>
	<span class="n">__u64</span> <span class="n">sps_ints</span><span class="p">;</span>
	<span class="cm">/* number of interrupts for errors */</span>
	<span class="n">__u64</span> <span class="n">sps_errints</span><span class="p">;</span>
	<span class="cm">/* number of errors from chip (not incl. packet errors or CRC) */</span>
	<span class="n">__u64</span> <span class="n">sps_errs</span><span class="p">;</span>
	<span class="cm">/* number of packet errors from chip other than CRC */</span>
	<span class="n">__u64</span> <span class="n">sps_pkterrs</span><span class="p">;</span>
	<span class="cm">/* number of packets with CRC errors (ICRC and VCRC) */</span>
	<span class="n">__u64</span> <span class="n">sps_crcerrs</span><span class="p">;</span>
	<span class="cm">/* number of hardware errors reported (parity, etc.) */</span>
	<span class="n">__u64</span> <span class="n">sps_hwerrs</span><span class="p">;</span>
	<span class="cm">/* number of times IB link changed state unexpectedly */</span>
	<span class="n">__u64</span> <span class="n">sps_iblink</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">sps_unused</span><span class="p">;</span> <span class="cm">/* was fastrcvint, no longer implemented */</span>
	<span class="cm">/* number of kernel (port0) packets received */</span>
	<span class="n">__u64</span> <span class="n">sps_port0pkts</span><span class="p">;</span>
	<span class="cm">/* number of &quot;ethernet&quot; packets sent by driver */</span>
	<span class="n">__u64</span> <span class="n">sps_ether_spkts</span><span class="p">;</span>
	<span class="cm">/* number of &quot;ethernet&quot; packets received by driver */</span>
	<span class="n">__u64</span> <span class="n">sps_ether_rpkts</span><span class="p">;</span>
	<span class="cm">/* number of SMA packets sent by driver. Obsolete. */</span>
	<span class="n">__u64</span> <span class="n">sps_sma_spkts</span><span class="p">;</span>
	<span class="cm">/* number of SMA packets received by driver. Obsolete. */</span>
	<span class="n">__u64</span> <span class="n">sps_sma_rpkts</span><span class="p">;</span>
	<span class="cm">/* number of times all ports rcvhdrq was full and packet dropped */</span>
	<span class="n">__u64</span> <span class="n">sps_hdrqfull</span><span class="p">;</span>
	<span class="cm">/* number of times all ports egrtid was full and packet dropped */</span>
	<span class="n">__u64</span> <span class="n">sps_etidfull</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * number of times we tried to send from driver, but no pio buffers</span>
<span class="cm">	 * avail</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">sps_nopiobufs</span><span class="p">;</span>
	<span class="cm">/* number of ports currently open */</span>
	<span class="n">__u64</span> <span class="n">sps_ports</span><span class="p">;</span>
	<span class="cm">/* list of pkeys (other than default) accepted (0 means not set) */</span>
	<span class="n">__u16</span> <span class="n">sps_pkeys</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__u16</span> <span class="n">sps_unused16</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* available; maintaining compatible layout */</span>
	<span class="cm">/* number of user ports per chip (not IB ports) */</span>
	<span class="n">__u32</span> <span class="n">sps_nports</span><span class="p">;</span>
	<span class="cm">/* not our interrupt, or already handled */</span>
	<span class="n">__u32</span> <span class="n">sps_nullintr</span><span class="p">;</span>
	<span class="cm">/* max number of packets handled per receive call */</span>
	<span class="n">__u32</span> <span class="n">sps_maxpkts_call</span><span class="p">;</span>
	<span class="cm">/* avg number of packets handled per receive call */</span>
	<span class="n">__u32</span> <span class="n">sps_avgpkts_call</span><span class="p">;</span>
	<span class="cm">/* total number of pages locked */</span>
	<span class="n">__u64</span> <span class="n">sps_pagelocks</span><span class="p">;</span>
	<span class="cm">/* total number of pages unlocked */</span>
	<span class="n">__u64</span> <span class="n">sps_pageunlocks</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Number of packets dropped in kernel other than errors (ether</span>
<span class="cm">	 * packets if ipath not configured, etc.)</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">sps_krdrops</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">sps_txeparity</span><span class="p">;</span> <span class="cm">/* PIO buffer parity error, recovered */</span>
	<span class="cm">/* pad for future growth */</span>
	<span class="n">__u64</span> <span class="n">__sps_pad</span><span class="p">[</span><span class="mi">45</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * These are the status bits readable (in ascii form, 64bit value)</span>
<span class="cm"> * from the &quot;status&quot; sysfs file.</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_STATUS_INITTED       0x1	</span><span class="cm">/* basic initialization done */</span><span class="cp"></span>
<span class="cp">#define IPATH_STATUS_DISABLED      0x2	</span><span class="cm">/* hardware disabled */</span><span class="cp"></span>
<span class="cm">/* Device has been disabled via admin request */</span>
<span class="cp">#define IPATH_STATUS_ADMIN_DISABLED    0x4</span>
<span class="cm">/* Chip has been found and initted */</span>
<span class="cp">#define IPATH_STATUS_CHIP_PRESENT 0x20</span>
<span class="cm">/* IB link is at ACTIVE, usable for data traffic */</span>
<span class="cp">#define IPATH_STATUS_IB_READY     0x40</span>
<span class="cm">/* link is configured, LID, MTU, etc. have been set */</span>
<span class="cp">#define IPATH_STATUS_IB_CONF      0x80</span>
<span class="cm">/* no link established, probably no cable */</span>
<span class="cp">#define IPATH_STATUS_IB_NOCABLE  0x100</span>
<span class="cm">/* A Fatal hardware error has occurred. */</span>
<span class="cp">#define IPATH_STATUS_HWERROR     0x200</span>

<span class="cm">/*</span>
<span class="cm"> * The list of usermode accessible registers.  Also see Reg_* later in file.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_ipath_ureg</span> <span class="p">{</span>
	<span class="cm">/* (RO)  DMA RcvHdr to be used next. */</span>
	<span class="n">ur_rcvhdrtail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* (RW)  RcvHdr entry to be processed next by host. */</span>
	<span class="n">ur_rcvhdrhead</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="cm">/* (RO)  Index of next Eager index to use. */</span>
	<span class="n">ur_rcvegrindextail</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="cm">/* (RW)  Eager TID to be processed next */</span>
	<span class="n">ur_rcvegrindexhead</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="cm">/* For internal use only; max register number. */</span>
	<span class="n">_IPATH_UregMax</span>
<span class="p">}</span> <span class="n">ipath_ureg</span><span class="p">;</span>

<span class="cm">/* bit values for spi_runtime_flags */</span>
<span class="cp">#define IPATH_RUNTIME_HT	0x1</span>
<span class="cp">#define IPATH_RUNTIME_PCIE	0x2</span>
<span class="cp">#define IPATH_RUNTIME_FORCE_WC_ORDER	0x4</span>
<span class="cp">#define IPATH_RUNTIME_RCVHDR_COPY	0x8</span>
<span class="cp">#define IPATH_RUNTIME_MASTER	0x10</span>
<span class="cp">#define IPATH_RUNTIME_NODMA_RTAIL 0x80</span>
<span class="cp">#define IPATH_RUNTIME_SDMA	      0x200</span>
<span class="cp">#define IPATH_RUNTIME_FORCE_PIOAVAIL 0x400</span>
<span class="cp">#define IPATH_RUNTIME_PIO_REGSWAPPED 0x800</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is returned by ipath_userinit() immediately after</span>
<span class="cm"> * open to get implementation-specific info, and info specific to this</span>
<span class="cm"> * instance.</span>
<span class="cm"> *</span>
<span class="cm"> * This struct must have explict pad fields where type sizes</span>
<span class="cm"> * may result in different alignments between 32 and 64 bit</span>
<span class="cm"> * programs, since the 64 bit * bit kernel requires the user code</span>
<span class="cm"> * to have matching offsets</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipath_base_info</span> <span class="p">{</span>
	<span class="cm">/* version of hardware, for feature checking. */</span>
	<span class="n">__u32</span> <span class="n">spi_hw_version</span><span class="p">;</span>
	<span class="cm">/* version of software, for feature checking. */</span>
	<span class="n">__u32</span> <span class="n">spi_sw_version</span><span class="p">;</span>
	<span class="cm">/* InfiniPath port assigned, goes into sent packets */</span>
	<span class="n">__u16</span> <span class="n">spi_port</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">spi_subport</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * IB MTU, packets IB data must be less than this.</span>
<span class="cm">	 * The MTU is in bytes, and will be a multiple of 4 bytes.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_mtu</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Size of a PIO buffer.  Any given packet&#39;s total size must be less</span>
<span class="cm">	 * than this (in words).  Included is the starting control word, so</span>
<span class="cm">	 * if 513 is returned, then total pkt size is 512 words or less.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_piosize</span><span class="p">;</span>
	<span class="cm">/* size of the TID cache in infinipath, in entries */</span>
	<span class="n">__u32</span> <span class="n">spi_tidcnt</span><span class="p">;</span>
	<span class="cm">/* size of the TID Eager list in infinipath, in entries */</span>
	<span class="n">__u32</span> <span class="n">spi_tidegrcnt</span><span class="p">;</span>
	<span class="cm">/* size of a single receive header queue entry in words. */</span>
	<span class="n">__u32</span> <span class="n">spi_rcvhdrent_size</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Count of receive header queue entries allocated.</span>
<span class="cm">	 * This may be less than the spu_rcvhdrcnt passed in!.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_rcvhdr_cnt</span><span class="p">;</span>

	<span class="cm">/* per-chip and other runtime features bitmap (IPATH_RUNTIME_*) */</span>
	<span class="n">__u32</span> <span class="n">spi_runtime_flags</span><span class="p">;</span>

	<span class="cm">/* address where receive buffer queue is mapped into */</span>
	<span class="n">__u64</span> <span class="n">spi_rcvhdr_base</span><span class="p">;</span>

	<span class="cm">/* user program. */</span>

	<span class="cm">/* base address of eager TID receive buffers. */</span>
	<span class="n">__u64</span> <span class="n">spi_rcv_egrbufs</span><span class="p">;</span>

	<span class="cm">/* Allocated by initialization code, not by protocol. */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Size of each TID buffer in host memory, starting at</span>
<span class="cm">	 * spi_rcv_egrbufs.  The buffers are virtually contiguous.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_rcv_egrbufsize</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The special QP (queue pair) value that identifies an infinipath</span>
<span class="cm">	 * protocol packet from standard IB packets.  More, probably much</span>
<span class="cm">	 * more, to be added.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_qpair</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * User register base for init code, not to be used directly by</span>
<span class="cm">	 * protocol or applications.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">__spi_uregbase</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Maximum buffer size in bytes that can be used in a single TID</span>
<span class="cm">	 * entry (assuming the buffer is aligned to this boundary).  This is</span>
<span class="cm">	 * the minimum of what the hardware and software support Guaranteed</span>
<span class="cm">	 * to be a power of 2.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_tid_maxsize</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * alignment of each pio send buffer (byte count</span>
<span class="cm">	 * to add to spi_piobufbase to get to second buffer)</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_pioalign</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The index of the first pio buffer available to this process;</span>
<span class="cm">	 * needed to do lookup in spi_pioavailaddr; not added to</span>
<span class="cm">	 * spi_piobufbase.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spi_pioindex</span><span class="p">;</span>
	 <span class="cm">/* number of buffers mapped for this process */</span>
	<span class="n">__u32</span> <span class="n">spi_piocnt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Base address of writeonly pio buffers for this process.</span>
<span class="cm">	 * Each buffer has spi_piosize words, and is aligned on spi_pioalign</span>
<span class="cm">	 * boundaries.  spi_piocnt buffers are mapped from this address</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spi_piobufbase</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Base address of readonly memory copy of the pioavail registers.</span>
<span class="cm">	 * There are 2 bits for each buffer.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spi_pioavailaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Address where driver updates a copy of the interface and driver</span>
<span class="cm">	 * status (IPATH_STATUS_*) as a 64 bit value.  It&#39;s followed by a</span>
<span class="cm">	 * string indicating hardware error, if there was one.</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spi_status</span><span class="p">;</span>

	<span class="cm">/* number of chip ports available to user processes */</span>
	<span class="n">__u32</span> <span class="n">spi_nports</span><span class="p">;</span>
	<span class="cm">/* unit number of chip we are using */</span>
	<span class="n">__u32</span> <span class="n">spi_unit</span><span class="p">;</span>
	<span class="cm">/* num bufs in each contiguous set */</span>
	<span class="n">__u32</span> <span class="n">spi_rcv_egrperchunk</span><span class="p">;</span>
	<span class="cm">/* size in bytes of each contiguous set */</span>
	<span class="n">__u32</span> <span class="n">spi_rcv_egrchunksize</span><span class="p">;</span>
	<span class="cm">/* total size of mmap to cover full rcvegrbuffers */</span>
	<span class="n">__u32</span> <span class="n">spi_rcv_egrbuftotlen</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">spi_filler_for_align</span><span class="p">;</span>
	<span class="cm">/* address of readonly memory copy of the rcvhdrq tail register. */</span>
	<span class="n">__u64</span> <span class="n">spi_rcvhdr_tailaddr</span><span class="p">;</span>

	<span class="cm">/* shared memory pages for subports if port is shared */</span>
	<span class="n">__u64</span> <span class="n">spi_subport_uregbase</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">spi_subport_rcvegrbuf</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">spi_subport_rcvhdr_base</span><span class="p">;</span>

	<span class="cm">/* shared memory page for hardware port if it is shared */</span>
	<span class="n">__u64</span> <span class="n">spi_port_uregbase</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">spi_port_rcvegrbuf</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">spi_port_rcvhdr_base</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">spi_port_rcvhdr_tailaddr</span><span class="p">;</span>

<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>


<span class="cm">/*</span>
<span class="cm"> * This version number is given to the driver by the user code during</span>
<span class="cm"> * initialization in the spu_userversion field of ipath_user_info, so</span>
<span class="cm"> * the driver can check for compatibility with user code.</span>
<span class="cm"> *</span>
<span class="cm"> * The major version changes when data structures</span>
<span class="cm"> * change in an incompatible way.  The driver must be the same or higher</span>
<span class="cm"> * for initialization to succeed.  In some cases, a higher version</span>
<span class="cm"> * driver will not interoperate with older software, and initialization</span>
<span class="cm"> * will return an error.</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_USER_SWMAJOR 1</span>

<span class="cm">/*</span>
<span class="cm"> * Minor version differences are always compatible</span>
<span class="cm"> * a within a major version, however if user software is larger</span>
<span class="cm"> * than driver software, some new features and/or structure fields</span>
<span class="cm"> * may not be implemented; the user code must deal with this if it</span>
<span class="cm"> * cares, or it must abort after initialization reports the difference.</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_USER_SWMINOR 6</span>

<span class="cp">#define IPATH_USER_SWVERSION ((IPATH_USER_SWMAJOR&lt;&lt;16) | IPATH_USER_SWMINOR)</span>

<span class="cp">#define IPATH_KERN_TYPE 0</span>

<span class="cm">/*</span>
<span class="cm"> * Similarly, this is the kernel version going back to the user.  It&#39;s</span>
<span class="cm"> * slightly different, in that we want to tell if the driver was built as</span>
<span class="cm"> * part of a QLogic release, or from the driver from openfabrics.org,</span>
<span class="cm"> * kernel.org, or a standard distribution, for support reasons.</span>
<span class="cm"> * The high bit is 0 for non-QLogic and 1 for QLogic-built/supplied.</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s returned by the driver to the user code during initialization in the</span>
<span class="cm"> * spi_sw_version field of ipath_base_info, so the user code can in turn</span>
<span class="cm"> * check for compatibility with the kernel.</span>
<span class="cm">*/</span>
<span class="cp">#define IPATH_KERN_SWVERSION ((IPATH_KERN_TYPE&lt;&lt;31) | IPATH_USER_SWVERSION)</span>

<span class="cm">/*</span>
<span class="cm"> * This structure is passed to ipath_userinit() to tell the driver where</span>
<span class="cm"> * user code buffers are, sizes, etc.   The offsets and sizes of the</span>
<span class="cm"> * fields must remain unchanged, for binary compatibility.  It can</span>
<span class="cm"> * be extended, if userversion is changed so user code can tell, if needed</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipath_user_info</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * version of user software, to detect compatibility issues.</span>
<span class="cm">	 * Should be set to IPATH_USER_SWVERSION.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spu_userversion</span><span class="p">;</span>

	<span class="cm">/* desired number of receive header queue entries */</span>
	<span class="n">__u32</span> <span class="n">spu_rcvhdrcnt</span><span class="p">;</span>

	<span class="cm">/* size of struct base_info to write to */</span>
	<span class="n">__u32</span> <span class="n">spu_base_info_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * number of words in KD protocol header</span>
<span class="cm">	 * This tells InfiniPath how many words to copy to rcvhdrq.  If 0,</span>
<span class="cm">	 * kernel uses a default.  Once set, attempts to set any other value</span>
<span class="cm">	 * are an error (EAGAIN) until driver is reloaded.</span>
<span class="cm">	 */</span>
	<span class="n">__u32</span> <span class="n">spu_rcvhdrsize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If two or more processes wish to share a port, each process</span>
<span class="cm">	 * must set the spu_subport_cnt and spu_subport_id to the same</span>
<span class="cm">	 * values.  The only restriction on the spu_subport_id is that</span>
<span class="cm">	 * it be unique for a given node.</span>
<span class="cm">	 */</span>
	<span class="n">__u16</span> <span class="n">spu_subport_cnt</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">spu_subport_id</span><span class="p">;</span>

	<span class="n">__u32</span> <span class="n">spu_unused</span><span class="p">;</span> <span class="cm">/* kept for compatible layout */</span>

	<span class="cm">/*</span>
<span class="cm">	 * address of struct base_info to write to</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">spu_base_info</span><span class="p">;</span>

<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cm">/* User commands. */</span>

<span class="cp">#define IPATH_CMD_MIN		16</span>

<span class="cp">#define __IPATH_CMD_USER_INIT	16	</span><span class="cm">/* old set up userspace (for old user code) */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_PORT_INFO	17	</span><span class="cm">/* find out what resources we got */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_RECV_CTRL	18	</span><span class="cm">/* control receipt of packets */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_TID_UPDATE	19	</span><span class="cm">/* update expected TID entries */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_TID_FREE	20	</span><span class="cm">/* free expected TID entries */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_SET_PART_KEY	21	</span><span class="cm">/* add partition key */</span><span class="cp"></span>
<span class="cp">#define __IPATH_CMD_SLAVE_INFO	22	</span><span class="cm">/* return info on slave processes (for old user code) */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_ASSIGN_PORT	23	</span><span class="cm">/* allocate HCA and port */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_USER_INIT 	24	</span><span class="cm">/* set up userspace */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_UNUSED_1	25</span>
<span class="cp">#define IPATH_CMD_UNUSED_2	26</span>
<span class="cp">#define IPATH_CMD_PIOAVAILUPD	27	</span><span class="cm">/* force an update of PIOAvail reg */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_POLL_TYPE	28	</span><span class="cm">/* set the kind of polling we want */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_ARMLAUNCH_CTRL	29 </span><span class="cm">/* armlaunch detection control */</span><span class="cp"></span>
<span class="cm">/* 30 is unused */</span>
<span class="cp">#define IPATH_CMD_SDMA_INFLIGHT 31	</span><span class="cm">/* sdma inflight counter request */</span><span class="cp"></span>
<span class="cp">#define IPATH_CMD_SDMA_COMPLETE 32	</span><span class="cm">/* sdma completion counter request */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Poll types</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_POLL_TYPE_URGENT	 0x01</span>
<span class="cp">#define IPATH_POLL_TYPE_OVERFLOW 0x02</span>

<span class="k">struct</span> <span class="n">ipath_port_info</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">num_active</span><span class="p">;</span>	<span class="cm">/* number of active units */</span>
	<span class="n">__u32</span> <span class="n">unit</span><span class="p">;</span>		<span class="cm">/* unit (chip) assigned to caller */</span>
	<span class="n">__u16</span> <span class="n">port</span><span class="p">;</span>		<span class="cm">/* port on unit assigned to caller */</span>
	<span class="n">__u16</span> <span class="n">subport</span><span class="p">;</span>		<span class="cm">/* subport on unit assigned to caller */</span>
	<span class="n">__u16</span> <span class="n">num_ports</span><span class="p">;</span>	<span class="cm">/* number of ports available on unit */</span>
	<span class="n">__u16</span> <span class="n">num_subports</span><span class="p">;</span>	<span class="cm">/* number of subports opened on port */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipath_tid_info</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">tidcnt</span><span class="p">;</span>
	<span class="cm">/* make structure same size in 32 and 64 bit */</span>
	<span class="n">__u32</span> <span class="n">tid__unused</span><span class="p">;</span>
	<span class="cm">/* virtual address of first page in transfer */</span>
	<span class="n">__u64</span> <span class="n">tidvaddr</span><span class="p">;</span>
	<span class="cm">/* pointer (same size 32/64 bit) to __u16 tid array */</span>
	<span class="n">__u64</span> <span class="n">tidlist</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * pointer (same size 32/64 bit) to bitmap of TIDs used</span>
<span class="cm">	 * for this call; checked for being large enough at open</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">tidmap</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipath_cmd</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>			<span class="cm">/* command type */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ipath_tid_info</span> <span class="n">tid_info</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ipath_user_info</span> <span class="n">user_info</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * address in userspace where we should put the sdma</span>
<span class="cm">		 * inflight counter</span>
<span class="cm">		 */</span>
		<span class="n">__u64</span> <span class="n">sdma_inflight</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * address in userspace where we should put the sdma</span>
<span class="cm">		 * completion counter</span>
<span class="cm">		 */</span>
		<span class="n">__u64</span> <span class="n">sdma_complete</span><span class="p">;</span>
		<span class="cm">/* address in userspace of struct ipath_port_info to</span>
<span class="cm">		   write result to */</span>
		<span class="n">__u64</span> <span class="n">port_info</span><span class="p">;</span>
		<span class="cm">/* enable/disable receipt of packets */</span>
		<span class="n">__u32</span> <span class="n">recv_ctrl</span><span class="p">;</span>
		<span class="cm">/* enable/disable armlaunch errors (non-zero to enable) */</span>
		<span class="n">__u32</span> <span class="n">armlaunch_ctrl</span><span class="p">;</span>
		<span class="cm">/* partition key to set */</span>
		<span class="n">__u16</span> <span class="n">part_key</span><span class="p">;</span>
		<span class="cm">/* user address of __u32 bitmask of active slaves */</span>
		<span class="n">__u64</span> <span class="n">slave_mask_addr</span><span class="p">;</span>
		<span class="cm">/* type of polling we want */</span>
		<span class="n">__u16</span> <span class="n">poll_type</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">cmd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipath_iovec</span> <span class="p">{</span>
	<span class="cm">/* Pointer to data, but same size 32 and 64 bit */</span>
	<span class="n">__u64</span> <span class="n">iov_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Length of data; don&#39;t need 64 bits, but want</span>
<span class="cm">	 * ipath_sendpkt to remain same size as before 32 bit changes, so...</span>
<span class="cm">	 */</span>
	<span class="n">__u64</span> <span class="n">iov_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Describes a single packet for send.  Each packet can have one or more</span>
<span class="cm"> * buffers, but the total length (exclusive of IB headers) must be less</span>
<span class="cm"> * than the MTU, and if using the PIO method, entire packet length,</span>
<span class="cm"> * including IB headers, must be less than the ipath_piosize value (words).</span>
<span class="cm"> * Use of this necessitates including sys/uio.h</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__ipath_sendpkt</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">sps_flags</span><span class="p">;</span>	<span class="cm">/* flags for packet (TBD) */</span>
	<span class="n">__u32</span> <span class="n">sps_cnt</span><span class="p">;</span>		<span class="cm">/* number of entries to use in sps_iov */</span>
	<span class="cm">/* array of iov&#39;s describing packet. TEMPORARY */</span>
	<span class="k">struct</span> <span class="n">ipath_iovec</span> <span class="n">sps_iov</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * diagnostics can send a packet by &quot;writing&quot; one of the following</span>
<span class="cm"> * two structs to diag data special file</span>
<span class="cm"> * The first is the legacy version for backward compatibility</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipath_diag_pkt</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">unit</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* The second diag_pkt struct is the expanded version that allows</span>
<span class="cm"> * more control over the packet, specifically, by allowing a custom</span>
<span class="cm"> * pbc (+ static rate) qword, so that special modes and deliberate</span>
<span class="cm"> * changes to CRCs can be used. The elements were also re-ordered</span>
<span class="cm"> * for better alignment and to avoid padding issues.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipath_diag_xpkt</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">pbc_wd</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">unit</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Data layout in I2C flash (for GUID, etc.)</span>
<span class="cm"> * All fields are little-endian binary unless otherwise stated</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_FLASH_VERSION 2</span>
<span class="k">struct</span> <span class="n">ipath_flash</span> <span class="p">{</span>
	<span class="cm">/* flash layout version (IPATH_FLASH_VERSION) */</span>
	<span class="n">__u8</span> <span class="n">if_fversion</span><span class="p">;</span>
	<span class="cm">/* checksum protecting if_length bytes */</span>
	<span class="n">__u8</span> <span class="n">if_csum</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * valid length (in use, protected by if_csum), including</span>
<span class="cm">	 * if_fversion and if_csum themselves)</span>
<span class="cm">	 */</span>
	<span class="n">__u8</span> <span class="n">if_length</span><span class="p">;</span>
	<span class="cm">/* the GUID, in network order */</span>
	<span class="n">__u8</span> <span class="n">if_guid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* number of GUIDs to use, starting from if_guid */</span>
	<span class="n">__u8</span> <span class="n">if_numguid</span><span class="p">;</span>
	<span class="cm">/* the (last 10 characters of) board serial number, in ASCII */</span>
	<span class="kt">char</span> <span class="n">if_serial</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="cm">/* board mfg date (YYYYMMDD ASCII) */</span>
	<span class="kt">char</span> <span class="n">if_mfgdate</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* last board rework/test date (YYYYMMDD ASCII) */</span>
	<span class="kt">char</span> <span class="n">if_testdate</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* logging of error counts, TBD */</span>
	<span class="n">__u8</span> <span class="n">if_errcntp</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* powered on hours, updated at driver unload */</span>
	<span class="n">__u8</span> <span class="n">if_powerhour</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="cm">/* ASCII free-form comment field */</span>
	<span class="kt">char</span> <span class="n">if_comment</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="cm">/* Backwards compatible prefix for longer QLogic Serial Numbers */</span>
	<span class="kt">char</span> <span class="n">if_sprefix</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* 82 bytes used, min flash size is 128 bytes */</span>
	<span class="n">__u8</span> <span class="n">if_future</span><span class="p">[</span><span class="mi">46</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * These are the counters implemented in the chip, and are listed in order.</span>
<span class="cm"> * The InterCaps naming is taken straight from the chip spec.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">infinipath_counters</span> <span class="p">{</span>
	<span class="n">__u64</span> <span class="n">LBIntCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">LBFlowStallCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxSDmaDescCnt</span><span class="p">;</span>	<span class="cm">/* was Reserved1 */</span>
	<span class="n">__u64</span> <span class="n">TxUnsupVLErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxDataPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxFlowPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxDwordCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxLenErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxMaxMinLenErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxUnderrunCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxFlowStallCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">TxDroppedPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxDroppedPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxDataPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxFlowPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxDwordCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxLenErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxMaxMinLenErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxICRCErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxVCRCErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxFlowCtrlErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxBadFormatCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxLinkProblemCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxEBPCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxLPCRCErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxBufOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxTIDFullErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxTIDValidErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxPKeyMismatchCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP0HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP1HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP2HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP3HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP4HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP5HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP6HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP7HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP8HdrEgrOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxP9HdrEgrOvflCnt</span><span class="p">;</span>	<span class="cm">/* was Reserved6 */</span>
	<span class="n">__u64</span> <span class="n">RxP10HdrEgrOvflCnt</span><span class="p">;</span>	<span class="cm">/* was Reserved7 */</span>
	<span class="n">__u64</span> <span class="n">RxP11HdrEgrOvflCnt</span><span class="p">;</span>	<span class="cm">/* new for IBA7220 */</span>
	<span class="n">__u64</span> <span class="n">RxP12HdrEgrOvflCnt</span><span class="p">;</span>	<span class="cm">/* new for IBA7220 */</span>
	<span class="n">__u64</span> <span class="n">RxP13HdrEgrOvflCnt</span><span class="p">;</span>	<span class="cm">/* new for IBA7220 */</span>
	<span class="n">__u64</span> <span class="n">RxP14HdrEgrOvflCnt</span><span class="p">;</span>	<span class="cm">/* new for IBA7220 */</span>
	<span class="n">__u64</span> <span class="n">RxP15HdrEgrOvflCnt</span><span class="p">;</span>	<span class="cm">/* new for IBA7220 */</span>
	<span class="n">__u64</span> <span class="n">RxP16HdrEgrOvflCnt</span><span class="p">;</span>	<span class="cm">/* new for IBA7220 */</span>
	<span class="n">__u64</span> <span class="n">IBStatusChangeCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IBLinkErrRecoveryCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IBLinkDownedCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IBSymbolErrCnt</span><span class="p">;</span>
	<span class="cm">/* The following are new for IBA7220 */</span>
	<span class="n">__u64</span> <span class="n">RxVL15DroppedPktCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxOtherLocalPhyErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">PcieRetryBufDiagQwordCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">ExcessBufferOvflCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">LocalLinkIntegrityErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxVlErrCnt</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">RxDlidFltrCnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The next set of defines are for packet headers, and chip register</span>
<span class="cm"> * and memory bits that are visible to and/or used by user-mode software</span>
<span class="cm"> * The other bits that are used only by the driver or diags are in</span>
<span class="cm"> * ipath_registers.h</span>
<span class="cm"> */</span>

<span class="cm">/* RcvHdrFlags bits */</span>
<span class="cp">#define INFINIPATH_RHF_LENGTH_MASK 0x7FF</span>
<span class="cp">#define INFINIPATH_RHF_LENGTH_SHIFT 0</span>
<span class="cp">#define INFINIPATH_RHF_RCVTYPE_MASK 0x7</span>
<span class="cp">#define INFINIPATH_RHF_RCVTYPE_SHIFT 11</span>
<span class="cp">#define INFINIPATH_RHF_EGRINDEX_MASK 0xFFF</span>
<span class="cp">#define INFINIPATH_RHF_EGRINDEX_SHIFT 16</span>
<span class="cp">#define INFINIPATH_RHF_SEQ_MASK 0xF</span>
<span class="cp">#define INFINIPATH_RHF_SEQ_SHIFT 0</span>
<span class="cp">#define INFINIPATH_RHF_HDRQ_OFFSET_MASK 0x7FF</span>
<span class="cp">#define INFINIPATH_RHF_HDRQ_OFFSET_SHIFT 4</span>
<span class="cp">#define INFINIPATH_RHF_H_ICRCERR   0x80000000</span>
<span class="cp">#define INFINIPATH_RHF_H_VCRCERR   0x40000000</span>
<span class="cp">#define INFINIPATH_RHF_H_PARITYERR 0x20000000</span>
<span class="cp">#define INFINIPATH_RHF_H_LENERR    0x10000000</span>
<span class="cp">#define INFINIPATH_RHF_H_MTUERR    0x08000000</span>
<span class="cp">#define INFINIPATH_RHF_H_IHDRERR   0x04000000</span>
<span class="cp">#define INFINIPATH_RHF_H_TIDERR    0x02000000</span>
<span class="cp">#define INFINIPATH_RHF_H_MKERR     0x01000000</span>
<span class="cp">#define INFINIPATH_RHF_H_IBERR     0x00800000</span>
<span class="cp">#define INFINIPATH_RHF_H_ERR_MASK  0xFF800000</span>
<span class="cp">#define INFINIPATH_RHF_L_USE_EGR   0x80000000</span>
<span class="cp">#define INFINIPATH_RHF_L_SWA       0x00008000</span>
<span class="cp">#define INFINIPATH_RHF_L_SWB       0x00004000</span>

<span class="cm">/* infinipath header fields */</span>
<span class="cp">#define INFINIPATH_I_VERS_MASK 0xF</span>
<span class="cp">#define INFINIPATH_I_VERS_SHIFT 28</span>
<span class="cp">#define INFINIPATH_I_PORT_MASK 0xF</span>
<span class="cp">#define INFINIPATH_I_PORT_SHIFT 24</span>
<span class="cp">#define INFINIPATH_I_TID_MASK 0x7FF</span>
<span class="cp">#define INFINIPATH_I_TID_SHIFT 13</span>
<span class="cp">#define INFINIPATH_I_OFFSET_MASK 0x1FFF</span>
<span class="cp">#define INFINIPATH_I_OFFSET_SHIFT 0</span>

<span class="cm">/* K_PktFlags bits */</span>
<span class="cp">#define INFINIPATH_KPF_INTR 0x1</span>
<span class="cp">#define INFINIPATH_KPF_SUBPORT_MASK 0x3</span>
<span class="cp">#define INFINIPATH_KPF_SUBPORT_SHIFT 1</span>

<span class="cp">#define INFINIPATH_MAX_SUBPORT	4</span>

<span class="cm">/* SendPIO per-buffer control */</span>
<span class="cp">#define INFINIPATH_SP_TEST    0x40</span>
<span class="cp">#define INFINIPATH_SP_TESTEBP 0x20</span>
<span class="cp">#define INFINIPATH_SP_TRIGGER_SHIFT  15</span>

<span class="cm">/* SendPIOAvail bits */</span>
<span class="cp">#define INFINIPATH_SENDPIOAVAIL_BUSY_SHIFT 1</span>
<span class="cp">#define INFINIPATH_SENDPIOAVAIL_CHECK_SHIFT 0</span>

<span class="cm">/* infinipath header format */</span>
<span class="k">struct</span> <span class="n">ipath_header</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Version - 4 bits, Port - 4 bits, TID - 10 bits and Offset -</span>
<span class="cm">	 * 14 bits before ECO change ~28 Dec 03.  After that, Vers 4,</span>
<span class="cm">	 * Port 4, TID 11, offset 13.</span>
<span class="cm">	 */</span>
	<span class="n">__le32</span> <span class="n">ver_port_tid_offset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">chksum</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">pkt_flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* infinipath user message header format.</span>
<span class="cm"> * This structure contains the first 4 fields common to all protocols</span>
<span class="cm"> * that employ infinipath.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipath_message_header</span> <span class="p">{</span>
	<span class="n">__be16</span> <span class="n">lrh</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__be32</span> <span class="n">bth</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="cm">/* fields below this point are in host byte order */</span>
	<span class="k">struct</span> <span class="n">ipath_header</span> <span class="n">iph</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sub_opcode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* infinipath ethernet header format */</span>
<span class="k">struct</span> <span class="n">ether_header</span> <span class="p">{</span>
	<span class="n">__be16</span> <span class="n">lrh</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__be32</span> <span class="n">bth</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ipath_header</span> <span class="n">iph</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">sub_opcode</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">lid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">mac</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">frag_num</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">seq_num</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">len</span><span class="p">;</span>
	<span class="cm">/* MUST be of word size due to PIO write requirements */</span>
	<span class="n">__le32</span> <span class="n">csum</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">csum_offset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">first_2_bytes</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">unused</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* currently unused */</span>
<span class="p">};</span>


<span class="cm">/* IB - LRH header consts */</span>
<span class="cp">#define IPATH_LRH_GRH 0x0003	</span><span class="cm">/* 1. word of IB LRH - next header: GRH */</span><span class="cp"></span>
<span class="cp">#define IPATH_LRH_BTH 0x0002	</span><span class="cm">/* 1. word of IB LRH - next header: BTH */</span><span class="cp"></span>

<span class="cm">/* misc. */</span>
<span class="cp">#define SIZE_OF_CRC 1</span>

<span class="cp">#define IPATH_DEFAULT_P_KEY 0xFFFF</span>
<span class="cp">#define IPATH_PERMISSIVE_LID 0xFFFF</span>
<span class="cp">#define IPATH_AETH_CREDIT_SHIFT 24</span>
<span class="cp">#define IPATH_AETH_CREDIT_MASK 0x1F</span>
<span class="cp">#define IPATH_AETH_CREDIT_INVAL 0x1F</span>
<span class="cp">#define IPATH_PSN_MASK 0xFFFFFF</span>
<span class="cp">#define IPATH_MSN_MASK 0xFFFFFF</span>
<span class="cp">#define IPATH_QPN_MASK 0xFFFFFF</span>
<span class="cp">#define IPATH_MULTICAST_LID_BASE 0xC000</span>
<span class="cp">#define IPATH_EAGER_TID_ID INFINIPATH_I_TID_MASK</span>
<span class="cp">#define IPATH_MULTICAST_QPN 0xFFFFFF</span>

<span class="cm">/* Receive Header Queue: receive type (from infinipath) */</span>
<span class="cp">#define RCVHQ_RCV_TYPE_EXPECTED  0</span>
<span class="cp">#define RCVHQ_RCV_TYPE_EAGER     1</span>
<span class="cp">#define RCVHQ_RCV_TYPE_NON_KD    2</span>
<span class="cp">#define RCVHQ_RCV_TYPE_ERROR     3</span>


<span class="cm">/* sub OpCodes - ith4x  */</span>
<span class="cp">#define IPATH_ITH4X_OPCODE_ENCAP 0x81</span>
<span class="cp">#define IPATH_ITH4X_OPCODE_LID_ARP 0x82</span>

<span class="cp">#define IPATH_HEADER_QUEUE_WORDS 9</span>

<span class="cm">/* functions for extracting fields from rcvhdrq entries for the driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ipath_hdrget_err_flags</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span> <span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_H_ERR_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ipath_hdrget_rcv_type</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span> <span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_RHF_RCVTYPE_SHIFT</span><span class="p">)</span>
	    <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_RCVTYPE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ipath_hdrget_length_in_bytes</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span> <span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_RHF_LENGTH_SHIFT</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_LENGTH_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ipath_hdrget_index</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span> <span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_RHF_EGRINDEX_SHIFT</span><span class="p">)</span>
	    <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_EGRINDEX_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ipath_hdrget_seq</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_RHF_SEQ_SHIFT</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_SEQ_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ipath_hdrget_offset</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_RHF_HDRQ_OFFSET_SHIFT</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_HDRQ_OFFSET_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ipath_hdrget_use_egr_buf</span><span class="p">(</span><span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">INFINIPATH_RHF_L_USE_EGR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">ipath_hdrget_ipath_ver</span><span class="p">(</span><span class="n">__le32</span> <span class="n">hdrword</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">__le32_to_cpu</span><span class="p">(</span><span class="n">hdrword</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_I_VERS_SHIFT</span><span class="p">)</span>
	    <span class="o">&amp;</span> <span class="n">INFINIPATH_I_VERS_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* _IPATH_COMMON_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
