<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › ipath › ipath_kernel.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ipath_kernel.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#ifndef _IPATH_KERNEL_H</span>
<span class="cp">#define _IPATH_KERNEL_H</span>
<span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2006, 2007, 2008 QLogic Corporation. All rights reserved.</span>
<span class="cm"> * Copyright (c) 2003, 2004, 2005, 2006 PathScale, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This header file is the base header file for infinipath kernel code</span>
<span class="cm"> * ipath_user.h serves a similar purpose for user code.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;rdma/ib_verbs.h&gt;</span>

<span class="cp">#include &quot;ipath_common.h&quot;</span>
<span class="cp">#include &quot;ipath_debug.h&quot;</span>
<span class="cp">#include &quot;ipath_registers.h&quot;</span>

<span class="cm">/* only s/w major version of InfiniPath we can handle */</span>
<span class="cp">#define IPATH_CHIP_VERS_MAJ 2U</span>

<span class="cm">/* don&#39;t care about this except printing */</span>
<span class="cp">#define IPATH_CHIP_VERS_MIN 0U</span>

<span class="cm">/* temporary, maybe always */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">infinipath_stats</span> <span class="n">ipath_stats</span><span class="p">;</span>

<span class="cp">#define IPATH_CHIP_SWVERSION IPATH_CHIP_VERS_MAJ</span>
<span class="cm">/*</span>
<span class="cm"> * First-cut critierion for &quot;device is active&quot; is</span>
<span class="cm"> * two thousand dwords combined Tx, Rx traffic per</span>
<span class="cm"> * 5-second interval. SMA packets are 64 dwords,</span>
<span class="cm"> * and occur &quot;a few per second&quot;, presumably each way.</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_TRAFFIC_ACTIVE_THRESHOLD (2000)</span>
<span class="cm">/*</span>
<span class="cm"> * Struct used to indicate which errors are logged in each of the</span>
<span class="cm"> * error-counters that are logged to EEPROM. A counter is incremented</span>
<span class="cm"> * _once_ (saturating at 255) for each event with any bits set in</span>
<span class="cm"> * the error or hwerror register masks below.</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_EEP_LOG_CNT (4)</span>
<span class="k">struct</span> <span class="n">ipath_eep_log_mask</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">errs_to_log</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hwerrs_to_log</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">port_rcvegrbuf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">port_rcvegrbuf_phys</span><span class="p">;</span>
	<span class="cm">/* rcvhdrq base, needs mmap before useful */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">port_rcvhdrq</span><span class="p">;</span>
	<span class="cm">/* kernel virtual address where hdrqtail is updated */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * temp buffer for expected send setup, allocated at open, instead</span>
<span class="cm">	 * of each setup call</span>
<span class="cm">	 */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">port_tid_pg_list</span><span class="p">;</span>
	<span class="cm">/* when waiting for rcv or pioavail */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">port_wait</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * rcvegr bufs base, physical, must fit</span>
<span class="cm">	 * in 44 bits so 32 bit programs mmap64 44 bit works)</span>
<span class="cm">	 */</span>
	<span class="n">dma_addr_t</span> <span class="n">port_rcvegr_phys</span><span class="p">;</span>
	<span class="cm">/* mmap of hdrq, must fit in 44 bits */</span>
	<span class="n">dma_addr_t</span> <span class="n">port_rcvhdrq_phys</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">port_rcvhdrqtailaddr_phys</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * number of opens (including slave subports) on this instance</span>
<span class="cm">	 * (ignoring forks, dup, etc. for now)</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">port_cnt</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * how much space to leave at start of eager TID entries for</span>
<span class="cm">	 * protocol use, on each TID</span>
<span class="cm">	 */</span>
	<span class="cm">/* instead of calculating it */</span>
	<span class="kt">unsigned</span> <span class="n">port_port</span><span class="p">;</span>
	<span class="cm">/* non-zero if port is being shared. */</span>
	<span class="n">u16</span> <span class="n">port_subport_cnt</span><span class="p">;</span>
	<span class="cm">/* non-zero if port is being shared. */</span>
	<span class="n">u16</span> <span class="n">port_subport_id</span><span class="p">;</span>
	<span class="cm">/* number of pio bufs for this port (all procs, if shared) */</span>
	<span class="n">u32</span> <span class="n">port_piocnt</span><span class="p">;</span>
	<span class="cm">/* first pio buffer for this port */</span>
	<span class="n">u32</span> <span class="n">port_pio_base</span><span class="p">;</span>
	<span class="cm">/* chip offset of PIO buffers for this port */</span>
	<span class="n">u32</span> <span class="n">port_piobufs</span><span class="p">;</span>
	<span class="cm">/* how many alloc_pages() chunks in port_rcvegrbuf_pages */</span>
	<span class="n">u32</span> <span class="n">port_rcvegrbuf_chunks</span><span class="p">;</span>
	<span class="cm">/* how many egrbufs per chunk */</span>
	<span class="n">u32</span> <span class="n">port_rcvegrbufs_perchunk</span><span class="p">;</span>
	<span class="cm">/* order for port_rcvegrbuf_pages */</span>
	<span class="kt">size_t</span> <span class="n">port_rcvegrbuf_size</span><span class="p">;</span>
	<span class="cm">/* rcvhdrq size (for freeing) */</span>
	<span class="kt">size_t</span> <span class="n">port_rcvhdrq_size</span><span class="p">;</span>
	<span class="cm">/* next expected TID to check when looking for free */</span>
	<span class="n">u32</span> <span class="n">port_tidcursor</span><span class="p">;</span>
	<span class="cm">/* next expected TID to check */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port_flag</span><span class="p">;</span>
	<span class="cm">/* what happened */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">int_flag</span><span class="p">;</span>
	<span class="cm">/* WAIT_RCV that timed out, no interrupt */</span>
	<span class="n">u32</span> <span class="n">port_rcvwait_to</span><span class="p">;</span>
	<span class="cm">/* WAIT_PIO that timed out, no interrupt */</span>
	<span class="n">u32</span> <span class="n">port_piowait_to</span><span class="p">;</span>
	<span class="cm">/* WAIT_RCV already happened, no wait */</span>
	<span class="n">u32</span> <span class="n">port_rcvnowait</span><span class="p">;</span>
	<span class="cm">/* WAIT_PIO already happened, no wait */</span>
	<span class="n">u32</span> <span class="n">port_pionowait</span><span class="p">;</span>
	<span class="cm">/* total number of rcvhdrqfull errors */</span>
	<span class="n">u32</span> <span class="n">port_hdrqfull</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Used to suppress multiple instances of same</span>
<span class="cm">	 * port staying stuck at same point.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">port_lastrcvhdrqtail</span><span class="p">;</span>
	<span class="cm">/* saved total number of rcvhdrqfull errors for poll edge trigger */</span>
	<span class="n">u32</span> <span class="n">port_hdrqfull_poll</span><span class="p">;</span>
	<span class="cm">/* total number of polled urgent packets */</span>
	<span class="n">u32</span> <span class="n">port_urgent</span><span class="p">;</span>
	<span class="cm">/* saved total number of polled urgent packets for poll edge trigger */</span>
	<span class="n">u32</span> <span class="n">port_urgent_poll</span><span class="p">;</span>
	<span class="cm">/* pid of process using this port */</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">port_pid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">port_subpid</span><span class="p">[</span><span class="n">INFINIPATH_MAX_SUBPORT</span><span class="p">];</span>
	<span class="cm">/* same size as task_struct .comm[] */</span>
	<span class="kt">char</span> <span class="n">port_comm</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="cm">/* pkeys set by this use of this port */</span>
	<span class="n">u16</span> <span class="n">port_pkeys</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* so file ops can get at unit */</span>
	<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">port_dd</span><span class="p">;</span>
	<span class="cm">/* A page of memory for rcvhdrhead, rcvegrhead, rcvegrtail * N */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">subport_uregbase</span><span class="p">;</span>
	<span class="cm">/* An array of pages for the eager receive buffers * N */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">subport_rcvegrbuf</span><span class="p">;</span>
	<span class="cm">/* An array of pages for the eager header queue entries * N */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">subport_rcvhdr_base</span><span class="p">;</span>
	<span class="cm">/* The version of the library which opened this port */</span>
	<span class="n">u32</span> <span class="n">userversion</span><span class="p">;</span>
	<span class="cm">/* Bitmask of active slaves */</span>
	<span class="n">u32</span> <span class="n">active_slaves</span><span class="p">;</span>
	<span class="cm">/* Type of packets or conditions we want to poll for */</span>
	<span class="n">u16</span> <span class="n">poll_type</span><span class="p">;</span>
	<span class="cm">/* port rcvhdrq head offset */</span>
	<span class="n">u32</span> <span class="n">port_head</span><span class="p">;</span>
	<span class="cm">/* receive packet sequence counter */</span>
	<span class="n">u32</span> <span class="n">port_seq_cnt</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sk_buff</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ipath_sge_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">ipath_verbs_txreq</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * control information for layered drivers</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">_ipath_layer</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">l_arg</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipath_skbinfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">phys</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipath_sdma_txreq</span> <span class="p">{</span>
	<span class="kt">int</span>                 <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>                 <span class="n">sg_count</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">map_addr</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="kt">void</span>              <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span>               <span class="o">*</span><span class="n">callback_cookie</span><span class="p">;</span>
	<span class="kt">int</span>                 <span class="n">callback_status</span><span class="p">;</span>
	<span class="n">u16</span>                 <span class="n">start_idx</span><span class="p">;</span>  <span class="cm">/* sdma private */</span>
	<span class="n">u16</span>                 <span class="n">next_descq_idx</span><span class="p">;</span>  <span class="cm">/* sdma private */</span>
	<span class="k">struct</span> <span class="n">list_head</span>    <span class="n">list</span><span class="p">;</span>       <span class="cm">/* sdma private */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ipath_sdma_desc</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">qw</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define IPATH_SDMA_TXREQ_F_USELARGEBUF  0x1</span>
<span class="cp">#define IPATH_SDMA_TXREQ_F_HEADTOHOST   0x2</span>
<span class="cp">#define IPATH_SDMA_TXREQ_F_INTREQ       0x4</span>
<span class="cp">#define IPATH_SDMA_TXREQ_F_FREEBUF      0x8</span>
<span class="cp">#define IPATH_SDMA_TXREQ_F_FREEDESC     0x10</span>
<span class="cp">#define IPATH_SDMA_TXREQ_F_VL15         0x20</span>

<span class="cp">#define IPATH_SDMA_TXREQ_S_OK        0</span>
<span class="cp">#define IPATH_SDMA_TXREQ_S_SENDERROR 1</span>
<span class="cp">#define IPATH_SDMA_TXREQ_S_ABORTED   2</span>
<span class="cp">#define IPATH_SDMA_TXREQ_S_SHUTDOWN  3</span>

<span class="cp">#define IPATH_SDMA_STATUS_SCORE_BOARD_DRAIN_IN_PROG	(1ull &lt;&lt; 63)</span>
<span class="cp">#define IPATH_SDMA_STATUS_ABORT_IN_PROG			(1ull &lt;&lt; 62)</span>
<span class="cp">#define IPATH_SDMA_STATUS_INTERNAL_SDMA_ENABLE		(1ull &lt;&lt; 61)</span>
<span class="cp">#define IPATH_SDMA_STATUS_SCB_EMPTY			(1ull &lt;&lt; 30)</span>

<span class="cm">/* max dwords in small buffer packet */</span>
<span class="cp">#define IPATH_SMALLBUF_DWORDS (dd-&gt;ipath_piosize2k &gt;&gt; 2)</span>

<span class="cm">/*</span>
<span class="cm"> * Possible IB config parameters for ipath_f_get/set_ib_cfg()</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_IB_CFG_LIDLMC 0 </span><span class="cm">/* Get/set LID (LS16b) and Mask (MS16b) */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_CFG_HRTBT 1 </span><span class="cm">/* Get/set Heartbeat off/enable/auto */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_HRTBT_ON 3 </span><span class="cm">/* Heartbeat enabled, sent every 100msec */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_HRTBT_OFF 0 </span><span class="cm">/* Heartbeat off */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_CFG_LWID_ENB 2 </span><span class="cm">/* Get/set allowed Link-width */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_CFG_LWID 3 </span><span class="cm">/* Get currently active Link-width */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_CFG_SPD_ENB 4 </span><span class="cm">/* Get/set allowed Link speeds */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_CFG_SPD 5 </span><span class="cm">/* Get current Link spd */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_CFG_RXPOL_ENB 6 </span><span class="cm">/* Get/set Auto-RX-polarity enable */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_CFG_LREV_ENB 7 </span><span class="cm">/* Get/set Auto-Lane-reversal enable */</span><span class="cp"></span>
<span class="cp">#define IPATH_IB_CFG_LINKLATENCY 8 </span><span class="cm">/* Get Auto-Lane-reversal enable */</span><span class="cp"></span>


<span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ipath_list</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ipath_kregs</span> <span class="k">const</span> <span class="o">*</span><span class="n">ipath_kregs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_cregs</span> <span class="k">const</span> <span class="o">*</span><span class="n">ipath_cregs</span><span class="p">;</span>

	<span class="cm">/* mem-mapped pointer to base of chip regs */</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ipath_kregbase</span><span class="p">;</span>
	<span class="cm">/* end of mem-mapped chip space; range checking */</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ipath_kregend</span><span class="p">;</span>
	<span class="cm">/* physical address of chip for io_remap, etc. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_physaddr</span><span class="p">;</span>
	<span class="cm">/* base of memory alloced for ipath_kregbase, for free */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">ipath_kregalloc</span><span class="p">;</span>
	<span class="cm">/* ipath_cfgports pointers */</span>
	<span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">**</span><span class="n">ipath_pd</span><span class="p">;</span>
	<span class="cm">/* sk_buffs used by port 0 eager receive queue */</span>
	<span class="k">struct</span> <span class="n">ipath_skbinfo</span> <span class="o">*</span><span class="n">ipath_port0_skbinfo</span><span class="p">;</span>
	<span class="cm">/* kvirt address of 1st 2k pio buffer */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ipath_pio2kbase</span><span class="p">;</span>
	<span class="cm">/* kvirt address of 1st 4k pio buffer */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ipath_pio4kbase</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * points to area where PIOavail registers will be DMA&#39;ed.</span>
<span class="cm">	 * Has to be on a page of it&#39;s own, because the page will be</span>
<span class="cm">	 * mapped into user program space.  This copy is *ONLY* ever</span>
<span class="cm">	 * written by DMA, not by the driver!  Need a copy per device</span>
<span class="cm">	 * when we get to multiple devices</span>
<span class="cm">	 */</span>
	<span class="k">volatile</span> <span class="n">__le64</span> <span class="o">*</span><span class="n">ipath_pioavailregs_dma</span><span class="p">;</span>
	<span class="cm">/* physical address where updates occur */</span>
	<span class="n">dma_addr_t</span> <span class="n">ipath_pioavailregs_phys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_ipath_layer</span> <span class="n">ipath_layer</span><span class="p">;</span>
	<span class="cm">/* setup intr */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_intrsetup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* fallback to alternate interrupt type if possible */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_intr_fallback</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* setup on-chip bus config */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_bus</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* hard reset chip */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_get_boardname</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
				     <span class="kt">size_t</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_init_hwerrors</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_handle_hwerrors</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span>
					<span class="kt">size_t</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_quiet_serdes</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_bringup_serdes</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_early_init</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_clear_tids</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_put_tid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span> <span class="n">__iomem</span><span class="o">*</span><span class="p">,</span>
				<span class="n">u32</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_tidtemplate</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_cleanup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_setextled</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>
	<span class="cm">/* fill out chip-specific fields */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_get_base_info</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* free irq */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_free_irq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ipath_message_header</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">ipath_f_get_msgheader</span><span class="p">)</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">__le32</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_config_ports</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">ushort</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_get_ib_cfg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_set_ib_cfg</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u32</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_config_jint</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span> <span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_read_counters</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">infinipath_counters</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_xgxs_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* per chip actions needed for IB Link up/down changes */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ipath_f_ib_updown</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="n">ipath_lastegr_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_ibdev</span> <span class="o">*</span><span class="n">verbs_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">verbs_timer</span><span class="p">;</span>
	<span class="cm">/* total dwords sent (summed from counter) */</span>
	<span class="n">u64</span> <span class="n">ipath_sword</span><span class="p">;</span>
	<span class="cm">/* total dwords rcvd (summed from counter) */</span>
	<span class="n">u64</span> <span class="n">ipath_rword</span><span class="p">;</span>
	<span class="cm">/* total packets sent (summed from counter) */</span>
	<span class="n">u64</span> <span class="n">ipath_spkts</span><span class="p">;</span>
	<span class="cm">/* total packets rcvd (summed from counter) */</span>
	<span class="n">u64</span> <span class="n">ipath_rpkts</span><span class="p">;</span>
	<span class="cm">/* ipath_statusp initially points to this. */</span>
	<span class="n">u64</span> <span class="n">_ipath_status</span><span class="p">;</span>
	<span class="cm">/* GUID for this interface, in network order */</span>
	<span class="n">__be64</span> <span class="n">ipath_guid</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * aggregrate of error bits reported since last cleared, for</span>
<span class="cm">	 * limiting of error reporting</span>
<span class="cm">	 */</span>
	<span class="n">ipath_err_t</span> <span class="n">ipath_lasterror</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * aggregrate of error bits reported since last cleared, for</span>
<span class="cm">	 * limiting of hwerror reporting</span>
<span class="cm">	 */</span>
	<span class="n">ipath_err_t</span> <span class="n">ipath_lasthwerror</span><span class="p">;</span>
	<span class="cm">/* errors masked because they occur too fast */</span>
	<span class="n">ipath_err_t</span> <span class="n">ipath_maskederrs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ipath_lastlinkrecov</span><span class="p">;</span> <span class="cm">/* link recoveries at last ACTIVE */</span>
	<span class="cm">/* these 5 fields are used to establish deltas for IB Symbol</span>
<span class="cm">	 * errors and linkrecovery errors. They can be reported on</span>
<span class="cm">	 * some chips during link negotiation prior to INIT, and with</span>
<span class="cm">	 * DDR when faking DDR negotiations with non-IBTA switches.</span>
<span class="cm">	 * The chip counters are adjusted at driver unload if there is</span>
<span class="cm">	 * a non-zero delta.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">ibdeltainprog</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ibsymdelta</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ibsymsnap</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">iblnkerrdelta</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">iblnkerrsnap</span><span class="p">;</span>

	<span class="cm">/* time in jiffies at which to re-enable maskederrs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_unmasktime</span><span class="p">;</span>
	<span class="cm">/* count of egrfull errors, combined for all ports */</span>
	<span class="n">u64</span> <span class="n">ipath_last_tidfull</span><span class="p">;</span>
	<span class="cm">/* for ipath_qcheck() */</span>
	<span class="n">u64</span> <span class="n">ipath_lastport0rcv_cnt</span><span class="p">;</span>
	<span class="cm">/* template for writing TIDs  */</span>
	<span class="n">u64</span> <span class="n">ipath_tidtemplate</span><span class="p">;</span>
	<span class="cm">/* value to write to free TIDs */</span>
	<span class="n">u64</span> <span class="n">ipath_tidinvalid</span><span class="p">;</span>
	<span class="cm">/* IBA6120 rcv interrupt setup */</span>
	<span class="n">u64</span> <span class="n">ipath_rhdrhead_intr_off</span><span class="p">;</span>

	<span class="cm">/* size of memory at ipath_kregbase */</span>
	<span class="n">u32</span> <span class="n">ipath_kregsize</span><span class="p">;</span>
	<span class="cm">/* number of registers used for pioavail */</span>
	<span class="n">u32</span> <span class="n">ipath_pioavregs</span><span class="p">;</span>
	<span class="cm">/* IPATH_POLL, etc. */</span>
	<span class="n">u32</span> <span class="n">ipath_flags</span><span class="p">;</span>
	<span class="cm">/* ipath_flags driver is waiting for */</span>
	<span class="n">u32</span> <span class="n">ipath_state_wanted</span><span class="p">;</span>
	<span class="cm">/* last buffer for user use, first buf for kernel use is this</span>
<span class="cm">	 * index. */</span>
	<span class="n">u32</span> <span class="n">ipath_lastport_piobuf</span><span class="p">;</span>
	<span class="cm">/* is a stats timer active */</span>
	<span class="n">u32</span> <span class="n">ipath_stats_timer_active</span><span class="p">;</span>
	<span class="cm">/* number of interrupts for this device -- saturates... */</span>
	<span class="n">u32</span> <span class="n">ipath_int_counter</span><span class="p">;</span>
	<span class="cm">/* dwords sent read from counter */</span>
	<span class="n">u32</span> <span class="n">ipath_lastsword</span><span class="p">;</span>
	<span class="cm">/* dwords received read from counter */</span>
	<span class="n">u32</span> <span class="n">ipath_lastrword</span><span class="p">;</span>
	<span class="cm">/* sent packets read from counter */</span>
	<span class="n">u32</span> <span class="n">ipath_lastspkts</span><span class="p">;</span>
	<span class="cm">/* received packets read from counter */</span>
	<span class="n">u32</span> <span class="n">ipath_lastrpkts</span><span class="p">;</span>
	<span class="cm">/* pio bufs allocated per port */</span>
	<span class="n">u32</span> <span class="n">ipath_pbufsport</span><span class="p">;</span>
	<span class="cm">/* if remainder on bufs/port, ports &lt; extrabuf get 1 extra */</span>
	<span class="n">u32</span> <span class="n">ipath_ports_extrabuf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipath_pioupd_thresh</span><span class="p">;</span> <span class="cm">/* update threshold, some chips */</span>
	<span class="cm">/*</span>
<span class="cm">	 * number of ports configured as max; zero is set to number chip</span>
<span class="cm">	 * supports, less gives more pio bufs/port, etc.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_cfgports</span><span class="p">;</span>
	<span class="cm">/* count of port 0 hdrqfull errors */</span>
	<span class="n">u32</span> <span class="n">ipath_p0_hdrqfull</span><span class="p">;</span>
	<span class="cm">/* port 0 number of receive eager buffers */</span>
	<span class="n">u32</span> <span class="n">ipath_p0_rcvegrcnt</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * index of last piobuffer we used.  Speeds up searching, by</span>
<span class="cm">	 * starting at this point.  Doesn&#39;t matter if multiple cpu&#39;s use and</span>
<span class="cm">	 * update, last updater is only write that matters.  Whenever it</span>
<span class="cm">	 * wraps, we update shadow copies.  Need a copy per device when we</span>
<span class="cm">	 * get to multiple devices</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_lastpioindex</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipath_lastpioindexl</span><span class="p">;</span>
	<span class="cm">/* max length of freezemsg */</span>
	<span class="n">u32</span> <span class="n">ipath_freezelen</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * consecutive times we wanted a PIO buffer but were unable to</span>
<span class="cm">	 * get one</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_consec_nopiobuf</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * hint that we should update ipath_pioavailshadow before</span>
<span class="cm">	 * looking for a PIO buffer</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_upd_pio_shadow</span><span class="p">;</span>
	<span class="cm">/* so we can rewrite it after a chip reset */</span>
	<span class="n">u32</span> <span class="n">ipath_pcibar0</span><span class="p">;</span>
	<span class="cm">/* so we can rewrite it after a chip reset */</span>
	<span class="n">u32</span> <span class="n">ipath_pcibar1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipath_x1_fix_tries</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipath_autoneg_tries</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">serdes_first_init_done</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ipath_relock</span> <span class="p">{</span>
		<span class="n">atomic_t</span> <span class="n">ipath_relock_timer_active</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">ipath_relock_timer</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ipath_relock_interval</span><span class="p">;</span> <span class="cm">/* in jiffies */</span>
	<span class="p">}</span> <span class="n">ipath_relock_singleton</span><span class="p">;</span>

	<span class="cm">/* interrupt number */</span>
	<span class="kt">int</span> <span class="n">ipath_irq</span><span class="p">;</span>
	<span class="cm">/* HT/PCI Vendor ID (here for NodeInfo) */</span>
	<span class="n">u16</span> <span class="n">ipath_vendorid</span><span class="p">;</span>
	<span class="cm">/* HT/PCI Device ID (here for NodeInfo) */</span>
	<span class="n">u16</span> <span class="n">ipath_deviceid</span><span class="p">;</span>
	<span class="cm">/* offset in HT config space of slave/primary interface block */</span>
	<span class="n">u8</span> <span class="n">ipath_ht_slave_off</span><span class="p">;</span>
	<span class="cm">/* for write combining settings */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_wc_cookie</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_wc_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_wc_len</span><span class="p">;</span>
	<span class="cm">/* ref count for each pkey */</span>
	<span class="n">atomic_t</span> <span class="n">ipath_pkeyrefs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/* shadow copy of struct page *&#39;s for exp tid pages */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">ipath_pageshadow</span><span class="p">;</span>
	<span class="cm">/* shadow copy of dma handles for exp tid pages */</span>
	<span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">ipath_physshadow</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ipath_egrtidbase</span><span class="p">;</span>
	<span class="cm">/* lock to workaround chip bug 9437 and others */</span>
	<span class="n">spinlock_t</span> <span class="n">ipath_kernel_tid_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ipath_user_tid_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">ipath_sendctrl_lock</span><span class="p">;</span>
	<span class="cm">/* around ipath_pd and (user ports) port_cnt use (intr vs free) */</span>
	<span class="n">spinlock_t</span> <span class="n">ipath_uctxt_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * IPATH_STATUS_*,</span>
<span class="cm">	 * this address is mapped readonly into user processes so they can</span>
<span class="cm">	 * get status cheaply, whenever they want.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">ipath_statusp</span><span class="p">;</span>
	<span class="cm">/* freeze msg if hw error put chip in freeze */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ipath_freezemsg</span><span class="p">;</span>
	<span class="cm">/* pci access data structure */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">user_cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">diag_cdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">user_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">diag_dev</span><span class="p">;</span>
	<span class="cm">/* timer used to prevent stats overflow, error throttling, etc. */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">ipath_stats_timer</span><span class="p">;</span>
	<span class="cm">/* timer to verify interrupts work, and fallback if possible */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">ipath_intrchk_timer</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ipath_dummy_hdrq</span><span class="p">;</span>	<span class="cm">/* used after port close */</span>
	<span class="n">dma_addr_t</span> <span class="n">ipath_dummy_hdrq_phys</span><span class="p">;</span>

	<span class="cm">/* SendDMA related entries */</span>
	<span class="n">spinlock_t</span>            <span class="n">ipath_sdma_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>         <span class="n">ipath_sdma_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>         <span class="n">ipath_sdma_abort_jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>         <span class="n">ipath_sdma_abort_intr_timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>         <span class="n">ipath_sdma_buf_jiffies</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_sdma_desc</span> <span class="o">*</span><span class="n">ipath_sdma_descq</span><span class="p">;</span>
	<span class="n">u64</span>		      <span class="n">ipath_sdma_descq_added</span><span class="p">;</span>
	<span class="n">u64</span>		      <span class="n">ipath_sdma_descq_removed</span><span class="p">;</span>
	<span class="kt">int</span>		      <span class="n">ipath_sdma_desc_nreserved</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">ipath_sdma_descq_cnt</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">ipath_sdma_descq_tail</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">ipath_sdma_descq_head</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">ipath_sdma_next_intr</span><span class="p">;</span>
	<span class="n">u16</span>                   <span class="n">ipath_sdma_reset_wait</span><span class="p">;</span>
	<span class="n">u8</span>                    <span class="n">ipath_sdma_generation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">ipath_sdma_abort_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">ipath_sdma_notify_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>      <span class="n">ipath_sdma_activelist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>      <span class="n">ipath_sdma_notifylist</span><span class="p">;</span>
	<span class="n">atomic_t</span>              <span class="n">ipath_sdma_vl15_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span>     <span class="n">ipath_sdma_vl15_timer</span><span class="p">;</span>

	<span class="n">dma_addr_t</span>       <span class="n">ipath_sdma_descq_phys</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">__le64</span> <span class="o">*</span><span class="n">ipath_sdma_head_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>       <span class="n">ipath_sdma_head_phys</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_ureg_align</span><span class="p">;</span> <span class="cm">/* user register alignment */</span>

	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">ipath_autoneg_work</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">ipath_autoneg_wait</span><span class="p">;</span>

	<span class="cm">/* HoL blocking / user app forward-progress state */</span>
	<span class="kt">unsigned</span>          <span class="n">ipath_hol_state</span><span class="p">;</span>
	<span class="kt">unsigned</span>          <span class="n">ipath_hol_next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">ipath_hol_timer</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Shadow copies of registers; size indicates read access size.</span>
<span class="cm">	 * Most of them are readonly, but some are write-only register,</span>
<span class="cm">	 * where we manipulate the bits in the shadow copy, and then write</span>
<span class="cm">	 * the shadow copy to infinipath.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We deliberately make most of these 32 bits, since they have</span>
<span class="cm">	 * restricted range.  For any that we read, we won&#39;t to generate 32</span>
<span class="cm">	 * bit accesses, since Opteron will generate 2 separate 32 bit HT</span>
<span class="cm">	 * transactions for a 64 bit read, and we want to avoid unnecessary</span>
<span class="cm">	 * HT transactions.</span>
<span class="cm">	 */</span>

	<span class="cm">/* This is the 64 bit group */</span>

	<span class="cm">/*</span>
<span class="cm">	 * shadow of pioavail, check to be sure it&#39;s large enough at</span>
<span class="cm">	 * init time.</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_pioavailshadow</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* bitmap of send buffers available for the kernel to use with PIO. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_pioavailkernel</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="cm">/* shadow of kr_gpio_out, for rmw ops */</span>
	<span class="n">u64</span> <span class="n">ipath_gpio_out</span><span class="p">;</span>
	<span class="cm">/* shadow the gpio mask register */</span>
	<span class="n">u64</span> <span class="n">ipath_gpio_mask</span><span class="p">;</span>
	<span class="cm">/* shadow the gpio output enable, etc... */</span>
	<span class="n">u64</span> <span class="n">ipath_extctrl</span><span class="p">;</span>
	<span class="cm">/* kr_revision shadow */</span>
	<span class="n">u64</span> <span class="n">ipath_revision</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * shadow of ibcctrl, for interrupt handling of link changes,</span>
<span class="cm">	 * etc.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">ipath_ibcctrl</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * last ibcstatus, to suppress &quot;duplicate&quot; status change messages,</span>
<span class="cm">	 * mostly from 2 to 3</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">ipath_lastibcstat</span><span class="p">;</span>
	<span class="cm">/* hwerrmask shadow */</span>
	<span class="n">ipath_err_t</span> <span class="n">ipath_hwerrmask</span><span class="p">;</span>
	<span class="n">ipath_err_t</span> <span class="n">ipath_errormask</span><span class="p">;</span> <span class="cm">/* errormask shadow */</span>
	<span class="cm">/* interrupt config reg shadow */</span>
	<span class="n">u64</span> <span class="n">ipath_intconfig</span><span class="p">;</span>
	<span class="cm">/* kr_sendpiobufbase value */</span>
	<span class="n">u64</span> <span class="n">ipath_piobufbase</span><span class="p">;</span>
	<span class="cm">/* kr_ibcddrctrl shadow */</span>
	<span class="n">u64</span> <span class="n">ipath_ibcddrctrl</span><span class="p">;</span>

	<span class="cm">/* these are the &quot;32 bit&quot; regs */</span>

	<span class="cm">/*</span>
<span class="cm">	 * number of GUIDs in the flash for this interface; may need some</span>
<span class="cm">	 * rethinking for setting on other ifaces</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_nguid</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * the following two are 32-bit bitmasks, but {test,clear,set}_bit</span>
<span class="cm">	 * all expect bit fields to be &quot;unsigned long&quot;</span>
<span class="cm">	 */</span>
	<span class="cm">/* shadow kr_rcvctrl */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_rcvctrl</span><span class="p">;</span>
	<span class="cm">/* shadow kr_sendctrl */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_sendctrl</span><span class="p">;</span>
	<span class="cm">/* to not count armlaunch after cancel */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_lastcancel</span><span class="p">;</span>
	<span class="cm">/* count cases where special trigger was needed (double write) */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ipath_spectriggerhit</span><span class="p">;</span>

	<span class="cm">/* value we put in kr_rcvhdrcnt */</span>
	<span class="n">u32</span> <span class="n">ipath_rcvhdrcnt</span><span class="p">;</span>
	<span class="cm">/* value we put in kr_rcvhdrsize */</span>
	<span class="n">u32</span> <span class="n">ipath_rcvhdrsize</span><span class="p">;</span>
	<span class="cm">/* value we put in kr_rcvhdrentsize */</span>
	<span class="n">u32</span> <span class="n">ipath_rcvhdrentsize</span><span class="p">;</span>
	<span class="cm">/* offset of last entry in rcvhdrq */</span>
	<span class="n">u32</span> <span class="n">ipath_hdrqlast</span><span class="p">;</span>
	<span class="cm">/* kr_portcnt value */</span>
	<span class="n">u32</span> <span class="n">ipath_portcnt</span><span class="p">;</span>
	<span class="cm">/* kr_pagealign value */</span>
	<span class="n">u32</span> <span class="n">ipath_palign</span><span class="p">;</span>
	<span class="cm">/* number of &quot;2KB&quot; PIO buffers */</span>
	<span class="n">u32</span> <span class="n">ipath_piobcnt2k</span><span class="p">;</span>
	<span class="cm">/* size in bytes of &quot;2KB&quot; PIO buffers */</span>
	<span class="n">u32</span> <span class="n">ipath_piosize2k</span><span class="p">;</span>
	<span class="cm">/* number of &quot;4KB&quot; PIO buffers */</span>
	<span class="n">u32</span> <span class="n">ipath_piobcnt4k</span><span class="p">;</span>
	<span class="cm">/* size in bytes of &quot;4KB&quot; PIO buffers */</span>
	<span class="n">u32</span> <span class="n">ipath_piosize4k</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipath_pioreserved</span><span class="p">;</span> <span class="cm">/* reserved special-inkernel; */</span>
	<span class="cm">/* kr_rcvegrbase value */</span>
	<span class="n">u32</span> <span class="n">ipath_rcvegrbase</span><span class="p">;</span>
	<span class="cm">/* kr_rcvegrcnt value */</span>
	<span class="n">u32</span> <span class="n">ipath_rcvegrcnt</span><span class="p">;</span>
	<span class="cm">/* kr_rcvtidbase value */</span>
	<span class="n">u32</span> <span class="n">ipath_rcvtidbase</span><span class="p">;</span>
	<span class="cm">/* kr_rcvtidcnt value */</span>
	<span class="n">u32</span> <span class="n">ipath_rcvtidcnt</span><span class="p">;</span>
	<span class="cm">/* kr_sendregbase */</span>
	<span class="n">u32</span> <span class="n">ipath_sregbase</span><span class="p">;</span>
	<span class="cm">/* kr_userregbase */</span>
	<span class="n">u32</span> <span class="n">ipath_uregbase</span><span class="p">;</span>
	<span class="cm">/* kr_counterregbase */</span>
	<span class="n">u32</span> <span class="n">ipath_cregbase</span><span class="p">;</span>
	<span class="cm">/* shadow the control register contents */</span>
	<span class="n">u32</span> <span class="n">ipath_control</span><span class="p">;</span>
	<span class="cm">/* PCI revision register (HTC rev on FPGA) */</span>
	<span class="n">u32</span> <span class="n">ipath_pcirev</span><span class="p">;</span>

	<span class="cm">/* chip address space used by 4k pio buffers */</span>
	<span class="n">u32</span> <span class="n">ipath_4kalign</span><span class="p">;</span>
	<span class="cm">/* The MTU programmed for this unit */</span>
	<span class="n">u32</span> <span class="n">ipath_ibmtu</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The max size IB packet, included IB headers that we can send.</span>
<span class="cm">	 * Starts same as ipath_piosize, but is affected when ibmtu is</span>
<span class="cm">	 * changed, or by size of eager buffers</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_ibmaxlen</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * ibmaxlen at init time, limited by chip and by receive buffer</span>
<span class="cm">	 * size.  Not changed after init.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_init_ibmaxlen</span><span class="p">;</span>
	<span class="cm">/* size of each rcvegrbuffer */</span>
	<span class="n">u32</span> <span class="n">ipath_rcvegrbufsize</span><span class="p">;</span>
	<span class="cm">/* localbus width (1, 2,4,8,16,32) from config space  */</span>
	<span class="n">u32</span> <span class="n">ipath_lbus_width</span><span class="p">;</span>
	<span class="cm">/* localbus speed (HT: 200,400,800,1000; PCIe 2500) */</span>
	<span class="n">u32</span> <span class="n">ipath_lbus_speed</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * number of sequential ibcstatus change for polling active/quiet</span>
<span class="cm">	 * (i.e., link not coming up).</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_ibpollcnt</span><span class="p">;</span>
	<span class="cm">/* low and high portions of MSI capability/vector */</span>
	<span class="n">u32</span> <span class="n">ipath_msi_lo</span><span class="p">;</span>
	<span class="cm">/* saved after PCIe init for restore after reset */</span>
	<span class="n">u32</span> <span class="n">ipath_msi_hi</span><span class="p">;</span>
	<span class="cm">/* MSI data (vector) saved for restore */</span>
	<span class="n">u16</span> <span class="n">ipath_msi_data</span><span class="p">;</span>
	<span class="cm">/* MLID programmed for this instance */</span>
	<span class="n">u16</span> <span class="n">ipath_mlid</span><span class="p">;</span>
	<span class="cm">/* LID programmed for this instance */</span>
	<span class="n">u16</span> <span class="n">ipath_lid</span><span class="p">;</span>
	<span class="cm">/* list of pkeys programmed; 0 if not set */</span>
	<span class="n">u16</span> <span class="n">ipath_pkeys</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * ASCII serial number, from flash, large enough for original</span>
<span class="cm">	 * all digit strings, and longer QLogic serial number format</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">ipath_serial</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="cm">/* human readable board version */</span>
	<span class="n">u8</span> <span class="n">ipath_boardversion</span><span class="p">[</span><span class="mi">96</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">ipath_lbus_info</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span> <span class="cm">/* human readable localbus info */</span>
	<span class="cm">/* chip major rev, from ipath_revision */</span>
	<span class="n">u8</span> <span class="n">ipath_majrev</span><span class="p">;</span>
	<span class="cm">/* chip minor rev, from ipath_revision */</span>
	<span class="n">u8</span> <span class="n">ipath_minrev</span><span class="p">;</span>
	<span class="cm">/* board rev, from ipath_revision */</span>
	<span class="n">u8</span> <span class="n">ipath_boardrev</span><span class="p">;</span>
	<span class="cm">/* saved for restore after reset */</span>
	<span class="n">u8</span> <span class="n">ipath_pci_cacheline</span><span class="p">;</span>
	<span class="cm">/* LID mask control */</span>
	<span class="n">u8</span> <span class="n">ipath_lmc</span><span class="p">;</span>
	<span class="cm">/* link width supported */</span>
	<span class="n">u8</span> <span class="n">ipath_link_width_supported</span><span class="p">;</span>
	<span class="cm">/* link speed supported */</span>
	<span class="n">u8</span> <span class="n">ipath_link_speed_supported</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_link_width_enabled</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_link_speed_enabled</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_link_width_active</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_link_speed_active</span><span class="p">;</span>
	<span class="cm">/* Rx Polarity inversion (compensate for ~tx on partner) */</span>
	<span class="n">u8</span> <span class="n">ipath_rx_pol_inv</span><span class="p">;</span>

	<span class="n">u8</span> <span class="n">ipath_r_portenable_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_r_intravail_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_r_tailupd_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_r_portcfg_shift</span><span class="p">;</span>

	<span class="cm">/* unit # of this chip, if present */</span>
	<span class="kt">int</span> <span class="n">ipath_unit</span><span class="p">;</span>

	<span class="cm">/* local link integrity counter */</span>
	<span class="n">u32</span> <span class="n">ipath_lli_counter</span><span class="p">;</span>
	<span class="cm">/* local link integrity errors */</span>
	<span class="n">u32</span> <span class="n">ipath_lli_errors</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Above counts only cases where _successive_ LocalLinkIntegrity</span>
<span class="cm">	 * errors were seen in the receive headers of kern-packets.</span>
<span class="cm">	 * Below are the three (monotonically increasing) counters</span>
<span class="cm">	 * maintained via GPIO interrupts on iba6120-rev2.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span> <span class="n">ipath_rxfc_unsupvl_errs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipath_overrun_thresh_errs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipath_lli_errs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not all devices managed by a driver instance are the same</span>
<span class="cm">	 * type, so these fields must be per-device.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">ipath_i_bitsextant</span><span class="p">;</span>
	<span class="n">ipath_err_t</span> <span class="n">ipath_e_bitsextant</span><span class="p">;</span>
	<span class="n">ipath_err_t</span> <span class="n">ipath_hwe_bitsextant</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Below should be computable from number of ports,</span>
<span class="cm">	 * since they are never modified.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">ipath_i_rcvavail_mask</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ipath_i_rcvurg_mask</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ipath_i_rcvurg_shift</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ipath_i_rcvavail_shift</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register bits for selecting i2c direction and values, used for</span>
<span class="cm">	 * I2C serial flash.</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">ipath_gpio_sda_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_gpio_scl_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_i2c_chain_type</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ipath_gpio_sda</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ipath_gpio_scl</span><span class="p">;</span>

	<span class="cm">/* lock for doing RMW of shadows/regs for ExtCtrl and GPIO */</span>
	<span class="n">spinlock_t</span> <span class="n">ipath_gpio_lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * IB link and linktraining states and masks that vary per chip in</span>
<span class="cm">	 * some way.  Set at init, to avoid each IB status change interrupt</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">ibcs_ls_shift</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ibcs_lts_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ibcs_mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ib_init</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ib_arm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ib_active</span><span class="p">;</span>

	<span class="n">u16</span> <span class="n">ipath_rhf_offset</span><span class="p">;</span> <span class="cm">/* offset of RHF within receive header entry */</span>

	<span class="cm">/*</span>
<span class="cm">	 * shift/mask for linkcmd, linkinitcmd, maxpktlen in ibccontol</span>
<span class="cm">	 * reg. Changes for IBA7220</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">ibcc_lic_mask</span><span class="p">;</span> <span class="cm">/* LinkInitCmd */</span>
	<span class="n">u8</span> <span class="n">ibcc_lc_shift</span><span class="p">;</span> <span class="cm">/* LinkCmd */</span>
	<span class="n">u8</span> <span class="n">ibcc_mpl_shift</span><span class="p">;</span> <span class="cm">/* Maxpktlen */</span>

	<span class="n">u8</span> <span class="n">delay_mult</span><span class="p">;</span>

	<span class="cm">/* used to override LED behavior */</span>
	<span class="n">u8</span> <span class="n">ipath_led_override</span><span class="p">;</span>  <span class="cm">/* Substituted for normal value, if non-zero */</span>
	<span class="n">u16</span> <span class="n">ipath_led_override_timeoff</span><span class="p">;</span> <span class="cm">/* delta to next timer event */</span>
	<span class="n">u8</span> <span class="n">ipath_led_override_vals</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* Alternates per blink-frame */</span>
	<span class="n">u8</span> <span class="n">ipath_led_override_phase</span><span class="p">;</span> <span class="cm">/* Just counts, LSB picks from vals[] */</span>
	<span class="n">atomic_t</span> <span class="n">ipath_led_override_timer_active</span><span class="p">;</span>
	<span class="cm">/* Used to flash LEDs in override mode */</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">ipath_led_override_timer</span><span class="p">;</span>

	<span class="cm">/* Support (including locks) for EEPROM logging of errors and time */</span>
	<span class="cm">/* control access to actual counters, timer */</span>
	<span class="n">spinlock_t</span> <span class="n">ipath_eep_st_lock</span><span class="p">;</span>
	<span class="cm">/* control high-level access to EEPROM */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">ipath_eep_lock</span><span class="p">;</span>
	<span class="cm">/* Below inc&#39;d by ipath_snap_cntrs(), locked by ipath_eep_st_lock */</span>
	<span class="kt">uint64_t</span> <span class="n">ipath_traffic_wds</span><span class="p">;</span>
	<span class="cm">/* active time is kept in seconds, but logged in hours */</span>
	<span class="n">atomic_t</span> <span class="n">ipath_active_time</span><span class="p">;</span>
	<span class="cm">/* Below are nominal shadow of EEPROM, new since last EEPROM update */</span>
	<span class="kt">uint8_t</span> <span class="n">ipath_eep_st_errs</span><span class="p">[</span><span class="n">IPATH_EEP_LOG_CNT</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">ipath_eep_st_new_errs</span><span class="p">[</span><span class="n">IPATH_EEP_LOG_CNT</span><span class="p">];</span>
	<span class="kt">uint16_t</span> <span class="n">ipath_eep_hrs</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * masks for which bits of errs, hwerrs that cause</span>
<span class="cm">	 * each of the counters to increment.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">ipath_eep_log_mask</span> <span class="n">ipath_eep_st_masks</span><span class="p">[</span><span class="n">IPATH_EEP_LOG_CNT</span><span class="p">];</span>

	<span class="cm">/* interrupt mitigation reload register info */</span>
	<span class="n">u16</span> <span class="n">ipath_jint_idle_ticks</span><span class="p">;</span>	<span class="cm">/* idle clock ticks */</span>
	<span class="n">u16</span> <span class="n">ipath_jint_max_packets</span><span class="p">;</span>	<span class="cm">/* max packets across all ports */</span>

	<span class="cm">/*</span>
<span class="cm">	 * lock for access to SerDes, and flags to sequence preset</span>
<span class="cm">	 * versus steady-state. 7220-only at the moment.</span>
<span class="cm">	 */</span>
	<span class="n">spinlock_t</span> <span class="n">ipath_sdepb_lock</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipath_presets_needed</span><span class="p">;</span> <span class="cm">/* Set if presets to be restored next DOWN */</span>
<span class="p">};</span>

<span class="cm">/* ipath_hol_state values (stopping/starting user proc, send flushing) */</span>
<span class="cp">#define IPATH_HOL_UP       0</span>
<span class="cp">#define IPATH_HOL_DOWN     1</span>
<span class="cm">/* ipath_hol_next toggle values, used when hol_state IPATH_HOL_DOWN */</span>
<span class="cp">#define IPATH_HOL_DOWNSTOP 0</span>
<span class="cp">#define IPATH_HOL_DOWNCONT 1</span>

<span class="cm">/* bit positions for sdma_status */</span>
<span class="cp">#define IPATH_SDMA_ABORTING  0</span>
<span class="cp">#define IPATH_SDMA_DISARMED  1</span>
<span class="cp">#define IPATH_SDMA_DISABLED  2</span>
<span class="cp">#define IPATH_SDMA_LAYERBUF  3</span>
<span class="cp">#define IPATH_SDMA_RUNNING  30</span>
<span class="cp">#define IPATH_SDMA_SHUTDOWN 31</span>

<span class="cm">/* bit combinations that correspond to abort states */</span>
<span class="cp">#define IPATH_SDMA_ABORT_NONE 0</span>
<span class="cp">#define IPATH_SDMA_ABORT_ABORTING (1UL &lt;&lt; IPATH_SDMA_ABORTING)</span>
<span class="cp">#define IPATH_SDMA_ABORT_DISARMED ((1UL &lt;&lt; IPATH_SDMA_ABORTING) | \</span>
<span class="cp">	(1UL &lt;&lt; IPATH_SDMA_DISARMED))</span>
<span class="cp">#define IPATH_SDMA_ABORT_DISABLED ((1UL &lt;&lt; IPATH_SDMA_ABORTING) | \</span>
<span class="cp">	(1UL &lt;&lt; IPATH_SDMA_DISABLED))</span>
<span class="cp">#define IPATH_SDMA_ABORT_ABORTED ((1UL &lt;&lt; IPATH_SDMA_ABORTING) | \</span>
<span class="cp">	(1UL &lt;&lt; IPATH_SDMA_DISARMED) | (1UL &lt;&lt; IPATH_SDMA_DISABLED))</span>
<span class="cp">#define IPATH_SDMA_ABORT_MASK ((1UL&lt;&lt;IPATH_SDMA_ABORTING) | \</span>
<span class="cp">	(1UL &lt;&lt; IPATH_SDMA_DISARMED) | (1UL &lt;&lt; IPATH_SDMA_DISABLED))</span>

<span class="cp">#define IPATH_SDMA_BUF_NONE 0</span>
<span class="cp">#define IPATH_SDMA_BUF_MASK (1UL&lt;&lt;IPATH_SDMA_LAYERBUF)</span>

<span class="cm">/* Private data for file operations */</span>
<span class="k">struct</span> <span class="n">ipath_filedata</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">subport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tidcursor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipath_user_sdma_queue</span> <span class="o">*</span><span class="n">pq</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">ipath_dev_list</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">spinlock_t</span> <span class="n">ipath_devs_lock</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">ipath_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ipath_init_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_enable_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_disable_wc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_count_units</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">npresentp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nupp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">maxportsp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_shutdown_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_clear_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">file_operations</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ipath_cdev_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">minor</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">cdev</span> <span class="o">**</span><span class="n">cdevp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">**</span><span class="n">devp</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_cdev_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cdev</span> <span class="o">**</span><span class="n">cdevp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device</span> <span class="o">**</span><span class="n">devp</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ipath_diag_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_diag_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">wait_queue_head_t</span> <span class="n">ipath_state_wait</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">ipath_user_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_user_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ipath_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">gfp_t</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">ipath_diag_inuse</span><span class="p">;</span>

<span class="n">irqreturn_t</span> <span class="n">ipath_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devid</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_decode_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">blen</span><span class="p">,</span>
		     <span class="n">ipath_err_t</span> <span class="n">err</span><span class="p">);</span>
<span class="cp">#if __IPATH_INFO || __IPATH_DBG</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ipath_ibcstatus_str</span><span class="p">[];</span>
<span class="cp">#endif</span>

<span class="cm">/* clean up any per-chip chip-specific stuff */</span>
<span class="kt">void</span> <span class="n">ipath_chip_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* clean up any chip type-specific stuff */</span>
<span class="kt">void</span> <span class="n">ipath_chip_done</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* check to see if we have to force ordering for write combining */</span>
<span class="kt">int</span> <span class="n">ipath_unordered_wc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ipath_disarm_piobufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">first</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_cancel_sends</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ipath_create_rcvhdrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_free_pddata</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ipath_parse_ushort</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">valp</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ipath_kreceive</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_setrcvhdrsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_reset_device</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_get_faststats</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_wait_linkstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_set_linkstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_set_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u16</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_set_lid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u8</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_set_rx_pol_inv</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">new_pol_inv</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_enable_armlaunch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_disable_armlaunch</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_hol_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_hol_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_hol_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_toggle_rclkrls</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_sd7220_clr_ibpar</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_set_relock_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_shutdown_relock_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* for use in system calls, where we want to know device type, etc. */</span>
<span class="cp">#define port_fp(fp) ((struct ipath_filedata *)(fp)-&gt;private_data)-&gt;pd</span>
<span class="cp">#define subport_fp(fp) \</span>
<span class="cp">	((struct ipath_filedata *)(fp)-&gt;private_data)-&gt;subport</span>
<span class="cp">#define tidcursor_fp(fp) \</span>
<span class="cp">	((struct ipath_filedata *)(fp)-&gt;private_data)-&gt;tidcursor</span>
<span class="cp">#define user_sdma_queue_fp(fp) \</span>
<span class="cp">	((struct ipath_filedata *)(fp)-&gt;private_data)-&gt;pq</span>

<span class="cm">/*</span>
<span class="cm"> * values for ipath_flags</span>
<span class="cm"> */</span>
		<span class="cm">/* chip can report link latency (IB 1.2) */</span>
<span class="cp">#define IPATH_HAS_LINK_LATENCY 0x1</span>
		<span class="cm">/* The chip is up and initted */</span>
<span class="cp">#define IPATH_INITTED       0x2</span>
		<span class="cm">/* set if any user code has set kr_rcvhdrsize */</span>
<span class="cp">#define IPATH_RCVHDRSZ_SET  0x4</span>
		<span class="cm">/* The chip is present and valid for accesses */</span>
<span class="cp">#define IPATH_PRESENT       0x8</span>
		<span class="cm">/* HT link0 is only 8 bits wide, ignore upper byte crc</span>
<span class="cm">		 * errors, etc. */</span>
<span class="cp">#define IPATH_8BIT_IN_HT0   0x10</span>
		<span class="cm">/* HT link1 is only 8 bits wide, ignore upper byte crc</span>
<span class="cm">		 * errors, etc. */</span>
<span class="cp">#define IPATH_8BIT_IN_HT1   0x20</span>
		<span class="cm">/* The link is down */</span>
<span class="cp">#define IPATH_LINKDOWN      0x40</span>
		<span class="cm">/* The link level is up (0x11) */</span>
<span class="cp">#define IPATH_LINKINIT      0x80</span>
		<span class="cm">/* The link is in the armed (0x21) state */</span>
<span class="cp">#define IPATH_LINKARMED     0x100</span>
		<span class="cm">/* The link is in the active (0x31) state */</span>
<span class="cp">#define IPATH_LINKACTIVE    0x200</span>
		<span class="cm">/* link current state is unknown */</span>
<span class="cp">#define IPATH_LINKUNK       0x400</span>
		<span class="cm">/* Write combining flush needed for PIO */</span>
<span class="cp">#define IPATH_PIO_FLUSH_WC  0x1000</span>
		<span class="cm">/* DMA Receive tail pointer */</span>
<span class="cp">#define IPATH_NODMA_RTAIL   0x2000</span>
		<span class="cm">/* no IB cable, or no device on IB cable */</span>
<span class="cp">#define IPATH_NOCABLE       0x4000</span>
		<span class="cm">/* Supports port zero per packet receive interrupts via</span>
<span class="cm">		 * GPIO */</span>
<span class="cp">#define IPATH_GPIO_INTR     0x8000</span>
		<span class="cm">/* uses the coded 4byte TID, not 8 byte */</span>
<span class="cp">#define IPATH_4BYTE_TID     0x10000</span>
		<span class="cm">/* packet/word counters are 32 bit, else those 4 counters</span>
<span class="cm">		 * are 64bit */</span>
<span class="cp">#define IPATH_32BITCOUNTERS 0x20000</span>
		<span class="cm">/* Interrupt register is 64 bits */</span>
<span class="cp">#define IPATH_INTREG_64     0x40000</span>
		<span class="cm">/* can miss port0 rx interrupts */</span>
<span class="cp">#define IPATH_DISABLED      0x80000 </span><span class="cm">/* administratively disabled */</span><span class="cp"></span>
		<span class="cm">/* Use GPIO interrupts for new counters */</span>
<span class="cp">#define IPATH_GPIO_ERRINTRS 0x100000</span>
<span class="cp">#define IPATH_SWAP_PIOBUFS  0x200000</span>
		<span class="cm">/* Supports Send DMA */</span>
<span class="cp">#define IPATH_HAS_SEND_DMA  0x400000</span>
		<span class="cm">/* Supports Send Count (not just word count) in PBC */</span>
<span class="cp">#define IPATH_HAS_PBC_CNT   0x800000</span>
		<span class="cm">/* Suppress heartbeat, even if turning off loopback */</span>
<span class="cp">#define IPATH_NO_HRTBT      0x1000000</span>
<span class="cp">#define IPATH_HAS_THRESH_UPDATE 0x4000000</span>
<span class="cp">#define IPATH_HAS_MULT_IB_SPEED 0x8000000</span>
<span class="cp">#define IPATH_IB_AUTONEG_INPROG 0x10000000</span>
<span class="cp">#define IPATH_IB_AUTONEG_FAILED 0x20000000</span>
		<span class="cm">/* Linkdown-disable intentionally, Do not attempt to bring up */</span>
<span class="cp">#define IPATH_IB_LINK_DISABLED 0x40000000</span>
<span class="cp">#define IPATH_IB_FORCE_NOTIFY 0x80000000 </span><span class="cm">/* force notify on next ib change */</span><span class="cp"></span>

<span class="cm">/* Bits in GPIO for the added interrupts */</span>
<span class="cp">#define IPATH_GPIO_PORT0_BIT 2</span>
<span class="cp">#define IPATH_GPIO_RXUVL_BIT 3</span>
<span class="cp">#define IPATH_GPIO_OVRUN_BIT 4</span>
<span class="cp">#define IPATH_GPIO_LLI_BIT 5</span>
<span class="cp">#define IPATH_GPIO_ERRINTR_MASK 0x38</span>

<span class="cm">/* portdata flag bit offsets */</span>
		<span class="cm">/* waiting for a packet to arrive */</span>
<span class="cp">#define IPATH_PORT_WAITING_RCV   2</span>
		<span class="cm">/* master has not finished initializing */</span>
<span class="cp">#define IPATH_PORT_MASTER_UNINIT 4</span>
		<span class="cm">/* waiting for an urgent packet to arrive */</span>
<span class="cp">#define IPATH_PORT_WAITING_URG 5</span>

<span class="cm">/* free up any allocated data at closes */</span>
<span class="kt">void</span> <span class="n">ipath_free_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ipath_getpiobuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u32</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_chg_pioavailkernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">start</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_init_iba6110_funcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_get_eeprom_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_update_eeprom_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_inc_eeprom_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">eidx</span><span class="p">,</span> <span class="n">u32</span> <span class="n">incr</span><span class="p">);</span>
<span class="n">u64</span> <span class="n">ipath_snap_cntr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">ipath_creg</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_disarm_senderrbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_force_pio_avail_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">signal_ib_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ib_event_type</span> <span class="n">ev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Set LED override, only the two LSBs have &quot;public&quot; meaning, but</span>
<span class="cm"> * any non-zero value substitutes them for the Link and LinkTrain</span>
<span class="cm"> * LED states.</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_LED_PHYS 1 </span><span class="cm">/* Physical (linktraining) GREEN LED */</span><span class="cp"></span>
<span class="cp">#define IPATH_LED_LOG 2  </span><span class="cm">/* Logical (link) YELLOW LED */</span><span class="cp"></span>
<span class="kt">void</span> <span class="n">ipath_set_led_override</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="cm">/* send dma routines */</span>
<span class="kt">int</span> <span class="n">setup_sdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">teardown_sdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_restart_sdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_sdma_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_sdma_verbs_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipath_sge_state</span> <span class="o">*</span><span class="p">,</span>
			  <span class="n">u32</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipath_verbs_txreq</span> <span class="o">*</span><span class="p">);</span>
<span class="cm">/* ipath_sdma_lock should be locked before calling this. */</span>
<span class="kt">int</span> <span class="n">ipath_sdma_make_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">);</span>

<span class="cm">/* must be called under ipath_sdma_lock */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">ipath_sdma_descq_freecnt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_descq_cnt</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_descq_added</span> <span class="o">-</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_descq_removed</span><span class="p">)</span> <span class="o">-</span>
		<span class="mi">1</span> <span class="o">-</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_desc_nreserved</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipath_sdma_desc_reserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_desc_nreserved</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipath_sdma_desc_unreserve</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u16</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_sdma_desc_nreserved</span> <span class="o">-=</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * number of words used for protocol header if not set by ipath_userinit();</span>
<span class="cm"> */</span>
<span class="cp">#define IPATH_DFLT_RCVHDRSIZE 9</span>

<span class="kt">int</span> <span class="n">ipath_get_user_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_release_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_release_user_pages_on_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_eeprom_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_eeprom_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_tempsense_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">regnum</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_tempsense_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">regnum</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data</span><span class="p">);</span>

<span class="cm">/* these are used for the registers that vary with port */</span>
<span class="kt">void</span> <span class="n">ipath_write_kreg_port</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">,</span> <span class="n">ipath_kreg</span><span class="p">,</span>
			   <span class="kt">unsigned</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * We could have a single register get/put routine, that takes a group type,</span>
<span class="cm"> * but this is somewhat clearer and cleaner.  It also gives us some error</span>
<span class="cm"> * checking.  64 bit register reads should always work, but are inefficient</span>
<span class="cm"> * on opteron (the northbridge always generates 2 separate HT 32 bit reads),</span>
<span class="cm"> * so we use kreg32 wherever possible.  User register and counter register</span>
<span class="cm"> * reads are always 32 bit reads, so only one form of those routines.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * At the moment, none of the s-registers are writable, so no</span>
<span class="cm"> * ipath_write_sreg().</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_read_ureg32 - read 32-bit virtualized per-port register</span>
<span class="cm"> * @dd: device</span>
<span class="cm"> * @regno: register number</span>
<span class="cm"> * @port: port number</span>
<span class="cm"> *</span>
<span class="cm"> * Return the contents of a register that is virtualized to be per port.</span>
<span class="cm"> * Returns -1 on errors (not distinguishable from valid contents at</span>
<span class="cm"> * runtime; we may add a separate error variable at some point).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipath_read_ureg32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				    <span class="n">ipath_ureg</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_PRESENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">regno</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		     <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uregbase</span> <span class="o">+</span>
		      <span class="p">(</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">+</span>
		      <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ureg_align</span> <span class="o">*</span> <span class="n">port</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ipath_write_ureg - write 32-bit virtualized per-port register</span>
<span class="cm"> * @dd: device</span>
<span class="cm"> * @regno: register number</span>
<span class="cm"> * @value: value</span>
<span class="cm"> * @port: port</span>
<span class="cm"> *</span>
<span class="cm"> * Write the contents of a register that is virtualized to be per port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipath_write_ureg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				    <span class="n">ipath_ureg</span> <span class="n">regno</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ubase</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_uregbase</span> <span class="o">+</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">+</span>
		 <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_ureg_align</span> <span class="o">*</span> <span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">)</span>
		<span class="n">writeq</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ubase</span><span class="p">[</span><span class="n">regno</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipath_read_kreg32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				    <span class="n">ipath_kreg</span> <span class="n">regno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_PRESENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">((</span><span class="n">u32</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">[</span><span class="n">regno</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ipath_read_kreg64</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				    <span class="n">ipath_kreg</span> <span class="n">regno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_PRESENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">readq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">[</span><span class="n">regno</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipath_write_kreg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				    <span class="n">ipath_kreg</span> <span class="n">regno</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">)</span>
		<span class="n">writeq</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">[</span><span class="n">regno</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ipath_read_creg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				  <span class="n">ipath_sreg</span> <span class="n">regno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_PRESENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">readq</span><span class="p">(</span><span class="n">regno</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		     <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cregbase</span> <span class="o">+</span>
		      <span class="p">(</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipath_read_creg32</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
					 <span class="n">ipath_sreg</span> <span class="n">regno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_PRESENT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">regno</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		     <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cregbase</span> <span class="o">+</span>
		      <span class="p">(</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipath_write_creg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span>
				    <span class="n">ipath_creg</span> <span class="n">regno</span><span class="p">,</span> <span class="n">u64</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">)</span>
		<span class="n">writeq</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">regno</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
		       <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_cregbase</span> <span class="o">+</span>
			<span class="p">(</span><span class="kt">char</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_kregbase</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ipath_clear_rcvhdrtail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">((</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0ULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipath_get_rcvhdrtail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">__le64</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrtail_kvaddr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipath_get_hdrqtail</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_portdata</span> <span class="o">*</span><span class="n">pd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_dd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hdrqtail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_NODMA_RTAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="o">*</span><span class="n">rhf_addr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">seq</span><span class="p">;</span>

		<span class="n">rhf_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_rcvhdrq</span> <span class="o">+</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_head</span> <span class="o">+</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_rhf_offset</span><span class="p">;</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">ipath_hdrget_seq</span><span class="p">(</span><span class="n">rhf_addr</span><span class="p">);</span>
		<span class="n">hdrqtail</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_head</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">==</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">port_seq_cnt</span><span class="p">)</span>
			<span class="n">hdrqtail</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">hdrqtail</span> <span class="o">=</span> <span class="n">ipath_get_rcvhdrtail</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hdrqtail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">ipath_read_ireg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">ipath_kreg</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">dd</span><span class="o">-&gt;</span><span class="n">ipath_flags</span> <span class="o">&amp;</span> <span class="n">IPATH_INTREG_64</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">ipath_read_kreg64</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">ipath_read_kreg32</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * from contents of IBCStatus (or a saved copy), return linkstate</span>
<span class="cm"> * Report ACTIVE_DEFER as ACTIVE, because we treat them the same</span>
<span class="cm"> * everywhere, anyway (and should be, for almost all purposes).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipath_ib_linkstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ibcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">ibcs</span> <span class="o">&gt;&gt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ibcs_ls_shift</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">INFINIPATH_IBCS_LINKSTATE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">INFINIPATH_IBCS_L_STATE_ACT_DEFER</span><span class="p">)</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">INFINIPATH_IBCS_L_STATE_ACTIVE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* from contents of IBCStatus (or a saved copy), return linktrainingstate */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipath_ib_linktrstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ibcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">ibcs</span> <span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ibcs_lts_mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * from contents of IBCStatus (or a saved copy), return logical link state</span>
<span class="cm"> * combination of link state and linktraining state (down, active, init,</span>
<span class="cm"> * arm, etc.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ipath_ib_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="n">dd</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ibcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ibs</span><span class="p">;</span>
	<span class="n">ibs</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">ibcs</span> <span class="o">&gt;&gt;</span> <span class="n">INFINIPATH_IBCS_LINKTRAININGSTATE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="n">dd</span><span class="o">-&gt;</span><span class="n">ibcs_lts_mask</span><span class="p">;</span>
	<span class="n">ibs</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">ibcs</span> <span class="o">&amp;</span>
		<span class="p">(</span><span class="n">INFINIPATH_IBCS_LINKSTATE_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">dd</span><span class="o">-&gt;</span><span class="n">ibcs_ls_shift</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">ibs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sysfs interface.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">device_driver</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ib_ipath_version</span><span class="p">[];</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">ipath_driver_attr_groups</span><span class="p">[];</span>

<span class="kt">int</span> <span class="n">ipath_device_create_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_device_remove_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipath_expose_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ipath_init_ipathfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ipath_exit_ipathfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipathfs_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ipathfs_remove_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipath_devdata</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * dma_addr wrappers - all 0&#39;s invalid for hw</span>
<span class="cm"> */</span>
<span class="n">dma_addr_t</span> <span class="n">ipath_map_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
			  <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">dma_addr_t</span> <span class="n">ipath_map_single</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ipath_get_unit_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">unit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Flush write combining store buffers (if present) and perform a write</span>
<span class="cm"> * barrier.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_X86_64)</span>
<span class="cp">#define ipath_flush_wc() asm volatile(&quot;sfence&quot; ::: &quot;memory&quot;)</span>
<span class="cp">#else</span>
<span class="cp">#define ipath_flush_wc() wmb()</span>
<span class="cp">#endif</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">ipath_debug</span><span class="p">;</span> <span class="cm">/* debugging bit mask */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">ipath_linkrecovery</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">ipath_mtu4096</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">ipath_mutex</span><span class="p">;</span>

<span class="cp">#define IPATH_DRV_NAME		&quot;ib_ipath&quot;</span>
<span class="cp">#define IPATH_MAJOR		233</span>
<span class="cp">#define IPATH_USER_MINOR_BASE	0</span>
<span class="cp">#define IPATH_DIAGPKT_MINOR	127</span>
<span class="cp">#define IPATH_DIAG_MINOR_BASE	129</span>
<span class="cp">#define IPATH_NMINORS		255</span>

<span class="cp">#define ipath_dev_err(dd,fmt,...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		const struct ipath_devdata *__dd = (dd); \</span>
<span class="cp">		if (__dd-&gt;pcidev) \</span>
<span class="cp">			dev_err(&amp;__dd-&gt;pcidev-&gt;dev, &quot;%s: &quot; fmt, \</span>
<span class="cp">				ipath_get_unit_name(__dd-&gt;ipath_unit), \</span>
<span class="cp">				##__VA_ARGS__); \</span>
<span class="cp">		else \</span>
<span class="cp">			printk(KERN_ERR IPATH_DRV_NAME &quot;: %s: &quot; fmt, \</span>
<span class="cp">			       ipath_get_unit_name(__dd-&gt;ipath_unit), \</span>
<span class="cp">			       ##__VA_ARGS__); \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#if _IPATH_DEBUGGING</span>

<span class="cp"># define __IPATH_DBG_WHICH(which,fmt,...) \</span>
<span class="cp">	do { \</span>
<span class="cp">		if (unlikely(ipath_debug &amp; (which))) \</span>
<span class="cp">			printk(KERN_DEBUG IPATH_DRV_NAME &quot;: %s: &quot; fmt, \</span>
<span class="cp">			       __func__,##__VA_ARGS__); \</span>
<span class="cp">	} while(0)</span>

<span class="cp"># define ipath_dbg(fmt,...) \</span>
<span class="cp">	__IPATH_DBG_WHICH(__IPATH_DBG,fmt,##__VA_ARGS__)</span>
<span class="cp"># define ipath_cdbg(which,fmt,...) \</span>
<span class="cp">	__IPATH_DBG_WHICH(__IPATH_##which##DBG,fmt,##__VA_ARGS__)</span>

<span class="cp">#else </span><span class="cm">/* ! _IPATH_DEBUGGING */</span><span class="cp"></span>

<span class="cp"># define ipath_dbg(fmt,...)</span>
<span class="cp"># define ipath_cdbg(which,fmt,...)</span>

<span class="cp">#endif </span><span class="cm">/* _IPATH_DEBUGGING */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * this is used for formatting hw error messages...</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ipath_hwerror_msgs</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define INFINIPATH_HWE_MSG(a, b) { .mask = INFINIPATH_HWE_##a, .msg = b }</span>

<span class="cm">/* in ipath_intr.c... */</span>
<span class="kt">void</span> <span class="n">ipath_format_hwerrors</span><span class="p">(</span><span class="n">u64</span> <span class="n">hwerrs</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">ipath_hwerror_msgs</span> <span class="o">*</span><span class="n">hwerrmsgs</span><span class="p">,</span>
			   <span class="kt">size_t</span> <span class="n">nhwerrmsgs</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">lmsg</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* _IPATH_KERNEL_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
