<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › hw › ehca › ehca_qp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>ehca_qp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  IBM eServer eHCA Infiniband device driver for Linux on POWER</span>
<span class="cm"> *</span>
<span class="cm"> *  QP functions</span>
<span class="cm"> *</span>
<span class="cm"> *  Authors: Joachim Fenkes &lt;fenkes@de.ibm.com&gt;</span>
<span class="cm"> *           Stefan Roscher &lt;stefan.roscher@de.ibm.com&gt;</span>
<span class="cm"> *           Waleri Fomin &lt;fomin@de.ibm.com&gt;</span>
<span class="cm"> *           Hoang-Nam Nguyen &lt;hnguyen@de.ibm.com&gt;</span>
<span class="cm"> *           Reinhard Ernst &lt;rernst@de.ibm.com&gt;</span>
<span class="cm"> *           Heiko J Schick &lt;schickhj@de.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2005 IBM Corporation</span>
<span class="cm"> *</span>
<span class="cm"> *  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *  This source code is distributed under a dual license of GPL v2.0 and OpenIB</span>
<span class="cm"> *  BSD.</span>
<span class="cm"> *</span>
<span class="cm"> * OpenIB BSD License</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> * Redistributions of source code must retain the above copyright notice, this</span>
<span class="cm"> * list of conditions and the following disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="cm"> * this list of conditions and the following disclaimer in the documentation</span>
<span class="cm"> * and/or other materials</span>
<span class="cm"> * provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="cm"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span>
<span class="cm"> * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER</span>
<span class="cm"> * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;ehca_classes.h&quot;</span>
<span class="cp">#include &quot;ehca_tools.h&quot;</span>
<span class="cp">#include &quot;ehca_qes.h&quot;</span>
<span class="cp">#include &quot;ehca_iverbs.h&quot;</span>
<span class="cp">#include &quot;hcp_if.h&quot;</span>
<span class="cp">#include &quot;hipz_fns.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">qp_cache</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * attributes not supported by query qp</span>
<span class="cm"> */</span>
<span class="cp">#define QP_ATTR_QUERY_NOT_SUPPORTED (IB_QP_ACCESS_FLAGS       | \</span>
<span class="cp">				     IB_QP_EN_SQD_ASYNC_NOTIFY)</span>

<span class="cm">/*</span>
<span class="cm"> * ehca (internal) qp state values</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ehca_qp_state</span> <span class="p">{</span>
	<span class="n">EHCA_QPS_RESET</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">EHCA_QPS_INIT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">EHCA_QPS_RTR</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">EHCA_QPS_RTS</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">EHCA_QPS_SQD</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">EHCA_QPS_SQE</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">EHCA_QPS_ERR</span> <span class="o">=</span> <span class="mi">128</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * qp state transitions as defined by IB Arch Rel 1.1 page 431</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ib_qp_statetrans</span> <span class="p">{</span>
	<span class="n">IB_QPST_ANY2RESET</span><span class="p">,</span>
	<span class="n">IB_QPST_ANY2ERR</span><span class="p">,</span>
	<span class="n">IB_QPST_RESET2INIT</span><span class="p">,</span>
	<span class="n">IB_QPST_INIT2RTR</span><span class="p">,</span>
	<span class="n">IB_QPST_INIT2INIT</span><span class="p">,</span>
	<span class="n">IB_QPST_RTR2RTS</span><span class="p">,</span>
	<span class="n">IB_QPST_RTS2SQD</span><span class="p">,</span>
	<span class="n">IB_QPST_RTS2RTS</span><span class="p">,</span>
	<span class="n">IB_QPST_SQD2RTS</span><span class="p">,</span>
	<span class="n">IB_QPST_SQE2RTS</span><span class="p">,</span>
	<span class="n">IB_QPST_SQD2SQD</span><span class="p">,</span>
	<span class="n">IB_QPST_MAX</span>	<span class="cm">/* nr of transitions, this must be last!!! */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ib2ehca_qp_state maps IB to ehca qp_state</span>
<span class="cm"> * returns ehca qp state corresponding to given ib qp state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">ehca_qp_state</span> <span class="nf">ib2ehca_qp_state</span><span class="p">(</span><span class="k">enum</span> <span class="n">ib_qp_state</span> <span class="n">ib_qp_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ib_qp_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_QPS_RESET</span>:
		<span class="k">return</span> <span class="n">EHCA_QPS_RESET</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_INIT</span>:
		<span class="k">return</span> <span class="n">EHCA_QPS_INIT</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_RTR</span>:
		<span class="k">return</span> <span class="n">EHCA_QPS_RTR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_RTS</span>:
		<span class="k">return</span> <span class="n">EHCA_QPS_RTS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_SQD</span>:
		<span class="k">return</span> <span class="n">EHCA_QPS_SQD</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_SQE</span>:
		<span class="k">return</span> <span class="n">EHCA_QPS_SQE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_ERR</span>:
		<span class="k">return</span> <span class="n">EHCA_QPS_ERR</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ehca_gen_err</span><span class="p">(</span><span class="s">&quot;invalid ib_qp_state=%x&quot;</span><span class="p">,</span> <span class="n">ib_qp_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ehca2ib_qp_state maps ehca to IB qp_state</span>
<span class="cm"> * returns ib qp state corresponding to given ehca qp state</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">ib_qp_state</span> <span class="nf">ehca2ib_qp_state</span><span class="p">(</span><span class="k">enum</span> <span class="n">ehca_qp_state</span>
						<span class="n">ehca_qp_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ehca_qp_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EHCA_QPS_RESET</span>:
		<span class="k">return</span> <span class="n">IB_QPS_RESET</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EHCA_QPS_INIT</span>:
		<span class="k">return</span> <span class="n">IB_QPS_INIT</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EHCA_QPS_RTR</span>:
		<span class="k">return</span> <span class="n">IB_QPS_RTR</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EHCA_QPS_RTS</span>:
		<span class="k">return</span> <span class="n">IB_QPS_RTS</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EHCA_QPS_SQD</span>:
		<span class="k">return</span> <span class="n">IB_QPS_SQD</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EHCA_QPS_SQE</span>:
		<span class="k">return</span> <span class="n">IB_QPS_SQE</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EHCA_QPS_ERR</span>:
		<span class="k">return</span> <span class="n">IB_QPS_ERR</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ehca_gen_err</span><span class="p">(</span><span class="s">&quot;invalid ehca_qp_state=%x&quot;</span><span class="p">,</span> <span class="n">ehca_qp_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ehca_qp_type used as index for req_attr and opt_attr of</span>
<span class="cm"> * struct ehca_modqp_statetrans</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">ehca_qp_type</span> <span class="p">{</span>
	<span class="n">QPT_RC</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">QPT_UC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">QPT_UD</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">QPT_SQP</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="n">QPT_MAX</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ib2ehcaqptype maps Ib to ehca qp_type</span>
<span class="cm"> * returns ehca qp type corresponding to ib qp type</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">ehca_qp_type</span> <span class="nf">ib2ehcaqptype</span><span class="p">(</span><span class="k">enum</span> <span class="n">ib_qp_type</span> <span class="n">ibqptype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ibqptype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_QPT_SMI</span>:
	<span class="k">case</span> <span class="n">IB_QPT_GSI</span>:
		<span class="k">return</span> <span class="n">QPT_SQP</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_RC</span>:
		<span class="k">return</span> <span class="n">QPT_RC</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_UC</span>:
		<span class="k">return</span> <span class="n">QPT_UC</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_UD</span>:
		<span class="k">return</span> <span class="n">QPT_UD</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ehca_gen_err</span><span class="p">(</span><span class="s">&quot;Invalid ibqptype=%x&quot;</span><span class="p">,</span> <span class="n">ibqptype</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">ib_qp_statetrans</span> <span class="nf">get_modqp_statetrans</span><span class="p">(</span><span class="kt">int</span> <span class="n">ib_fromstate</span><span class="p">,</span>
							 <span class="kt">int</span> <span class="n">ib_tostate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ib_tostate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_QPS_RESET</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_ANY2RESET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_INIT</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">ib_fromstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IB_QPS_RESET</span>:
			<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_RESET2INIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IB_QPS_INIT</span>:
			<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_INIT2INIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_RTR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ib_fromstate</span> <span class="o">==</span> <span class="n">IB_QPS_INIT</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_INIT2RTR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_RTS</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">ib_fromstate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IB_QPS_RTR</span>:
			<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_RTR2RTS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IB_QPS_RTS</span>:
			<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_RTS2RTS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IB_QPS_SQD</span>:
			<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_SQD2RTS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IB_QPS_SQE</span>:
			<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_SQE2RTS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_SQD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ib_fromstate</span> <span class="o">==</span> <span class="n">IB_QPS_RTS</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_RTS2SQD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_SQE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_ERR</span>:
		<span class="n">index</span> <span class="o">=</span> <span class="n">IB_QPST_ANY2ERR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ibqptype2servicetype returns hcp service type corresponding to given</span>
<span class="cm"> * ib qp type used by create_qp()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ibqptype2servicetype</span><span class="p">(</span><span class="k">enum</span> <span class="n">ib_qp_type</span> <span class="n">ibqptype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ibqptype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_QPT_SMI</span>:
	<span class="k">case</span> <span class="n">IB_QPT_GSI</span>:
		<span class="k">return</span> <span class="n">ST_UD</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_RC</span>:
		<span class="k">return</span> <span class="n">ST_RC</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_UC</span>:
		<span class="k">return</span> <span class="n">ST_UC</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_UD</span>:
		<span class="k">return</span> <span class="n">ST_UD</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_RAW_IPV6</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_RAW_ETHERTYPE</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ehca_gen_err</span><span class="p">(</span><span class="s">&quot;Invalid ibqptype=%x&quot;</span><span class="p">,</span> <span class="n">ibqptype</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * init userspace queue info from ipz_queue data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">queue2resp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipzu_queue_resp</span> <span class="o">*</span><span class="n">resp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ipz_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">qe_size</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">qe_size</span><span class="p">;</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">act_nr_of_sg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">act_nr_of_sg</span><span class="p">;</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">queue_length</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">queue_length</span><span class="p">;</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">pagesize</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">pagesize</span><span class="p">;</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">toggle_state</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">toggle_state</span><span class="p">;</span>
	<span class="n">resp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * init_qp_queue initializes/constructs r/squeue and registers queue pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">init_qp_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ehca_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ipz_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">q_type</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">expected_hret</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ehca_alloc_queue_parms</span> <span class="o">*</span><span class="n">parms</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">wqe_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ipz_rc</span><span class="p">,</span> <span class="n">nr_q_pages</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">vpage</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rpage</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">ib_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipz_adapter_handle</span> <span class="n">ipz_hca_handle</span> <span class="o">=</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parms</span><span class="o">-&gt;</span><span class="n">queue_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parms</span><span class="o">-&gt;</span><span class="n">is_small</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_q_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ipz_rc</span> <span class="o">=</span> <span class="n">ipz_queue_ctor</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">nr_q_pages</span><span class="p">,</span>
					<span class="mi">128</span> <span class="o">&lt;&lt;</span> <span class="n">parms</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span>
					<span class="n">wqe_size</span><span class="p">,</span> <span class="n">parms</span><span class="o">-&gt;</span><span class="n">act_nr_sges</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">nr_q_pages</span> <span class="o">=</span> <span class="n">parms</span><span class="o">-&gt;</span><span class="n">queue_size</span><span class="p">;</span>
		<span class="n">ipz_rc</span> <span class="o">=</span> <span class="n">ipz_queue_ctor</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">nr_q_pages</span><span class="p">,</span>
					<span class="n">EHCA_PAGESIZE</span><span class="p">,</span> <span class="n">wqe_size</span><span class="p">,</span>
					<span class="n">parms</span><span class="o">-&gt;</span><span class="n">act_nr_sges</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipz_rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ib_dev</span><span class="p">,</span> <span class="s">&quot;Cannot allocate page for queue. ipz_rc=%i&quot;</span><span class="p">,</span>
			 <span class="n">ipz_rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* register queue pages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">nr_q_pages</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vpage</span> <span class="o">=</span> <span class="n">ipz_qpageit_get_inc</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vpage</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ib_dev</span><span class="p">,</span> <span class="s">&quot;ipz_qpageit_get_inc() &quot;</span>
				 <span class="s">&quot;failed p_vpage= %p&quot;</span><span class="p">,</span> <span class="n">vpage</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">init_qp_queue1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rpage</span> <span class="o">=</span> <span class="n">virt_to_abs</span><span class="p">(</span><span class="n">vpage</span><span class="p">);</span>

		<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_register_rpage_qp</span><span class="p">(</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
						 <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
						 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q_type</span><span class="p">,</span>
						 <span class="n">rpage</span><span class="p">,</span> <span class="n">parms</span><span class="o">-&gt;</span><span class="n">is_small</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
						 <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="p">(</span><span class="n">nr_q_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* last page! */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">expected_hret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">ib_dev</span><span class="p">,</span> <span class="s">&quot;hipz_qp_register_rpage() &quot;</span>
					 <span class="s">&quot;h_ret=%lli&quot;</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">init_qp_queue1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">vpage</span> <span class="o">=</span> <span class="n">ipz_qpageit_get_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vpage</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">ib_dev</span><span class="p">,</span> <span class="s">&quot;ipz_qpageit_get_inc() &quot;</span>
					 <span class="s">&quot;should not succeed vpage=%p&quot;</span><span class="p">,</span> <span class="n">vpage</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">init_qp_queue1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_PAGE_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">ib_dev</span><span class="p">,</span> <span class="s">&quot;hipz_qp_register_rpage() &quot;</span>
					 <span class="s">&quot;h_ret=%lli&quot;</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">init_qp_queue1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ipz_qeit_reset</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">init_qp_queue1:</span>
	<span class="n">ipz_queue_dtor</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ehca_calc_wqe_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">act_nr_sge</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_llqp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_llqp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">128</span> <span class="o">&lt;&lt;</span> <span class="n">act_nr_sge</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_wqe</span><span class="p">,</span>
				<span class="n">u</span><span class="p">.</span><span class="n">nud</span><span class="p">.</span><span class="n">sg_list</span><span class="p">[</span><span class="n">act_nr_sge</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ehca_determine_small_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_alloc_queue_parms</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">req_nr_sge</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_llqp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">wqe_size</span><span class="p">,</span> <span class="n">q_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">act_nr_sge</span> <span class="o">=</span> <span class="n">req_nr_sge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_llqp</span><span class="p">)</span>
		<span class="cm">/* round up #SGEs so WQE size is a power of 2 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">act_nr_sge</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">act_nr_sge</span> <span class="o">&lt;=</span> <span class="mi">252</span><span class="p">;</span>
		     <span class="n">act_nr_sge</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">act_nr_sge</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">act_nr_sge</span> <span class="o">&gt;=</span> <span class="n">req_nr_sge</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

	<span class="n">wqe_size</span> <span class="o">=</span> <span class="n">ehca_calc_wqe_size</span><span class="p">(</span><span class="n">act_nr_sge</span><span class="p">,</span> <span class="n">is_llqp</span><span class="p">);</span>
	<span class="n">q_size</span> <span class="o">=</span> <span class="n">wqe_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">max_wr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q_size</span> <span class="o">&lt;=</span> <span class="mi">512</span><span class="p">)</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">q_size</span> <span class="o">&lt;=</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">is_small</span> <span class="o">=</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* needs to be called with cq-&gt;spinlock held */</span>
<span class="kt">void</span> <span class="nf">ehca_add_to_err_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on_sq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="cm">/* TODO: support low latency QPs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">ext_type</span> <span class="o">==</span> <span class="n">EQPT_LLQP</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on_sq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">sqp_err_list</span><span class="p">;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">sq_err_node</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="o">-&gt;</span><span class="n">rqp_err_list</span><span class="p">;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">rq_err_node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">del_from_err_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_cq</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_queue_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_queue_map</span> <span class="o">*</span><span class="n">qmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">qmap</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">qmap</span><span class="o">-&gt;</span><span class="n">entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">qmap</span><span class="o">-&gt;</span><span class="n">left_to_poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">qmap</span><span class="o">-&gt;</span><span class="n">next_wqe_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qmap</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qmap</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">qmap</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cqe_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create an ib_qp struct that is either a QP or an SRQ, depending on</span>
<span class="cm"> * the value of the is_srq parameter. If init_attr and srq_init_attr share</span>
<span class="cm"> * fields, the field out of init_attr is used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="nf">internal_create_qp</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="o">*</span><span class="n">init_attr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ib_srq_init_attr</span> <span class="o">*</span><span class="n">srq_init_attr</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_srq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span><span class="p">,</span> <span class="o">*</span><span class="n">my_srq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehca_pd</span> <span class="o">*</span><span class="n">my_pd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_pd</span><span class="p">,</span> <span class="n">ib_pd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span><span class="p">,</span>
					      <span class="n">ib_device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ib_ucontext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">h_ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_llqp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">has_srq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">is_user</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qp_type</span><span class="p">,</span> <span class="n">max_send_sge</span><span class="p">,</span> <span class="n">max_recv_sge</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* h_call&#39;s out parameters */</span>
	<span class="k">struct</span> <span class="n">ehca_alloc_qp_parms</span> <span class="n">parms</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swqe_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rwqe_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ib_qp_num</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">max_num_qps</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Unable to create QP, max number of %i &quot;</span>
			 <span class="s">&quot;QPs reached.&quot;</span><span class="p">,</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">max_num_qps</span><span class="p">);</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;To increase the maximum number of QPs &quot;</span>
			 <span class="s">&quot;use the number_of_qps module parameter.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">create_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parms</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parms</span><span class="p">));</span>
	<span class="n">qp_type</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">qp_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">sq_sig_type</span> <span class="o">!=</span> <span class="n">IB_SIGNAL_REQ_WR</span> <span class="o">&amp;&amp;</span>
		<span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">sq_sig_type</span> <span class="o">!=</span> <span class="n">IB_SIGNAL_ALL_WR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;init_attr-&gt;sg_sig_type=%x not allowed&quot;</span><span class="p">,</span>
			 <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">sq_sig_type</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* save LLQP info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">is_llqp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">ext_type</span> <span class="o">=</span> <span class="n">EQPT_LLQP</span><span class="p">;</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">ll_comp_flags</span> <span class="o">=</span> <span class="n">qp_type</span> <span class="o">&amp;</span> <span class="n">LLQP_COMP_MASK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qp_type</span> <span class="o">&amp;=</span> <span class="mh">0x1F</span><span class="p">;</span>
	<span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">&amp;=</span> <span class="mh">0x1F</span><span class="p">;</span>

	<span class="cm">/* handle SRQ base QPs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">srq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">my_srq</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">srq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_srq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_UC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;UC with SRQ not supported&quot;</span><span class="p">);</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">has_srq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">ext_type</span> <span class="o">=</span> <span class="n">EQPT_SRQBASE</span><span class="p">;</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">srq_qpn</span> <span class="o">=</span> <span class="n">my_srq</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_llqp</span> <span class="o">&amp;&amp;</span> <span class="n">has_srq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;LLQPs can&#39;t have an SRQ&quot;</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* handle SRQs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_srq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">ext_type</span> <span class="o">=</span> <span class="n">EQPT_SRQ</span><span class="p">;</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">srq_limit</span> <span class="o">=</span> <span class="n">srq_init_attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">srq_limit</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;no more than three SGEs &quot;</span>
				 <span class="s">&quot;supported for SRQ  pd=%p  max_sge=%x&quot;</span><span class="p">,</span>
				 <span class="n">pd</span><span class="p">,</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span><span class="p">);</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* check QP type */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">!=</span> <span class="n">IB_QPT_UD</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qp_type</span> <span class="o">!=</span> <span class="n">IB_QPT_UC</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qp_type</span> <span class="o">!=</span> <span class="n">IB_QPT_RC</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qp_type</span> <span class="o">!=</span> <span class="n">IB_QPT_SMI</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qp_type</span> <span class="o">!=</span> <span class="n">IB_QPT_GSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;wrong QP Type=%x&quot;</span><span class="p">,</span> <span class="n">qp_type</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_llqp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">qp_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IB_QPT_RC</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					 <span class="s">&quot;Invalid Number of max_sq_wr=%x &quot;</span>
					 <span class="s">&quot;or max_rq_wr=%x for RC LLQP&quot;</span><span class="p">,</span>
					 <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span><span class="p">,</span>
					 <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span><span class="p">);</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IB_QPT_UD</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EHCA_BMASK_GET</span><span class="p">(</span><span class="n">HCA_CAP_UD_LL_QP</span><span class="p">,</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">hca_cap</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;UD LLQP not supported &quot;</span>
					 <span class="s">&quot;by this adapter&quot;</span><span class="p">);</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSYS</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span> <span class="o">&lt;=</span> <span class="mi">5</span>
			    <span class="o">&amp;&amp;</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span> <span class="o">&gt;=</span> <span class="mi">1</span>
			    <span class="o">&amp;&amp;</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">&lt;=</span> <span class="mi">5</span>
			    <span class="o">&amp;&amp;</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					 <span class="s">&quot;Invalid Number of max_send_sge=%x &quot;</span>
					 <span class="s">&quot;or max_recv_sge=%x for UD LLQP&quot;</span><span class="p">,</span>
					 <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span><span class="p">,</span>
					 <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span><span class="p">);</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					 <span class="s">&quot;Invalid Number of &quot;</span>
					 <span class="s">&quot;max_send_wr=%x for UD QP_TYPE=%x&quot;</span><span class="p">,</span>
					 <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span><span class="p">,</span> <span class="n">qp_type</span><span class="p">);</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;unsupported LL QP Type=%x&quot;</span><span class="p">,</span>
				 <span class="n">qp_type</span><span class="p">);</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">max_sge</span> <span class="o">=</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_UD</span> <span class="o">||</span> <span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_SMI</span>
			       <span class="o">||</span> <span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_GSI</span><span class="p">)</span> <span class="o">?</span> <span class="mi">250</span> <span class="o">:</span> <span class="mi">252</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span> <span class="o">&gt;</span> <span class="n">max_sge</span>
		    <span class="o">||</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">&gt;</span> <span class="n">max_sge</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid number of SGEs requested &quot;</span>
				 <span class="s">&quot;send_sge=%x recv_sge=%x max_sge=%x&quot;</span><span class="p">,</span>
				 <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span><span class="p">,</span>
				 <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span><span class="p">,</span> <span class="n">max_sge</span><span class="p">);</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">my_qp</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">qp_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;pd=%p not enough memory to alloc qp&quot;</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">uobject</span> <span class="o">&amp;&amp;</span> <span class="n">udata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">is_user</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">context</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">uobject</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">wait_completion</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">spinlock_s</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">spinlock_r</span><span class="p">);</span>
	<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">=</span> <span class="n">qp_type</span><span class="p">;</span>
	<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ext_type</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">ext_type</span><span class="p">;</span>
	<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IB_QPS_RESET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="p">)</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span> <span class="o">=</span>
			<span class="n">container_of</span><span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_cq</span><span class="p">,</span> <span class="n">ib_cq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">)</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span> <span class="o">=</span>
			<span class="n">container_of</span><span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_cq</span><span class="p">,</span> <span class="n">ib_cq</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Can&#39;t reserve idr resources.&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">create_qp_exit0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Can&#39;t allocate new idr entry.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">create_qp_exit0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">token</span> <span class="o">&gt;</span> <span class="mh">0x1FFFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid number of qp&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">create_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_srq</span><span class="p">)</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">srq_token</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">;</span>

	<span class="n">parms</span><span class="p">.</span><span class="n">servicetype</span> <span class="o">=</span> <span class="n">ibqptype2servicetype</span><span class="p">(</span><span class="n">qp_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parms</span><span class="p">.</span><span class="n">servicetype</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid qp_type=%x&quot;</span><span class="p">,</span> <span class="n">qp_type</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">create_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Always signal by WQE so we can hide circ. WQEs */</span>
	<span class="n">parms</span><span class="p">.</span><span class="n">sigtype</span> <span class="o">=</span> <span class="n">HCALL_SIGT_BY_WQE</span><span class="p">;</span>

	<span class="cm">/* UD_AV CIRCUMVENTION */</span>
	<span class="n">max_send_sge</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span><span class="p">;</span>
	<span class="n">max_recv_sge</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parms</span><span class="p">.</span><span class="n">servicetype</span> <span class="o">==</span> <span class="n">ST_UD</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_llqp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">max_send_sge</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">max_recv_sge</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">parms</span><span class="p">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">;</span>
	<span class="n">parms</span><span class="p">.</span><span class="n">eq_handle</span> <span class="o">=</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">.</span><span class="n">ipz_eq_handle</span><span class="p">;</span>
	<span class="n">parms</span><span class="p">.</span><span class="n">pd</span> <span class="o">=</span> <span class="n">my_pd</span><span class="o">-&gt;</span><span class="n">fw_pd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">)</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">send_cq_handle</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">ipz_cq_handle</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="p">)</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">recv_cq_handle</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="o">-&gt;</span><span class="n">ipz_cq_handle</span><span class="p">;</span>

	<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">max_wr</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span><span class="p">;</span>
	<span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">max_wr</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span><span class="p">;</span>
	<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">max_sge</span> <span class="o">=</span> <span class="n">max_send_sge</span><span class="p">;</span>
	<span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">max_sge</span> <span class="o">=</span> <span class="n">max_recv_sge</span><span class="p">;</span>

	<span class="cm">/* RC QPs need one more SWQE for unsolicited ack circumvention */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_RC</span><span class="p">)</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">max_wr</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">EHCA_BMASK_GET</span><span class="p">(</span><span class="n">HCA_CAP_MINI_QP</span><span class="p">,</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">hca_cap</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HAS_SQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span>
			<span class="n">ehca_determine_small_queue</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">,</span> <span class="n">max_send_sge</span><span class="p">,</span> <span class="n">is_llqp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span>
			<span class="n">ehca_determine_small_queue</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">,</span> <span class="n">max_recv_sge</span><span class="p">,</span> <span class="n">is_llqp</span><span class="p">);</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">qp_storage</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">is_small</span> <span class="o">||</span> <span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">is_small</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_alloc_resource_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parms</span><span class="p">,</span> <span class="n">is_user</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;h_alloc_resource_qp() failed h_ret=%lli&quot;</span><span class="p">,</span>
			 <span class="n">h_ret</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">create_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ib_qp_num</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">real_qp_num</span><span class="p">;</span>
	<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">qp_handle</span><span class="p">;</span>
	<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">galpas</span><span class="p">;</span>

	<span class="n">swqe_size</span> <span class="o">=</span> <span class="n">ehca_calc_wqe_size</span><span class="p">(</span><span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_sges</span><span class="p">,</span> <span class="n">is_llqp</span><span class="p">);</span>
	<span class="n">rwqe_size</span> <span class="o">=</span> <span class="n">ehca_calc_wqe_size</span><span class="p">(</span><span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">act_nr_sges</span><span class="p">,</span> <span class="n">is_llqp</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">qp_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_QPT_RC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">is_llqp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_sges</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">act_nr_sges</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* hide the extra WQE */</span>
		<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_wqes</span><span class="o">--</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPT_UD</span>:
	<span class="k">case</span> <span class="n">IB_QPT_GSI</span>:
	<span class="k">case</span> <span class="n">IB_QPT_SMI</span>:
		<span class="cm">/* UD circumvention */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_llqp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_sges</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">act_nr_sges</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_sges</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">act_nr_sges</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IB_QPT_GSI</span> <span class="o">==</span> <span class="n">qp_type</span> <span class="o">||</span> <span class="n">IB_QPT_SMI</span> <span class="o">==</span> <span class="n">qp_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_wqes</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span><span class="p">;</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">act_nr_wqes</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span><span class="p">;</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_sges</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span><span class="p">;</span>
			<span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">act_nr_sges</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span><span class="p">;</span>
			<span class="n">ib_qp_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_SMI</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize r/squeue and register queue pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_SQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">init_qp_queue</span><span class="p">(</span>
			<span class="n">shca</span><span class="p">,</span> <span class="n">my_pd</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">)</span> <span class="o">?</span> <span class="n">H_PAGE_REGISTERED</span> <span class="o">:</span> <span class="n">H_SUCCESS</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">,</span> <span class="n">swqe_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t initialize squeue &quot;</span>
				 <span class="s">&quot;and pages ret=%i&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">create_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_user</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">.</span><span class="n">queue_length</span> <span class="o">/</span>
				<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">.</span><span class="n">qe_size</span><span class="p">;</span>
			<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">entries</span> <span class="o">*</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_qmap_entry</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t allocate squeue &quot;</span>
					 <span class="s">&quot;map ret=%i&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">create_qp_exit3</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_err_node</span><span class="p">);</span>
			<span class="cm">/* to avoid the generation of bogus flush CQEs */</span>
			<span class="n">reset_queue_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">init_qp_queue</span><span class="p">(</span>
			<span class="n">shca</span><span class="p">,</span> <span class="n">my_pd</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			<span class="n">H_SUCCESS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">,</span> <span class="n">rwqe_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t initialize rqueue &quot;</span>
				 <span class="s">&quot;and pages ret=%i&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">create_qp_exit4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_user</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">.</span><span class="n">queue_length</span> <span class="o">/</span>
				<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">.</span><span class="n">qe_size</span><span class="p">;</span>
			<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">entries</span> <span class="o">*</span>
						    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_qmap_entry</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t allocate squeue &quot;</span>
					 <span class="s">&quot;map ret=%i&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">create_qp_exit5</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_err_node</span><span class="p">);</span>
			<span class="cm">/* to avoid the generation of bogus flush CQEs */</span>
			<span class="n">reset_queue_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">srq</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this is a base QP, use the queue map of the SRQ */</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span> <span class="o">=</span> <span class="n">my_srq</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_err_node</span><span class="p">);</span>

		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span> <span class="o">=</span> <span class="n">my_srq</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_srq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_srq</span><span class="p">.</span><span class="n">pd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_pd</span><span class="o">-&gt;</span><span class="n">ib_pd</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_srq</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">my_pd</span><span class="o">-&gt;</span><span class="n">ib_pd</span><span class="p">.</span><span class="n">device</span><span class="p">;</span>

		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_srq</span><span class="p">.</span><span class="n">srq_context</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">qp_context</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_srq</span><span class="p">.</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">qp_num</span> <span class="o">=</span> <span class="n">ib_qp_num</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">pd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_pd</span><span class="o">-&gt;</span><span class="n">ib_pd</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">my_pd</span><span class="o">-&gt;</span><span class="n">ib_pd</span><span class="p">.</span><span class="n">device</span><span class="p">;</span>

		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">recv_cq</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">send_cq</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">;</span>

		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">qp_type</span> <span class="o">=</span> <span class="n">qp_type</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">srq</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">srq</span><span class="p">;</span>

		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">qp_context</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">qp_context</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_inline_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* not supported yet */</span>
	<span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">act_nr_sges</span><span class="p">;</span>
	<span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">rqueue</span><span class="p">.</span><span class="n">act_nr_wqes</span><span class="p">;</span>
	<span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_sges</span><span class="p">;</span>
	<span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">squeue</span><span class="p">.</span><span class="n">act_nr_wqes</span><span class="p">;</span>
	<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span> <span class="o">=</span> <span class="o">*</span><span class="n">init_attr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_SMI</span> <span class="o">||</span> <span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_GSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shca</span><span class="o">-&gt;</span><span class="n">sport</span><span class="p">[</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">port_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">ibqp_sqp</span><span class="p">[</span><span class="n">qp_type</span><span class="p">]</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehca_nr_ports</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* alloc array to cache subsequent modify qp parms</span>
<span class="cm">			 * for autodetect mode</span>
<span class="cm">			 */</span>
			<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span> <span class="o">=</span>
				<span class="n">kzalloc</span><span class="p">(</span><span class="n">EHCA_MOD_QP_PARM_MAX</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
					 <span class="s">&quot;Could not alloc mod_qp_parm&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">create_qp_exit5</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE: define_apq0() not supported yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_GSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h_ret</span> <span class="o">=</span> <span class="n">ehca_define_sqp</span><span class="p">(</span><span class="n">shca</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">init_attr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">);</span>
			<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="cm">/* the QP pointer is no longer valid */</span>
			<span class="n">shca</span><span class="o">-&gt;</span><span class="n">sport</span><span class="p">[</span><span class="n">init_attr</span><span class="o">-&gt;</span><span class="n">port_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">ibqp_sqp</span><span class="p">[</span><span class="n">qp_type</span><span class="p">]</span> <span class="o">=</span>
				<span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">create_qp_exit6</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca_cq_assign_qp</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
				 <span class="s">&quot;Couldn&#39;t assign qp to send_cq ret=%i&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">create_qp_exit7</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* copy queues, galpa data to user space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">context</span> <span class="o">&amp;&amp;</span> <span class="n">udata</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehca_create_qp_resp</span> <span class="n">resp</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">resp</span><span class="p">));</span>

		<span class="n">resp</span><span class="p">.</span><span class="n">qp_num</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">;</span>
		<span class="n">resp</span><span class="p">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">;</span>
		<span class="n">resp</span><span class="p">.</span><span class="n">qp_type</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span><span class="p">;</span>
		<span class="n">resp</span><span class="p">.</span><span class="n">ext_type</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ext_type</span><span class="p">;</span>
		<span class="n">resp</span><span class="p">.</span><span class="n">qkey</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qkey</span><span class="p">;</span>
		<span class="n">resp</span><span class="p">.</span><span class="n">real_qp_num</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">HAS_SQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span>
			<span class="n">queue2resp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resp</span><span class="p">.</span><span class="n">ipz_squeue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span>
			<span class="n">queue2resp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resp</span><span class="p">.</span><span class="n">ipz_rqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">);</span>
		<span class="n">resp</span><span class="p">.</span><span class="n">fw_handle_ofs</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span>
			<span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">fw_handle</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ib_copy_to_udata</span><span class="p">(</span><span class="n">udata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resp</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">resp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Copy to udata failed&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">create_qp_exit8</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">my_qp</span><span class="p">;</span>

<span class="nl">create_qp_exit8:</span>
	<span class="n">ehca_cq_unassign_qp</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">);</span>

<span class="nl">create_qp_exit7:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">);</span>

<span class="nl">create_qp_exit6:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_user</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">map</span><span class="p">);</span>

<span class="nl">create_qp_exit5:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span>
		<span class="n">ipz_queue_dtor</span><span class="p">(</span><span class="n">my_pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">);</span>

<span class="nl">create_qp_exit4:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_SQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_user</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">map</span><span class="p">);</span>

<span class="nl">create_qp_exit3:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_SQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span>
		<span class="n">ipz_queue_dtor</span><span class="p">(</span><span class="n">my_pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">);</span>

<span class="nl">create_qp_exit2:</span>
	<span class="n">hipz_h_destroy_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">);</span>

<span class="nl">create_qp_exit1:</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">create_qp_exit0:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">qp_cache</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="nf">ehca_create_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="o">*</span><span class="n">qp_init_attr</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">internal_create_qp</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">qp_init_attr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">udata</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="p">)</span><span class="n">ret</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">internal_destroy_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ib_uobject</span> <span class="o">*</span><span class="n">uobject</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="nf">ehca_create_srq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_pd</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ib_srq_init_attr</span> <span class="o">*</span><span class="n">srq_init_attr</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="n">qp_init_attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span><span class="p">,</span>
					      <span class="n">ib_device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hcp_modify_qp_control_block</span> <span class="o">*</span><span class="n">mqpcb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hret</span><span class="p">,</span> <span class="n">update_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srq_init_attr</span><span class="o">-&gt;</span><span class="n">srq_type</span> <span class="o">!=</span> <span class="n">IB_SRQT_BASIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSYS</span><span class="p">);</span>

	<span class="cm">/* For common attributes, internal_create_qp() takes its info</span>
<span class="cm">	 * out of qp_init_attr, so copy all common attrs there.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qp_init_attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">qp_init_attr</span><span class="p">));</span>
	<span class="n">qp_init_attr</span><span class="p">.</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">srq_init_attr</span><span class="o">-&gt;</span><span class="n">event_handler</span><span class="p">;</span>
	<span class="n">qp_init_attr</span><span class="p">.</span><span class="n">qp_context</span> <span class="o">=</span> <span class="n">srq_init_attr</span><span class="o">-&gt;</span><span class="n">srq_context</span><span class="p">;</span>
	<span class="n">qp_init_attr</span><span class="p">.</span><span class="n">sq_sig_type</span> <span class="o">=</span> <span class="n">IB_SIGNAL_ALL_WR</span><span class="p">;</span>
	<span class="n">qp_init_attr</span><span class="p">.</span><span class="n">qp_type</span> <span class="o">=</span> <span class="n">IB_QPT_RC</span><span class="p">;</span>
	<span class="n">qp_init_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span> <span class="o">=</span> <span class="n">srq_init_attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">max_wr</span><span class="p">;</span>
	<span class="n">qp_init_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">=</span> <span class="n">srq_init_attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">max_sge</span><span class="p">;</span>

	<span class="n">my_qp</span> <span class="o">=</span> <span class="n">internal_create_qp</span><span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qp_init_attr</span><span class="p">,</span> <span class="n">srq_init_attr</span><span class="p">,</span> <span class="n">udata</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="p">)</span><span class="n">my_qp</span><span class="p">;</span>

	<span class="cm">/* copy back return values */</span>
	<span class="n">srq_init_attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">max_wr</span> <span class="o">=</span> <span class="n">qp_init_attr</span><span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span><span class="p">;</span>
	<span class="n">srq_init_attr</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">.</span><span class="n">max_sge</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* drive SRQ into RTR state */</span>
	<span class="n">mqpcb</span> <span class="o">=</span> <span class="n">ehca_alloc_fw_ctrlblock</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mqpcb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Could not get zeroed page for mqpcb &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x &quot;</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">create_srq1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span> <span class="o">=</span> <span class="n">EHCA_QPS_INIT</span><span class="p">;</span>
	<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">prim_phys_port</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">update_mask</span> <span class="o">=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_QP_STATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">hret</span> <span class="o">=</span> <span class="n">hipz_h_modify_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
				<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
				<span class="n">update_mask</span><span class="p">,</span>
				<span class="n">mqpcb</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Could not modify SRQ to INIT &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x h_ret=%lli&quot;</span><span class="p">,</span>
			 <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">,</span> <span class="n">hret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">create_srq2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">update_mask</span> <span class="o">=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_QP_ENABLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">hret</span> <span class="o">=</span> <span class="n">hipz_h_modify_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
				<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
				<span class="n">update_mask</span><span class="p">,</span>
				<span class="n">mqpcb</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Could not enable SRQ &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x h_ret=%lli&quot;</span><span class="p">,</span>
			 <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">,</span> <span class="n">hret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">create_srq2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span>  <span class="o">=</span> <span class="n">EHCA_QPS_RTR</span><span class="p">;</span>
	<span class="n">update_mask</span> <span class="o">=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_QP_STATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">hret</span> <span class="o">=</span> <span class="n">hipz_h_modify_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
				<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
				<span class="n">update_mask</span><span class="p">,</span>
				<span class="n">mqpcb</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Could not modify SRQ to RTR &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x h_ret=%lli&quot;</span><span class="p">,</span>
			 <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">,</span> <span class="n">hret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">create_srq2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehca_free_fw_ctrlblock</span><span class="p">(</span><span class="n">mqpcb</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_srq</span><span class="p">;</span>

<span class="nl">create_srq2:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">hret</span><span class="p">));</span>
	<span class="n">ehca_free_fw_ctrlblock</span><span class="p">(</span><span class="n">mqpcb</span><span class="p">);</span>

<span class="nl">create_srq1:</span>
	<span class="n">internal_destroy_qp</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_srq</span><span class="p">.</span><span class="n">uobject</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * prepare_sqe_rts called by internal_modify_qp() at trans sqe -&gt; rts</span>
<span class="cm"> * set purge bit of bad wqe and subsequent wqes to avoid reentering sqe</span>
<span class="cm"> * returns total number of bad wqes in bad_wqe_cnt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_sqe_rts</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="o">*</span><span class="n">bad_wqe_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">h_ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipz_queue</span> <span class="o">*</span><span class="n">squeue</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bad_send_wqe_p</span><span class="p">,</span> <span class="o">*</span><span class="n">bad_send_wqe_v</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">q_ofs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehca_wqe</span> <span class="o">*</span><span class="n">wqe</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qp_num</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">qp_num</span><span class="p">;</span>

	<span class="cm">/* get send wqe pointer */</span>
	<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_disable_and_get_wqe</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
					   <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">bad_send_wqe_p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">,</span> <span class="s">&quot;hipz_h_disable_and_get_wqe() failed&quot;</span>
			 <span class="s">&quot; ehca_qp=%p qp_num=%x h_ret=%lli&quot;</span><span class="p">,</span>
			 <span class="n">my_qp</span><span class="p">,</span> <span class="n">qp_num</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bad_send_wqe_p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u64</span><span class="p">)</span><span class="n">bad_send_wqe_p</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">)));</span>
	<span class="n">ehca_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">,</span> <span class="s">&quot;qp_num=%x bad_send_wqe_p=%p&quot;</span><span class="p">,</span>
		 <span class="n">qp_num</span><span class="p">,</span> <span class="n">bad_send_wqe_p</span><span class="p">);</span>
	<span class="cm">/* convert wqe pointer to vadr */</span>
	<span class="n">bad_send_wqe_v</span> <span class="o">=</span> <span class="n">abs_to_virt</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">bad_send_wqe_p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehca_debug_level</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ehca_dmp</span><span class="p">(</span><span class="n">bad_send_wqe_v</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;qp_num=%x bad_wqe&quot;</span><span class="p">,</span> <span class="n">qp_num</span><span class="p">);</span>
	<span class="n">squeue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipz_queue_abs_to_offset</span><span class="p">(</span><span class="n">squeue</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bad_send_wqe_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_ofs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">,</span> <span class="s">&quot;failed to get wqe offset qp_num=%x&quot;</span>
			 <span class="s">&quot; bad_send_wqe_p=%p&quot;</span><span class="p">,</span> <span class="n">qp_num</span><span class="p">,</span> <span class="n">bad_send_wqe_p</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* loop sets wqe&#39;s purge bit */</span>
	<span class="n">wqe</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehca_wqe</span> <span class="o">*</span><span class="p">)</span><span class="n">ipz_qeit_calc</span><span class="p">(</span><span class="n">squeue</span><span class="p">,</span> <span class="n">q_ofs</span><span class="p">);</span>
	<span class="o">*</span><span class="n">bad_wqe_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">optype</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="n">wqe</span><span class="o">-&gt;</span><span class="n">wqef</span> <span class="o">!=</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ehca_debug_level</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">ehca_dmp</span><span class="p">(</span><span class="n">wqe</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;qp_num=%x wqe&quot;</span><span class="p">,</span> <span class="n">qp_num</span><span class="p">);</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">nr_of_data_seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* suppress data access */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">wqef</span> <span class="o">=</span> <span class="n">WQEF_PURGE</span><span class="p">;</span> <span class="cm">/* WQE to be purged */</span>
		<span class="n">q_ofs</span> <span class="o">=</span> <span class="n">ipz_queue_advance_offset</span><span class="p">(</span><span class="n">squeue</span><span class="p">,</span> <span class="n">q_ofs</span><span class="p">);</span>
		<span class="n">wqe</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehca_wqe</span> <span class="o">*</span><span class="p">)</span><span class="n">ipz_qeit_calc</span><span class="p">(</span><span class="n">squeue</span><span class="p">,</span> <span class="n">q_ofs</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bad_wqe_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">bad_wqe_cnt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * bad wqe will be reprocessed and ignored when pol_cq() is called,</span>
<span class="cm">	 *  i.e. nr of wqes with flush error status is one less</span>
<span class="cm">	 */</span>
	<span class="n">ehca_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">,</span> <span class="s">&quot;qp_num=%x flusherr_wqe_cnt=%x&quot;</span><span class="p">,</span>
		 <span class="n">qp_num</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">bad_wqe_cnt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">wqef</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">calc_left_cqes</span><span class="p">(</span><span class="n">u64</span> <span class="n">wqe_p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipz_queue</span> <span class="o">*</span><span class="n">ipz_queue</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">ehca_queue_map</span> <span class="o">*</span><span class="n">qmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">wqe_v</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">q_ofs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wqe_idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail_idx</span><span class="p">;</span>

	<span class="cm">/* convert real to abs address */</span>
	<span class="n">wqe_p</span> <span class="o">=</span> <span class="n">wqe_p</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">));</span>

	<span class="n">wqe_v</span> <span class="o">=</span> <span class="n">abs_to_virt</span><span class="p">(</span><span class="n">wqe_p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ipz_queue_abs_to_offset</span><span class="p">(</span><span class="n">ipz_queue</span><span class="p">,</span> <span class="n">wqe_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_ofs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ehca_gen_err</span><span class="p">(</span><span class="s">&quot;Invalid offset for calculating left cqes &quot;</span>
				<span class="s">&quot;wqe_p=%#llx wqe_v=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wqe_p</span><span class="p">,</span> <span class="n">wqe_v</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tail_idx</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">(</span><span class="n">qmap</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="n">qmap</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
	<span class="n">wqe_idx</span> <span class="o">=</span> <span class="n">q_ofs</span> <span class="o">/</span> <span class="n">ipz_queue</span><span class="o">-&gt;</span><span class="n">qe_size</span><span class="p">;</span>

	<span class="cm">/* check all processed wqes, whether a cqe is requested or not */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tail_idx</span> <span class="o">!=</span> <span class="n">wqe_idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qmap</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">tail_idx</span><span class="p">].</span><span class="n">cqe_req</span><span class="p">)</span>
			<span class="n">qmap</span><span class="o">-&gt;</span><span class="n">left_to_poll</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tail_idx</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">(</span><span class="n">tail_idx</span><span class="p">,</span> <span class="n">qmap</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* save index in queue, where we have to start flushing */</span>
	<span class="n">qmap</span><span class="o">-&gt;</span><span class="n">next_wqe_idx</span> <span class="o">=</span> <span class="n">wqe_idx</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_for_left_cqes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">h_ret</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">send_wqe_p</span><span class="p">,</span> <span class="o">*</span><span class="n">recv_wqe_p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">qp_num</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">qp_num</span><span class="p">;</span>

	<span class="cm">/* this hcall is not supported on base QPs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ext_type</span> <span class="o">!=</span> <span class="n">EQPT_SRQBASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get send and receive wqe pointer */</span>
		<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_disable_and_get_wqe</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
				<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">send_wqe_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_wqe_p</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">,</span> <span class="s">&quot;disable_and_get_wqe() &quot;</span>
				 <span class="s">&quot;failed ehca_qp=%p qp_num=%x h_ret=%lli&quot;</span><span class="p">,</span>
				 <span class="n">my_qp</span><span class="p">,</span> <span class="n">qp_num</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * acquire lock to ensure that nobody is polling the cq which</span>
<span class="cm">		 * could mean that the qmap-&gt;tail pointer is in an</span>
<span class="cm">		 * inconsistent state.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">calc_left_cqes</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">send_wqe_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>


		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">calc_left_cqes</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">recv_wqe_p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">left_to_poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">next_wqe_idx</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span>
							<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">left_to_poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">next_wqe_idx</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span>
							<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* this assures flush cqes being generated only for pending wqes */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">left_to_poll</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">left_to_poll</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ehca_add_to_err_list</span><span class="p">(</span><span class="n">my_qp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ehca_add_to_err_list</span><span class="p">(</span><span class="n">my_qp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="o">-&gt;</span><span class="n">spinlock</span><span class="p">,</span>
					<span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * internal_modify_qp with circumvention to handle aqp0 properly</span>
<span class="cm"> * smi_reset2init indicates if this is an internal reset-to-init-call for</span>
<span class="cm"> * smi. This flag must always be zero if called from ehca_modify_qp()!</span>
<span class="cm"> * This internal func was intorduced to avoid recursion of ehca_modify_qp()!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">internal_modify_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">ibqp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">attr_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">smi_reset2init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">ib_qp_state</span> <span class="n">qp_cur_state</span><span class="p">,</span> <span class="n">qp_new_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">qp_attr_idx</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_qp_statetrans</span> <span class="n">statetrans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hcp_modify_qp_control_block</span> <span class="o">*</span><span class="n">mqpcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ibqp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_qp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span><span class="p">,</span> <span class="n">ib_device</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">update_mask</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">h_ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bad_wqe_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_user</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">squeue_locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* do query_qp to obtain current attr values */</span>
	<span class="n">mqpcb</span> <span class="o">=</span> <span class="n">ehca_alloc_fw_ctrlblock</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mqpcb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Could not get zeroed page for mqpcb &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x &quot;</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_query_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
				<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
				<span class="n">mqpcb</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;hipz_h_query_qp() failed &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x h_ret=%lli&quot;</span><span class="p">,</span>
			 <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">modify_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">uobject</span><span class="p">)</span>
		<span class="n">is_user</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">qp_cur_state</span> <span class="o">=</span> <span class="n">ehca2ib_qp_state</span><span class="p">(</span><span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qp_cur_state</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* invalid qp state */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid current ehca_qp_state=%x &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span>
			 <span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">modify_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * circumvention to set aqp0 initial state to init</span>
<span class="cm">	 * as expected by IB spec</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smi_reset2init</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_SMI</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qp_cur_state</span> <span class="o">==</span> <span class="n">IB_QPS_RESET</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_STATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">attr</span><span class="o">-&gt;</span><span class="n">qp_state</span> <span class="o">==</span> <span class="n">IB_QPS_INIT</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* RESET -&gt; INIT */</span>
		<span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="n">smiqp_attr</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">qp_state</span> <span class="o">=</span> <span class="n">IB_QPS_INIT</span><span class="p">,</span>
			<span class="p">.</span><span class="n">port_num</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">.</span><span class="n">port_num</span><span class="p">,</span>
			<span class="p">.</span><span class="n">pkey_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">.</span><span class="n">qkey</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="p">};</span>
		<span class="kt">int</span> <span class="n">smiqp_attr_mask</span> <span class="o">=</span> <span class="n">IB_QP_STATE</span> <span class="o">|</span> <span class="n">IB_QP_PORT</span> <span class="o">|</span>
			<span class="n">IB_QP_PKEY_INDEX</span> <span class="o">|</span> <span class="n">IB_QP_QKEY</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">smirc</span> <span class="o">=</span> <span class="n">internal_modify_qp</span><span class="p">(</span>
			<span class="n">ibqp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smiqp_attr</span><span class="p">,</span> <span class="n">smiqp_attr_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smirc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;SMI RESET -&gt; INIT failed. &quot;</span>
				 <span class="s">&quot;ehca_modify_qp() rc=%i&quot;</span><span class="p">,</span> <span class="n">smirc</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">H_PARAMETER</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">qp_cur_state</span> <span class="o">=</span> <span class="n">IB_QPS_INIT</span><span class="p">;</span>
		<span class="n">ehca_dbg</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;SMI RESET -&gt; INIT succeeded&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* is transmitted current state  equal to &quot;real&quot; current state */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_CUR_STATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">qp_cur_state</span> <span class="o">!=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">cur_qp_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
			 <span class="s">&quot;Invalid IB_QP_CUR_STATE attr-&gt;curr_qp_state=%x &lt;&gt;&quot;</span>
			 <span class="s">&quot; actual cur_qp_state=%x. ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span>
			 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">cur_qp_state</span><span class="p">,</span> <span class="n">qp_cur_state</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">modify_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehca_dbg</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;ehca_qp=%p qp_num=%x current qp_state=%x &quot;</span>
		 <span class="s">&quot;new qp_state=%x attribute_mask=%x&quot;</span><span class="p">,</span>
		 <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">qp_cur_state</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">,</span> <span class="n">attr_mask</span><span class="p">);</span>

	<span class="n">qp_new_state</span> <span class="o">=</span> <span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_STATE</span> <span class="o">?</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">qp_state</span> <span class="o">:</span> <span class="n">qp_cur_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smi_reset2init</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">ib_modify_qp_is_ok</span><span class="p">(</span><span class="n">qp_cur_state</span><span class="p">,</span> <span class="n">qp_new_state</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span><span class="p">,</span>
				<span class="n">attr_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
			 <span class="s">&quot;Invalid qp transition new_state=%x cur_state=%x &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x attr_mask=%x&quot;</span><span class="p">,</span> <span class="n">qp_new_state</span><span class="p">,</span>
			 <span class="n">qp_cur_state</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">attr_mask</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">modify_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span> <span class="o">=</span> <span class="n">ib2ehca_qp_state</span><span class="p">(</span><span class="n">qp_new_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">)</span>
		<span class="n">update_mask</span> <span class="o">=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_QP_STATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid new qp state=%x &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span>
			 <span class="n">qp_new_state</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">modify_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* retrieve state transition struct to get req and opt attrs */</span>
	<span class="n">statetrans</span> <span class="o">=</span> <span class="n">get_modqp_statetrans</span><span class="p">(</span><span class="n">qp_cur_state</span><span class="p">,</span> <span class="n">qp_new_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">statetrans</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;&lt;INVALID STATE CHANGE&gt; qp_cur_state=%x &quot;</span>
			 <span class="s">&quot;new_qp_state=%x State_xsition=%x ehca_qp=%p &quot;</span>
			 <span class="s">&quot;qp_num=%x&quot;</span><span class="p">,</span> <span class="n">qp_cur_state</span><span class="p">,</span> <span class="n">qp_new_state</span><span class="p">,</span>
			 <span class="n">statetrans</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">modify_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qp_attr_idx</span> <span class="o">=</span> <span class="n">ib2ehcaqptype</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qp_attr_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">qp_attr_idx</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
			 <span class="s">&quot;Invalid QP type=%x ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span>
			 <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">modify_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ehca_dbg</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
		 <span class="s">&quot;ehca_qp=%p qp_num=%x &lt;VALID STATE CHANGE&gt; qp_state_xsit=%x&quot;</span><span class="p">,</span>
		 <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">statetrans</span><span class="p">);</span>

	<span class="cm">/* eHCA2 rev2 and higher require the SEND_GRH_FLAG to be set</span>
<span class="cm">	 * in non-LL UD QPs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_UD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ext_type</span> <span class="o">!=</span> <span class="n">EQPT_LLQP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">statetrans</span> <span class="o">==</span> <span class="n">IB_QPST_INIT2RTR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">hw_level</span> <span class="o">&gt;=</span> <span class="mh">0x22</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SEND_GRH_FLAG</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">send_grh_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* sqe -&gt; rts: set purge bit of bad wqe before actual trans */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_UD</span> <span class="o">||</span>
	     <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_GSI</span> <span class="o">||</span>
	     <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_SMI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">statetrans</span> <span class="o">==</span> <span class="n">IB_QPST_SQE2RTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* mark next free wqe if kernel */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">uobject</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ehca_wqe</span> <span class="o">*</span><span class="n">wqe</span><span class="p">;</span>
			<span class="cm">/* lock send queue */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">spinlock_s</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">squeue_locked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* mark next free wqe */</span>
			<span class="n">wqe</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ehca_wqe</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">ipz_qeit_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">);</span>
			<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">optype</span> <span class="o">=</span> <span class="n">wqe</span><span class="o">-&gt;</span><span class="n">wqef</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">ehca_dbg</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;qp_num=%x next_free_wqe=%p&quot;</span><span class="p">,</span>
				 <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">wqe</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">prepare_sqe_rts</span><span class="p">(</span><span class="n">my_qp</span><span class="p">,</span> <span class="n">shca</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bad_wqe_cnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;prepare_sqe_rts() failed &quot;</span>
				 <span class="s">&quot;ehca_qp=%p qp_num=%x ret=%i&quot;</span><span class="p">,</span>
				 <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * enable RDMA_Atomic_Control if reset-&gt;init und reliable con</span>
<span class="cm">	 * this is necessary since gen2 does not provide that flag,</span>
<span class="cm">	 * but pHyp requires it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">statetrans</span> <span class="o">==</span> <span class="n">IB_QPST_RESET2INIT</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_RC</span> <span class="o">||</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_UC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">rdma_atomic_ctrl</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_RDMA_ATOMIC_CTRL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* circ. pHyp requires #RDMA/Atomic Resp Res for UC INIT -&gt; RTR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">statetrans</span> <span class="o">==</span> <span class="n">IB_QPST_INIT2RTR</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_UC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_MAX_DEST_RD_ATOMIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">rdma_nr_atomic_resp_res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* default to 1 */</span>
		<span class="n">update_mask</span> <span class="o">|=</span>
			<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_RDMA_NR_ATOMIC_RESP_RES</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_PKEY_INDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">pkey_index</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid pkey_index=%x. &quot;</span>
				 <span class="s">&quot;ehca_qp=%p qp_num=%x max_pkey_index=f&quot;</span><span class="p">,</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">pkey_index</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">prim_p_key_idx</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">pkey_index</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_PRIM_P_KEY_IDX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ehca_sport</span> <span class="o">*</span><span class="n">sport</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">aqp1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">port_num</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">port_num</span> <span class="o">&gt;</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_ports</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid port=%x. &quot;</span>
				 <span class="s">&quot;ehca_qp=%p qp_num=%x num_ports=%x&quot;</span><span class="p">,</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">port_num</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span>
				 <span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_ports</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">sport</span><span class="p">[</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">port_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sport</span><span class="o">-&gt;</span><span class="n">ibqp_sqp</span><span class="p">[</span><span class="n">IB_QPT_GSI</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/* should not occur */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;AQP1 was not created for &quot;</span>
				 <span class="s">&quot;port=%x&quot;</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">port_num</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">aqp1</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sport</span><span class="o">-&gt;</span><span class="n">ibqp_sqp</span><span class="p">[</span><span class="n">IB_QPT_GSI</span><span class="p">],</span>
				    <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_qp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">!=</span> <span class="n">IB_QPT_GSI</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">!=</span> <span class="n">IB_QPT_SMI</span> <span class="o">&amp;&amp;</span>
		    <span class="n">aqp1</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * firmware will reject this modify_qp() because</span>
<span class="cm">			 * port is not activated/initialized fully</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">ehca_warn</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t modify qp port=%x: &quot;</span>
				  <span class="s">&quot;either port is being activated (try again) &quot;</span>
				  <span class="s">&quot;or cabling issue&quot;</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">port_num</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">prim_phys_port</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">port_num</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_PRIM_PHYS_PORT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_QKEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qkey</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">qkey</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_QKEY</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_AV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">dlid</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">dlid</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_DLID</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">source_path_bits</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">src_path_bits</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SOURCE_PATH_BITS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">service_level</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">sl</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SERVICE_LEVEL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ehca_calc_ipd</span><span class="p">(</span><span class="n">shca</span><span class="p">,</span> <span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">prim_phys_port</span><span class="p">,</span>
				  <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">static_rate</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">max_static_rate</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_MAX_STATIC_RATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Always supply the GRH flag, even if it&#39;s zero, to give the</span>
<span class="cm">		 * hypervisor a clear &quot;yes&quot; or &quot;no&quot; instead of a &quot;perhaps&quot;</span>
<span class="cm">		 */</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SEND_GRH_FLAG</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * only if GRH is TRUE we might consider SOURCE_GID_IDX</span>
<span class="cm">		 * and DEST_GID otherwise phype will return H_ATTR_PARM!!!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">ah_flags</span> <span class="o">==</span> <span class="n">IB_AH_GRH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">send_grh_flag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">source_gid_idx</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">sgid_index</span><span class="p">;</span>
			<span class="n">update_mask</span> <span class="o">|=</span>
				<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SOURCE_GID_IDX</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
				<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">dest_gid</span><span class="p">.</span><span class="n">byte</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">dgid</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>

			<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_DEST_GID</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">flow_label</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">flow_label</span><span class="p">;</span>
			<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_FLOW_LABEL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">hop_limit</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">hop_limit</span><span class="p">;</span>
			<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_HOP_LIMIT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">traffic_class</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">traffic_class</span><span class="p">;</span>
			<span class="n">update_mask</span> <span class="o">|=</span>
				<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_TRAFFIC_CLASS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_PATH_MTU</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* store ld(MTU) */</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mtu_shift</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">path_mtu</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">path_mtu</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">path_mtu</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_PATH_MTU</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_TIMEOUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_RETRY_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">retry_count</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">retry_cnt</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_RETRY_COUNT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_RNR_RETRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">rnr_retry_count</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">rnr_retry</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_RNR_RETRY_COUNT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_RQ_PSN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">receive_psn</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">rq_psn</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_RECEIVE_PSN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_MAX_DEST_RD_ATOMIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">rdma_nr_atomic_resp_res</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">max_dest_rd_atomic</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">?</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">max_dest_rd_atomic</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span>
			<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_RDMA_NR_ATOMIC_RESP_RES</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_MAX_QP_RD_ATOMIC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">rdma_atomic_outst_dest_qp</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">max_rd_atomic</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">?</span>
			<span class="n">attr</span><span class="o">-&gt;</span><span class="n">max_rd_atomic</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span>
			<span class="n">EHCA_BMASK_SET</span>
			<span class="p">(</span><span class="n">MQPCB_MASK_RDMA_ATOMIC_OUTST_DEST_QP</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_ALT_PATH</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_port_num</span> <span class="o">&lt;</span> <span class="mi">1</span>
		    <span class="o">||</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_port_num</span> <span class="o">&gt;</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_ports</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid alt_port=%x. &quot;</span>
				 <span class="s">&quot;ehca_qp=%p qp_num=%x num_ports=%x&quot;</span><span class="p">,</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_port_num</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span>
				 <span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_ports</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">alt_phys_port</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_port_num</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_pkey_index</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid alt_pkey_index=%x. &quot;</span>
				 <span class="s">&quot;ehca_qp=%p qp_num=%x max_pkey_index=f&quot;</span><span class="p">,</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">pkey_index</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">alt_p_key_idx</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_pkey_index</span><span class="p">;</span>

		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">timeout_al</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_timeout</span><span class="p">;</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">dlid_al</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">dlid</span><span class="p">;</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">source_path_bits_al</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">src_path_bits</span><span class="p">;</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">service_level_al</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">sl</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ehca_calc_ipd</span><span class="p">(</span><span class="n">shca</span><span class="p">,</span> <span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">alt_phys_port</span><span class="p">,</span>
				  <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">static_rate</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">max_static_rate_al</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* OpenIB doesn&#39;t support alternate retry counts - copy them */</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">retry_count_al</span> <span class="o">=</span> <span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="p">;</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">rnr_retry_count_al</span> <span class="o">=</span> <span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">rnr_retry_count</span><span class="p">;</span>

		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_ALT_PHYS_PORT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_ALT_P_KEY_IDX</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_TIMEOUT_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_DLID_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SOURCE_PATH_BITS_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SERVICE_LEVEL_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_MAX_STATIC_RATE_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_RETRY_COUNT_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_RNR_RETRY_COUNT_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Always supply the GRH flag, even if it&#39;s zero, to give the</span>
<span class="cm">		 * hypervisor a clear &quot;yes&quot; or &quot;no&quot; instead of a &quot;perhaps&quot;</span>
<span class="cm">		 */</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SEND_GRH_FLAG_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * only if GRH is TRUE we might consider SOURCE_GID_IDX</span>
<span class="cm">		 * and DEST_GID otherwise phype will return H_ATTR_PARM!!!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">ah_flags</span> <span class="o">==</span> <span class="n">IB_AH_GRH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">send_grh_flag_al</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
				<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">dest_gid_al</span><span class="p">.</span><span class="n">byte</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span>
					<span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">dgid</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">source_gid_idx_al</span> <span class="o">=</span>
				<span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">sgid_index</span><span class="p">;</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">flow_label_al</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">flow_label</span><span class="p">;</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">hop_limit_al</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">hop_limit</span><span class="p">;</span>
			<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">traffic_class_al</span> <span class="o">=</span>
				<span class="n">attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">traffic_class</span><span class="p">;</span>

			<span class="n">update_mask</span> <span class="o">|=</span>
				<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SOURCE_GID_IDX_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_DEST_GID_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_FLOW_LABEL_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_HOP_LIMIT_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_TRAFFIC_CLASS_AL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_MIN_RNR_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">min_rnr_nak_timer_field</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">min_rnr_timer</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span>
			<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_MIN_RNR_NAK_TIMER_FIELD</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_SQ_PSN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">send_psn</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">sq_psn</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_SEND_PSN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_DEST_QPN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">dest_qp_nr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">dest_qp_num</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_DEST_QP_NR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_PATH_MIG_STATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">path_mig_state</span> <span class="o">!=</span> <span class="n">IB_MIG_REARM</span>
		    <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">path_mig_state</span> <span class="o">!=</span> <span class="n">IB_MIG_MIGRATED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid mig_state=%x&quot;</span><span class="p">,</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">path_mig_state</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">path_migration_state</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">path_mig_state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">path_mig_state</span> <span class="o">==</span> <span class="n">IB_MIG_REARM</span><span class="p">)</span>
			<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mig_armed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span>
			<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_PATH_MIGRATION_STATE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_CAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">max_nr_outst_send_wr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span>
			<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_MAX_NR_OUTST_SEND_WR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">max_nr_outst_recv_wr</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span>
			<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_MAX_NR_OUTST_RECV_WR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* no support for max_send/recv_sge yet */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehca_debug_level</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ehca_dmp</span><span class="p">(</span><span class="n">mqpcb</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">70</span><span class="p">,</span> <span class="s">&quot;qp_num=%x&quot;</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>

	<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_modify_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
				 <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
				 <span class="n">update_mask</span><span class="p">,</span>
				 <span class="n">mqpcb</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;hipz_h_modify_qp() failed h_ret=%lli &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_UD</span> <span class="o">||</span>
	     <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_GSI</span> <span class="o">||</span>
	     <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_SMI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">statetrans</span> <span class="o">==</span> <span class="n">IB_QPST_SQE2RTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* doorbell to reprocessing wqes */</span>
		<span class="n">iosync</span><span class="p">();</span> <span class="cm">/* serialize GAL register access */</span>
		<span class="n">hipz_update_sqa</span><span class="p">(</span><span class="n">my_qp</span><span class="p">,</span> <span class="n">bad_wqe_cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ehca_gen_dbg</span><span class="p">(</span><span class="s">&quot;doorbell for %x wqes&quot;</span><span class="p">,</span> <span class="n">bad_wqe_cnt</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">statetrans</span> <span class="o">==</span> <span class="n">IB_QPST_RESET2INIT</span> <span class="o">||</span>
	    <span class="n">statetrans</span> <span class="o">==</span> <span class="n">IB_QPST_INIT2INIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span> <span class="o">=</span> <span class="n">EHCA_QPS_INIT</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">=</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_QP_ENABLE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_modify_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span>
					 <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
					 <span class="n">update_mask</span><span class="p">,</span>
					 <span class="n">mqpcb</span><span class="p">,</span>
					 <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;ENABLE in context of &quot;</span>
				 <span class="s">&quot;RESET_2_INIT failed! Maybe you didn&#39;t get &quot;</span>
				 <span class="s">&quot;a LID h_ret=%lli ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span>
				 <span class="n">h_ret</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">qp_new_state</span> <span class="o">==</span> <span class="n">IB_QPS_ERR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">qp_cur_state</span> <span class="o">!=</span> <span class="n">IB_QPS_ERR</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_user</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">check_for_left_cqes</span><span class="p">(</span><span class="n">my_qp</span><span class="p">,</span> <span class="n">shca</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">modify_qp_exit2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">statetrans</span> <span class="o">==</span> <span class="n">IB_QPST_ANY2RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ipz_qeit_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">);</span>
		<span class="n">ipz_qeit_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qp_cur_state</span> <span class="o">==</span> <span class="n">IB_QPS_ERR</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_user</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">del_from_err_list</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_err_node</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span>
				<span class="n">del_from_err_list</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_err_node</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_user</span><span class="p">)</span>
			<span class="n">reset_queue_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_user</span><span class="p">)</span>
			<span class="n">reset_queue_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_QKEY</span><span class="p">)</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qkey</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">qkey</span><span class="p">;</span>

<span class="nl">modify_qp_exit2:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">squeue_locked</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* this means: sqe -&gt; rts */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">spinlock_s</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sqerr_purgeflag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">modify_qp_exit1:</span>
	<span class="n">ehca_free_fw_ctrlblock</span><span class="p">(</span><span class="n">mqpcb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ehca_modify_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">ibqp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">attr_mask</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span><span class="p">,</span>
					      <span class="n">ib_device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ibqp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_qp</span><span class="p">);</span>

	<span class="cm">/* The if-block below caches qp_attr to be modified for GSI and SMI</span>
<span class="cm">	 * qps during the initialization by ib_mad. When the respective port</span>
<span class="cm">	 * is activated, ie we got an event PORT_ACTIVE, we&#39;ll replay the</span>
<span class="cm">	 * cached modify calls sequence, see ehca_recover_sqs() below.</span>
<span class="cm">	 * Why that is required:</span>
<span class="cm">	 * 1) If one port is connected, older code requires that port one</span>
<span class="cm">	 *    to be connected and module option nr_ports=1 to be given by</span>
<span class="cm">	 *    user, which is very inconvenient for end user.</span>
<span class="cm">	 * 2) Firmware accepts modify_qp() only if respective port has become</span>
<span class="cm">	 *    active. Older code had a wait loop of 30sec create_qp()/</span>
<span class="cm">	 *    define_aqp1(), which is not appropriate in practice. This</span>
<span class="cm">	 *    code now removes that wait loop, see define_aqp1(), and always</span>
<span class="cm">	 *    reports all ports to ib_mad resp. users. Only activated ports</span>
<span class="cm">	 *    will then usable for the users.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_GSI</span> <span class="o">||</span> <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_SMI</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">.</span><span class="n">port_num</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ehca_sport</span> <span class="o">*</span><span class="n">sport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">sport</span><span class="p">[</span><span class="n">port</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sport</span><span class="o">-&gt;</span><span class="n">mod_sqp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* cache qp_attr only during init */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ehca_mod_qp_parm</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm_idx</span> <span class="o">&gt;=</span> <span class="n">EHCA_MOD_QP_PARM_MAX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ehca_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">,</span>
					 <span class="s">&quot;mod_qp_parm overflow state=%x port=%x&quot;</span>
					 <span class="s">&quot; type=%x&quot;</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">,</span>
					 <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">.</span><span class="n">port_num</span><span class="p">,</span>
					 <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sport</span><span class="o">-&gt;</span><span class="n">mod_sqp_lock</span><span class="p">,</span>
						       <span class="n">flags</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">[</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm_idx</span><span class="p">];</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">attr_mask</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">=</span> <span class="o">*</span><span class="n">attr</span><span class="p">;</span>
			<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm_idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ehca_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">,</span>
				 <span class="s">&quot;Saved qp_attr for state=%x port=%x type=%x&quot;</span><span class="p">,</span>
				 <span class="n">attr</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">.</span><span class="n">port_num</span><span class="p">,</span>
				 <span class="n">ibqp</span><span class="o">-&gt;</span><span class="n">qp_type</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sport</span><span class="o">-&gt;</span><span class="n">mod_sqp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sport</span><span class="o">-&gt;</span><span class="n">mod_sqp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">internal_modify_qp</span><span class="p">(</span><span class="n">ibqp</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">attr_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_QP_STATE</span><span class="p">))</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ehca_recover_sqp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">sqp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_sqp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sqp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_qp</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">.</span><span class="n">port_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="n">attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ehca_mod_qp_parm</span> <span class="o">*</span><span class="n">qp_parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">qp_parm_idx</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">wr_cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ehca_dbg</span><span class="p">(</span><span class="n">sqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;SQP port=%x qp_num=%x&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">sqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>

	<span class="n">qp_parm</span> <span class="o">=</span> <span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">;</span>
	<span class="n">qp_parm_idx</span> <span class="o">=</span> <span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm_idx</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qp_parm_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">attr</span> <span class="o">=</span> <span class="n">qp_parm</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">attr</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">internal_modify_qp</span><span class="p">(</span><span class="n">sqp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">qp_parm</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">sqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Could not modify SQP port=%x &quot;</span>
				 <span class="s">&quot;qp_num=%x ret=%x&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">sqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_qp_parm</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ehca_dbg</span><span class="p">(</span><span class="n">sqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;SQP port=%x qp_num=%x in state=%x&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="p">,</span> <span class="n">sqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">attr</span><span class="p">.</span><span class="n">qp_state</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* re-trigger posted recv wrs */</span>
	<span class="n">wr_cnt</span> <span class="o">=</span>  <span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">.</span><span class="n">current_q_offset</span> <span class="o">/</span>
		<span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">.</span><span class="n">qe_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wr_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">spinlock_r</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">hipz_update_rqa</span><span class="p">(</span><span class="n">my_sqp</span><span class="p">,</span> <span class="n">wr_cnt</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">spinlock_r</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ehca_dbg</span><span class="p">(</span><span class="n">sqp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;doorbell port=%x qp_num=%x wr_cnt=%lx&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="p">,</span> <span class="n">sqp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">wr_cnt</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">free_qp_parm:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">qp_parm</span><span class="p">);</span>
	<span class="cm">/* this prevents subsequent calls to modify_qp() to cache qp_attr */</span>
	<span class="n">my_sqp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ehca_query_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">qp_attr</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">qp_attr_mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_qp_init_attr</span> <span class="o">*</span><span class="n">qp_init_attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_qp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span><span class="p">,</span>
					      <span class="n">ib_device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ipz_adapter_handle</span> <span class="n">adapter_handle</span> <span class="o">=</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hcp_modify_qp_control_block</span> <span class="o">*</span><span class="n">qpcb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">h_ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qp_attr_mask</span> <span class="o">&amp;</span> <span class="n">QP_ATTR_QUERY_NOT_SUPPORTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Invalid attribute mask &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x qp_attr_mask=%x &quot;</span><span class="p">,</span>
			 <span class="n">my_qp</span><span class="p">,</span> <span class="n">qp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">qp_attr_mask</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qpcb</span> <span class="o">=</span> <span class="n">ehca_alloc_fw_ctrlblock</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qpcb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Out of memory for qpcb &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">qp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_query_qp</span><span class="p">(</span><span class="n">adapter_handle</span><span class="p">,</span>
				<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">pf</span><span class="p">,</span>
				<span class="n">qpcb</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;hipz_h_query_qp() failed &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x h_ret=%lli&quot;</span><span class="p">,</span>
			 <span class="n">my_qp</span><span class="p">,</span> <span class="n">qp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">query_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cur_qp_state</span> <span class="o">=</span> <span class="n">ehca2ib_qp_state</span><span class="p">(</span><span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">);</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">qp_state</span> <span class="o">=</span> <span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cur_qp_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cur_qp_state</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Got invalid ehca_qp_state=%x &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span>
			 <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">qp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">query_qp_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">qp_state</span> <span class="o">==</span> <span class="n">IB_QPS_SQD</span><span class="p">)</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">sq_draining</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">qkey</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">qkey</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">path_mtu</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">path_mtu</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">path_mig_state</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">path_migration_state</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">rq_psn</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">receive_psn</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">sq_psn</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">send_psn</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">min_rnr_timer</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">min_rnr_nak_timer_field</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_wr</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">max_nr_outst_send_wr</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_wr</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">max_nr_outst_recv_wr</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* UD_AV CIRCUMVENTION */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_UD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span> <span class="o">=</span>
			<span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">actual_nr_sges_in_sq_wqe</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">=</span>
			<span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">actual_nr_sges_in_rq_wqe</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_send_sge</span> <span class="o">=</span>
			<span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">actual_nr_sges_in_sq_wqe</span><span class="p">;</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_recv_sge</span> <span class="o">=</span>
			<span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">actual_nr_sges_in_rq_wqe</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">cap</span><span class="p">.</span><span class="n">max_inline_data</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_max_inline_data_size</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">dest_qp_num</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">dest_qp_nr</span><span class="p">;</span>

	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">pkey_index</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">prim_p_key_idx</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">port_num</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">prim_phys_port</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">retry_cnt</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">retry_count</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">rnr_retry</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">rnr_retry_count</span><span class="p">;</span>

	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_pkey_index</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">alt_p_key_idx</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_port_num</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">alt_phys_port</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_timeout</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">timeout_al</span><span class="p">;</span>

	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">max_dest_rd_atomic</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">rdma_nr_atomic_resp_res</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">max_rd_atomic</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">rdma_atomic_outst_dest_qp</span><span class="p">;</span>

	<span class="cm">/* primary av */</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">service_level</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">send_grh_flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">ah_flags</span> <span class="o">=</span> <span class="n">IB_AH_GRH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">static_rate</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">max_static_rate</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">dlid</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">dlid</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">src_path_bits</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">source_path_bits</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">port_num</span> <span class="o">=</span> <span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">port_num</span><span class="p">;</span>

	<span class="cm">/* primary GRH */</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">traffic_class</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">traffic_class</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">hop_limit</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">hop_limit</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">sgid_index</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">source_gid_idx</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">flow_label</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">flow_label</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">dgid</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">dest_gid</span><span class="p">.</span><span class="n">byte</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>

	<span class="cm">/* alternate AV */</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">sl</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">service_level_al</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">send_grh_flag_al</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">ah_flags</span> <span class="o">=</span> <span class="n">IB_AH_GRH</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">static_rate</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">max_static_rate_al</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">dlid</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">dlid_al</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">src_path_bits</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">source_path_bits_al</span><span class="p">;</span>

	<span class="cm">/* alternate GRH */</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">traffic_class</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">traffic_class_al</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">hop_limit</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">hop_limit_al</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">sgid_index</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">source_gid_idx_al</span><span class="p">;</span>
	<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">flow_label</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">flow_label_al</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">alt_ah_attr</span><span class="p">.</span><span class="n">grh</span><span class="p">.</span><span class="n">dgid</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">dest_gid_al</span><span class="p">.</span><span class="n">byte</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span>

	<span class="cm">/* return init attributes given in ehca_create_qp */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qp_init_attr</span><span class="p">)</span>
		<span class="o">*</span><span class="n">qp_init_attr</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehca_debug_level</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ehca_dmp</span><span class="p">(</span><span class="n">qpcb</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">70</span><span class="p">,</span> <span class="s">&quot;qp_num=%x&quot;</span><span class="p">,</span> <span class="n">qp</span><span class="o">-&gt;</span><span class="n">qp_num</span><span class="p">);</span>

<span class="nl">query_qp_exit1:</span>
	<span class="n">ehca_free_fw_ctrlblock</span><span class="p">(</span><span class="n">qpcb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ehca_modify_srq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">ibsrq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_srq_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="k">enum</span> <span class="n">ib_srq_attr_mask</span> <span class="n">attr_mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_udata</span> <span class="o">*</span><span class="n">udata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ibsrq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_srq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">ibsrq</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span><span class="p">,</span> <span class="n">ib_device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hcp_modify_qp_control_block</span> <span class="o">*</span><span class="n">mqpcb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">update_mask</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">h_ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mqpcb</span> <span class="o">=</span> <span class="n">ehca_alloc_fw_ctrlblock</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mqpcb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibsrq</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Could not get zeroed page for mqpcb &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x &quot;</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">update_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span> <span class="o">&amp;</span> <span class="n">IB_SRQ_LIMIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">attr_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IB_SRQ_LIMIT</span><span class="p">;</span>
		<span class="n">update_mask</span> <span class="o">|=</span>
			<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_CURR_SRQ_LIMIT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">MQPCB_MASK_QP_AFF_ASYN_EV_LOG_REG</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">curr_srq_limit</span> <span class="o">=</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">srq_limit</span><span class="p">;</span>
		<span class="n">mqpcb</span><span class="o">-&gt;</span><span class="n">qp_aff_asyn_ev_log_reg</span> <span class="o">=</span>
			<span class="n">EHCA_BMASK_SET</span><span class="p">(</span><span class="n">QPX_AAELOG_RESET_SRQ_LIMIT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* by now, all bits in attr_mask should have been cleared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibsrq</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;invalid attribute mask bits set  &quot;</span>
			 <span class="s">&quot;attr_mask=%x&quot;</span><span class="p">,</span> <span class="n">attr_mask</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">modify_srq_exit0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehca_debug_level</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ehca_dmp</span><span class="p">(</span><span class="n">mqpcb</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">70</span><span class="p">,</span> <span class="s">&quot;qp_num=%x&quot;</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">);</span>

	<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_modify_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="n">update_mask</span><span class="p">,</span> <span class="n">mqpcb</span><span class="p">,</span>
				 <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">ibsrq</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;hipz_h_modify_qp() failed h_ret=%lli &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span>
			 <span class="n">h_ret</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">modify_srq_exit0:</span>
	<span class="n">ehca_free_fw_ctrlblock</span><span class="p">(</span><span class="n">mqpcb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ehca_query_srq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ib_srq_attr</span> <span class="o">*</span><span class="n">srq_attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">srq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_srq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">srq</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span><span class="p">,</span>
					      <span class="n">ib_device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ipz_adapter_handle</span> <span class="n">adapter_handle</span> <span class="o">=</span> <span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hcp_modify_qp_control_block</span> <span class="o">*</span><span class="n">qpcb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">h_ret</span><span class="p">;</span>

	<span class="n">qpcb</span> <span class="o">=</span> <span class="n">ehca_alloc_fw_ctrlblock</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qpcb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">srq</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;Out of memory for qpcb &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_query_qp</span><span class="p">(</span><span class="n">adapter_handle</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_qp_handle</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span> <span class="n">qpcb</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">galpas</span><span class="p">.</span><span class="n">kernel</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">srq</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;hipz_h_query_qp() failed &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x h_ret=%lli&quot;</span><span class="p">,</span>
			 <span class="n">my_qp</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">query_srq_exit1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">srq_attr</span><span class="o">-&gt;</span><span class="n">max_wr</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">max_nr_outst_recv_wr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">srq_attr</span><span class="o">-&gt;</span><span class="n">max_sge</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">srq_attr</span><span class="o">-&gt;</span><span class="n">srq_limit</span> <span class="o">=</span> <span class="n">qpcb</span><span class="o">-&gt;</span><span class="n">curr_srq_limit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ehca_debug_level</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ehca_dmp</span><span class="p">(</span><span class="n">qpcb</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">70</span><span class="p">,</span> <span class="s">&quot;qp_num=%x&quot;</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">);</span>

<span class="nl">query_srq_exit1:</span>
	<span class="n">ehca_free_fw_ctrlblock</span><span class="p">(</span><span class="n">qpcb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">internal_destroy_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span> <span class="o">*</span><span class="n">my_qp</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ib_uobject</span> <span class="o">*</span><span class="n">uobject</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ehca_shca</span> <span class="o">*</span><span class="n">shca</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_shca</span><span class="p">,</span> <span class="n">ib_device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehca_pd</span> <span class="o">*</span><span class="n">my_pd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ib_qp</span><span class="p">.</span><span class="n">pd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_pd</span><span class="p">,</span>
					     <span class="n">ib_pd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ehca_sport</span> <span class="o">*</span><span class="n">sport</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">sport</span><span class="p">[</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">.</span><span class="n">port_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">qp_num</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">real_qp_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">h_ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">port_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_user</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ib_qp_type</span>	<span class="n">qp_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uobject</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">is_user</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mm_count_galpa</span> <span class="o">||</span>
		    <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mm_count_rqueue</span> <span class="o">||</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mm_count_squeue</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Resources still referenced in &quot;</span>
				 <span class="s">&quot;user space qp_num=%x&quot;</span><span class="p">,</span> <span class="n">qp_num</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ehca_cq_unassign_qp</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">,</span> <span class="n">qp_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ehca_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t unassign qp from &quot;</span>
				 <span class="s">&quot;send_cq ret=%i qp_num=%x cq_num=%x&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
				 <span class="n">qp_num</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="o">-&gt;</span><span class="n">cq_number</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr</span><span class="p">,</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ehca_qp_idr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * SRQs will never get into an error list and do not have a recv_cq,</span>
<span class="cm">	 * so we need to skip them here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_SRQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_user</span><span class="p">)</span>
		<span class="n">del_from_err_list</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">recv_cq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_err_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_SQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_user</span><span class="p">)</span>
		<span class="n">del_from_err_list</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">send_cq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_err_node</span><span class="p">);</span>

	<span class="cm">/* now wait until all pending events have completed */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">wait_completion</span><span class="p">,</span> <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">nr_events</span><span class="p">));</span>

	<span class="n">h_ret</span> <span class="o">=</span> <span class="n">hipz_h_destroy_qp</span><span class="p">(</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ipz_hca_handle</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h_ret</span> <span class="o">!=</span> <span class="n">H_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ehca_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hipz_h_destroy_qp() failed h_ret=%lli &quot;</span>
			 <span class="s">&quot;ehca_qp=%p qp_num=%x&quot;</span><span class="p">,</span> <span class="n">h_ret</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">,</span> <span class="n">qp_num</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ehca2ib_return_code</span><span class="p">(</span><span class="n">h_ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">port_num</span> <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">.</span><span class="n">port_num</span><span class="p">;</span>
	<span class="n">qp_type</span>  <span class="o">=</span> <span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">init_attr</span><span class="p">.</span><span class="n">qp_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_SMI</span> <span class="o">||</span> <span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_GSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sport</span><span class="o">-&gt;</span><span class="n">mod_sqp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span><span class="p">);</span>
		<span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">mod_qp_parm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">shca</span><span class="o">-&gt;</span><span class="n">sport</span><span class="p">[</span><span class="n">port_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">ibqp_sqp</span><span class="p">[</span><span class="n">qp_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sport</span><span class="o">-&gt;</span><span class="n">mod_sqp_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* no support for IB_QPT_SMI yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qp_type</span> <span class="o">==</span> <span class="n">IB_QPT_GSI</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ib_event</span> <span class="n">event</span><span class="p">;</span>
		<span class="n">ehca_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device %s: port %x is inactive.&quot;</span><span class="p">,</span>
				<span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">port_num</span><span class="p">);</span>
		<span class="n">event</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">ib_device</span><span class="p">;</span>
		<span class="n">event</span><span class="p">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">IB_EVENT_PORT_ERR</span><span class="p">;</span>
		<span class="n">event</span><span class="p">.</span><span class="n">element</span><span class="p">.</span><span class="n">port_num</span> <span class="o">=</span> <span class="n">port_num</span><span class="p">;</span>
		<span class="n">shca</span><span class="o">-&gt;</span><span class="n">sport</span><span class="p">[</span><span class="n">port_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">IB_PORT_DOWN</span><span class="p">;</span>
		<span class="n">ib_dispatch_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_RQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ipz_queue_dtor</span><span class="p">(</span><span class="n">my_pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_rqueue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_user</span><span class="p">)</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">rq_map</span><span class="p">.</span><span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HAS_SQ</span><span class="p">(</span><span class="n">my_qp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ipz_queue_dtor</span><span class="p">(</span><span class="n">my_pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">ipz_squeue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_user</span><span class="p">)</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">my_qp</span><span class="o">-&gt;</span><span class="n">sq_map</span><span class="p">.</span><span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">qp_cache</span><span class="p">,</span> <span class="n">my_qp</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shca</span><span class="o">-&gt;</span><span class="n">num_qps</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ehca_destroy_qp</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">internal_destroy_qp</span><span class="p">(</span><span class="n">qp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
				   <span class="n">container_of</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_qp</span><span class="p">),</span>
				   <span class="n">qp</span><span class="o">-&gt;</span><span class="n">uobject</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ehca_destroy_srq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_srq</span> <span class="o">*</span><span class="n">srq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">internal_destroy_qp</span><span class="p">(</span><span class="n">srq</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span>
				   <span class="n">container_of</span><span class="p">(</span><span class="n">srq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">,</span> <span class="n">ib_srq</span><span class="p">),</span>
				   <span class="n">srq</span><span class="o">-&gt;</span><span class="n">uobject</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ehca_init_qp_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qp_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;ehca_cache_qp&quot;</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ehca_qp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qp_cache</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ehca_cleanup_qp_cache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qp_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">qp_cache</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
