<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › core › iwcm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>iwcm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2004, 2005 Intel Corporation.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2004 Topspin Corporation.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2004, 2005 Voltaire Corporation.  All rights reserved.</span>
<span class="cm"> * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.</span>
<span class="cm"> * Copyright (c) 2005 Open Grid Computing, Inc. All rights reserved.</span>
<span class="cm"> * Copyright (c) 2005 Network Appliance, Inc. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions of source code must retain the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *      - Redistributions in binary form must reproduce the above</span>
<span class="cm"> *        copyright notice, this list of conditions and the following</span>
<span class="cm"> *        disclaimer in the documentation and/or other materials</span>
<span class="cm"> *        provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;rdma/iw_cm.h&gt;</span>
<span class="cp">#include &lt;rdma/ib_addr.h&gt;</span>

<span class="cp">#include &quot;iwcm.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Tom Tucker&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;iWARP CM&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;Dual BSD/GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">iwcm_wq</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iwcm_work</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="n">event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">free_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * The following services provide a mechanism for pre-allocating iwcm_work</span>
<span class="cm"> * elements.  The design pre-allocates them  based on the cm_id type:</span>
<span class="cm"> *	LISTENING IDS: 	Get enough elements preallocated to handle the</span>
<span class="cm"> *			listen backlog.</span>
<span class="cm"> *	ACTIVE IDS:	4: CONNECT_REPLY, ESTABLISHED, DISCONNECT, CLOSE</span>
<span class="cm"> *	PASSIVE IDS:	3: ESTABLISHED, DISCONNECT, CLOSE</span>
<span class="cm"> *</span>
<span class="cm"> * Allocating them in connect and listen avoids having to deal</span>
<span class="cm"> * with allocation failures on the event upcall from the provider (which</span>
<span class="cm"> * is called in the interrupt context).</span>
<span class="cm"> *</span>
<span class="cm"> * One exception is when creating the cm_id for incoming connection requests.</span>
<span class="cm"> * There are two cases:</span>
<span class="cm"> * 1) in the event upcall, cm_event_handler(), for a listening cm_id.  If</span>
<span class="cm"> *    the backlog is exceeded, then no more connection request events will</span>
<span class="cm"> *    be processed.  cm_event_handler() returns -ENOMEM in this case.  Its up</span>
<span class="cm"> *    to the provider to reject the connection request.</span>
<span class="cm"> * 2) in the connection request workqueue handler, cm_conn_req_handler().</span>
<span class="cm"> *    If work elements cannot be allocated for the new connect request cm_id,</span>
<span class="cm"> *    then IWCM will call the provider reject method.  This is ok since</span>
<span class="cm"> *    cm_conn_req_handler() runs in the workqueue thread context.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iwcm_work</span> <span class="o">*</span><span class="nf">get_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_free_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">work</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_free_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_work</span><span class="p">,</span>
			  <span class="n">free_list</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">work_free_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dealloc_work_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_free_list</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">list_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_work</span><span class="p">,</span> <span class="n">free_list</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_work_entries</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_free_list</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">work</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_work</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dealloc_work_entries</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">work</span><span class="o">-&gt;</span><span class="n">cm_id</span> <span class="o">=</span> <span class="n">cm_id_priv</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">put_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Save private data from incoming connection requests to</span>
<span class="cm"> * iw_cm_event, so the low level driver doesn&#39;t have to. Adjust</span>
<span class="cm"> * the event ptr to point to the local copy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_private_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">,</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">private_data_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">event</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_cm_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dealloc_work_entries</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release a reference on cm_id. If the last reference is being</span>
<span class="cm"> * released, enable the waiting thread (in iw_destroy_cm_id) to</span>
<span class="cm"> * get woken up, and return 1 if a thread is already waiting.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwcm_deref_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">));</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">destroy_comp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rem_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iwcm_deref_id</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">IWCM_F_CALLBACK_DESTROY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">));</span>
		<span class="n">free_cm_id</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cm_event_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="nf">iw_create_cm_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				 <span class="n">iw_cm_handler</span> <span class="n">cm_handler</span><span class="p">,</span>
				 <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cm_id_priv</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cm_id_priv</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_IDLE</span><span class="p">;</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">cm_handler</span> <span class="o">=</span> <span class="n">cm_handler</span><span class="p">;</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="p">;</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">event_handler</span> <span class="o">=</span> <span class="n">cm_event_handler</span><span class="p">;</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">add_ref</span> <span class="o">=</span> <span class="n">add_ref</span><span class="p">;</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">rem_ref</span> <span class="o">=</span> <span class="n">rem_ref</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">destroy_comp</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_free_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iw_create_cm_id</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwcm_modify_qp_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="n">qp_attr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">qp_attr</span><span class="p">.</span><span class="n">qp_state</span> <span class="o">=</span> <span class="n">IB_QPS_ERR</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ib_modify_qp</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qp_attr</span><span class="p">,</span> <span class="n">IB_QP_STATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is really the RDMAC CLOSING state. It is most similar to the</span>
<span class="cm"> * IB SQD QP state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwcm_modify_qp_sqd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="n">qp_attr</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">qp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">qp_attr</span><span class="p">.</span><span class="n">qp_state</span> <span class="o">=</span> <span class="n">IB_QPS_SQD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ib_modify_qp</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qp_attr</span><span class="p">,</span> <span class="n">IB_QP_STATE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CM_ID &lt;-- CLOSING</span>
<span class="cm"> *</span>
<span class="cm"> * Block if a passive or active connection is currently being processed. Then</span>
<span class="cm"> * process the event as follows:</span>
<span class="cm"> * - If we are ESTABLISHED, move to CLOSING and modify the QP state</span>
<span class="cm"> *   based on the abrupt flag</span>
<span class="cm"> * - If the connection is already in the CLOSING or IDLE state, the peer is</span>
<span class="cm"> *   disconnecting concurrently with us and we&#39;ve already seen the</span>
<span class="cm"> *   DISCONNECT event -- ignore the request and return 0</span>
<span class="cm"> * - Disconnect on a listening endpoint returns -EINVAL</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iw_cm_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">abrupt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="cm">/* Wait if we&#39;re currently in a connect or accept downcall */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">,</span>
		   <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_ESTABLISHED</span>:
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_CLOSING</span><span class="p">;</span>

		<span class="cm">/* QP could be &lt;nul&gt; for user-mode client */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">)</span>
			<span class="n">qp</span> <span class="o">=</span> <span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_LISTEN</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_CLOSING</span>:
		<span class="cm">/* remote peer closed first */</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_IDLE</span>:
		<span class="cm">/* accept or connect returned !0 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_CONN_RECV</span>:
		<span class="cm">/*</span>
<span class="cm">		 * App called disconnect before/without calling accept after</span>
<span class="cm">		 * connect_request event delivered.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_CONN_SENT</span>:
		<span class="cm">/* Can only get here if wait above fails */</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">abrupt</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iwcm_modify_qp_err</span><span class="p">(</span><span class="n">qp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iwcm_modify_qp_sqd</span><span class="p">(</span><span class="n">qp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If both sides are disconnecting the QP could</span>
<span class="cm">		 * already be in ERR or SQD states</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iw_cm_disconnect</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CM_ID &lt;-- DESTROYING</span>
<span class="cm"> *</span>
<span class="cm"> * Clean up all resources associated with the connection and release</span>
<span class="cm"> * the initial reference taken by iw_create_cm_id.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_cm_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Wait if we&#39;re currently in a connect or accept downcall. A</span>
<span class="cm">	 * listening endpoint should never block here.</span>
<span class="cm">	 */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">,</span>
		   <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_LISTEN</span>:
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_DESTROYING</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* destroy the listening endpoint */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">destroy_listen</span><span class="p">(</span><span class="n">cm_id</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_ESTABLISHED</span>:
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_DESTROYING</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Abrupt close of the connection */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">iwcm_modify_qp_err</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_IDLE</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_CLOSING</span>:
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_DESTROYING</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_CONN_RECV</span>:
		<span class="cm">/*</span>
<span class="cm">		 * App called destroy before/without calling accept after</span>
<span class="cm">		 * receiving connection request event notification or</span>
<span class="cm">		 * returned non zero from the event callback function.</span>
<span class="cm">		 * In either case, must tell the provider to reject.</span>
<span class="cm">		 */</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_DESTROYING</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_CONN_SENT</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_DESTROYING</span>:
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">rem_ref</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">);</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">iwcm_deref_id</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is only called by the application thread and cannot</span>
<span class="cm"> * be called by the event thread. The function will wait for all</span>
<span class="cm"> * references to be released on the cm_id and then kfree the cm_id</span>
<span class="cm"> * object.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iw_destroy_cm_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">IWCM_F_CALLBACK_DESTROY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>

	<span class="n">destroy_cm_id</span><span class="p">(</span><span class="n">cm_id</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">destroy_comp</span><span class="p">);</span>

	<span class="n">free_cm_id</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iw_destroy_cm_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CM_ID &lt;-- LISTEN</span>
<span class="cm"> *</span>
<span class="cm"> * Start listening for connect requests. Generates one CONNECT_REQUEST</span>
<span class="cm"> * event for each inbound connect request.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iw_cm_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_work_entries</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_IDLE</span>:
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_LISTEN</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">create_listen</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_IDLE</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iw_cm_listen</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CM_ID &lt;-- IDLE</span>
<span class="cm"> *</span>
<span class="cm"> * Rejects an inbound connection request. No events are generated.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iw_cm_reject</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">,</span>
		 <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private_data</span><span class="p">,</span>
		 <span class="n">u8</span> <span class="n">private_data_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IW_CM_STATE_CONN_RECV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_IDLE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">reject</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="n">private_data</span><span class="p">,</span>
					  <span class="n">private_data_len</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iw_cm_reject</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * CM_ID &lt;-- ESTABLISHED</span>
<span class="cm"> *</span>
<span class="cm"> * Accepts an inbound connection request and generates an ESTABLISHED</span>
<span class="cm"> * event. Callers of iw_cm_disconnect and iw_destroy_cm_id will block</span>
<span class="cm"> * until the ESTABLISHED event is received from the provider.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iw_cm_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">iw_cm_conn_param</span> <span class="o">*</span><span class="n">iw_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IW_CM_STATE_CONN_RECV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Get the ib_qp given the QPN */</span>
	<span class="n">qp</span> <span class="o">=</span> <span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">get_qp</span><span class="p">(</span><span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">iw_param</span><span class="o">-&gt;</span><span class="n">qpn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">add_ref</span><span class="p">(</span><span class="n">qp</span><span class="p">);</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span> <span class="o">=</span> <span class="n">qp</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="n">iw_param</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* An error on accept precludes provider events */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IW_CM_STATE_CONN_RECV</span><span class="p">);</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_IDLE</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">rem_ref</span><span class="p">(</span><span class="n">qp</span><span class="p">);</span>
			<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iw_cm_accept</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Active Side: CM_ID &lt;-- CONN_SENT</span>
<span class="cm"> *</span>
<span class="cm"> * If successful, results in the generation of a CONNECT_REPLY</span>
<span class="cm"> * event. iw_cm_disconnect and iw_cm_destroy will block until the</span>
<span class="cm"> * CONNECT_REPLY event is received from the provider.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iw_cm_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iw_cm_conn_param</span> <span class="o">*</span><span class="n">iw_param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_qp</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_work_entries</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IW_CM_STATE_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the ib_qp given the QPN */</span>
	<span class="n">qp</span> <span class="o">=</span> <span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">get_qp</span><span class="p">(</span><span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">iw_param</span><span class="o">-&gt;</span><span class="n">qpn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">add_ref</span><span class="p">(</span><span class="n">qp</span><span class="p">);</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span> <span class="o">=</span> <span class="n">qp</span><span class="p">;</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_CONN_SENT</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="n">iw_param</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">rem_ref</span><span class="p">(</span><span class="n">qp</span><span class="p">);</span>
			<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IW_CM_STATE_CONN_SENT</span><span class="p">);</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_IDLE</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iw_cm_connect</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Passive Side: new CM_ID &lt;-- CONN_RECV</span>
<span class="cm"> *</span>
<span class="cm"> * Handles an inbound connect request. The function creates a new</span>
<span class="cm"> * iw_cm_id to represent the new connection and inherits the client</span>
<span class="cm"> * callback function and other attributes from the listening parent.</span>
<span class="cm"> *</span>
<span class="cm"> * The work item contains a pointer to the listen_cm_id and the event. The</span>
<span class="cm"> * listen_cm_id contains the client cm_handler, context and</span>
<span class="cm"> * device. These are copied when the device is cloned. The event</span>
<span class="cm"> * contains the new four tuple.</span>
<span class="cm"> *</span>
<span class="cm"> * An error on the child should not affect the parent, so this</span>
<span class="cm"> * function does not return a value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cm_conn_req_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">listen_id_priv</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">iw_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The provider should never generate a connection request</span>
<span class="cm">	 * event with a bad status.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>

	<span class="n">cm_id</span> <span class="o">=</span> <span class="n">iw_create_cm_id</span><span class="p">(</span><span class="n">listen_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">device</span><span class="p">,</span>
				<span class="n">listen_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">cm_handler</span><span class="p">,</span>
				<span class="n">listen_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">context</span><span class="p">);</span>
	<span class="cm">/* If the cm_id could not be created, ignore the request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cm_id</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">provider_data</span> <span class="o">=</span> <span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">provider_data</span><span class="p">;</span>
	<span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">local_addr</span> <span class="o">=</span> <span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">local_addr</span><span class="p">;</span>
	<span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">remote_addr</span> <span class="o">=</span> <span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">remote_addr</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_CONN_RECV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We could be destroying the listening id. If so, ignore this</span>
<span class="cm">	 * upcall.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">listen_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IW_CM_STATE_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">iw_cm_reject</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">iw_destroy_cm_id</span><span class="p">(</span><span class="n">cm_id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listen_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_work_entries</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iw_cm_reject</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">iw_destroy_cm_id</span><span class="p">(</span><span class="n">cm_id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Call the client CM handler */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id</span><span class="o">-&gt;</span><span class="n">cm_handler</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iw_cm_reject</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">IWCM_F_CALLBACK_DESTROY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">destroy_cm_id</span><span class="p">(</span><span class="n">cm_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">free_cm_id</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">private_data_len</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Passive Side: CM_ID &lt;-- ESTABLISHED</span>
<span class="cm"> *</span>
<span class="cm"> * The provider generated an ESTABLISHED event which means that</span>
<span class="cm"> * the MPA negotion has completed successfully and we are now in MPA</span>
<span class="cm"> * FPDU mode.</span>
<span class="cm"> *</span>
<span class="cm"> * This event can only be received in the CONN_RECV state. If the</span>
<span class="cm"> * remote peer closed, the ESTABLISHED event would be received followed</span>
<span class="cm"> * by the CLOSE event. If the app closes, it will block until we wake</span>
<span class="cm"> * it up after processing this event.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cm_conn_est_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">iw_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We clear the CONNECT_WAIT bit here to allow the callback</span>
<span class="cm">	 * function to call iw_cm_disconnect. Calling iw_destroy_cm_id</span>
<span class="cm">	 * from a callback handler is not allowed.</span>
<span class="cm">	 */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IW_CM_STATE_CONN_RECV</span><span class="p">);</span>
	<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_ESTABLISHED</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">cm_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Active Side: CM_ID &lt;-- ESTABLISHED</span>
<span class="cm"> *</span>
<span class="cm"> * The app has called connect and is waiting for the established event to</span>
<span class="cm"> * post it&#39;s requests to the server. This event will wake up anyone</span>
<span class="cm"> * blocked in iw_cm_disconnect or iw_destroy_id.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cm_conn_rep_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">iw_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear the connect wait bit so a callback function calling</span>
<span class="cm">	 * iw_cm_disconnect will not wait and deadlock this thread</span>
<span class="cm">	 */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">IWCM_F_CONNECT_WAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">IW_CM_STATE_CONN_SENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">local_addr</span> <span class="o">=</span> <span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">local_addr</span><span class="p">;</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">remote_addr</span> <span class="o">=</span> <span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">remote_addr</span><span class="p">;</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_ESTABLISHED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* REJECTED or RESET */</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">rem_ref</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">);</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_IDLE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">cm_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">private_data_len</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>

	<span class="cm">/* Wake up waiters on connect complete */</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">connect_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CM_ID &lt;-- CLOSING</span>
<span class="cm"> *</span>
<span class="cm"> * If in the ESTABLISHED state, move to CLOSING.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cm_disconnect_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">iw_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">IW_CM_STATE_ESTABLISHED</span><span class="p">)</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_CLOSING</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * CM_ID &lt;-- IDLE</span>
<span class="cm"> *</span>
<span class="cm"> * If in the ESTBLISHED or CLOSING states, the QP will have have been</span>
<span class="cm"> * moved by the provider to the ERR state. Disassociate the CM_ID from</span>
<span class="cm"> * the QP,  move to IDLE, and remove the &#39;connected&#39; reference.</span>
<span class="cm"> *</span>
<span class="cm"> * If in some other state, the cm_id was destroyed asynchronously.</span>
<span class="cm"> * This is the last reference that will result in waking up</span>
<span class="cm"> * the app thread blocked in iw_destroy_cm_id.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cm_close_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">iw_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">iwcm</span><span class="o">-&gt;</span><span class="n">rem_ref</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span><span class="p">);</span>
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">qp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_ESTABLISHED</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_CLOSING</span>:
		<span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">IW_CM_STATE_IDLE</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">cm_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_DESTROYING</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">iw_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">iw_event</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IW_CM_EVENT_CONNECT_REQUEST</span>:
		<span class="n">cm_conn_req_handler</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_EVENT_CONNECT_REPLY</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_conn_rep_handler</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_EVENT_ESTABLISHED</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_conn_est_handler</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_EVENT_DISCONNECT</span>:
		<span class="n">cm_disconnect_handler</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IW_CM_EVENT_CLOSE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cm_close_handler</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="n">iw_event</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Process events on the work_list for the cm_id. If the callback</span>
<span class="cm"> * function requests that the cm_id be deleted, a flag is set in the</span>
<span class="cm"> * cm_id flags to indicate that when the last reference is</span>
<span class="cm"> * removed, the cm_id is to be destroyed. This is necessary to</span>
<span class="cm"> * distinguish between an object that will be destroyed by the app</span>
<span class="cm"> * thread asleep on the destroy_comp list vs. an object destroyed</span>
<span class="cm"> * here synchronously when the last reference is removed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cm_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">_work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_work</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_work</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="n">levent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">cm_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">destroy_id</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">empty</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">work</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">iwcm_work</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">empty</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
		<span class="n">levent</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">;</span>
		<span class="n">put_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">process_event</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">levent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">IWCM_F_CALLBACK_DESTROY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">destroy_cm_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">destroy_id</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">IWCM_F_CALLBACK_DESTROY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iwcm_deref_id</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">destroy_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">));</span>
				<span class="n">free_cm_id</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called on interrupt context. Schedule events on</span>
<span class="cm"> * the iwcm_wq thread to allow callback functions to downcall into</span>
<span class="cm"> * the CM and/or block.  Events are queued to a per-CM_ID</span>
<span class="cm"> * work_list. If this is the first event on the work_list, the work</span>
<span class="cm"> * element is also queued on the iwcm_wq thread.</span>
<span class="cm"> *</span>
<span class="cm"> * Each event holds a reference on the cm_id. Until the last posted</span>
<span class="cm"> * event has been delivered and processed, the cm_id cannot be</span>
<span class="cm"> * deleted.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * 	      0	- the event was handled.</span>
<span class="cm"> *	-ENOMEM	- the event was not handled due to lack of resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cm_event_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">iw_cm_event</span> <span class="o">*</span><span class="n">iw_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">work</span> <span class="o">=</span> <span class="n">get_work</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">cm_work_handler</span><span class="p">);</span>
	<span class="n">work</span><span class="o">-&gt;</span><span class="n">cm_id</span> <span class="o">=</span> <span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="n">work</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">iw_event</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">event</span> <span class="o">==</span> <span class="n">IW_CM_EVENT_CONNECT_REQUEST</span> <span class="o">||</span>
	     <span class="n">work</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">event</span> <span class="o">==</span> <span class="n">IW_CM_EVENT_CONNECT_REPLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">work</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">private_data_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_private_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">iwcm_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwcm_init_qp_init_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">qp_attr</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="o">*</span><span class="n">qp_attr_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_IDLE</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_CONN_SENT</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_CONN_RECV</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_ESTABLISHED</span>:
		<span class="o">*</span><span class="n">qp_attr_mask</span> <span class="o">=</span> <span class="n">IB_QP_STATE</span> <span class="o">|</span> <span class="n">IB_QP_ACCESS_FLAGS</span><span class="p">;</span>
		<span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">qp_access_flags</span> <span class="o">=</span> <span class="n">IB_ACCESS_REMOTE_WRITE</span><span class="o">|</span>
					   <span class="n">IB_ACCESS_REMOTE_READ</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iwcm_init_qp_rts_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">qp_attr</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="o">*</span><span class="n">qp_attr_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IW_CM_STATE_IDLE</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_CONN_SENT</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_CONN_RECV</span>:
	<span class="k">case</span> <span class="n">IW_CM_STATE_ESTABLISHED</span>:
		<span class="o">*</span><span class="n">qp_attr_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cm_id_priv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iw_cm_init_qp_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">iw_cm_id</span> <span class="o">*</span><span class="n">cm_id</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">ib_qp_attr</span> <span class="o">*</span><span class="n">qp_attr</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="o">*</span><span class="n">qp_attr_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iwcm_id_private</span> <span class="o">*</span><span class="n">cm_id_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">cm_id_priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cm_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iwcm_id_private</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qp_attr</span><span class="o">-&gt;</span><span class="n">qp_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IB_QPS_INIT</span>:
	<span class="k">case</span> <span class="n">IB_QPS_RTR</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwcm_init_qp_init_attr</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span>
					     <span class="n">qp_attr</span><span class="p">,</span> <span class="n">qp_attr_mask</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IB_QPS_RTS</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iwcm_init_qp_rts_attr</span><span class="p">(</span><span class="n">cm_id_priv</span><span class="p">,</span>
					    <span class="n">qp_attr</span><span class="p">,</span> <span class="n">qp_attr_mask</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iw_cm_init_qp_attr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">iw_cm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iwcm_wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;iw_cm_wq&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iwcm_wq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">iw_cm_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">iwcm_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">iw_cm_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">iw_cm_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
