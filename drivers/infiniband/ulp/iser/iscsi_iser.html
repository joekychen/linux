<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › infiniband › ulp › iser › iscsi_iser.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>iscsi_iser.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * iSER transport for the Open iSCSI Initiator &amp; iSER transport internals</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Dmitry Yusupov</span>
<span class="cm"> * Copyright (C) 2004 Alex Aizman</span>
<span class="cm"> * Copyright (C) 2005 Mike Christie</span>
<span class="cm"> * based on code maintained by open-iscsi@googlegroups.com</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004, 2005, 2006 Voltaire, Inc. All rights reserved.</span>
<span class="cm"> * Copyright (c) 2005, 2006 Cisco Systems.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This software is available to you under a choice of one of two</span>
<span class="cm"> * licenses.  You may choose to be licensed under the terms of the GNU</span>
<span class="cm"> * General Public License (GPL) Version 2, available from the file</span>
<span class="cm"> * COPYING in the main directory of this source tree, or the</span>
<span class="cm"> * OpenIB.org BSD license below:</span>
<span class="cm"> *</span>
<span class="cm"> *     Redistribution and use in source and binary forms, with or</span>
<span class="cm"> *     without modification, are permitted provided that the following</span>
<span class="cm"> *     conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> *	- Redistributions of source code must retain the above</span>
<span class="cm"> *	  copyright notice, this list of conditions and the following</span>
<span class="cm"> *	  disclaimer.</span>
<span class="cm"> *</span>
<span class="cm"> *	- Redistributions in binary form must reproduce the above</span>
<span class="cm"> *	  copyright notice, this list of conditions and the following</span>
<span class="cm"> *	  disclaimer in the documentation and/or other materials</span>
<span class="cm"> *	  provided with the distribution.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS</span>
<span class="cm"> * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN</span>
<span class="cm"> * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span>
<span class="cm"> * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="cm"> * SOFTWARE.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef __ISCSI_ISER_H__</span>
<span class="cp">#define __ISCSI_ISER_H__</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;scsi/libiscsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_iscsi.h&gt;</span>

<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>

<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>

<span class="cp">#include &lt;rdma/ib_verbs.h&gt;</span>
<span class="cp">#include &lt;rdma/ib_fmr_pool.h&gt;</span>
<span class="cp">#include &lt;rdma/rdma_cm.h&gt;</span>

<span class="cp">#define DRV_NAME	&quot;iser&quot;</span>
<span class="cp">#define PFX		DRV_NAME &quot;: &quot;</span>
<span class="cp">#define DRV_VER		&quot;0.1&quot;</span>
<span class="cp">#define DRV_DATE	&quot;May 7th, 2006&quot;</span>

<span class="cp">#define iser_dbg(fmt, arg...)				\</span>
<span class="cp">	do {						\</span>
<span class="cp">		if (iser_debug_level &gt; 1)		\</span>
<span class="cp">			printk(KERN_DEBUG PFX &quot;%s:&quot; fmt,\</span>
<span class="cp">				__func__ , ## arg);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define iser_warn(fmt, arg...)				\</span>
<span class="cp">	do {						\</span>
<span class="cp">		if (iser_debug_level &gt; 0)		\</span>
<span class="cp">			printk(KERN_DEBUG PFX &quot;%s:&quot; fmt,\</span>
<span class="cp">				__func__ , ## arg);	\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define iser_err(fmt, arg...)				\</span>
<span class="cp">	do {						\</span>
<span class="cp">		printk(KERN_ERR PFX &quot;%s:&quot; fmt,          \</span>
<span class="cp">		       __func__ , ## arg);		\</span>
<span class="cp">	} while (0)</span>

<span class="cp">#define SHIFT_4K	12</span>
<span class="cp">#define SIZE_4K	(1ULL &lt;&lt; SHIFT_4K)</span>
<span class="cp">#define MASK_4K	(~(SIZE_4K-1))</span>

					<span class="cm">/* support up to 512KB in one RDMA */</span>
<span class="cp">#define ISCSI_ISER_SG_TABLESIZE         (0x80000 &gt;&gt; SHIFT_4K)</span>
<span class="cp">#define ISER_DEF_CMD_PER_LUN		128</span>

<span class="cm">/* QP settings */</span>
<span class="cm">/* Maximal bounds on received asynchronous PDUs */</span>
<span class="cp">#define ISER_MAX_RX_MISC_PDUS		4 </span><span class="cm">/* NOOP_IN(2) , ASYNC_EVENT(2)   */</span><span class="cp"></span>

<span class="cp">#define ISER_MAX_TX_MISC_PDUS		6 </span><span class="cm">/* NOOP_OUT(2), TEXT(1),         *</span>
<span class="cm">					   * SCSI_TMFUNC(2), LOGOUT(1) */</span><span class="cp"></span>

<span class="cp">#define ISER_QP_MAX_RECV_DTOS		(ISCSI_DEF_XMIT_CMDS_MAX)</span>

<span class="cp">#define ISER_MIN_POSTED_RX		(ISCSI_DEF_XMIT_CMDS_MAX &gt;&gt; 2)</span>

<span class="cm">/* the max TX (send) WR supported by the iSER QP is defined by                 *</span>
<span class="cm"> * max_send_wr = T * (1 + D) + C ; D is how many inflight dataouts we expect   *</span>
<span class="cm"> * to have at max for SCSI command. The tx posting &amp; completion handling code  *</span>
<span class="cm"> * supports -EAGAIN scheme where tx is suspended till the QP has room for more *</span>
<span class="cm"> * send WR. D=8 comes from 64K/8K                                              */</span>

<span class="cp">#define ISER_INFLIGHT_DATAOUTS		8</span>

<span class="cp">#define ISER_QP_MAX_REQ_DTOS		(ISCSI_DEF_XMIT_CMDS_MAX *    \</span>
<span class="cp">					(1 + ISER_INFLIGHT_DATAOUTS) + \</span>
<span class="cp">					ISER_MAX_TX_MISC_PDUS        + \</span>
<span class="cp">					ISER_MAX_RX_MISC_PDUS)</span>

<span class="cp">#define ISER_VER			0x10</span>
<span class="cp">#define ISER_WSV			0x08</span>
<span class="cp">#define ISER_RSV			0x04</span>

<span class="k">struct</span> <span class="n">iser_hdr</span> <span class="p">{</span>
	<span class="n">u8</span>      <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span>      <span class="n">rsvd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__be32</span>  <span class="n">write_stag</span><span class="p">;</span> <span class="cm">/* write rkey */</span>
	<span class="n">__be64</span>  <span class="n">write_va</span><span class="p">;</span>
	<span class="n">__be32</span>  <span class="n">read_stag</span><span class="p">;</span>  <span class="cm">/* read rkey */</span>
	<span class="n">__be64</span>  <span class="n">read_va</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* Constant PDU lengths calculations */</span>
<span class="cp">#define ISER_HEADERS_LEN  (sizeof(struct iser_hdr) + sizeof(struct iscsi_hdr))</span>

<span class="cp">#define ISER_RECV_DATA_SEG_LEN	128</span>
<span class="cp">#define ISER_RX_PAYLOAD_SIZE	(ISER_HEADERS_LEN + ISER_RECV_DATA_SEG_LEN)</span>
<span class="cp">#define ISER_RX_LOGIN_SIZE	(ISER_HEADERS_LEN + ISCSI_DEF_MAX_RECV_SEG_LEN)</span>

<span class="cm">/* Length of an object name string */</span>
<span class="cp">#define ISER_OBJECT_NAME_SIZE		    64</span>

<span class="k">enum</span> <span class="n">iser_ib_conn_state</span> <span class="p">{</span>
	<span class="n">ISER_CONN_INIT</span><span class="p">,</span>		   <span class="cm">/* descriptor allocd, no conn          */</span>
	<span class="n">ISER_CONN_PENDING</span><span class="p">,</span>	   <span class="cm">/* in the process of being established */</span>
	<span class="n">ISER_CONN_UP</span><span class="p">,</span>		   <span class="cm">/* up and running                      */</span>
	<span class="n">ISER_CONN_TERMINATING</span><span class="p">,</span>	   <span class="cm">/* in the process of being terminated  */</span>
	<span class="n">ISER_CONN_DOWN</span><span class="p">,</span>		   <span class="cm">/* shut down                           */</span>
	<span class="n">ISER_CONN_STATES_NUM</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">iser_task_status</span> <span class="p">{</span>
	<span class="n">ISER_TASK_STATUS_INIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">ISER_TASK_STATUS_STARTED</span><span class="p">,</span>
	<span class="n">ISER_TASK_STATUS_COMPLETED</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">iser_data_dir</span> <span class="p">{</span>
	<span class="n">ISER_DIR_IN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	   <span class="cm">/* to initiator */</span>
	<span class="n">ISER_DIR_OUT</span><span class="p">,</span>		   <span class="cm">/* from initiator */</span>
	<span class="n">ISER_DIRS_NUM</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iser_data_buf</span> <span class="p">{</span>
	<span class="kt">void</span>               <span class="o">*</span><span class="n">buf</span><span class="p">;</span>      <span class="cm">/* pointer to the sg list               */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">size</span><span class="p">;</span>      <span class="cm">/* num entries of this sg               */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>      <span class="n">data_len</span><span class="p">;</span>  <span class="cm">/* total data len                       */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>       <span class="n">dma_nents</span><span class="p">;</span> <span class="cm">/* returned by dma_map_sg               */</span>
	<span class="kt">char</span>       	   <span class="o">*</span><span class="n">copy_buf</span><span class="p">;</span> <span class="cm">/* allocated copy buf for SGs unaligned *</span>
<span class="cm">	                               * for rdma which are copied            */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg_single</span><span class="p">;</span> <span class="cm">/* SG-ified clone of a non SG SC or     *</span>
<span class="cm">				       * unaligned SG                         */</span>
  <span class="p">};</span>

<span class="cm">/* fwd declarations */</span>
<span class="k">struct</span> <span class="n">iser_device</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iscsi_iser_conn</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iscsi_iser_task</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">iscsi_endpoint</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iser_mem_reg</span> <span class="p">{</span>
	<span class="n">u32</span>  <span class="n">lkey</span><span class="p">;</span>
	<span class="n">u32</span>  <span class="n">rkey</span><span class="p">;</span>
	<span class="n">u64</span>  <span class="n">va</span><span class="p">;</span>
	<span class="n">u64</span>  <span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem_h</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">is_fmr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iser_regd_buf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iser_mem_reg</span>     <span class="n">reg</span><span class="p">;</span>        <span class="cm">/* memory registration info        */</span>
	<span class="kt">void</span>                    <span class="o">*</span><span class="n">virt_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iser_device</span>      <span class="o">*</span><span class="n">device</span><span class="p">;</span>    <span class="cm">/* device-&gt;device for dma_unmap    */</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">direction</span><span class="p">;</span>  <span class="cm">/* direction for dma_unmap	       */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">data_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">iser_desc_type</span> <span class="p">{</span>
	<span class="n">ISCSI_TX_CONTROL</span> <span class="p">,</span>
	<span class="n">ISCSI_TX_SCSI_COMMAND</span><span class="p">,</span>
	<span class="n">ISCSI_TX_DATAOUT</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iser_tx_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iser_hdr</span>              <span class="n">iser_header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_hdr</span>             <span class="n">iscsi_header</span><span class="p">;</span>
	<span class="k">enum</span>   <span class="n">iser_desc_type</span>        <span class="n">type</span><span class="p">;</span>
	<span class="n">u64</span>		             <span class="n">dma_addr</span><span class="p">;</span>
	<span class="cm">/* sg[0] points to iser/iscsi headers, sg[1] optionally points to either</span>
<span class="cm">	of immediate data, unsolicited data-out or control (login,text) */</span>
	<span class="k">struct</span> <span class="n">ib_sge</span>		     <span class="n">tx_sg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span>                          <span class="n">num_sge</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define ISER_RX_PAD_SIZE	(256 - (ISER_RX_PAYLOAD_SIZE + \</span>
<span class="cp">					sizeof(u64) + sizeof(struct ib_sge)))</span>
<span class="k">struct</span> <span class="n">iser_rx_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iser_hdr</span>              <span class="n">iser_header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_hdr</span>             <span class="n">iscsi_header</span><span class="p">;</span>
	<span class="kt">char</span>		             <span class="n">data</span><span class="p">[</span><span class="n">ISER_RECV_DATA_SEG_LEN</span><span class="p">];</span>
	<span class="n">u64</span>		             <span class="n">dma_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_sge</span>		     <span class="n">rx_sg</span><span class="p">;</span>
	<span class="kt">char</span>		             <span class="n">pad</span><span class="p">[</span><span class="n">ISER_RX_PAD_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">iser_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">ib_device</span>             <span class="o">*</span><span class="n">ib_device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_pd</span>	             <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_cq</span>	             <span class="o">*</span><span class="n">rx_cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_cq</span>	             <span class="o">*</span><span class="n">tx_cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_mr</span>	             <span class="o">*</span><span class="n">mr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span>	     <span class="n">cq_tasklet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_event_handler</span>      <span class="n">event_handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>             <span class="n">ig_list</span><span class="p">;</span> <span class="cm">/* entry in ig devices list */</span>
	<span class="kt">int</span>                          <span class="n">refcount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iser_conn</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_iser_conn</span>       <span class="o">*</span><span class="n">iser_conn</span><span class="p">;</span> <span class="cm">/* iser conn for upcalls  */</span>
	<span class="k">struct</span> <span class="n">iscsi_endpoint</span>	     <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">iser_ib_conn_state</span>	     <span class="n">state</span><span class="p">;</span>	    <span class="cm">/* rdma connection state   */</span>
	<span class="n">atomic_t</span>		     <span class="n">refcount</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		     <span class="n">lock</span><span class="p">;</span>	    <span class="cm">/* used for state changes  */</span>
	<span class="k">struct</span> <span class="n">iser_device</span>           <span class="o">*</span><span class="n">device</span><span class="p">;</span>       <span class="cm">/* device context          */</span>
	<span class="k">struct</span> <span class="n">rdma_cm_id</span>            <span class="o">*</span><span class="n">cma_id</span><span class="p">;</span>       <span class="cm">/* CMA ID		       */</span>
	<span class="k">struct</span> <span class="n">ib_qp</span>	             <span class="o">*</span><span class="n">qp</span><span class="p">;</span>           <span class="cm">/* QP 		       */</span>
	<span class="k">struct</span> <span class="n">ib_fmr_pool</span>           <span class="o">*</span><span class="n">fmr_pool</span><span class="p">;</span>     <span class="cm">/* pool of IB FMRs         */</span>
	<span class="n">wait_queue_head_t</span>	     <span class="n">wait</span><span class="p">;</span>          <span class="cm">/* waitq for conn/disconn  */</span>
	<span class="kt">int</span>                          <span class="n">post_recv_buf_count</span><span class="p">;</span> <span class="cm">/* posted rx count  */</span>
	<span class="n">atomic_t</span>                     <span class="n">post_send_buf_count</span><span class="p">;</span> <span class="cm">/* posted tx count   */</span>
	<span class="kt">char</span> 			     <span class="n">name</span><span class="p">[</span><span class="n">ISER_OBJECT_NAME_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iser_page_vec</span>         <span class="o">*</span><span class="n">page_vec</span><span class="p">;</span>     <span class="cm">/* represents SG to fmr maps*</span>
<span class="cm">						     * maps serialized as tx is*/</span>
	<span class="k">struct</span> <span class="n">list_head</span>	     <span class="n">conn_list</span><span class="p">;</span>       <span class="cm">/* entry in ig conn list */</span>

	<span class="kt">char</span>  			     <span class="o">*</span><span class="n">login_buf</span><span class="p">;</span>
	<span class="kt">char</span>			     <span class="o">*</span><span class="n">login_req_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">login_resp_buf</span><span class="p">;</span>
	<span class="n">u64</span>			     <span class="n">login_req_dma</span><span class="p">,</span> <span class="n">login_resp_dma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> 		     <span class="n">rx_desc_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iser_rx_desc</span>	     <span class="o">*</span><span class="n">rx_descs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ib_recv_wr</span>	     <span class="n">rx_wr</span><span class="p">[</span><span class="n">ISER_MIN_POSTED_RX</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iscsi_iser_conn</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iscsi_conn</span>            <span class="o">*</span><span class="n">iscsi_conn</span><span class="p">;</span><span class="cm">/* ptr to iscsi conn */</span>
	<span class="k">struct</span> <span class="n">iser_conn</span>             <span class="o">*</span><span class="n">ib_conn</span><span class="p">;</span>   <span class="cm">/* iSER IB conn      */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iscsi_iser_task</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iser_tx_desc</span>          <span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iscsi_iser_conn</span>	     <span class="o">*</span><span class="n">iser_conn</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">iser_task_status</span> 	     <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span>                          <span class="n">command_sent</span><span class="p">;</span>  <span class="cm">/* set if command  sent  */</span>
	<span class="kt">int</span>                          <span class="n">dir</span><span class="p">[</span><span class="n">ISER_DIRS_NUM</span><span class="p">];</span>      <span class="cm">/* set if dir use*/</span>
	<span class="k">struct</span> <span class="n">iser_regd_buf</span>         <span class="n">rdma_regd</span><span class="p">[</span><span class="n">ISER_DIRS_NUM</span><span class="p">];</span><span class="cm">/* regd rdma buf */</span>
	<span class="k">struct</span> <span class="n">iser_data_buf</span>         <span class="n">data</span><span class="p">[</span><span class="n">ISER_DIRS_NUM</span><span class="p">];</span>     <span class="cm">/* orig. data des*/</span>
	<span class="k">struct</span> <span class="n">iser_data_buf</span>         <span class="n">data_copy</span><span class="p">[</span><span class="n">ISER_DIRS_NUM</span><span class="p">];</span><span class="cm">/* contig. copy  */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iser_page_vec</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iser_global</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mutex</span>      <span class="n">device_list_mutex</span><span class="p">;</span><span class="cm">/*                   */</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="n">device_list</span><span class="p">;</span>	     <span class="cm">/* all iSER devices */</span>
	<span class="k">struct</span> <span class="n">mutex</span>      <span class="n">connlist_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>  <span class="n">connlist</span><span class="p">;</span>		<span class="cm">/* all iSER IB connections */</span>

	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">desc_cache</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">iser_global</span> <span class="n">ig</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">iser_debug_level</span><span class="p">;</span>

<span class="cm">/* allocate connection resources needed for rdma functionality */</span>
<span class="kt">int</span> <span class="n">iser_conn_set_full_featured_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">iser_send_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">iser_send_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">iser_send_data_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">iscsi_data</span> <span class="o">*</span><span class="n">hdr</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iscsi_iser_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_conn</span> <span class="o">*</span><span class="n">conn</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">iscsi_hdr</span>       <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
		     <span class="kt">char</span>                   <span class="o">*</span><span class="n">rx_data</span><span class="p">,</span>
		     <span class="kt">int</span>                    <span class="n">rx_data_len</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_conn_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_conn_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">iser_conn_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destroy_cma_id_allowed</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_conn_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_rcv_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_rx_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span>    <span class="n">dto_xfer_len</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_snd_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_tx_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_task_rdma_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_iser_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_task_rdma_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_iser_task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_free_rx_descriptors</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_finalize_rdma_unaligned_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_iser_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				     <span class="k">enum</span> <span class="n">iser_data_dir</span>         <span class="n">cmd_dir</span><span class="p">);</span>

<span class="kt">int</span>  <span class="n">iser_reg_rdma_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_iser_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
		       <span class="k">enum</span>   <span class="n">iser_data_dir</span>        <span class="n">cmd_dir</span><span class="p">);</span>

<span class="kt">int</span>  <span class="n">iser_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span>   <span class="o">*</span><span class="n">ib_conn</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">src_addr</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">dst_addr</span><span class="p">,</span>
		  <span class="kt">int</span>                <span class="n">non_blocking</span><span class="p">);</span>

<span class="kt">int</span>  <span class="n">iser_reg_page_vec</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span>     <span class="o">*</span><span class="n">ib_conn</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">iser_page_vec</span> <span class="o">*</span><span class="n">page_vec</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">iser_mem_reg</span>  <span class="o">*</span><span class="n">mem_reg</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_unreg_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_mem_reg</span> <span class="o">*</span><span class="n">mem_reg</span><span class="p">);</span>

<span class="kt">int</span>  <span class="n">iser_post_recvl</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">);</span>
<span class="kt">int</span>  <span class="n">iser_post_recvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">int</span>  <span class="n">iser_post_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iser_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">iser_dma_map_task_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_iser_task</span> <span class="o">*</span><span class="n">iser_task</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">iser_data_buf</span>       <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			    <span class="k">enum</span>   <span class="n">iser_data_dir</span>       <span class="n">iser_dir</span><span class="p">,</span>
			    <span class="k">enum</span>   <span class="n">dma_data_direction</span>  <span class="n">dma_dir</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">iser_dma_unmap_task_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_iser_task</span> <span class="o">*</span><span class="n">iser_task</span><span class="p">);</span>
<span class="kt">int</span>  <span class="n">iser_initialize_task_headers</span><span class="p">(</span><span class="k">struct</span> <span class="n">iscsi_task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">iser_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">iser_alloc_rx_descriptors</span><span class="p">(</span><span class="k">struct</span> <span class="n">iser_conn</span> <span class="o">*</span><span class="n">ib_conn</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
