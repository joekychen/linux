<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › virt › fsl_hypervisor.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fsl_hypervisor.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Freescale Hypervisor Management Driver</span>

<span class="cm"> * Copyright (C) 2008-2011 Freescale Semiconductor, Inc.</span>
<span class="cm"> * Author: Timur Tabi &lt;timur@freescale.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is licensed under the terms of the GNU General Public License</span>
<span class="cm"> * version 2.  This program is licensed &quot;as is&quot; without any warranty of any</span>
<span class="cm"> * kind, whether express or implied.</span>
<span class="cm"> *</span>
<span class="cm"> * The Freescale hypervisor management driver provides several services to</span>
<span class="cm"> * drivers and applications related to the Freescale hypervisor:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. An ioctl interface for querying and managing partitions.</span>
<span class="cm"> *</span>
<span class="cm"> * 2. A file interface to reading incoming doorbells.</span>
<span class="cm"> *</span>
<span class="cm"> * 3. An interrupt handler for shutting down the partition upon receiving the</span>
<span class="cm"> *    shutdown doorbell from a manager partition.</span>
<span class="cm"> *</span>
<span class="cm"> * 4. A kernel interface for receiving callbacks when a managed partition</span>
<span class="cm"> *    shuts down.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;asm/fsl_hcalls.h&gt;</span>

<span class="cp">#include &lt;linux/fsl_hypervisor.h&gt;</span>

<span class="k">static</span> <span class="n">BLOCKING_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">failover_subscribers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Ioctl interface for FSL_HV_IOCTL_PARTITION_RESTART</span>
<span class="cm"> *</span>
<span class="cm"> * Restart a running partition</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">ioctl_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_restart</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_hv_ioctl_restart</span> <span class="n">param</span><span class="p">;</span>

	<span class="cm">/* Get the parameters from the user */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_restart</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">fh_partition_restart</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">partition</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">ret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ioctl interface for FSL_HV_IOCTL_PARTITION_STATUS</span>
<span class="cm"> *</span>
<span class="cm"> * Query the status of a partition</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">ioctl_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_status</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_hv_ioctl_status</span> <span class="n">param</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Get the parameters from the user */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_status</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">fh_partition_get_status</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">partition</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">param</span><span class="p">.</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">param</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_status</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ioctl interface for FSL_HV_IOCTL_PARTITION_START</span>
<span class="cm"> *</span>
<span class="cm"> * Start a stopped partition.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">ioctl_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_start</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_hv_ioctl_start</span> <span class="n">param</span><span class="p">;</span>

	<span class="cm">/* Get the parameters from the user */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_start</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">fh_partition_start</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">partition</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">entry_point</span><span class="p">,</span>
				       <span class="n">param</span><span class="p">.</span><span class="n">load</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">ret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ioctl interface for FSL_HV_IOCTL_PARTITION_STOP</span>
<span class="cm"> *</span>
<span class="cm"> * Stop a running partition</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">ioctl_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_stop</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_hv_ioctl_stop</span> <span class="n">param</span><span class="p">;</span>

	<span class="cm">/* Get the parameters from the user */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_stop</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">fh_partition_stop</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">partition</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">ret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ioctl interface for FSL_HV_IOCTL_MEMCPY</span>
<span class="cm"> *</span>
<span class="cm"> * The FH_MEMCPY hypercall takes an array of address/address/size structures</span>
<span class="cm"> * to represent the data being copied.  As a convenience to the user, this</span>
<span class="cm"> * ioctl takes a user-create buffer and a pointer to a guest physically</span>
<span class="cm"> * contiguous buffer in the remote partition, and creates the</span>
<span class="cm"> * address/address/size array for the hypercall.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">ioctl_memcpy</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_memcpy</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_hv_ioctl_memcpy</span> <span class="n">param</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sg_list_unaligned</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fh_sg_list</span> <span class="o">*</span><span class="n">sg_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lb_offset</span><span class="p">;</span> <span class="cm">/* Offset within a page of the local buffer */</span>

	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_pinned</span><span class="p">;</span> <span class="cm">/* return value from get_user_pages() */</span>
	<span class="n">phys_addr_t</span> <span class="n">remote_paddr</span><span class="p">;</span> <span class="cm">/* The next address in the remote buffer */</span>
	<span class="kt">uint32_t</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* The number of bytes left to copy */</span>

	<span class="cm">/* Get the parameters from the user */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_memcpy</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * One partition must be local, the other must be remote.  In other</span>
<span class="cm">	 * words, if source and target are both -1, or are both not -1, then</span>
<span class="cm">	 * return an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">param</span><span class="p">.</span><span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">target</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The array of pages returned by get_user_pages() covers only</span>
<span class="cm">	 * page-aligned memory.  Since the user buffer is probably not</span>
<span class="cm">	 * page-aligned, we need to handle the discrepancy.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We calculate the offset within a page of the S/G list, and make</span>
<span class="cm">	 * adjustments accordingly.  This will result in a page list that looks</span>
<span class="cm">	 * like this:</span>
<span class="cm">	 *</span>
<span class="cm">	 *      ----    &lt;-- first page starts before the buffer</span>
<span class="cm">	 *     |    |</span>
<span class="cm">	 *     |////|-&gt; ----</span>
<span class="cm">	 *     |////|  |    |</span>
<span class="cm">	 *      ----   |    |</span>
<span class="cm">	 *             |    |</span>
<span class="cm">	 *      ----   |    |</span>
<span class="cm">	 *     |////|  |    |</span>
<span class="cm">	 *     |////|  |    |</span>
<span class="cm">	 *     |////|  |    |</span>
<span class="cm">	 *      ----   |    |</span>
<span class="cm">	 *             |    |</span>
<span class="cm">	 *      ----   |    |</span>
<span class="cm">	 *     |////|  |    |</span>
<span class="cm">	 *     |////|  |    |</span>
<span class="cm">	 *     |////|  |    |</span>
<span class="cm">	 *      ----   |    |</span>
<span class="cm">	 *             |    |</span>
<span class="cm">	 *      ----   |    |</span>
<span class="cm">	 *     |////|  |    |</span>
<span class="cm">	 *     |////|-&gt; ----</span>
<span class="cm">	 *     |    |   &lt;-- last page ends after the buffer</span>
<span class="cm">	 *      ----</span>
<span class="cm">	 *</span>
<span class="cm">	 * The distance between the start of the first page and the start of the</span>
<span class="cm">	 * buffer is lb_offset.  The hashed (///) areas are the parts of the</span>
<span class="cm">	 * page list that contain the actual buffer.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The advantage of this approach is that the number of pages is</span>
<span class="cm">	 * equal to the number of entries in the S/G list that we give to the</span>
<span class="cm">	 * hypervisor.</span>
<span class="cm">	 */</span>
	<span class="n">lb_offset</span> <span class="o">=</span> <span class="n">param</span><span class="p">.</span><span class="n">local_vaddr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">count</span> <span class="o">+</span> <span class="n">lb_offset</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* Allocate the buffers we need */</span>

	<span class="cm">/*</span>
<span class="cm">	 * &#39;pages&#39; is an array of struct page pointers that&#39;s initialized by</span>
<span class="cm">	 * get_user_pages().</span>
<span class="cm">	 */</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">num_pages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fsl-hv: could not allocate page list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * sg_list is the list of fh_sg_list objects that we pass to the</span>
<span class="cm">	 * hypervisor.</span>
<span class="cm">	 */</span>
	<span class="n">sg_list_unaligned</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">num_pages</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fh_sg_list</span><span class="p">)</span> <span class="o">+</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fh_sg_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_list_unaligned</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fsl-hv: could not allocate S/G list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sg_list</span> <span class="o">=</span> <span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">sg_list_unaligned</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fh_sg_list</span><span class="p">));</span>

	<span class="cm">/* Get the physical addresses of the source buffer */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">num_pinned</span> <span class="o">=</span> <span class="n">get_user_pages</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span>
		<span class="n">param</span><span class="p">.</span><span class="n">local_vaddr</span> <span class="o">-</span> <span class="n">lb_offset</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">,</span>
		<span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">READ</span> <span class="o">:</span> <span class="n">WRITE</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_pinned</span> <span class="o">!=</span> <span class="n">num_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get_user_pages() failed */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fsl-hv: could not lock source buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_pinned</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">num_pinned</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Build the fh_sg_list[] array.  The first page is special</span>
<span class="cm">	 * because it&#39;s misaligned.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">source</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">lb_offset</span><span class="p">;</span>
		<span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">target</span> <span class="o">=</span> <span class="n">param</span><span class="p">.</span><span class="n">remote_paddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">source</span> <span class="o">=</span> <span class="n">param</span><span class="p">.</span><span class="n">remote_paddr</span><span class="p">;</span>
		<span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">target</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">lb_offset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">lb_offset</span><span class="p">);</span>

	<span class="n">remote_paddr</span> <span class="o">=</span> <span class="n">param</span><span class="p">.</span><span class="n">remote_paddr</span> <span class="o">+</span> <span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">param</span><span class="p">.</span><span class="n">count</span> <span class="o">-</span> <span class="n">sg_list</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">source</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* local to remote */</span>
			<span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">source</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">target</span> <span class="o">=</span> <span class="n">remote_paddr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* remote to local */</span>
			<span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">source</span> <span class="o">=</span> <span class="n">remote_paddr</span><span class="p">;</span>
			<span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">target</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">remote_paddr</span> <span class="o">+=</span> <span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">sg_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">fh_partition_memcpy</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">source</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">target</span><span class="p">,</span>
		<span class="n">virt_to_phys</span><span class="p">(</span><span class="n">sg_list</span><span class="p">),</span> <span class="n">num_pages</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sg_list_unaligned</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">ret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ioctl interface for FSL_HV_IOCTL_DOORBELL</span>
<span class="cm"> *</span>
<span class="cm"> * Ring a doorbell</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">ioctl_doorbell</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_doorbell</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_hv_ioctl_doorbell</span> <span class="n">param</span><span class="p">;</span>

	<span class="cm">/* Get the parameters from the user. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_doorbell</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ev_doorbell_send</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">doorbell</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">ret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">ioctl_dtprop</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_prop</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsl_hv_ioctl_prop</span> <span class="n">param</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">upath</span><span class="p">,</span> <span class="o">*</span><span class="n">upropname</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">upropval</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">propname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">propval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Get the parameters from the user. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fsl_hv_ioctl_prop</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">upath</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">param</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
	<span class="n">upropname</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">param</span><span class="p">.</span><span class="n">propname</span><span class="p">;</span>
	<span class="n">upropval</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">param</span><span class="p">.</span><span class="n">propval</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">upath</span><span class="p">,</span> <span class="n">FH_DTPROP_MAX_PATHLEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">propname</span> <span class="o">=</span> <span class="n">strndup_user</span><span class="p">(</span><span class="n">upropname</span><span class="p">,</span> <span class="n">FH_DTPROP_MAX_PATHLEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">propname</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">propname</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">proplen</span> <span class="o">&gt;</span> <span class="n">FH_DTPROP_MAX_PROPLEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">propval</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">proplen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">propval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">propval</span><span class="p">,</span> <span class="n">upropval</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">proplen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">fh_partition_set_dtprop</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span>
						    <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">path</span><span class="p">),</span>
						    <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">propname</span><span class="p">),</span>
						    <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">propval</span><span class="p">),</span>
						    <span class="n">param</span><span class="p">.</span><span class="n">proplen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">=</span> <span class="n">fh_partition_get_dtprop</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span>
						    <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">path</span><span class="p">),</span>
						    <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">propname</span><span class="p">),</span>
						    <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">propval</span><span class="p">),</span>
						    <span class="o">&amp;</span><span class="n">param</span><span class="p">.</span><span class="n">proplen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">upropval</span><span class="p">,</span> <span class="n">propval</span><span class="p">,</span> <span class="n">param</span><span class="p">.</span><span class="n">proplen</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">put_user</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">proplen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">proplen</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">param</span><span class="p">.</span><span class="n">ret</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">propval</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">propname</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ioctl main entry point</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">fsl_hv_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">argaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argaddr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FSL_HV_IOCTL_PARTITION_RESTART</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl_restart</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_HV_IOCTL_PARTITION_GET_STATUS</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl_status</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_HV_IOCTL_PARTITION_START</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl_start</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_HV_IOCTL_PARTITION_STOP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl_stop</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_HV_IOCTL_MEMCPY</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl_memcpy</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_HV_IOCTL_DOORBELL</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl_doorbell</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_HV_IOCTL_GETPROP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl_dtprop</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FSL_HV_IOCTL_SETPROP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl_dtprop</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fsl-hv: bad ioctl dir=%u type=%u cmd=%u size=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">_IOC_DIR</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
			 <span class="n">_IOC_SIZE</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Linked list of processes that have us open */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">db_list</span><span class="p">;</span>

<span class="cm">/* spinlock for db_list */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">db_list_lock</span><span class="p">);</span>

<span class="cm">/* The size of the doorbell event queue.  This must be a power of two. */</span>
<span class="cp">#define QSIZE	16</span>

<span class="cm">/* Returns the next head/tail pointer, wrapping around the queue if necessary */</span>
<span class="cp">#define nextp(x) (((x) + 1) &amp; (QSIZE - 1))</span>

<span class="cm">/* Per-open data structure */</span>
<span class="k">struct</span> <span class="n">doorbell_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">q</span><span class="p">[</span><span class="n">QSIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Linked list of ISRs that we registered */</span>
<span class="k">struct</span> <span class="n">list_head</span> <span class="n">isr_list</span><span class="p">;</span>

<span class="cm">/* Per-ISR data structure */</span>
<span class="k">struct</span> <span class="n">doorbell_isr</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">doorbell</span><span class="p">;</span>	<span class="cm">/* The doorbell handle */</span>
	<span class="kt">uint32_t</span> <span class="n">partition</span><span class="p">;</span>	<span class="cm">/* The partition handle, if used */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Add a doorbell to all of the doorbell queues</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fsl_hv_queue_doorbell</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">doorbell</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doorbell_queue</span> <span class="o">*</span><span class="n">dbq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Prevent another core from modifying db_list */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">!=</span> <span class="n">nextp</span><span class="p">(</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dbq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">[</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">doorbell</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * This memory barrier eliminates the need to grab</span>
<span class="cm">			 * the spinlock for dbq.</span>
<span class="cm">			 */</span>
			<span class="n">smp_wmb</span><span class="p">();</span>
			<span class="n">dbq</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">nextp</span><span class="p">(</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handler for all doorbells</span>
<span class="cm"> *</span>
<span class="cm"> * We use the same interrupt handler for all doorbells.  Whenever a doorbell</span>
<span class="cm"> * is rung, and we receive an interrupt, we just put the handle for that</span>
<span class="cm"> * doorbell (passed to us as *data) into all of the queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">fsl_hv_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fsl_hv_queue_doorbell</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * State change thread function</span>
<span class="cm"> *</span>
<span class="cm"> * The state change notification arrives in an interrupt, but we can&#39;t call</span>
<span class="cm"> * blocking_notifier_call_chain() in an interrupt handler.  We could call</span>
<span class="cm"> * atomic_notifier_call_chain(), but that would require the clients&#39; call-back</span>
<span class="cm"> * function to run in interrupt context.  Since we don&#39;t want to impose that</span>
<span class="cm"> * restriction on the clients, we use a threaded IRQ to process the</span>
<span class="cm"> * notification in kernel context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">fsl_hv_state_change_thread</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doorbell_isr</span> <span class="o">*</span><span class="n">dbisr</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">failover_subscribers</span><span class="p">,</span> <span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">partition</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt handler for state-change doorbells</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">fsl_hv_state_change_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doorbell_isr</span> <span class="o">*</span><span class="n">dbisr</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* It&#39;s still a doorbell, so add it to all the queues. */</span>
	<span class="n">fsl_hv_queue_doorbell</span><span class="p">(</span><span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>

	<span class="cm">/* Determine the new state, and if it&#39;s stopped, notify the clients. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fh_partition_get_status</span><span class="p">(</span><span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">partition</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">FH_PARTITION_STOPPED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_WAKE_THREAD</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns a bitmask indicating whether a read will block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fsl_hv_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doorbell_queue</span> <span class="o">*</span><span class="n">dbq</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">dbq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the handles for any incoming doorbells</span>
<span class="cm"> *</span>
<span class="cm"> * If there are doorbell handles in the queue for this open instance, then</span>
<span class="cm"> * return them to the caller as an array of 32-bit integers.  Otherwise,</span>
<span class="cm"> * block until there is at least one handle to return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">fsl_hv_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			   <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doorbell_queue</span> <span class="o">*</span><span class="n">dbq</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">buf</span><span class="p">;</span> <span class="cm">/* for put_user() */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make sure we stop when the user buffer is full. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">dbell</span><span class="p">;</span>	<span class="cm">/* Local copy of doorbell queue data */</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the queue is empty, then either we&#39;re done or we need</span>
<span class="cm">		 * to block.  If the application specified O_NONBLOCK, then</span>
<span class="cm">		 * we return the appropriate error code.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">dbq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span>
						     <span class="n">dbq</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">!=</span> <span class="n">dbq</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Even though we have an smp_wmb() in the ISR, the core</span>
<span class="cm">		 * might speculatively execute the &quot;dbell = ...&quot; below while</span>
<span class="cm">		 * it&#39;s evaluating the if-statement above.  In that case, the</span>
<span class="cm">		 * value put into dbell could be stale if the core accepts the</span>
<span class="cm">		 * speculation. To prevent that, we need a read memory barrier</span>
<span class="cm">		 * here as well.</span>
<span class="cm">		 */</span>
		<span class="n">smp_rmb</span><span class="p">();</span>

		<span class="cm">/* Copy the data to a temporary local buffer, because</span>
<span class="cm">		 * we can&#39;t call copy_to_user() from inside a spinlock</span>
<span class="cm">		 */</span>
		<span class="n">dbell</span> <span class="o">=</span> <span class="n">dbq</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">[</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">];</span>
		<span class="n">dbq</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">nextp</span><span class="p">(</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">dbell</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Open the driver and prepare for reading doorbells.</span>
<span class="cm"> *</span>
<span class="cm"> * Every time an application opens the driver, we create a doorbell queue</span>
<span class="cm"> * for that file handle.  This queue is used for any incoming doorbells.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_hv_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doorbell_queue</span> <span class="o">*</span><span class="n">dbq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dbq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">doorbell_queue</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fsl-hv: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dbq</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Close the driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fsl_hv_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doorbell_queue</span> <span class="o">*</span><span class="n">dbq</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dbq</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fsl_hv_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">fsl_hv_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">fsl_hv_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">fsl_hv_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">fsl_hv_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">fsl_hv_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span> <span class="n">fsl_hv_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">fsl_hv_misc_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span>
	<span class="s">&quot;fsl-hv&quot;</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">fsl_hv_fops</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">fsl_hv_shutdown_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">orderly_poweroff</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns the handle of the parent of the given node</span>
<span class="cm"> *</span>
<span class="cm"> * The handle is the value of the &#39;hv-handle&#39; property</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_parent_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">prop</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="cm">/* It&#39;s not really possible for this to fail */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The proper name for the handle property is &quot;hv-handle&quot;, but some</span>
<span class="cm">	 * older versions of the hypervisor used &quot;reg&quot;.</span>
<span class="cm">	 */</span>
	<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;hv-handle&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="n">prop</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span> <span class="o">||</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* This can happen only if the node is malformed */</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register a callback for failover events</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by device drivers to register their callback</span>
<span class="cm"> * functions for fail-over events.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fsl_hv_failover_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">failover_subscribers</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fsl_hv_failover_register</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Unregister a callback for failover events</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fsl_hv_failover_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">failover_subscribers</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">fsl_hv_failover_unregister</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return TRUE if we&#39;re running under FSL hypervisor</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks to see if we&#39;re running under the Freescale</span>
<span class="cm"> * hypervisor, and returns zero if we&#39;re not, or non-zero if we are.</span>
<span class="cm"> *</span>
<span class="cm"> * First, it checks if MSR[GS]==1, which means we&#39;re running under some</span>
<span class="cm"> * hypervisor.  Then it checks if there is a hypervisor node in the device</span>
<span class="cm"> * tree.  Currently, that means there needs to be a node in the root called</span>
<span class="cm"> * &quot;hypervisor&quot; and which has a property named &quot;fsl,hv-version&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">has_fsl_hypervisor</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mfmsr</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">MSR_GS</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/hypervisor&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;fsl,hv-version&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">of_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Freescale hypervisor management driver init</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when this module is loaded.</span>
<span class="cm"> *</span>
<span class="cm"> * Register ourselves as a miscellaneous driver.  This will register the</span>
<span class="cm"> * fops structure and create the right sysfs entries for udev.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">fsl_hypervisor_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">doorbell_isr</span> <span class="o">*</span><span class="n">dbisr</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Freescale hypervisor management driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_fsl_hypervisor</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;fsl-hv: no hypervisor found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsl_hv_misc_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fsl-hv: cannot register device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">isr_list</span><span class="p">);</span>

	<span class="n">for_each_compatible_node</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;epapr,hv-receive-doorbell&quot;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>

		<span class="n">handle</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;interrupts&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span> <span class="o">||</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fsl-hv: no &#39;interrupts&#39; property in %s node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dbisr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dbisr</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dbisr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_of_memory</span><span class="p">;</span>

		<span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
		<span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">doorbell</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;fsl,hv-shutdown-doorbell&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* The shutdown doorbell gets its own ISR */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">fsl_hv_shutdown_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span>
			<span class="s">&quot;fsl,hv-state-change-doorbell&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The state change doorbell triggers a notification if</span>
<span class="cm">			 * the state of the managed partition changes to</span>
<span class="cm">			 * &quot;stopped&quot;. We need a separate interrupt handler for</span>
<span class="cm">			 * that, and we also need to know the handle of the</span>
<span class="cm">			 * target partition, not just the handle of the</span>
<span class="cm">			 * doorbell.</span>
<span class="cm">			 */</span>
			<span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">partition</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">get_parent_handle</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fsl-hv: node %s has missing or &quot;</span>
				       <span class="s">&quot;malformed parent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">dbisr</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">fsl_hv_state_change_isr</span><span class="p">,</span>
						   <span class="n">fsl_hv_state_change_thread</span><span class="p">,</span>
						   <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dbisr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">fsl_hv_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dbisr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;fsl-hv: could not request irq %u for node %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">irq</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dbisr</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">isr_list</span><span class="p">);</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;fsl-hv: registered handler for doorbell %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">doorbell</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_of_memory:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dbisr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">isr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dbisr</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dbisr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsl_hv_misc_dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Freescale hypervisor management driver termination</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when this driver is unloaded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">fsl_hypervisor_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">doorbell_isr</span> <span class="o">*</span><span class="n">dbisr</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dbisr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">isr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dbisr</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dbisr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dbisr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fsl_hv_misc_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">fsl_hypervisor_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">fsl_hypervisor_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Timur Tabi &lt;timur@freescale.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Freescale hypervisor management driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
