<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ppp › ppp_async.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ppp_async.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * PPP async serial channel driver for Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1999 Paul Mackerras.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver provides the encapsulation and framing for sending</span>
<span class="cm"> * and receiving PPP frames over async serial lines.  It relies on</span>
<span class="cm"> * the generic PPP layer to give it frames to send and to process</span>
<span class="cm"> * received frames.  It implements the PPP line discipline.</span>
<span class="cm"> *</span>
<span class="cm"> * Part of the code in this driver was inspired by the old async-only</span>
<span class="cm"> * PPP driver, written by Michael Callahan and Al Longyear, and</span>
<span class="cm"> * subsequently hacked by Paul Mackerras.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/crc-ccitt.h&gt;</span>
<span class="cp">#include &lt;linux/ppp_defs.h&gt;</span>
<span class="cp">#include &lt;linux/ppp-ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/ppp_channel.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/string.h&gt;</span>

<span class="cp">#define PPP_VERSION	&quot;2.4.2&quot;</span>

<span class="cp">#define OBUFSIZE	4096</span>

<span class="cm">/* Structure for storing local state. */</span>
<span class="k">struct</span> <span class="n">asyncppp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">state</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">rbits</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">mru</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	<span class="n">xmit_lock</span><span class="p">;</span>
	<span class="n">spinlock_t</span>	<span class="n">recv_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">xmit_flags</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">xaccm</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u32</span>		<span class="n">raccm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">bytes_sent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">bytes_rcvd</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">tpkt</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">tpkt_pos</span><span class="p">;</span>
	<span class="n">u16</span>		<span class="n">tfcs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">optr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">olim</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">last_xmit</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span>	<span class="o">*</span><span class="n">rpkt</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">lcp_fcs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">rqueue</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tsk</span><span class="p">;</span>

	<span class="n">atomic_t</span>	<span class="n">refcnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">semaphore</span> <span class="n">dead_sem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ppp_channel</span> <span class="n">chan</span><span class="p">;</span>	<span class="cm">/* interface to generic ppp layer */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">obuf</span><span class="p">[</span><span class="n">OBUFSIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Bit numbers in xmit_flags */</span>
<span class="cp">#define XMIT_WAKEUP	0</span>
<span class="cp">#define XMIT_FULL	1</span>
<span class="cp">#define XMIT_BUSY	2</span>

<span class="cm">/* State bits */</span>
<span class="cp">#define SC_TOSS		1</span>
<span class="cp">#define SC_ESCAPE	2</span>
<span class="cp">#define SC_PREV_ERROR	4</span>

<span class="cm">/* Bits in rbits */</span>
<span class="cp">#define SC_RCV_BITS	(SC_RCV_B7_1|SC_RCV_B7_0|SC_RCV_ODDP|SC_RCV_EVNP)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">flag_time</span> <span class="o">=</span> <span class="n">HZ</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">flag_time</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">flag_time</span><span class="p">,</span> <span class="s">&quot;ppp_async: interval between flagged packets (in clock ticks)&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_LDISC</span><span class="p">(</span><span class="n">N_PPP</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Prototypes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ppp_async_encode</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ppp_async_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">ppp_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ppp_async_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ppp_async_flush_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ppp_async_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ppp_async_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ppp_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ppp_async_process</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">async_lcp_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inbound</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ppp_channel_ops</span> <span class="n">async_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start_xmit</span> <span class="o">=</span> <span class="n">ppp_async_send</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>      <span class="o">=</span> <span class="n">ppp_async_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Routines implementing the PPP line discipline.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * We have a potential race on dereferencing tty-&gt;disc_data,</span>
<span class="cm"> * because the tty layer provides no locking at all - thus one</span>
<span class="cm"> * cpu could be running ppp_asynctty_receive while another</span>
<span class="cm"> * calls ppp_asynctty_close, which zeroes tty-&gt;disc_data and</span>
<span class="cm"> * frees the memory that ppp_asynctty_receive is using.  The best</span>
<span class="cm"> * way to fix this is to use a rwlock in the tty struct, but for now</span>
<span class="cm"> * we use a single global rwlock for all ttys in ppp line discipline.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: this is no longer true. The _close path for the ldisc is</span>
<span class="cm"> * now guaranteed to be sane.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">disc_data_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="nf">ap_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disc_data_lock</span><span class="p">);</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disc_data_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ap</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ap_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dead_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when a tty is put into PPP line discipline. Called in process</span>
<span class="cm"> * context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppp_asynctty_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">speed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* initialize the asyncppp structure */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">=</span> <span class="n">PPP_MRU</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">recv_lock</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x60000000U</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">raccm</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">lcp_fcs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">rqueue</span><span class="p">);</span>
	<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">,</span> <span class="n">ppp_async_process</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ap</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dead_sem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">async_ops</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">PPP_MRU</span><span class="p">;</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="n">tty_get_baud_rate</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ppp_register_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">receive_room</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when the tty is put into another line discipline</span>
<span class="cm"> * or it hangs up.  We have to wait for any cpu currently</span>
<span class="cm"> * executing in any of the other ppp_asynctty_* routines to</span>
<span class="cm"> * finish before we can call ppp_unregister_channel and free</span>
<span class="cm"> * the asyncppp struct.  This routine must be called from</span>
<span class="cm"> * process context, not interrupt or softirq context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppp_asynctty_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disc_data_lock</span><span class="p">);</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disc_data_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have now ensured that nobody can start using ap from now</span>
<span class="cm">	 * on, but we have to wait for all existing users to finish.</span>
<span class="cm">	 * Note that ppp_unregister_channel ensures that no calls to</span>
<span class="cm">	 * our channel ops (i.e. ppp_async_send/ioctl) are in progress</span>
<span class="cm">	 * by the time it returns.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dead_sem</span><span class="p">);</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">ppp_unregister_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">rpkt</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">rqueue</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called on tty hangup in process context.</span>
<span class="cm"> *</span>
<span class="cm"> * Wait for I/O to driver to complete and unregister PPP channel.</span>
<span class="cm"> * This is already done by the close routine, so just call that.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ppp_asynctty_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ppp_asynctty_close</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Read does nothing - no data is ever available this way.</span>
<span class="cm"> * Pppd reads and writes packets via /dev/ppp instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ppp_asynctty_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write on the tty does nothing, the packets all come in</span>
<span class="cm"> * from the ppp generic stuff.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ppp_asynctty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called in process context only. May be re-entered by multiple</span>
<span class="cm"> * ioctl calling threads.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppp_asynctty_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ap_get</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PPPIOCGCHAN</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">ppp_channel_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">),</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PPPIOCGUNIT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">ppp_unit_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">),</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCFLSH</span>:
		<span class="cm">/* flush our buffers and the serial port&#39;s buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="n">TCIOFLUSH</span> <span class="o">||</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">TCOFLUSH</span><span class="p">)</span>
			<span class="n">ppp_async_flush_output</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tty_perform_flush</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">FIONREAD</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* Try the various mode ioctls */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tty_mode_ioctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ap_put</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No kernel lock - fine */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">ppp_asynctty_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* May sleep, don&#39;t call from interrupt level or with interrupts disabled */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppp_asynctty_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		  <span class="kt">char</span> <span class="o">*</span><span class="n">cflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ap_get</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">recv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ppp_async_input</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cflags</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">recv_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">rqueue</span><span class="p">))</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">ap_put</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">tty_unthrottle</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppp_asynctty_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ap_get</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">XMIT_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">);</span>
	<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">ap_put</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="n">ppp_ldisc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">magic</span>	<span class="o">=</span> <span class="n">TTY_LDISC_MAGIC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;ppp&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">ppp_asynctty_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>	<span class="o">=</span> <span class="n">ppp_asynctty_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hangup</span>	<span class="o">=</span> <span class="n">ppp_asynctty_hangup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">ppp_asynctty_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>	<span class="o">=</span> <span class="n">ppp_asynctty_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>	<span class="o">=</span> <span class="n">ppp_asynctty_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>	<span class="o">=</span> <span class="n">ppp_asynctty_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">receive_buf</span> <span class="o">=</span> <span class="n">ppp_asynctty_receive</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_wakeup</span> <span class="o">=</span> <span class="n">ppp_asynctty_wakeup</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">ppp_async_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">tty_register_ldisc</span><span class="p">(</span><span class="n">N_PPP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ppp_ldisc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PPP_async: error %d registering line disc.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The following routines provide the PPP channel interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppp_async_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ppp_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">accm</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PPPIOCGFLAGS</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">rbits</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PPPIOCSFLAGS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SC_RCV_BITS</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">recv_lock</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">rbits</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">SC_RCV_BITS</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">recv_lock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PPPIOCGASYNCMAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PPPIOCSASYNCMAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PPPIOCGRASYNCMAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">raccm</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PPPIOCSRASYNCMAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">raccm</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PPPIOCGXASYNCMAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PPPIOCSXASYNCMAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">accm</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">accm</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">accm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x40000000U</span><span class="p">;</span>	<span class="cm">/* can&#39;t escape 0x5e */</span>
		<span class="n">accm</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x60000000U</span><span class="p">;</span>		<span class="cm">/* must escape 0x7d, 0x7e */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">,</span> <span class="n">accm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PPPIOCGMRU</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">mru</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PPPIOCSMRU</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">PPP_MRU</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">PPP_MRU</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called at softirq level to deliver received packets</span>
<span class="cm"> * to the ppp_generic code, and to tell the ppp_generic code</span>
<span class="cm"> * if we can accept more output now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ppp_async_process</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* process received packets */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">rqueue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">ppp_input_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ppp_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* try to push more stuff out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XMIT_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ppp_async_push</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ppp_output_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Procedures for encapsulation and framing.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Procedure to encode the data for async serial transmission.</span>
<span class="cm"> * Does octet stuffing (escaping), puts the address/control bytes</span>
<span class="cm"> * on if A/C compression is disabled, and does protocol compression.</span>
<span class="cm"> * Assumes ap-&gt;tpkt != 0 on entry.</span>
<span class="cm"> * Returns 1 if we finished the current frame, 0 otherwise.</span>
<span class="cm"> */</span>

<span class="cp">#define PUT_BYTE(ap, buf, c, islcp)	do {		\</span>
<span class="cp">	if ((islcp &amp;&amp; c &lt; 0x20) || (ap-&gt;xaccm[c &gt;&gt; 5] &amp; (1 &lt;&lt; (c &amp; 0x1f)))) {\</span>
<span class="cp">		*buf++ = PPP_ESCAPE;			\</span>
<span class="cp">		*buf++ = c ^ PPP_TRANS;			\</span>
<span class="cp">	} else						\</span>
<span class="cp">		*buf++ = c;				\</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppp_async_encode</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fcs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">proto</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">buflim</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">islcp</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt_pos</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">fcs</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">tfcs</span><span class="p">;</span>
	<span class="n">proto</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * LCP packets with code values between 1 (configure-reqest)</span>
<span class="cm">	 * and 7 (code-reject) must be sent as though no options</span>
<span class="cm">	 * had been negotiated.</span>
<span class="cm">	 */</span>
	<span class="n">islcp</span> <span class="o">=</span> <span class="n">proto</span> <span class="o">==</span> <span class="n">PPP_LCP</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">islcp</span><span class="p">)</span>
			<span class="n">async_lcp_peek</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Start of a new packet - insert the leading FLAG</span>
<span class="cm">		 * character if necessary.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">islcp</span> <span class="o">||</span> <span class="n">flag_time</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_xmit</span> <span class="o">+</span> <span class="n">flag_time</span><span class="p">))</span>
			<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">PPP_FLAG</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_xmit</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">fcs</span> <span class="o">=</span> <span class="n">PPP_INITFCS</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Put in the address/control bytes if necessary</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SC_COMP_AC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">islcp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PUT_BYTE</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">islcp</span><span class="p">);</span>
			<span class="n">fcs</span> <span class="o">=</span> <span class="n">PPP_FCS</span><span class="p">(</span><span class="n">fcs</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
			<span class="n">PUT_BYTE</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="n">islcp</span><span class="p">);</span>
			<span class="n">fcs</span> <span class="o">=</span> <span class="n">PPP_FCS</span><span class="p">(</span><span class="n">fcs</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once we put in the last byte, we need to put in the FCS</span>
<span class="cm">	 * and closing flag, so make sure there is at least 7 bytes</span>
<span class="cm">	 * of free space in the output buffer.</span>
<span class="cm">	 */</span>
	<span class="n">buflim</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">obuf</span> <span class="o">+</span> <span class="n">OBUFSIZE</span> <span class="o">-</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span> <span class="o">&lt;</span> <span class="n">buflim</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SC_COMP_PROT</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* compress protocol field */</span>
		<span class="n">fcs</span> <span class="o">=</span> <span class="n">PPP_FCS</span><span class="p">(</span><span class="n">fcs</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="n">PUT_BYTE</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">islcp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remember where we are up to in this packet.</span>
<span class="cm">		 */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt_pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">tfcs</span> <span class="o">=</span> <span class="n">fcs</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have finished the packet.  Add the FCS and flag.</span>
<span class="cm">	 */</span>
	<span class="n">fcs</span> <span class="o">=</span> <span class="o">~</span><span class="n">fcs</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">fcs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">PUT_BYTE</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">islcp</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcs</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">PUT_BYTE</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">islcp</span><span class="p">);</span>
	<span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">=</span> <span class="n">PPP_FLAG</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="n">consume_skb</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Transmit-side routines.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Send a packet to the peer over an async tty line.</span>
<span class="cm"> * Returns 1 iff the packet was accepted.</span>
<span class="cm"> * If the packet was not accepted, we will call ppp_output_wakeup</span>
<span class="cm"> * at some later time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppp_async_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">ppp_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">ppp_async_push</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">XMIT_FULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* already full */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ppp_async_push</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Push as much data as possible out to the tty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ppp_async_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">avail</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tty_stuffed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can get called recursively here if the tty write</span>
<span class="cm">	 * function calls our wakeup function.  This can happen</span>
<span class="cm">	 * for example on a pty with both the master and slave</span>
<span class="cm">	 * set to PPP line discipline.</span>
<span class="cm">	 * We use the XMIT_BUSY bit to detect this and get out,</span>
<span class="cm">	 * leaving the XMIT_WAKEUP bit set to tell the other</span>
<span class="cm">	 * instance that it may now be able to write more now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">XMIT_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">XMIT_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">))</span>
			<span class="n">tty_stuffed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tty_stuffed</span> <span class="o">&amp;&amp;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span> <span class="o">&lt;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">avail</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span> <span class="o">-</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">sent</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span><span class="p">,</span> <span class="n">avail</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sent</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">flush</span><span class="p">;</span>	<span class="cm">/* error, e.g. loss of CD */</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span> <span class="o">+=</span> <span class="n">sent</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sent</span> <span class="o">&lt;</span> <span class="n">avail</span><span class="p">)</span>
				<span class="n">tty_stuffed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span> <span class="o">&gt;=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span> <span class="o">&amp;&amp;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ppp_async_encode</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* finished processing ap-&gt;tpkt */</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">XMIT_FULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">);</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We haven&#39;t made any progress this time around.</span>
<span class="cm">		 * Clear XMIT_BUSY to let other callers in, but</span>
<span class="cm">		 * after doing so we have to check if anyone set</span>
<span class="cm">		 * XMIT_WAKEUP since we last checked it.  If they</span>
<span class="cm">		 * did, we should try again to set XMIT_BUSY and go</span>
<span class="cm">		 * around again in case XMIT_BUSY was still set when</span>
<span class="cm">		 * the other caller tried.</span>
<span class="cm">		 */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">XMIT_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">);</span>
		<span class="cm">/* any more work to do? if not, exit the loop */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">XMIT_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">)</span> <span class="o">||</span>
		      <span class="p">(</span><span class="o">!</span><span class="n">tty_stuffed</span> <span class="o">&amp;&amp;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* more work to do, see if we can do it now */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">XMIT_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">done</span><span class="p">;</span>

<span class="nl">flush:</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">XMIT_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">XMIT_FULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush output from our internal buffers.</span>
<span class="cm"> * Called for the TCFLSH ioctl. Can be entered in parallel</span>
<span class="cm"> * but this is covered by the xmit_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppp_async_flush_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_lock</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">optr</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">olim</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">tpkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">XMIT_FULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_flags</span><span class="p">);</span>
		<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">xmit_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>
		<span class="n">ppp_output_wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Receive-side routines.</span>
<span class="cm"> */</span>

<span class="cm">/* see how many ordinary chars there are at the start of buf */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">scan_ordinary</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">PPP_ESCAPE</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="n">PPP_FLAG</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mh">0x20</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">raccm</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* called when a flag is seen - do end-of-packet processing */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">process_input_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">fcs</span><span class="p">,</span> <span class="n">proto</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">rpkt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SC_TOSS</span> <span class="o">|</span> <span class="n">SC_ESCAPE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* 0-length packet */</span>

	<span class="cm">/* check the FCS */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>	<span class="cm">/* too short */</span>
	<span class="n">fcs</span> <span class="o">=</span> <span class="n">PPP_INITFCS</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">len</span><span class="p">)</span>
		<span class="n">fcs</span> <span class="o">=</span> <span class="n">PPP_FCS</span><span class="p">(</span><span class="n">fcs</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcs</span> <span class="o">!=</span> <span class="n">PPP_GOODFCS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>	<span class="cm">/* bad FCS */</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* check for address/control and protocol compression */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">PPP_ALLSTATIONS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* chop off address/control */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">PPP_UI</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">proto</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">proto</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* protocol is compressed */</span>
		<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">proto</span> <span class="o">=</span> <span class="p">(</span><span class="n">proto</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proto</span> <span class="o">==</span> <span class="n">PPP_LCP</span><span class="p">)</span>
			<span class="n">async_lcp_peek</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* queue the frame to be processed */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">rqueue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">rpkt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">err:</span>
	<span class="cm">/* frame had an error, remember that, reset SC_TOSS &amp; SC_ESCAPE */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SC_PREV_ERROR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* make skb appear as freshly allocated */</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Called when the tty driver has data for us. Runs parallel with the</span>
<span class="cm">   other ldisc functions but will not be re-entered */</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ppp_async_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>

	<span class="cm">/* update bits used for 8-bit cleanness detection */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">rbits</span> <span class="o">&amp;</span> <span class="n">SC_RCV_BITS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">s</span> <span class="o">|=</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span><span class="o">?</span> <span class="n">SC_RCV_B7_1</span><span class="o">:</span> <span class="n">SC_RCV_B7_0</span><span class="p">;</span>
			<span class="n">c</span> <span class="o">=</span> <span class="p">((</span><span class="n">c</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">^</span> <span class="n">c</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
			<span class="n">s</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x6996</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">))</span><span class="o">?</span> <span class="n">SC_RCV_ODDP</span><span class="o">:</span> <span class="n">SC_RCV_EVNP</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">rbits</span> <span class="o">|=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* scan through and see how many chars we can do in bulk */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SC_ESCAPE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">PPP_ESCAPE</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">scan_ordinary</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

		<span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SC_TOSS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* check the flags to see if any char had an error */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* start tossing */</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">SC_TOSS</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SC_TOSS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* stuff the chars in the skb */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">rpkt</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">+</span> <span class="n">PPP_HDRLEN</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
 				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">rpkt</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
 			<span class="p">}</span>
 			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 				<span class="cm">/* Try to get the payload 4-byte aligned.</span>
<span class="cm"> 				 * This should match the</span>
<span class="cm"> 				 * PPP_ALLSTATIONS/PPP_UI/compressed tests in</span>
<span class="cm"> 				 * process_input_packet, but we do not have</span>
<span class="cm"> 				 * enough chars here to test buf[1] and buf[2].</span>
<span class="cm"> 				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">PPP_ALLSTATIONS</span><span class="p">)</span>
					<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* packet overflowed MRU */</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">SC_TOSS</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sp</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SC_ESCAPE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^=</span> <span class="n">PPP_TRANS</span><span class="p">;</span>
					<span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SC_ESCAPE</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">c</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">flags</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">SC_TOSS</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">PPP_FLAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">process_input_packet</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">PPP_ESCAPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">SC_ESCAPE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">I_IXON</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">START_CHAR</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">))</span>
				<span class="n">start_tty</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">STOP_CHAR</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">))</span>
				<span class="n">stop_tty</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* otherwise it&#39;s a char in the recv ACCM */</span>
		<span class="o">++</span><span class="n">n</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">nomem:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;PPPasync: no memory (input pkt)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">SC_TOSS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We look at LCP frames going past so that we can notice</span>
<span class="cm"> * and react to the LCP configure-ack from the peer.</span>
<span class="cm"> * In the situation where the peer has been sent a configure-ack</span>
<span class="cm"> * already, LCP is up once it has sent its configure-ack</span>
<span class="cm"> * so the immediately following packet can be sent with the</span>
<span class="cm"> * configured LCP options.  This allows us to process the following</span>
<span class="cm"> * packet correctly without pppd needing to respond quickly.</span>
<span class="cm"> *</span>
<span class="cm"> * We only respond to the received configure-ack if we have just</span>
<span class="cm"> * sent a configure-request, and the configure-ack contains the</span>
<span class="cm"> * same data (this is checked using a 16-bit crc of the data).</span>
<span class="cm"> */</span>
<span class="cp">#define CONFREQ		1	</span><span class="cm">/* LCP code field values */</span><span class="cp"></span>
<span class="cp">#define CONFACK		2</span>
<span class="cp">#define LCP_MRU		1	</span><span class="cm">/* LCP option numbers */</span><span class="cp"></span>
<span class="cp">#define LCP_ASYNCMAP	2</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">async_lcp_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">asyncppp</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inbound</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">fcs</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">code</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>		<span class="cm">/* skip protocol bytes */</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>		<span class="cm">/* 4 = code, ID, length */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">code</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">!=</span> <span class="n">CONFACK</span> <span class="o">&amp;&amp;</span> <span class="n">code</span> <span class="o">!=</span> <span class="n">CONFREQ</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dlen</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">dlen</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* packet got truncated or length is bogus */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="p">(</span><span class="n">inbound</span><span class="o">?</span> <span class="n">CONFACK</span><span class="o">:</span> <span class="n">CONFREQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * sent confreq or received confack:</span>
<span class="cm">		 * calculate the crc of the data from the ID field on.</span>
<span class="cm">		 */</span>
		<span class="n">fcs</span> <span class="o">=</span> <span class="n">PPP_INITFCS</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dlen</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">fcs</span> <span class="o">=</span> <span class="n">PPP_FCS</span><span class="p">(</span><span class="n">fcs</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inbound</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* outbound confreq - remember the crc for later */</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">lcp_fcs</span> <span class="o">=</span> <span class="n">fcs</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* received confack, check the crc */</span>
		<span class="n">fcs</span> <span class="o">^=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">lcp_fcs</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">lcp_fcs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inbound</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>	<span class="cm">/* not interested in received confreq */</span>

	<span class="cm">/* process the options in the confack */</span>
	<span class="n">data</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">dlen</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="cm">/* data[0] is code, data[1] is length */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dlen</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">dlen</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LCP_MRU</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inbound</span><span class="p">)</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">mru</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LCP_ASYNCMAP</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inbound</span><span class="p">)</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">raccm</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">xaccm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dlen</span> <span class="o">-=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ppp_async_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tty_unregister_ldisc</span><span class="p">(</span><span class="n">N_PPP</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;failed to unregister PPP line discipline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">ppp_async_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ppp_async_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
