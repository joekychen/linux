<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wan › cycx_drv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>cycx_drv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">* cycx_drv.c	Cyclom 2X Support Module.</span>
<span class="cm">*</span>
<span class="cm">*		This module is a library of common hardware specific</span>
<span class="cm">*		functions used by the Cyclades Cyclom 2X sync card.</span>
<span class="cm">*</span>
<span class="cm">* Author:	Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;</span>
<span class="cm">*</span>
<span class="cm">* Copyright:	(c) 1998-2003 Arnaldo Carvalho de Melo</span>
<span class="cm">*</span>
<span class="cm">* Based on sdladrv.c by Gene Kozin &lt;genek@compuserve.com&gt;</span>
<span class="cm">*</span>
<span class="cm">*		This program is free software; you can redistribute it and/or</span>
<span class="cm">*		modify it under the terms of the GNU General Public License</span>
<span class="cm">*		as published by the Free Software Foundation; either version</span>
<span class="cm">*		2 of the License, or (at your option) any later version.</span>
<span class="cm">* ============================================================================</span>
<span class="cm">* 1999/11/11	acme		set_current_state(TASK_INTERRUPTIBLE), code</span>
<span class="cm">*				cleanup</span>
<span class="cm">* 1999/11/08	acme		init_cyc2x deleted, doing nothing</span>
<span class="cm">* 1999/11/06	acme		back to read[bw], write[bw] and memcpy_to and</span>
<span class="cm">*				fromio to use dpmbase ioremaped</span>
<span class="cm">* 1999/10/26	acme		use isa_read[bw], isa_write[bw] &amp; isa_memcpy_to</span>
<span class="cm">*				&amp; fromio</span>
<span class="cm">* 1999/10/23	acme		cleanup to only supports cyclom2x: all the other</span>
<span class="cm">*				boards are no longer manufactured by cyclades,</span>
<span class="cm">*				if someone wants to support them... be my guest!</span>
<span class="cm">* 1999/05/28    acme		cycx_intack &amp; cycx_intde gone for good</span>
<span class="cm">* 1999/05/18	acme		lots of unlogged work, submitting to Linus...</span>
<span class="cm">* 1999/01/03	acme		more judicious use of data types</span>
<span class="cm">* 1999/01/03	acme		judicious use of data types :&gt;</span>
<span class="cm">*				cycx_inten trying to reset pending interrupts</span>
<span class="cm">*				from cyclom 2x - I think this isn&#39;t the way to</span>
<span class="cm">*				go, but for now...</span>
<span class="cm">* 1999/01/02	acme		cycx_intack ok, I think there&#39;s nothing to do</span>
<span class="cm">*				to ack an int in cycx_drv.c, only handle it in</span>
<span class="cm">*				cyx_isr (or in the other protocols: cyp_isr,</span>
<span class="cm">*				cyf_isr, when they get implemented.</span>
<span class="cm">* Dec 31, 1998	acme		cycx_data_boot &amp; cycx_code_boot fixed, crossing</span>
<span class="cm">*				fingers to see x25_configure in cycx_x25.c</span>
<span class="cm">*				work... :)</span>
<span class="cm">* Dec 26, 1998	acme		load implementation fixed, seems to work! :)</span>
<span class="cm">*				cycx_2x_dpmbase_options with all the possible</span>
<span class="cm">*				DPM addresses (20).</span>
<span class="cm">*				cycx_intr implemented (test this!)</span>
<span class="cm">*				general code cleanup</span>
<span class="cm">* Dec  8, 1998	Ivan Passos	Cyclom-2X firmware load implementation.</span>
<span class="cm">* Aug  8, 1998	acme		Initial version.</span>
<span class="cm">*/</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/init.h&gt;		</span><span class="cm">/* __init */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;	</span><span class="cm">/* printk(), and other useful stuff */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/stddef.h&gt;	</span><span class="cm">/* offsetof(), etc. */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/errno.h&gt;	</span><span class="cm">/* return codes */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/cycx_drv.h&gt;	</span><span class="cm">/* API definitions */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/cycx_cfm.h&gt;	</span><span class="cm">/* CYCX firmware module definitions */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/delay.h&gt;	</span><span class="cm">/* udelay, msleep_interruptible */</span><span class="cp"></span>
<span class="cp">#include &lt;asm/io.h&gt;		</span><span class="cm">/* read[wl], write[wl], ioremap, iounmap */</span><span class="cp"></span>

<span class="cp">#define	MOD_VERSION	0</span>
<span class="cp">#define	MOD_RELEASE	6</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Arnaldo Carvalho de Melo&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Cyclom 2x Sync Card Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="cm">/* Hardware-specific functions */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">load_cyc2x</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cycx_firmware</span> <span class="o">*</span><span class="n">cfm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">cycx_bootcfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">reset_cyc2x</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">detect_cyc2x</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>

<span class="cm">/* Miscellaneous functions */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">get_option_index</span><span class="p">(</span><span class="k">const</span> <span class="kt">long</span> <span class="o">*</span><span class="n">optlist</span><span class="p">,</span> <span class="kt">long</span> <span class="n">optval</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">checksum</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#define wait_cyc(addr) cycx_exec(addr + CMD_OFFSET)</span>

<span class="cm">/* Global Data */</span>

<span class="cm">/* private data */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">fullname</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Cyclom 2X Support Module&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">copyright</span><span class="p">[]</span> <span class="o">=</span>
	<span class="s">&quot;(c) 1998-2003 Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&quot;</span><span class="p">;</span>

<span class="cm">/* Hardware configuration options.</span>
<span class="cm"> * These are arrays of configuration options used by verification routines.</span>
<span class="cm"> * The first element of each array is its size (i.e. number of options).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">cyc2x_dpmbase_options</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">20</span><span class="p">,</span>
	<span class="mh">0xA0000</span><span class="p">,</span> <span class="mh">0xA4000</span><span class="p">,</span> <span class="mh">0xA8000</span><span class="p">,</span> <span class="mh">0xAC000</span><span class="p">,</span> <span class="mh">0xB0000</span><span class="p">,</span> <span class="mh">0xB4000</span><span class="p">,</span> <span class="mh">0xB8000</span><span class="p">,</span>
	<span class="mh">0xBC000</span><span class="p">,</span> <span class="mh">0xC0000</span><span class="p">,</span> <span class="mh">0xC4000</span><span class="p">,</span> <span class="mh">0xC8000</span><span class="p">,</span> <span class="mh">0xCC000</span><span class="p">,</span> <span class="mh">0xD0000</span><span class="p">,</span> <span class="mh">0xD4000</span><span class="p">,</span>
	<span class="mh">0xD8000</span><span class="p">,</span> <span class="mh">0xDC000</span><span class="p">,</span> <span class="mh">0xE0000</span><span class="p">,</span> <span class="mh">0xE4000</span><span class="p">,</span> <span class="mh">0xE8000</span><span class="p">,</span> <span class="mh">0xEC000</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">cycx_2x_irq_options</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span> <span class="p">};</span>

<span class="cm">/* Kernel Loadable Module Entry Points */</span>
<span class="cm">/* Module &#39;insert&#39; entry point.</span>
<span class="cm"> * o print announcement</span>
<span class="cm"> * o initialize static data</span>
<span class="cm"> *</span>
<span class="cm"> * Return:	0	Ok</span>
<span class="cm"> *		&lt; 0	error.</span>
<span class="cm"> * Context:	process */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cycx_drv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s v%u.%u %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">fullname</span><span class="p">,</span> <span class="n">MOD_VERSION</span><span class="p">,</span> <span class="n">MOD_RELEASE</span><span class="p">,</span> <span class="n">copyright</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Module &#39;remove&#39; entry point.</span>
<span class="cm"> * o release all remaining system resources */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cycx_drv_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/* Kernel APIs */</span>
<span class="cm">/* Set up adapter.</span>
<span class="cm"> * o detect adapter type</span>
<span class="cm"> * o verify hardware configuration options</span>
<span class="cm"> * o check for hardware conflicts</span>
<span class="cm"> * o set up adapter shared memory</span>
<span class="cm"> * o test adapter memory</span>
<span class="cm"> * o load firmware</span>
<span class="cm"> * Return:	0	ok.</span>
<span class="cm"> *		&lt; 0	error */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cycx_setup</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">cycx_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">cfm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dpmbase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Verify IRQ configuration options */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_option_index</span><span class="p">(</span><span class="n">cycx_2x_irq_options</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;IRQ %d is invalid!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup adapter dual-port memory window and test memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dpmbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;you must specify the dpm address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
 		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_option_index</span><span class="p">(</span><span class="n">cyc2x_dpmbase_options</span><span class="p">,</span> <span class="n">dpmbase</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;memory address 0x%lX is invalid!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dpmbase</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">dpmbase</span><span class="p">,</span> <span class="n">CYCX_WINDOWSIZE</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmsize</span> <span class="o">=</span> <span class="n">CYCX_WINDOWSIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">detect_cyc2x</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;adapter Cyclom 2X not found at address 0x%lX!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dpmbase</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;found Cyclom 2X card at address 0x%lX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dpmbase</span><span class="p">);</span>

	<span class="cm">/* Load firmware. If loader fails then shut down adapter */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">load_cyc2x</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">cfm</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">cycx_down</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>         <span class="cm">/* shutdown adapter */</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cycx_down</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">cycx_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Enable interrupt generation.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cycx_inten</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Generate an interrupt to adapter&#39;s CPU. */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cycx_intr</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">cycx_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span> <span class="o">+</span> <span class="n">GEN_CYCX_INTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Execute Adapter Command.</span>
<span class="cm"> * o Set exec flag.</span>
<span class="cm"> * o Busy-wait until flag is reset. */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cycx_exec</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">cycx_exec</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* wait till addr content is zeroed */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">readw</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Read absolute adapter memory.</span>
<span class="cm"> * Transfer data from adapter&#39;s memory to data buffer. */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cycx_peek</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">cycx_peek</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy_fromio</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span> <span class="o">+</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Write Absolute Adapter Memory.</span>
<span class="cm"> * Transfer data from data buffer to adapter&#39;s memory. */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cycx_poke</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">cycx_poke</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">writeb</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span> <span class="o">+</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Hardware-Specific Functions */</span>

<span class="cm">/* Load Aux Routines */</span>
<span class="cm">/* Reset board hardware.</span>
<span class="cm">   return 1 if memory exists at addr and 0 if not. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">memory_exists</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">tries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">TEST_PATTERN</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">readw</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">==</span> <span class="n">TEST_PATTERN</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">readw</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">)</span> <span class="o">==</span> <span class="n">TEST_PATTERN</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Load reset code. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_load</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pt_code</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">RESET_OFFSET</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span> <span class="cm">/*, j; */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cm">/*		for (j = 0 ; j &lt; 50 ; j++); Delay - FIXME busy waiting... */</span>
		<span class="n">writeb</span><span class="p">(</span><span class="o">*</span><span class="n">buffer</span><span class="o">++</span><span class="p">,</span> <span class="n">pt_code</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Load buffer using boot interface.</span>
<span class="cm"> * o copy data from buffer to Cyclom-X memory</span>
<span class="cm"> * o wait for reset code to copy it to right portion of memory */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">buffer_load</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">DATA_OFFSET</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">GEN_BOOT_DAT</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">CMD_OFFSET</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">wait_cyc</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set up entry point and kick start Cyclom-X CPU. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cycx_start</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* put in 0x30 offset the jump instruction to the code entry point */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0xea</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mh">0x31</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0xc4</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mh">0x32</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mh">0x33</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="mh">0x34</span><span class="p">);</span>

	<span class="cm">/* cmd to start executing code */</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">GEN_START</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">CMD_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Load and boot reset code. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cycx_reset_boot</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pt_start</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">START_OFFSET</span><span class="p">;</span>

	<span class="n">writeb</span><span class="p">(</span><span class="mh">0xea</span><span class="p">,</span> <span class="n">pt_start</span><span class="o">++</span><span class="p">);</span> <span class="cm">/* jmp to f000:3f00 */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">pt_start</span><span class="o">++</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0xfc</span><span class="p">,</span> <span class="n">pt_start</span><span class="o">++</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">pt_start</span><span class="o">++</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">,</span> <span class="n">pt_start</span><span class="p">);</span>
	<span class="n">reset_load</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* 80186 was in hold, go */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">START_CPU</span><span class="p">);</span>
	<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Load data.bin file through boot (reset) interface. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cycx_data_boot</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pt_boot_cmd</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">CMD_OFFSET</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* boot buffer length */</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">CFM_LOAD_BUFSZ</span><span class="p">,</span> <span class="n">pt_boot_cmd</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">GEN_DEFPAR</span><span class="p">,</span> <span class="n">pt_boot_cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_cyc</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">writew</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pt_boot_cmd</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">,</span> <span class="n">pt_boot_cmd</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">GEN_SET_SEG</span><span class="p">,</span> <span class="n">pt_boot_cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_cyc</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">CFM_LOAD_BUFSZ</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_load</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">CFM_LOAD_BUFSZ</span><span class="p">,</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error !!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Load code.bin file through boot (reset) interface. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cycx_code_boot</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pt_boot_cmd</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">CMD_OFFSET</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* boot buffer length */</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">CFM_LOAD_BUFSZ</span><span class="p">,</span> <span class="n">pt_boot_cmd</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">GEN_DEFPAR</span><span class="p">,</span> <span class="n">pt_boot_cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_cyc</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">writew</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">,</span> <span class="n">pt_boot_cmd</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="n">writew</span><span class="p">(</span><span class="mh">0xc400</span><span class="p">,</span> <span class="n">pt_boot_cmd</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>
	<span class="n">writew</span><span class="p">(</span><span class="n">GEN_SET_SEG</span><span class="p">,</span> <span class="n">pt_boot_cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait_cyc</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">CFM_LOAD_BUFSZ</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_load</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
				<span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">CFM_LOAD_BUFSZ</span><span class="p">,</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error !!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Load adapter from the memory image of the CYCX firmware module.</span>
<span class="cm"> * o verify firmware integrity and compatibility</span>
<span class="cm"> * o start adapter up */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_cyc2x</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cycx_firmware</span> <span class="o">*</span><span class="n">cfm</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cycx_fw_header</span> <span class="o">*</span><span class="n">img_hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">reset_image</span><span class="p">,</span>
	   <span class="o">*</span><span class="n">data_image</span><span class="p">,</span>
	   <span class="o">*</span><span class="n">code_image</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pt_cycld</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span> <span class="o">+</span> <span class="mh">0x400</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cksum</span><span class="p">;</span>

	<span class="cm">/* Announce */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;firmware signature=</span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfm</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">);</span>

	<span class="cm">/* Verify firmware signature */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">cfm</span><span class="o">-&gt;</span><span class="n">signature</span><span class="p">,</span> <span class="n">CFM_SIGNATURE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;load_cyc2x: not Cyclom-2X firmware!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;firmware version=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfm</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>

	<span class="cm">/* Verify firmware module format version */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfm</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="n">CFM_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: firmware format %u rejected! Expecting %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">cfm</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">CFM_VERSION</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Verify firmware module length and checksum */</span>
	<span class="n">cksum</span> <span class="o">=</span> <span class="n">checksum</span><span class="p">((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cfm</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_fw_info</span><span class="p">)</span> <span class="o">+</span>
					  <span class="n">cfm</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">codesize</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm">	FIXME cfm-&gt;info.codesize is off by 2</span>
<span class="cm">	if (((len - sizeof(struct cycx_firmware) - 1) != cfm-&gt;info.codesize) ||</span>
<span class="cm">*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cksum</span> <span class="o">!=</span> <span class="n">cfm</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: firmware corrupted!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; cdsize = 0x%x (expected 0x%lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_firmware</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		       <span class="n">cfm</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">codesize</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot; chksum = 0x%x (expected 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">cksum</span><span class="p">,</span> <span class="n">cfm</span><span class="o">-&gt;</span><span class="n">checksum</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If everything is ok, set reset, data and code pointers */</span>
	<span class="n">img_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cycx_fw_header</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cfm</span><span class="o">-&gt;</span><span class="n">image</span><span class="p">;</span>
<span class="cp">#ifdef FIRMWARE_DEBUG</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: image sizes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; reset=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">img_hdr</span><span class="o">-&gt;</span><span class="n">reset_size</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  data=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">img_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;  code=%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">img_hdr</span><span class="o">-&gt;</span><span class="n">code_size</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">reset_image</span> <span class="o">=</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">img_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_fw_header</span><span class="p">);</span>
	<span class="n">data_image</span> <span class="o">=</span> <span class="n">reset_image</span> <span class="o">+</span> <span class="n">img_hdr</span><span class="o">-&gt;</span><span class="n">reset_size</span><span class="p">;</span>
	<span class="n">code_image</span> <span class="o">=</span> <span class="n">data_image</span> <span class="o">+</span> <span class="n">img_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>

	<span class="cm">/*---- Start load ----*/</span>
	<span class="cm">/* Announce */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;loading firmware %s (ID=%u)...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cfm</span><span class="o">-&gt;</span><span class="n">descr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">cfm</span><span class="o">-&gt;</span><span class="n">descr</span> <span class="o">:</span> <span class="s">&quot;unknown firmware&quot;</span><span class="p">,</span>
		<span class="n">cfm</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">codeid</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset Cyclom hardware */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reset_cyc2x</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;dpm problem or board not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Load reset.bin */</span>
		<span class="n">cycx_reset_boot</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span><span class="p">,</span> <span class="n">reset_image</span><span class="p">,</span> <span class="n">img_hdr</span><span class="o">-&gt;</span><span class="n">reset_size</span><span class="p">);</span>
		<span class="cm">/* reset is waiting for boot */</span>
		<span class="n">writew</span><span class="p">(</span><span class="n">GEN_POWER_ON</span><span class="p">,</span> <span class="n">pt_cycld</span><span class="p">);</span>
		<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">readw</span><span class="p">(</span><span class="n">pt_cycld</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">reset_loaded</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;reset not started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">reset_loaded:</span>
	<span class="cm">/* Load data.bin */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cycx_data_boot</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span><span class="p">,</span> <span class="n">data_image</span><span class="p">,</span> <span class="n">img_hdr</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cannot load data file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Load code.bin */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cycx_code_boot</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span><span class="p">,</span> <span class="n">code_image</span><span class="p">,</span> <span class="n">img_hdr</span><span class="o">-&gt;</span><span class="n">code_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;cannot load code file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prepare boot-time configuration data */</span>
	<span class="n">cycx_bootcfg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* kick-off CPU */</span>
	<span class="n">cycx_start</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span><span class="p">);</span>

	<span class="cm">/* Arthur Ganzert&#39;s tip: wait a while after the firmware loading...</span>
<span class="cm">	   seg abr 26 17:17:12 EST 1999 - acme */</span>
	<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;firmware loaded!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* enable interrupts */</span>
	<span class="n">cycx_inten</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Prepare boot-time firmware configuration data.</span>
<span class="cm"> * o initialize configuration data area</span>
<span class="cm">   From async.doc - V_3.4.0 - 07/18/1994</span>
<span class="cm">   - As of now, only static buffers are available to the user.</span>
<span class="cm">     So, the bit VD_RXDIRC must be set in &#39;valid&#39;. That means that user</span>
<span class="cm">     wants to use the static transmission and reception buffers. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cycx_bootcfg</span><span class="p">(</span><span class="k">struct</span> <span class="n">cycx_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* use fixed buffers */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">FIXED_BUFFERS</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dpmbase</span> <span class="o">+</span> <span class="n">CONF_OFFSET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Detect Cyclom 2x adapter.</span>
<span class="cm"> *	Following tests are used to detect Cyclom 2x adapter:</span>
<span class="cm"> *       to be completed based on the tests done below</span>
<span class="cm"> *	Return 1 if detected o.k. or 0 if failed.</span>
<span class="cm"> *	Note:	This test is destructive! Adapter will be left in shutdown</span>
<span class="cm"> *		state after the test. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">detect_cyc2x</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">reset_cyc2x</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">memory_exists</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Miscellaneous */</span>
<span class="cm">/* Get option&#39;s index into the options list.</span>
<span class="cm"> *	Return option&#39;s index (1 .. N) or zero if option is invalid. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_option_index</span><span class="p">(</span><span class="k">const</span> <span class="kt">long</span> <span class="o">*</span><span class="n">optlist</span><span class="p">,</span> <span class="kt">long</span> <span class="n">optval</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">optlist</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">optlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">optval</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reset adapter&#39;s CPU. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reset_cyc2x</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">RST_ENABLE</span><span class="p">);</span>
	<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">RST_DISABLE</span><span class="p">);</span>
	<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">memory_exists</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Calculate 16-bit CRC using CCITT polynomial. */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">checksum</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">crc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mask</span><span class="p">,</span> <span class="n">flag</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">len</span><span class="p">;</span> <span class="o">--</span><span class="n">len</span><span class="p">,</span> <span class="o">++</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">mask</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="n">mask</span><span class="p">;</span> <span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">crc</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">);</span>
			<span class="n">crc</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">crc</span> <span class="o">|=</span> <span class="p">((</span><span class="o">*</span><span class="n">buf</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
				<span class="n">crc</span> <span class="o">^=</span> <span class="mh">0x1021</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="n">crc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">cycx_drv_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cycx_drv_cleanup</span><span class="p">);</span>

<span class="cm">/* End */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
