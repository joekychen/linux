<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wan › z85230.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>z85230.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	(c) Copyright 1998 Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *	(c) Copyright 2000, 2001 Red Hat Inc</span>
<span class="cm"> *</span>
<span class="cm"> *	Development of this driver was funded by Equiinet Ltd</span>
<span class="cm"> *			http://www.equiinet.com</span>
<span class="cm"> *</span>
<span class="cm"> *	ChangeLog:</span>
<span class="cm"> *</span>
<span class="cm"> *	Asynchronous mode dropped for 2.2. For 2.5 we will attempt the</span>
<span class="cm"> *	unification of all the Z85x30 asynchronous drivers for real.</span>
<span class="cm"> *</span>
<span class="cm"> *	DMA now uses get_free_page as kmalloc buffers may span a 64K </span>
<span class="cm"> *	boundary.</span>
<span class="cm"> *</span>
<span class="cm"> *	Modified for SMP safety and SMP locking by Alan Cox</span>
<span class="cm"> *					&lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Performance</span>
<span class="cm"> *</span>
<span class="cm"> *	Z85230:</span>
<span class="cm"> *	Non DMA you want a 486DX50 or better to do 64Kbits. 9600 baud</span>
<span class="cm"> *	X.25 is not unrealistic on all machines. DMA mode can in theory</span>
<span class="cm"> *	handle T1/E1 quite nicely. In practice the limit seems to be about</span>
<span class="cm"> *	512Kbit-&gt;1Mbit depending on motherboard.</span>
<span class="cm"> *</span>
<span class="cm"> *	Z85C30:</span>
<span class="cm"> *	64K will take DMA, 9600 baud X.25 should be ok.</span>
<span class="cm"> *</span>
<span class="cm"> *	Z8530:</span>
<span class="cm"> *	Synchronous mode without DMA is unlikely to pass about 2400 baud.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/hdlc.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#define RT_LOCK</span>
<span class="cp">#define RT_UNLOCK</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &quot;z85230.h&quot;</span>


<span class="cm">/**</span>
<span class="cm"> *	z8530_read_port - Architecture specific interface function</span>
<span class="cm"> *	@p: port to read</span>
<span class="cm"> *</span>
<span class="cm"> *	Provided port access methods. The Comtrol SV11 requires no delays</span>
<span class="cm"> *	between accesses and uses PC I/O. Some drivers may need a 5uS delay</span>
<span class="cm"> *	</span>
<span class="cm"> *	In the longer term this should become an architecture specific</span>
<span class="cm"> *	section so that this can become a generic driver interface for all</span>
<span class="cm"> *	platforms. For now we only handle PC I/O ports with or without the</span>
<span class="cm"> *	dread 5uS sanity delay.</span>
<span class="cm"> *</span>
<span class="cm"> *	The caller must hold sufficient locks to avoid violating the horrible</span>
<span class="cm"> *	5uS delay rule.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">z8530_read_port</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">r</span><span class="o">=</span><span class="n">inb</span><span class="p">(</span><span class="n">Z8530_PORT_OF</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">&amp;</span><span class="n">Z8530_PORT_SLEEP</span><span class="p">)</span>	<span class="cm">/* gcc should figure this out efficiently ! */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_write_port - Architecture specific interface function</span>
<span class="cm"> *	@p: port to write</span>
<span class="cm"> *	@d: value to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Write a value to a port with delays if need be. Note that the</span>
<span class="cm"> *	caller must hold locks to avoid read/writes from other contexts</span>
<span class="cm"> *	violating the 5uS rule</span>
<span class="cm"> *</span>
<span class="cm"> *	In the longer term this should become an architecture specific</span>
<span class="cm"> *	section so that this can become a generic driver interface for all</span>
<span class="cm"> *	platforms. For now we only handle PC I/O ports with or without the</span>
<span class="cm"> *	dread 5uS sanity delay.</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">z8530_write_port</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p</span><span class="p">,</span> <span class="n">u8</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">Z8530_PORT_OF</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">&amp;</span><span class="n">Z8530_PORT_SLEEP</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">void</span> <span class="n">z8530_rx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">z8530_tx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	read_zsreg - Read a register from a Z85230 </span>
<span class="cm"> *	@c: Z8530 channel to read from (2 per chip)</span>
<span class="cm"> *	@reg: Register to read</span>
<span class="cm"> *	FIXME: Use a spinlock.</span>
<span class="cm"> *	</span>
<span class="cm"> *	Most of the Z8530 registers are indexed off the control registers.</span>
<span class="cm"> *	A read is done by writing to the control register and reading the</span>
<span class="cm"> *	register back.  The caller must hold the lock</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">read_zsreg</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
		<span class="n">z8530_write_port</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ctrlio</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">z8530_read_port</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ctrlio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	read_zsdata - Read the data port of a Z8530 channel</span>
<span class="cm"> *	@c: The Z8530 channel to read the data port from</span>
<span class="cm"> *</span>
<span class="cm"> *	The data port provides fast access to some things. We still</span>
<span class="cm"> *	have all the 5uS delays to worry about.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">read_zsdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">r</span><span class="o">=</span><span class="n">z8530_read_port</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dataio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	write_zsreg - Write to a Z8530 channel register</span>
<span class="cm"> *	@c: The Z8530 channel</span>
<span class="cm"> *	@reg: Register number</span>
<span class="cm"> *	@val: Value to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Write a value to an indexed register. The caller must hold the lock</span>
<span class="cm"> *	to honour the irritating delay rules. We know about register 0</span>
<span class="cm"> *	being fast to access.</span>
<span class="cm"> *</span>
<span class="cm"> *      Assumes c-&gt;lock is held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_zsreg</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
		<span class="n">z8530_write_port</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ctrlio</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">z8530_write_port</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ctrlio</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	write_zsctrl - Write to a Z8530 control register</span>
<span class="cm"> *	@c: The Z8530 channel</span>
<span class="cm"> *	@val: Value to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Write directly to the control register on the Z8530</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_zsctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">z8530_write_port</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">ctrlio</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	write_zsdata - Write to a Z8530 control register</span>
<span class="cm"> *	@c: The Z8530 channel</span>
<span class="cm"> *	@val: Value to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Write directly to the data register on the Z8530</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_zsdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">z8530_write_port</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dataio</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Register loading parameters for a dead port</span>
<span class="cm"> */</span>
 
<span class="n">u8</span> <span class="n">z8530_dead_port</span><span class="p">[]</span><span class="o">=</span>
<span class="p">{</span>
	<span class="mi">255</span>
<span class="p">};</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_dead_port</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Register loading parameters for currently supported circuit types</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> *	Data clocked by telco end. This is the correct data for the UK</span>
<span class="cm"> *	&quot;kilostream&quot; service, and most other similar services.</span>
<span class="cm"> */</span>
 
<span class="n">u8</span> <span class="n">z8530_hdlc_kilostream</span><span class="p">[]</span><span class="o">=</span>
<span class="p">{</span>
	<span class="mi">4</span><span class="p">,</span>	<span class="n">SYNC_ENAB</span><span class="o">|</span><span class="n">SDLC</span><span class="o">|</span><span class="n">X1CLK</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span>	<span class="cm">/* No vector */</span>
	<span class="mi">1</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">3</span><span class="p">,</span>	<span class="n">ENT_HM</span><span class="o">|</span><span class="n">RxCRC_ENAB</span><span class="o">|</span><span class="n">Rx8</span><span class="p">,</span>
	<span class="mi">5</span><span class="p">,</span>	<span class="n">TxCRC_ENAB</span><span class="o">|</span><span class="n">RTS</span><span class="o">|</span><span class="n">TxENAB</span><span class="o">|</span><span class="n">Tx8</span><span class="o">|</span><span class="n">DTR</span><span class="p">,</span>
	<span class="mi">9</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span>		<span class="cm">/* Disable interrupts */</span>
	<span class="mi">6</span><span class="p">,</span>	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mi">7</span><span class="p">,</span>	<span class="n">FLAG</span><span class="p">,</span>
	<span class="mi">10</span><span class="p">,</span>	<span class="n">ABUNDER</span><span class="o">|</span><span class="n">NRZ</span><span class="o">|</span><span class="n">CRCPS</span><span class="p">,</span><span class="cm">/*MARKIDLE ??*/</span>
	<span class="mi">11</span><span class="p">,</span>	<span class="n">TCTRxCP</span><span class="p">,</span>
	<span class="mi">14</span><span class="p">,</span>	<span class="n">DISDPLL</span><span class="p">,</span>
	<span class="mi">15</span><span class="p">,</span>	<span class="n">DCDIE</span><span class="o">|</span><span class="n">SYNCIE</span><span class="o">|</span><span class="n">CTSIE</span><span class="o">|</span><span class="n">TxUIE</span><span class="o">|</span><span class="n">BRKIE</span><span class="p">,</span>
	<span class="mi">1</span><span class="p">,</span>	<span class="n">EXT_INT_ENAB</span><span class="o">|</span><span class="n">TxINT_ENAB</span><span class="o">|</span><span class="n">INT_ALL_Rx</span><span class="p">,</span>
	<span class="mi">9</span><span class="p">,</span>	<span class="n">NV</span><span class="o">|</span><span class="n">MIE</span><span class="o">|</span><span class="n">NORESET</span><span class="p">,</span>
	<span class="mi">255</span>
<span class="p">};</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_hdlc_kilostream</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	As above but for enhanced chips.</span>
<span class="cm"> */</span>
 
<span class="n">u8</span> <span class="n">z8530_hdlc_kilostream_85230</span><span class="p">[]</span><span class="o">=</span>
<span class="p">{</span>
	<span class="mi">4</span><span class="p">,</span>	<span class="n">SYNC_ENAB</span><span class="o">|</span><span class="n">SDLC</span><span class="o">|</span><span class="n">X1CLK</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span>	<span class="cm">/* No vector */</span>
	<span class="mi">1</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span>
	<span class="mi">3</span><span class="p">,</span>	<span class="n">ENT_HM</span><span class="o">|</span><span class="n">RxCRC_ENAB</span><span class="o">|</span><span class="n">Rx8</span><span class="p">,</span>
	<span class="mi">5</span><span class="p">,</span>	<span class="n">TxCRC_ENAB</span><span class="o">|</span><span class="n">RTS</span><span class="o">|</span><span class="n">TxENAB</span><span class="o">|</span><span class="n">Tx8</span><span class="o">|</span><span class="n">DTR</span><span class="p">,</span>
	<span class="mi">9</span><span class="p">,</span>	<span class="mi">0</span><span class="p">,</span>		<span class="cm">/* Disable interrupts */</span>
	<span class="mi">6</span><span class="p">,</span>	<span class="mh">0xFF</span><span class="p">,</span>
	<span class="mi">7</span><span class="p">,</span>	<span class="n">FLAG</span><span class="p">,</span>
	<span class="mi">10</span><span class="p">,</span>	<span class="n">ABUNDER</span><span class="o">|</span><span class="n">NRZ</span><span class="o">|</span><span class="n">CRCPS</span><span class="p">,</span>	<span class="cm">/* MARKIDLE?? */</span>
	<span class="mi">11</span><span class="p">,</span>	<span class="n">TCTRxCP</span><span class="p">,</span>
	<span class="mi">14</span><span class="p">,</span>	<span class="n">DISDPLL</span><span class="p">,</span>
	<span class="mi">15</span><span class="p">,</span>	<span class="n">DCDIE</span><span class="o">|</span><span class="n">SYNCIE</span><span class="o">|</span><span class="n">CTSIE</span><span class="o">|</span><span class="n">TxUIE</span><span class="o">|</span><span class="n">BRKIE</span><span class="p">,</span>
	<span class="mi">1</span><span class="p">,</span>	<span class="n">EXT_INT_ENAB</span><span class="o">|</span><span class="n">TxINT_ENAB</span><span class="o">|</span><span class="n">INT_ALL_Rx</span><span class="p">,</span>
	<span class="mi">9</span><span class="p">,</span>	<span class="n">NV</span><span class="o">|</span><span class="n">MIE</span><span class="o">|</span><span class="n">NORESET</span><span class="p">,</span>
	<span class="mi">23</span><span class="p">,</span>	<span class="mi">3</span><span class="p">,</span>		<span class="cm">/* Extended mode AUTO TX and EOM*/</span>
	
	<span class="mi">255</span>
<span class="p">};</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_hdlc_kilostream_85230</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_flush_fifo - Flush on chip RX FIFO</span>
<span class="cm"> *	@c: Channel to flush</span>
<span class="cm"> *</span>
<span class="cm"> *	Flush the receive FIFO. There is no specific option for this, we </span>
<span class="cm"> *	blindly read bytes and discard them. Reading when there is no data</span>
<span class="cm"> *	is harmless. The 8530 has a 4 byte FIFO, the 85230 has 8 bytes.</span>
<span class="cm"> *	</span>
<span class="cm"> *	All locking is handled for the caller. On return data may still be</span>
<span class="cm"> *	present if it arrived during the flush.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_flush_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
	<span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
	<span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
	<span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">==</span><span class="n">Z85230</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
		<span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
		<span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
		<span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>	

<span class="cm">/**</span>
<span class="cm"> *	z8530_rtsdtr - Control the outgoing DTS/RTS line</span>
<span class="cm"> *	@c: The Z8530 channel to control;</span>
<span class="cm"> *	@set: 1 to set, 0 to clear</span>
<span class="cm"> *</span>
<span class="cm"> *	Sets or clears DTR/RTS on the requested line. All locking is handled</span>
<span class="cm"> *	by the caller. For now we assume all boards use the actual RTS/DTR</span>
<span class="cm"> *	on the chip. Apparently one or two don&#39;t. We&#39;ll scream about them</span>
<span class="cm"> *	later.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_rtsdtr</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">RTS</span> <span class="o">|</span> <span class="n">DTR</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RTS</span> <span class="o">|</span> <span class="n">DTR</span><span class="p">);</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R5</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_rx - Handle a PIO receive event</span>
<span class="cm"> *	@c: Z8530 channel to process</span>
<span class="cm"> *</span>
<span class="cm"> *	Receive handler for receiving in PIO mode. This is much like the </span>
<span class="cm"> *	async one but not quite the same or as complex</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Its intended that this handler can easily be separated from</span>
<span class="cm"> *	the main code to run realtime. That&#39;ll be needed for some machines</span>
<span class="cm"> *	(eg to ever clock 64kbits on a sparc ;)).</span>
<span class="cm"> *</span>
<span class="cm"> *	The RT_LOCK macros don&#39;t do anything now. Keep the code covered</span>
<span class="cm"> *	by them as short as possible in all circumstances - clocks cost</span>
<span class="cm"> *	baud. The interrupt handler is assumed to be atomic w.r.t. to</span>
<span class="cm"> *	other code - this is true in the RT case too.</span>
<span class="cm"> *</span>
<span class="cm"> *	We only cover the sync cases for this. If you want 2Mbit async</span>
<span class="cm"> *	do it yourself but consider medical assistance first. This non DMA </span>
<span class="cm"> *	synchronous mode is portable code. The DMA mode assumes PCI like </span>
<span class="cm"> *	ISA DMA</span>
<span class="cm"> *</span>
<span class="cm"> *	Called with the device lock held</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ch</span><span class="p">,</span><span class="n">stat</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* FIFO empty ? */</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R0</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ch</span><span class="o">=</span><span class="n">read_zsdata</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">stat</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
	
		<span class="cm">/*</span>
<span class="cm">		 *	Overrun ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dptr</span><span class="o">++=</span><span class="n">ch</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span><span class="n">stat</span><span class="o">&amp;</span><span class="n">END_FR</span><span class="p">)</span>
		<span class="p">{</span>
		
			<span class="cm">/*</span>
<span class="cm">			 *	Error ?</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">stat</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Rx_OVR</span><span class="o">|</span><span class="n">CRC_ERR</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="cm">/* Rewind the buffer and return */</span>
				<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
					<span class="n">c</span><span class="o">-&gt;</span><span class="n">dptr</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">stat</span><span class="o">&amp;</span><span class="n">Rx_OVR</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: overrun</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_overrun</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">(</span><span class="n">stat</span><span class="o">&amp;</span><span class="n">CRC_ERR</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_crc_err</span><span class="o">++</span><span class="p">;</span>
					<span class="cm">/* printk(&quot;crc error\n&quot;); */</span>
				<span class="p">}</span>
				<span class="cm">/* Shove the frame upstream */</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *	Drop the lock for RX processing, or</span>
<span class="cm">		 		 *	there are deadlocks</span>
<span class="cm">		 		 */</span>
				<span class="n">z8530_rx_done</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
				<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_Rx_CRC</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Clear irq</span>
<span class="cm">	 */</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ERR_RES</span><span class="p">);</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	z8530_tx - Handle a PIO transmit event</span>
<span class="cm"> *	@c: Z8530 channel to process</span>
<span class="cm"> *</span>
<span class="cm"> *	Z8530 transmit interrupt handler for the PIO mode. The basic</span>
<span class="cm"> *	idea is to attempt to keep the FIFO fed. We fill as many bytes</span>
<span class="cm"> *	in as possible, its quite possible that we won&#39;t keep up with the</span>
<span class="cm"> *	data rate otherwise.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txcount</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIFO full ? */</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R0</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">4</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">txcount</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Shovel out the byte</span>
<span class="cm">		 */</span>
		<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R8</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_ptr</span><span class="o">++</span><span class="p">);</span>
		<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
		<span class="cm">/* We are about to underflow */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txcount</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_EOM_L</span><span class="p">);</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R10</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&amp;~</span><span class="n">ABUNDER</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	
	<span class="cm">/*</span>
<span class="cm">	 *	End of frame TX - fire another one</span>
<span class="cm">	 */</span>
	 
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_Tx_P</span><span class="p">);</span>

	<span class="n">z8530_tx_done</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>	 
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_status - Handle a PIO status exception</span>
<span class="cm"> *	@chan: Z8530 channel to process</span>
<span class="cm"> *</span>
<span class="cm"> *	A status event occurred in PIO synchronous mode. There are several</span>
<span class="cm"> *	reasons the chip will bother us here. A transmit underrun means we</span>
<span class="cm"> *	failed to feed the chip fast enough and just broke a packet. A DCD</span>
<span class="cm"> *	change is a line up or down.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">,</span> <span class="n">altered</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">read_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R0</span><span class="p">);</span>
	<span class="n">altered</span> <span class="o">=</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">^</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">TxEOM</span><span class="p">)</span> <span class="p">{</span>
<span class="cm">/*		printk(&quot;%s: Tx underrun.\n&quot;, chan-&gt;dev-&gt;name); */</span>
		<span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">ERR_RES</span><span class="p">);</span>
		<span class="n">z8530_tx_done</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">altered</span> <span class="o">&amp;</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dcdcheck</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dcdcheck</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: DCD raised</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">RxENABLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">)</span>
				<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: DCD lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RxENABLE</span><span class="p">);</span>
			<span class="n">z8530_flush_fifo</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">)</span>
				<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">RES_EXT_INT</span><span class="p">);</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">z8530_irqhandler</span> <span class="n">z8530_sync</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="n">z8530_rx</span><span class="p">,</span>
	<span class="n">z8530_tx</span><span class="p">,</span>
	<span class="n">z8530_status</span>
<span class="p">};</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_sync</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_dma_rx - Handle a DMA RX event</span>
<span class="cm"> *	@chan: Channel to handle</span>
<span class="cm"> *</span>
<span class="cm"> *	Non bus mastering DMA interfaces for the Z8x30 devices. This</span>
<span class="cm"> *	is really pretty PC specific. The DMA mode means that most receive</span>
<span class="cm"> *	events are handled by the DMA hardware. We get a kick here only if</span>
<span class="cm"> *	a frame ended.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_dma_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">rxdma_on</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Special condition check only */</span>
		<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
	
		<span class="n">read_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R7</span><span class="p">);</span>
		<span class="n">read_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R6</span><span class="p">);</span>
		
		<span class="n">status</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
	
		<span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="o">&amp;</span><span class="n">END_FR</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">z8530_rx_done</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>	<span class="cm">/* Fire up the next one */</span>
		<span class="p">}</span>		
		<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">ERR_RES</span><span class="p">);</span>
		<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/* DMA is off right now, drain the slow way */</span>
		<span class="n">z8530_rx</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="p">}</span>	
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_dma_tx - Handle a DMA TX event</span>
<span class="cm"> *	@chan:	The Z8530 channel to handle</span>
<span class="cm"> *</span>
<span class="cm"> *	We have received an interrupt while doing DMA transmissions. It</span>
<span class="cm"> *	shouldn&#39;t happen. Scream loudly if it does.</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_dma_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Hey who turned the DMA off?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">z8530_tx</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* This shouldn&#39;t occur in DMA mode */</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DMA tx - bogus event!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">z8530_tx</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_dma_status - Handle a DMA status exception</span>
<span class="cm"> *	@chan: Z8530 channel to process</span>
<span class="cm"> *	</span>
<span class="cm"> *	A status event occurred on the Z8530. We receive these for two reasons</span>
<span class="cm"> *	when in DMA mode. Firstly if we finished a packet transfer we get one</span>
<span class="cm"> *	and kick the next packet out. Secondly we may see a DCD change.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_dma_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">,</span> <span class="n">altered</span><span class="p">;</span>

	<span class="n">status</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R0</span><span class="p">);</span>
	<span class="n">altered</span><span class="o">=</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">^</span><span class="n">status</span><span class="p">;</span>
	
	<span class="n">chan</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">;</span>


	<span class="k">if</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="o">&amp;</span><span class="n">TxEOM</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
			<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">disable_dma</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
			<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>	
			<span class="n">chan</span><span class="o">-&gt;</span><span class="n">txdma_on</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">z8530_tx_done</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">altered</span> <span class="o">&amp;</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dcdcheck</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dcdcheck</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: DCD raised</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="n">RxENABLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">)</span>
				<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: DCD lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">chan</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RxENABLE</span><span class="p">);</span>
			<span class="n">z8530_flush_fifo</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">)</span>
				<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">RES_EXT_INT</span><span class="p">);</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">z8530_irqhandler</span> <span class="n">z8530_dma_sync</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">z8530_dma_rx</span><span class="p">,</span>
	<span class="n">z8530_dma_tx</span><span class="p">,</span>
	<span class="n">z8530_dma_status</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">z8530_irqhandler</span> <span class="n">z8530_txdma_sync</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">z8530_rx</span><span class="p">,</span>
	<span class="n">z8530_dma_tx</span><span class="p">,</span>
	<span class="n">z8530_dma_status</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_rx_clear - Handle RX events from a stopped chip</span>
<span class="cm"> *	@c: Z8530 channel to shut up</span>
<span class="cm"> *</span>
<span class="cm"> *	Receive interrupt vectors for a Z8530 that is in &#39;parked&#39; mode.</span>
<span class="cm"> *	For machines with PCI Z85x30 cards, or level triggered interrupts</span>
<span class="cm"> *	(eg the MacII) we must clear the interrupt cause or die.</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_rx_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Data and status bytes</span>
<span class="cm">	 */</span>
	<span class="n">u8</span> <span class="n">stat</span><span class="p">;</span>

	<span class="n">read_zsdata</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">stat</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">stat</span><span class="o">&amp;</span><span class="n">END_FR</span><span class="p">)</span>
		<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_Rx_CRC</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Clear irq</span>
<span class="cm">	 */</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ERR_RES</span><span class="p">);</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_tx_clear - Handle TX events from a stopped chip</span>
<span class="cm"> *	@c: Z8530 channel to shut up</span>
<span class="cm"> *</span>
<span class="cm"> *	Transmit interrupt vectors for a Z8530 that is in &#39;parked&#39; mode.</span>
<span class="cm"> *	For machines with PCI Z85x30 cards, or level triggered interrupts</span>
<span class="cm"> *	(eg the MacII) we must clear the interrupt cause or die.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_tx_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_Tx_P</span><span class="p">);</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_status_clear - Handle status events from a stopped chip</span>
<span class="cm"> *	@chan: Z8530 channel to shut up</span>
<span class="cm"> *</span>
<span class="cm"> *	Status interrupt vectors for a Z8530 that is in &#39;parked&#39; mode.</span>
<span class="cm"> *	For machines with PCI Z85x30 cards, or level triggered interrupts</span>
<span class="cm"> *	(eg the MacII) we must clear the interrupt cause or die.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_status_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">R0</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="o">&amp;</span><span class="n">TxEOM</span><span class="p">)</span>
		<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">ERR_RES</span><span class="p">);</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">RES_EXT_INT</span><span class="p">);</span>
	<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">chan</span><span class="p">,</span> <span class="n">RES_H_IUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">z8530_irqhandler</span> <span class="n">z8530_nop</span><span class="o">=</span>
<span class="p">{</span>
	<span class="n">z8530_rx_clear</span><span class="p">,</span>
	<span class="n">z8530_tx_clear</span><span class="p">,</span>
	<span class="n">z8530_status_clear</span>
<span class="p">};</span>


<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_nop</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_interrupt - Handle an interrupt from a Z8530</span>
<span class="cm"> *	@irq: 	Interrupt number</span>
<span class="cm"> *	@dev_id: The Z8530 device that is interrupting.</span>
<span class="cm"> *</span>
<span class="cm"> *	A Z85[2]30 device has stuck its hand in the air for attention.</span>
<span class="cm"> *	We scan both the channels on the chip for events and then call</span>
<span class="cm"> *	the channel specific call backs for each channel that has events.</span>
<span class="cm"> *	We have to use callback functions because the two channels can be</span>
<span class="cm"> *	in different modes.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking is done for the handlers. Note that locking is done</span>
<span class="cm"> *	at the chip level (the 5uS delay issue is per chip not per</span>
<span class="cm"> *	channel). c-&gt;lock for both channels points to dev-&gt;lock</span>
<span class="cm"> */</span>

<span class="n">irqreturn_t</span> <span class="nf">z8530_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">z8530_dev</span> <span class="o">*</span><span class="n">dev</span><span class="o">=</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">intr</span><span class="p">);</span>
	<span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">locker</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">work</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">z8530_irqhandler</span> <span class="o">*</span><span class="n">irqs</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">locker</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;IRQ re-enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">locker</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="o">++</span><span class="n">work</span><span class="o">&lt;</span><span class="mi">5000</span><span class="p">)</span>
	<span class="p">{</span>

		<span class="n">intr</span> <span class="o">=</span> <span class="n">read_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R3</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">intr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CHARxIP</span><span class="o">|</span><span class="n">CHATxIP</span><span class="o">|</span><span class="n">CHAEXT</span><span class="o">|</span><span class="n">CHBRxIP</span><span class="o">|</span><span class="n">CHBTxIP</span><span class="o">|</span><span class="n">CHBEXT</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
	
		<span class="cm">/* This holds the IRQ status. On the 8530 you must read it from chan </span>
<span class="cm">		   A even though it applies to the whole chip */</span>
		
		<span class="cm">/* Now walk the chip and see what it is wanting - it may be</span>
<span class="cm">		   an IRQ for someone else remember */</span>
		   
		<span class="n">irqs</span><span class="o">=</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">.</span><span class="n">irqs</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">intr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CHARxIP</span><span class="o">|</span><span class="n">CHATxIP</span><span class="o">|</span><span class="n">CHAEXT</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">intr</span><span class="o">&amp;</span><span class="n">CHARxIP</span><span class="p">)</span>
				<span class="n">irqs</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">intr</span><span class="o">&amp;</span><span class="n">CHATxIP</span><span class="p">)</span>
				<span class="n">irqs</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">intr</span><span class="o">&amp;</span><span class="n">CHAEXT</span><span class="p">)</span>
				<span class="n">irqs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">irqs</span><span class="o">=</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">.</span><span class="n">irqs</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">intr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CHBRxIP</span><span class="o">|</span><span class="n">CHBTxIP</span><span class="o">|</span><span class="n">CHBEXT</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">intr</span><span class="o">&amp;</span><span class="n">CHBRxIP</span><span class="p">)</span>
				<span class="n">irqs</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">intr</span><span class="o">&amp;</span><span class="n">CHBTxIP</span><span class="p">)</span>
				<span class="n">irqs</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">intr</span><span class="o">&amp;</span><span class="n">CHBEXT</span><span class="p">)</span>
				<span class="n">irqs</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">work</span><span class="o">==</span><span class="mi">5000</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: interrupt jammed - abort(0x%X)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">intr</span><span class="p">);</span>
	<span class="cm">/* Ok all done */</span>
	<span class="n">locker</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_interrupt</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">reg_init</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="o">=</span>
<span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
	<span class="mh">0x55</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> *	z8530_sync_open - Open a Z8530 channel for PIO</span>
<span class="cm"> *	@dev:	The network interface we are using</span>
<span class="cm"> *	@c:	The Z8530 channel to open in synchronous PIO mode</span>
<span class="cm"> *</span>
<span class="cm"> *	Switch a Z8530 into synchronous mode without DMA assist. We</span>
<span class="cm"> *	raise the RTS/DTR and commence network operation.</span>
<span class="cm"> */</span>
 
<span class="kt">int</span> <span class="nf">z8530_sync_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="o">+</span><span class="mi">64</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">irqs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z8530_sync</span><span class="p">;</span>

	<span class="cm">/* This loads the double buffer up */</span>
	<span class="n">z8530_rx_done</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>	<span class="cm">/* Load the frame ring */</span>
	<span class="n">z8530_rx_done</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>	<span class="cm">/* Load the backup frame */</span>
	<span class="n">z8530_rtsdtr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">|=</span><span class="n">TxINT_ENAB</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R3</span><span class="p">]</span><span class="o">|</span><span class="n">RxENABLE</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_sync_open</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_sync_close - Close a PIO Z8530 channel</span>
<span class="cm"> *	@dev: Network device to close</span>
<span class="cm"> *	@c: Z8530 channel to disassociate and move to idle</span>
<span class="cm"> *</span>
<span class="cm"> *	Close down a Z8530 interface and switch its interrupt handlers</span>
<span class="cm"> *	to discard future events.</span>
<span class="cm"> */</span>
 
<span class="kt">int</span> <span class="nf">z8530_sync_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">chk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">irqs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z8530_nop</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="n">chk</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">R0</span><span class="p">);</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R3</span><span class="p">]);</span>
	<span class="n">z8530_rtsdtr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_sync_close</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_sync_dma_open - Open a Z8530 for DMA I/O</span>
<span class="cm"> *	@dev: The network device to attach</span>
<span class="cm"> *	@c: The Z8530 channel to configure in sync DMA mode.</span>
<span class="cm"> *</span>
<span class="cm"> *	Set up a Z85x30 device for synchronous DMA in both directions. Two</span>
<span class="cm"> *	ISA DMA channels must be available for this to work. We assume ISA</span>
<span class="cm"> *	DMA driven I/O and PC limits on access.</span>
<span class="cm"> */</span>
 
<span class="kt">int</span> <span class="nf">z8530_sync_dma_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cflags</span><span class="p">,</span> <span class="n">dflags</span><span class="p">;</span>
	
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="o">+</span><span class="mi">64</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Load the DMA interfaces up</span>
<span class="cm">	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Allocate the DMA flip buffers. Limit by page size.</span>
<span class="cm">	 *	Everyone runs 1500 mtu or less on wan links so this</span>
<span class="cm">	 *	should be fine.</span>
<span class="cm">	 */</span>
	 
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span>  <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	 
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
	
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_used</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_tx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_num</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_ready</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Enable DMA control mode</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">cflags</span><span class="p">);</span>
	 
	<span class="cm">/*</span>
<span class="cm">	 *	TX DMA via DIR/REQ</span>
<span class="cm">	 */</span>
	 
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R14</span><span class="p">]</span><span class="o">|=</span> <span class="n">DTRREQ</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R14</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R14</span><span class="p">]);</span>     

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="n">TxINT_ENAB</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	RX DMA via W/Req</span>
<span class="cm">	 */</span>	 

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">|=</span> <span class="n">WT_FN_RDYFN</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">|=</span> <span class="n">WT_RDY_RT</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">|=</span> <span class="n">INT_ERR_Rx</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="n">TxINT_ENAB</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">|=</span> <span class="n">WT_RDY_ENAB</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>            
	
	<span class="cm">/*</span>
<span class="cm">	 *	DMA interrupts</span>
<span class="cm">	 */</span>
	 
	<span class="cm">/*</span>
<span class="cm">	 *	Set up the DMA configuration</span>
<span class="cm">	 */</span>	
	 
	<span class="n">dflags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
	 
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">,</span> <span class="n">DMA_MODE_READ</span><span class="o">|</span><span class="mh">0x10</span><span class="p">);</span>
	<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">,</span> <span class="n">virt_to_bus</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">set_dma_count</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
	<span class="n">enable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>

	<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">,</span> <span class="n">DMA_MODE_WRITE</span><span class="p">);</span>
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">dflags</span><span class="p">);</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Select the DMA interrupt handlers</span>
<span class="cm">	 */</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	 
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">irqs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z8530_dma_sync</span><span class="p">;</span>
	<span class="n">z8530_rtsdtr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R3</span><span class="p">]</span><span class="o">|</span><span class="n">RxENABLE</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">cflags</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_sync_dma_open</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_sync_dma_close - Close down DMA I/O</span>
<span class="cm"> *	@dev: Network device to detach</span>
<span class="cm"> *	@c: Z8530 channel to move into discard mode</span>
<span class="cm"> *</span>
<span class="cm"> *	Shut down a DMA mode synchronous interface. Halt the DMA, and</span>
<span class="cm"> *	free the buffers.</span>
<span class="cm"> */</span>
 
<span class="kt">int</span> <span class="nf">z8530_sync_dma_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">chk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">irqs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z8530_nop</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Disable the PC DMA channels</span>
<span class="cm">	 */</span>
	
	<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span> 
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>
	
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Disable DMA control mode</span>
<span class="cm">	 */</span>
	 
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="n">WT_RDY_ENAB</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>            
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">WT_RDY_RT</span><span class="o">|</span><span class="n">WT_FN_RDYFN</span><span class="o">|</span><span class="n">INT_ERR_Rx</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">|=</span> <span class="n">INT_ALL_Rx</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R14</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="n">DTRREQ</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R14</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R14</span><span class="p">]);</span>   
	
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span>  <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chk</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">R0</span><span class="p">);</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R3</span><span class="p">]);</span>
	<span class="n">z8530_rtsdtr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_sync_dma_close</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_sync_txdma_open - Open a Z8530 for TX driven DMA</span>
<span class="cm"> *	@dev: The network device to attach</span>
<span class="cm"> *	@c: The Z8530 channel to configure in sync DMA mode.</span>
<span class="cm"> *</span>
<span class="cm"> *	Set up a Z85x30 device for synchronous DMA tranmission. One</span>
<span class="cm"> *	ISA DMA channel must be available for this to work. The receive</span>
<span class="cm"> *	side is run in PIO mode, but then it has the bigger FIFO.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">z8530_sync_txdma_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cflags</span><span class="p">,</span> <span class="n">dflags</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Opening sync interface for TX-DMA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="o">+</span><span class="mi">64</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Allocate the DMA flip buffers. Limit by page size.</span>
<span class="cm">	 *	Everyone runs 1500 mtu or less on wan links so this</span>
<span class="cm">	 *	should be fine.</span>
<span class="cm">	 */</span>
	 
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span>  <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	 
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>


	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">cflags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Load the PIO receive ring</span>
<span class="cm">	 */</span>

	<span class="n">z8530_rx_done</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">z8530_rx_done</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

 	<span class="cm">/*</span>
<span class="cm">	 *	Load the DMA interfaces up</span>
<span class="cm">	 */</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_used</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_num</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_ready</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_tx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

 	<span class="cm">/*</span>
<span class="cm">	 *	Enable DMA control mode</span>
<span class="cm">	 */</span>

 	<span class="cm">/*</span>
<span class="cm">	 *	TX DMA via DIR/REQ</span>
<span class="cm"> 	 */</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R14</span><span class="p">]</span><span class="o">|=</span> <span class="n">DTRREQ</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R14</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R14</span><span class="p">]);</span>     
	
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="n">TxINT_ENAB</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Set up the DMA configuration</span>
<span class="cm">	 */</span>	
	 
	<span class="n">dflags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>

	<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">,</span> <span class="n">DMA_MODE_WRITE</span><span class="p">);</span>
	<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>

	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">dflags</span><span class="p">);</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Select the DMA interrupt handlers</span>
<span class="cm">	 */</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	 
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">irqs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z8530_txdma_sync</span><span class="p">;</span>
	<span class="n">z8530_rtsdtr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R3</span><span class="p">]</span><span class="o">|</span><span class="n">RxENABLE</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">cflags</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_sync_txdma_open</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_sync_txdma_close - Close down a TX driven DMA channel</span>
<span class="cm"> *	@dev: Network device to detach</span>
<span class="cm"> *	@c: Z8530 channel to move into discard mode</span>
<span class="cm"> *</span>
<span class="cm"> *	Shut down a DMA/PIO split mode synchronous interface. Halt the DMA, </span>
<span class="cm"> *	and  free the buffers.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">z8530_sync_txdma_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dflags</span><span class="p">,</span> <span class="n">cflags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">chk</span><span class="p">;</span>

	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">cflags</span><span class="p">);</span>
	
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">irqs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z8530_nop</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Disable the PC DMA channels</span>
<span class="cm">	 */</span>
	 
	<span class="n">dflags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>

	<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">dflags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Disable DMA control mode</span>
<span class="cm">	 */</span>
	 
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="n">WT_RDY_ENAB</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>            
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">WT_RDY_RT</span><span class="o">|</span><span class="n">WT_FN_RDYFN</span><span class="o">|</span><span class="n">INT_ERR_Rx</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]</span><span class="o">|=</span> <span class="n">INT_ALL_Rx</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R1</span><span class="p">]);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R14</span><span class="p">]</span><span class="o">&amp;=</span> <span class="o">~</span><span class="n">DTRREQ</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R14</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R14</span><span class="p">]);</span>   
	
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">chk</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">R0</span><span class="p">);</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R3</span><span class="p">]);</span>
	<span class="n">z8530_rtsdtr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">cflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_sync_txdma_close</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> *	Name strings for Z8530 chips. SGI claim to have a 130, Zilog deny</span>
<span class="cm"> *	it exists...</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">z8530_type_name</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span>
	<span class="s">&quot;Z8530&quot;</span><span class="p">,</span>
	<span class="s">&quot;Z85C30&quot;</span><span class="p">,</span>
	<span class="s">&quot;Z85230&quot;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_describe - Uniformly describe a Z8530 port</span>
<span class="cm"> *	@dev: Z8530 device to describe</span>
<span class="cm"> *	@mapping: string holding mapping type (eg &quot;I/O&quot; or &quot;Mem&quot;)</span>
<span class="cm"> *	@io: the port value in question</span>
<span class="cm"> *</span>
<span class="cm"> *	Describe a Z8530 in a standard format. We must pass the I/O as</span>
<span class="cm"> *	the port offset isn&#39;t predictable. The main reason for this function</span>
<span class="cm"> *	is to try and get a common format of report.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">z8530_describe</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: %s found at %s 0x%lX, IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> 
		<span class="n">z8530_type_name</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">],</span>
		<span class="n">mapping</span><span class="p">,</span>
		<span class="n">Z8530_PORT_OF</span><span class="p">(</span><span class="n">io</span><span class="p">),</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_describe</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Locked operation part of the z8530 init code</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">do_z8530_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* NOP the interrupt handlers first - we might get a</span>
<span class="cm">	   floating IRQ transition when we reset the chip */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">.</span><span class="n">irqs</span><span class="o">=&amp;</span><span class="n">z8530_nop</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">.</span><span class="n">irqs</span><span class="o">=&amp;</span><span class="n">z8530_nop</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">.</span><span class="n">dcdcheck</span><span class="o">=</span><span class="n">DCD</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">.</span><span class="n">dcdcheck</span><span class="o">=</span><span class="n">DCD</span><span class="p">;</span>

	<span class="cm">/* Reset the chip */</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R9</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="cm">/* Now check its valid */</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R12</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">read_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R12</span><span class="p">)</span><span class="o">!=</span><span class="mh">0xAA</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R12</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">read_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R12</span><span class="p">)</span><span class="o">!=</span><span class="mh">0x55</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">=</span><span class="n">Z8530</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	See the application note.</span>
<span class="cm">	 */</span>
	 
	<span class="n">write_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">);</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	If we can set the low bit of R15 then</span>
<span class="cm">	 *	the chip is enhanced.</span>
<span class="cm">	 */</span>
	 
	<span class="k">if</span><span class="p">(</span><span class="n">read_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R15</span><span class="p">)</span><span class="o">==</span><span class="mh">0x01</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* This C30 versus 230 detect is from Klaus Kudielka&#39;s dmascc */</span>
		<span class="cm">/* Put a char in the fifo */</span>
		<span class="n">write_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">read_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R0</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Tx_BUF_EMP</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">Z85230</span><span class="p">;</span>	<span class="cm">/* Has a FIFO */</span>
		<span class="k">else</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">Z85C30</span><span class="p">;</span>	<span class="cm">/* Z85C30, 1 byte FIFO */</span>
	<span class="p">}</span>
		
	<span class="cm">/*</span>
<span class="cm">	 *	The code assumes R7&#39; and friends are</span>
<span class="cm">	 *	off. Use write_zsext() for these and keep</span>
<span class="cm">	 *	this bit clear.</span>
<span class="cm">	 */</span>
	 
	<span class="n">write_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		
	<span class="cm">/*</span>
<span class="cm">	 *	At this point it looks like the chip is behaving</span>
<span class="cm">	 */</span>
	 
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="n">reg_init</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">.</span><span class="n">regs</span><span class="p">,</span> <span class="n">reg_init</span> <span class="p">,</span><span class="mi">16</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_init - Initialise a Z8530 device</span>
<span class="cm"> *	@dev: Z8530 device to initialise.</span>
<span class="cm"> *</span>
<span class="cm"> *	Configure up a Z8530/Z85C30 or Z85230 chip. We check the device</span>
<span class="cm"> *	is present, identify the type and then program it to hopefully</span>
<span class="cm"> *	keep quite and behave. This matters a lot, a Z8530 in the wrong</span>
<span class="cm"> *	state will sometimes get into stupid modes generating 10Khz</span>
<span class="cm"> *	interrupt streams and the like.</span>
<span class="cm"> *</span>
<span class="cm"> *	We set the interrupt handler up to discard any events, in case</span>
<span class="cm"> *	we get them during reset or setp.</span>
<span class="cm"> *</span>
<span class="cm"> *	Return 0 for success, or a negative value indicating the problem</span>
<span class="cm"> *	in errno form.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">z8530_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Set up the chip level lock */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_z8530_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_shutdown - Shutdown a Z8530 device</span>
<span class="cm"> *	@dev: The Z8530 chip to shutdown</span>
<span class="cm"> *</span>
<span class="cm"> *	We set the interrupt handlers to silence any interrupts. We then </span>
<span class="cm"> *	reset the chip and wait 100uS to be sure the reset completed. Just</span>
<span class="cm"> *	in case the caller then tries to do stuff.</span>
<span class="cm"> *</span>
<span class="cm"> *	This is called without the lock held</span>
<span class="cm"> */</span>
 
<span class="kt">int</span> <span class="nf">z8530_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="cm">/* Reset the chip */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">.</span><span class="n">irqs</span><span class="o">=&amp;</span><span class="n">z8530_nop</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanB</span><span class="p">.</span><span class="n">irqs</span><span class="o">=&amp;</span><span class="n">z8530_nop</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chanA</span><span class="p">,</span> <span class="n">R9</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">);</span>
	<span class="cm">/* We must lock the udelay, the chip is offlimits here */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_shutdown</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_channel_load - Load channel data</span>
<span class="cm"> *	@c: Z8530 channel to configure</span>
<span class="cm"> *	@rtable: table of register, value pairs</span>
<span class="cm"> *	FIXME: ioctl to allow user uploaded tables</span>
<span class="cm"> *</span>
<span class="cm"> *	Load a Z8530 channel up from the system data. We use +16 to </span>
<span class="cm"> *	indicate the &quot;prime&quot; registers. The value 255 terminates the</span>
<span class="cm"> *	table.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">z8530_channel_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rtable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">rtable</span><span class="o">!=</span><span class="mi">255</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">reg</span><span class="o">=*</span><span class="n">rtable</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">reg</span><span class="o">&gt;</span><span class="mh">0x0F</span><span class="p">)</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">|</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">reg</span><span class="o">&amp;</span><span class="mh">0x0F</span><span class="p">,</span> <span class="o">*</span><span class="n">rtable</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">reg</span><span class="o">&gt;</span><span class="mh">0x0F</span><span class="p">)</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R15</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">&amp;~</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span><span class="o">=*</span><span class="n">rtable</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_function</span><span class="o">=</span><span class="n">z8530_null_rx</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_skb</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="o">=</span><span class="mi">1500</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">status</span><span class="o">=</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R0</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">sync</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R3</span><span class="p">]</span><span class="o">|</span><span class="n">RxENABLE</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_channel_load</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	z8530_tx_begin - Begin packet transmission</span>
<span class="cm"> *	@c: The Z8530 channel to kick</span>
<span class="cm"> *</span>
<span class="cm"> *	This is the speed sensitive side of transmission. If we are called</span>
<span class="cm"> *	and no buffer is being transmitted we commence the next buffer. If</span>
<span class="cm"> *	nothing is queued we idle the sync. </span>
<span class="cm"> *</span>
<span class="cm"> *	Note: We are handling this code path in the interrupt path, keep it</span>
<span class="cm"> *	fast or bad things will happen.</span>
<span class="cm"> *</span>
<span class="cm"> *	Called with the lock held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_tx_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
		
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_skb</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_skb</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_ptr</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_ptr</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Idle on */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 *	Check if we crapped out.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_dma_residue</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">txcount</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">txcount</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		
		
		<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_tx</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *	FIXME. DMA is broken for the original 8530,</span>
<span class="cm">			 *	on the older parts we need to set a flag and</span>
<span class="cm">			 *	wait for a further TX interrupt to fire this</span>
<span class="cm">			 *	stage off	</span>
<span class="cm">			 */</span>
			 
			<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
			<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *	These two are needed by the 8530/85C30</span>
<span class="cm">			 *	and must be issued when idling.</span>
<span class="cm">			 */</span>
			 
			<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">!=</span><span class="n">Z85230</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_Tx_CRC</span><span class="p">);</span>
				<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_EOM_L</span><span class="p">);</span>
			<span class="p">}</span>	
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R10</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&amp;~</span><span class="n">ABUNDER</span><span class="p">);</span>
			<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
			<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">,</span> <span class="n">virt_to_bus</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_ptr</span><span class="p">));</span>
			<span class="n">set_dma_count</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">txcount</span><span class="p">);</span>
			<span class="n">enable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txdma</span><span class="p">);</span>
			<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_EOM_L</span><span class="p">);</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R5</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="n">R5</span><span class="p">]</span><span class="o">|</span><span class="n">TxENAB</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>

			<span class="cm">/* ABUNDER off */</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R10</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
			<span class="n">write_zsctrl</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">RES_Tx_CRC</span><span class="p">);</span>
	
			<span class="k">while</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">txcount</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">read_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">R0</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Tx_BUF_EMP</span><span class="p">))</span>
			<span class="p">{</span>		
				<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R8</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_ptr</span><span class="o">++</span><span class="p">);</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">txcount</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Since we emptied tx_skb we can ask for more</span>
<span class="cm">	 */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_tx_done - TX complete callback</span>
<span class="cm"> *	@c: The channel that completed a transmit.</span>
<span class="cm"> *</span>
<span class="cm"> *	This is called when we complete a packet send. We wake the queue,</span>
<span class="cm"> *	start the next packet going and then free the buffer of the existing</span>
<span class="cm"> *	packet. This code is fairly timing sensitive.</span>
<span class="cm"> *</span>
<span class="cm"> *	Called with the register lock held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_tx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Actually this can happen.*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">z8530_tx_begin</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_null_rx - Discard a packet</span>
<span class="cm"> *	@c: The channel the packet arrived on</span>
<span class="cm"> *	@skb: The buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	We point the receive handler at this function when idle. Instead</span>
<span class="cm"> *	of processing the frames we get to throw them away.</span>
<span class="cm"> */</span>
 
<span class="kt">void</span> <span class="nf">z8530_null_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_null_rx</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_rx_done - Receive completion callback</span>
<span class="cm"> *	@c: The channel that completed a receive</span>
<span class="cm"> *</span>
<span class="cm"> *	A new packet is complete. Our goal here is to get back into receive</span>
<span class="cm"> *	mode as fast as possible. On the Z85230 we could change to using</span>
<span class="cm"> *	ESCC mode, but on the older chips we have no choice. We flip to the</span>
<span class="cm"> *	new buffer immediately in DMA mode so that the DMA of the next</span>
<span class="cm"> *	frame can occur while we are copying the previous buffer to an sk_buff</span>
<span class="cm"> *</span>
<span class="cm"> *	Called with the lock held</span>
<span class="cm"> */</span>
 
<span class="k">static</span> <span class="kt">void</span> <span class="nf">z8530_rx_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ct</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	Is our receive engine in DMA mode</span>
<span class="cm">	 */</span>
	 
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma_on</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Save the ready state and the buffer currently</span>
<span class="cm">		 *	being used as the DMA target</span>
<span class="cm">		 */</span>
		 
		<span class="kt">int</span> <span class="n">ready</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_ready</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rxb</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_num</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		
		<span class="cm">/*</span>
<span class="cm">		 *	Complete this DMA. Necessary to find the length</span>
<span class="cm">		 */</span>		
		 
		<span class="n">flags</span><span class="o">=</span><span class="n">claim_dma_lock</span><span class="p">();</span>
		
		<span class="n">disable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>
		<span class="n">clear_dma_ff</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma_on</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">ct</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="o">-</span><span class="n">get_dma_residue</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ct</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">ct</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* Shit happens.. */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_ready</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		
		<span class="cm">/*</span>
<span class="cm">		 *	Normal case: the other slot is free, start the next DMA</span>
<span class="cm">		 *	into it immediately.</span>
<span class="cm">		 */</span>
		 
		<span class="k">if</span><span class="p">(</span><span class="n">ready</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_num</span><span class="o">^=</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">,</span> <span class="n">DMA_MODE_READ</span><span class="o">|</span><span class="mh">0x10</span><span class="p">);</span>
			<span class="n">set_dma_addr</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">,</span> <span class="n">virt_to_bus</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_buf</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_num</span><span class="p">]));</span>
			<span class="n">set_dma_count</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">enable_dma</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">rxdma</span><span class="p">);</span>
			<span class="cm">/* Stop any frames that we missed the head of </span>
<span class="cm">			   from passing */</span>
			<span class="n">write_zsreg</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">RES_Rx_CRC</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="cm">/* Can&#39;t occur as we dont reenable the DMA irq until</span>
<span class="cm">			   after the flip is done */</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">,</span> <span class="s">&quot;DMA flip overrun!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Shove the old buffer into an sk_buff. We can&#39;t DMA</span>
<span class="cm">		 *	directly into one on a PC - it might be above the 16Mb</span>
<span class="cm">		 *	boundary. Optimisation - we could check to see if we</span>
<span class="cm">		 *	can avoid the copy. Optimisation 2 - make the memcpy</span>
<span class="cm">		 *	a copychecksum.</span>
<span class="cm">		 */</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">,</span> <span class="s">&quot;Memory squeeze</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
			<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rxb</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">ct</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">RT_LOCK</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	The game we play for non DMA is similar. We want to</span>
<span class="cm">		 *	get the controller set up for the next packet as fast</span>
<span class="cm">		 *	as possible. We potentially only have one byte + the</span>
<span class="cm">		 *	fifo length for this. Thus we want to flip to the new</span>
<span class="cm">		 *	buffer and then mess around copying and allocating</span>
<span class="cm">		 *	things. For the current case it doesn&#39;t matter but</span>
<span class="cm">		 *	if you build a system where the sync irq isn&#39;t blocked</span>
<span class="cm">		 *	by the kernel IRQ disable then you need only block the</span>
<span class="cm">		 *	sync IRQ for the RT_LOCK area.</span>
<span class="cm">		 *</span>
<span class="cm">		 */</span>
		<span class="n">ct</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">skb2</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">dptr</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">RT_UNLOCK</span><span class="p">;</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">skb2</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">skb2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">,</span> <span class="s">&quot;memory squeeze</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">skb2</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">ct</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	If we received a frame we must now process it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">rx_function</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">,</span> <span class="s">&quot;Lost a frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	spans_boundary - Check a packet can be ISA DMA&#39;d</span>
<span class="cm"> *	@skb: The buffer to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns true if the buffer cross a DMA boundary on a PC. The poor</span>
<span class="cm"> *	thing can only DMA within a 64K block not across the edges of it.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">spans_boundary</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">a</span><span class="o">^=</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&amp;</span><span class="mh">0x00010000</span><span class="p">)</span>	<span class="cm">/* If the 64K bit is different.. */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	z8530_queue_xmit - Queue a packet</span>
<span class="cm"> *	@c: The channel to use</span>
<span class="cm"> *	@skb: The packet to kick down the channel</span>
<span class="cm"> *</span>
<span class="cm"> *	Queue a packet for transmission. Because we have rather</span>
<span class="cm"> *	hard to hit interrupt latencies for the Z85230 per packet </span>
<span class="cm"> *	even in DMA mode we do the flip to DMA buffer if needed here</span>
<span class="cm"> *	not in the IRQ.</span>
<span class="cm"> *</span>
<span class="cm"> *	Called from the network code. The lock is not held at this </span>
<span class="cm"> *	point.</span>
<span class="cm"> */</span>

<span class="n">netdev_tx_t</span> <span class="nf">z8530_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">z8530_channel</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">netdevice</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>

	
	<span class="cm">/* PC SPECIFIC - DMA limits */</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *	If we will DMA the transmit and its gone over the ISA bus</span>
<span class="cm">	 *	limit, then copy to the flip buffer</span>
<span class="cm">	 */</span>
	 
	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dma_tx</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">virt_to_bus</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">+</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span><span class="o">&gt;=</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span> <span class="o">||</span> <span class="n">spans_boundary</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
	<span class="p">{</span>
		<span class="cm">/* </span>
<span class="cm">		 *	Send the flip buffer, and flip the flippy bit.</span>
<span class="cm">		 *	We don&#39;t care which is used when just so long as</span>
<span class="cm">		 *	we never use the same buffer twice in a row. Since</span>
<span class="cm">		 *	only one buffer can be going out at a time the other</span>
<span class="cm">		 *	has to be safe.</span>
<span class="cm">		 */</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_ptr</span><span class="o">=</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_buf</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_used</span><span class="p">];</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_dma_used</span><span class="o">^=</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Flip temp buffer */</span>
		<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_ptr</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_ptr</span><span class="o">=</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>	
	<span class="n">RT_LOCK</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tx_next_skb</span><span class="o">=</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">RT_UNLOCK</span><span class="p">;</span>
	
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">z8530_tx_begin</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">z8530_queue_xmit</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Module support</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">banner</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span>
	<span class="n">KERN_INFO</span> <span class="s">&quot;Generic Z85C30/Z85230 interface driver v0.02</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">z85230_init_driver</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">banner</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">z85230_init_driver</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">z85230_cleanup_driver</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">z85230_cleanup_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Red Hat Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Z85x30 synchronous driver core&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
