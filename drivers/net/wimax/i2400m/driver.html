<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wimax › i2400m › driver.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>driver.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Intel Wireless WiMAX Connection 2400m</span>
<span class="cm"> * Generic probe/disconnect, reset and message passing</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Intel Corporation &lt;linux-wimax@intel.com&gt;</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * See i2400m.h for driver documentation. This contains helpers for</span>
<span class="cm"> * the driver model glue [_setup()/_release()], handling device resets</span>
<span class="cm"> * [_dev_reset_handle()], and the backends for the WiMAX stack ops</span>
<span class="cm"> * reset [_op_reset()] and message from user [_op_msg_from_user()].</span>
<span class="cm"> *</span>
<span class="cm"> * ROADMAP:</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_op_msg_from_user()</span>
<span class="cm"> *   i2400m_msg_to_dev()</span>
<span class="cm"> *   wimax_msg_to_user_send()</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_op_reset()</span>
<span class="cm"> *   i240m-&gt;bus_reset()</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_dev_reset_handle()</span>
<span class="cm"> *   __i2400m_dev_reset_handle()</span>
<span class="cm"> *     __i2400m_dev_stop()</span>
<span class="cm"> *     __i2400m_dev_start()</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_setup()</span>
<span class="cm"> *   i2400m-&gt;bus_setup()</span>
<span class="cm"> *   i2400m_bootrom_init()</span>
<span class="cm"> *   register_netdev()</span>
<span class="cm"> *   wimax_dev_add()</span>
<span class="cm"> *   i2400m_dev_start()</span>
<span class="cm"> *     __i2400m_dev_start()</span>
<span class="cm"> *       i2400m_dev_bootstrap()</span>
<span class="cm"> *       i2400m_tx_setup()</span>
<span class="cm"> *       i2400m-&gt;bus_dev_start()</span>
<span class="cm"> *       i2400m_firmware_check()</span>
<span class="cm"> *       i2400m_check_mac_addr()</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_release()</span>
<span class="cm"> *   i2400m_dev_stop()</span>
<span class="cm"> *     __i2400m_dev_stop()</span>
<span class="cm"> *       i2400m_dev_shutdown()</span>
<span class="cm"> *       i2400m-&gt;bus_dev_stop()</span>
<span class="cm"> *       i2400m_tx_release()</span>
<span class="cm"> *   i2400m-&gt;bus_release()</span>
<span class="cm"> *   wimax_dev_rm()</span>
<span class="cm"> *   unregister_netdev()</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;i2400m.h&quot;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/wimax/i2400m.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#define D_SUBMODULE driver</span>
<span class="cp">#include &quot;debug-levels.h&quot;</span>


<span class="k">static</span> <span class="kt">char</span> <span class="n">i2400m_debug_params</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">i2400m_debug_params</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_debug_params</span><span class="p">),</span>
		    <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span>
		 <span class="s">&quot;String of space-separated NAME:VALUE pairs, where NAMEs &quot;</span>
		 <span class="s">&quot;are the different debug submodules and VALUE are the &quot;</span>
		 <span class="s">&quot;initial debug value to set.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">i2400m_barkers_params</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">barkers</span><span class="p">,</span> <span class="n">i2400m_barkers_params</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_barkers_params</span><span class="p">),</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">barkers</span><span class="p">,</span>
		 <span class="s">&quot;String of comma-separated 32-bit values; each is &quot;</span>
		 <span class="s">&quot;recognized as the value the device sends as a reboot &quot;</span>
		 <span class="s">&quot;signal; values are appended to a list--setting one value &quot;</span>
		 <span class="s">&quot;as zero cleans the existing list and starts a new one.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * WiMAX stack operation: relay a message from user space</span>
<span class="cm"> *</span>
<span class="cm"> * @wimax_dev: device descriptor</span>
<span class="cm"> * @pipe_name: named pipe the message is for</span>
<span class="cm"> * @msg_buf: pointer to the message bytes</span>
<span class="cm"> * @msg_len: length of the buffer</span>
<span class="cm"> * @genl_info: passed by the generic netlink layer</span>
<span class="cm"> *</span>
<span class="cm"> * The WiMAX stack will call this function when a message was received</span>
<span class="cm"> * from user space.</span>
<span class="cm"> *</span>
<span class="cm"> * For the i2400m, this is an L3L4 message, as specified in</span>
<span class="cm"> * include/linux/wimax/i2400m.h, and thus prefixed with a &#39;struct</span>
<span class="cm"> * i2400m_l3l4_hdr&#39;. Driver (and device) expect the messages to be</span>
<span class="cm"> * coded in Little Endian.</span>
<span class="cm"> *</span>
<span class="cm"> * This function just verifies that the header declaration and the</span>
<span class="cm"> * payload are consistent and then deals with it, either forwarding it</span>
<span class="cm"> * to the device or procesing it locally.</span>
<span class="cm"> *</span>
<span class="cm"> * In the i2400m, messages are basically commands that will carry an</span>
<span class="cm"> * ack, so we use i2400m_msg_to_dev() and then deliver the ack back to</span>
<span class="cm"> * user space. The rx.c code might intercept the response and use it</span>
<span class="cm"> * to update the driver&#39;s state, but then it will pass it on so it can</span>
<span class="cm"> * be relayed back to user space.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that asynchronous events from the device are processed and</span>
<span class="cm"> * sent to user space in rx.c.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_op_msg_from_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pipe_name</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg_buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">msg_len</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">genl_info</span> <span class="o">*</span><span class="n">genl_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">wimax_dev_to_i2400m</span><span class="p">(</span><span class="n">wimax_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ack_skb</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(wimax_dev %p [i2400m %p] msg_buf %p &quot;</span>
		  <span class="s">&quot;msg_len %zu genl_info %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wimax_dev</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span>
		  <span class="n">msg_buf</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">,</span> <span class="n">genl_info</span><span class="p">);</span>
	<span class="n">ack_skb</span> <span class="o">=</span> <span class="n">i2400m_msg_to_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">msg_buf</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ack_skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ack_skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_msg_to_dev</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wimax_msg_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">,</span> <span class="n">ack_skb</span><span class="p">);</span>
<span class="nl">error_msg_to_dev:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(wimax_dev %p [i2400m %p] msg_buf %p msg_len %zu &quot;</span>
		<span class="s">&quot;genl_info %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wimax_dev</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">msg_buf</span><span class="p">,</span> <span class="n">msg_len</span><span class="p">,</span>
		<span class="n">genl_info</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Context to wait for a reset to finalize</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2400m_reset_ctx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">completion</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * WiMAX stack operation: reset a device</span>
<span class="cm"> *</span>
<span class="cm"> * @wimax_dev: device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * See the documentation for wimax_reset() and wimax_dev-&gt;op_reset for</span>
<span class="cm"> * the requirements of this function. The WiMAX stack guarantees</span>
<span class="cm"> * serialization on calls to this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Do a warm reset on the device; if it fails, resort to a cold reset</span>
<span class="cm"> * and return -ENODEV. On successful warm reset, we need to block</span>
<span class="cm"> * until it is complete.</span>
<span class="cm"> *</span>
<span class="cm"> * The bus-driver implementation of reset takes care of falling back</span>
<span class="cm"> * to cold reset if warm fails.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_op_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">wimax_dev_to_i2400m</span><span class="p">(</span><span class="n">wimax_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_reset_ctx</span> <span class="n">ctx</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">completion</span> <span class="o">=</span> <span class="n">COMPLETION_INITIALIZER_ONSTACK</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">completion</span><span class="p">),</span>
		<span class="p">.</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(wimax_dev %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wimax_dev</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_reset</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_RT_WARM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">completion</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">result</span><span class="p">;</span>
	<span class="cm">/* if result &lt; 0, pass it on */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(wimax_dev %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wimax_dev</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Check the MAC address we got from boot mode is ok</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if ok, &lt; 0 errno code on error.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_check_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_tlv_detailed_device_info</span> <span class="o">*</span><span class="n">ddi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">zeromac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">i2400m_get_device_info</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot verify MAC address, error reading: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Extract MAC address */</span>
	<span class="n">ddi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">ETH_ALEN</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ddi</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">));</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;GET DEVICE INFO: mac addr %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">,</span>
		   <span class="k">sizeof</span><span class="p">(</span><span class="n">ddi</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;warning: device reports a different MAC address &quot;</span>
		 <span class="s">&quot;to that of boot mode&#39;s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reports     %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">);</span>
	<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot mode reported %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">zeromac</span><span class="p">,</span> <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zeromac</span><span class="p">)))</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reports an invalid MAC address, &quot;</span>
			<span class="s">&quot;not updating</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;updating MAC address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">=</span> <span class="n">ETH_ALEN</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ddi</span><span class="o">-&gt;</span><span class="n">mac_address</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">ok:</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * __i2400m_dev_start - Bring up driver communication with the device</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> * @flags: boot mode flags</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if ok, &lt; 0 errno code on error.</span>
<span class="cm"> *</span>
<span class="cm"> * Uploads firmware and brings up all the resources needed to be able</span>
<span class="cm"> * to communicate with the device.</span>
<span class="cm"> *</span>
<span class="cm"> * The workqueue has to be setup early, at least before RX handling</span>
<span class="cm"> * (it&#39;s only real user for now) so it can process reports as they</span>
<span class="cm"> * arrive. We also want to destroy it if we retry, to make sure it is</span>
<span class="cm"> * flushed...easier like this.</span>
<span class="cm"> *</span>
<span class="cm"> * TX needs to be setup before the bus-specific code (otherwise on</span>
<span class="cm"> * shutdown, the bus-tx code could try to access it).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">__i2400m_dev_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">wimax_dev</span><span class="o">-&gt;</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_retries</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
<span class="nl">retry:</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_dev_bootstrap</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot bootstrap device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_bootstrap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_tx_setup</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_tx_setup</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_rx_setup</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_rx_setup</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">work_queue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="n">wimax_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">work_queue</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot create workqueue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_create_workqueue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_dev_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_dev_start</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_bus_dev_start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* see i2400m-&gt;ready&#39;s documentation  */</span>
	<span class="cm">/* process pending reports from the device */</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">work_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_report_ws</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_firmware_check</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>	<span class="cm">/* fw versions ok? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_fw_check</span><span class="p">;</span>
	<span class="cm">/* At this point is ok to send commands to the device */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_check_mac_addr</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_check_mac_addr</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_dev_initialize</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_dev_initialize</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t want any additional unwanted error recovery triggered</span>
<span class="cm">	 * from any other context so if anything went wrong before we come</span>
<span class="cm">	 * here, let&#39;s keep i2400m-&gt;error_recovery untouched and leave it to</span>
<span class="cm">	 * dev_reset_handle(). See dev_reset_handle(). */</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">error_recovery</span><span class="p">);</span>
	<span class="cm">/* Every thing works so far, ok, now we are ready to</span>
<span class="cm">	 * take error recovery if it&#39;s required. */</span>

	<span class="cm">/* At this point, reports will come for the device and set it</span>
<span class="cm">	 * to the right state if it is different than UNINITIALIZED */</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(net_dev %p [i2400m %p]) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">net_dev</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="nl">error_dev_initialize:</span>
<span class="nl">error_check_mac_addr:</span>
<span class="nl">error_fw_check:</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* see i2400m-&gt;ready&#39;s documentation  */</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">work_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_dev_stop</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_dev_stop</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
<span class="nl">error_bus_dev_start:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">work_queue</span><span class="p">);</span>
<span class="nl">error_create_workqueue:</span>
	<span class="n">i2400m_rx_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
<span class="nl">error_rx_setup:</span>
	<span class="n">i2400m_tx_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
<span class="nl">error_tx_setup:</span>
<span class="nl">error_bootstrap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EL3RST</span> <span class="o">&amp;&amp;</span> <span class="n">times</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">I2400M_BRI_SOFT</span><span class="o">|</span><span class="n">I2400M_BRI_MAC_REINIT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(net_dev %p [i2400m %p]) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">net_dev</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_dev_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="n">bm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>	<span class="cm">/* Well, start the device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__i2400m_dev_start</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bm_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">alive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">wmb</span><span class="p">();</span><span class="cm">/* see i2400m-&gt;updown and i2400m-&gt;alive&#39;s doc */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_dev_stop - Tear down driver communication with the device</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if ok, &lt; 0 errno code on error.</span>
<span class="cm"> *</span>
<span class="cm"> * Releases all the resources allocated to communicate with the</span>
<span class="cm"> * device. Note we cannot destroy the workqueue earlier as until RX is</span>
<span class="cm"> * fully destroyed, it could still try to schedule jobs.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">__i2400m_dev_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">wimax_state_change</span><span class="p">(</span><span class="n">wimax_dev</span><span class="p">,</span> <span class="n">__WIMAX_ST_QUIESCING</span><span class="p">);</span>
	<span class="n">i2400m_msg_to_dev_cancel_wait</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="o">-</span><span class="n">EL3RST</span><span class="p">);</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">msg_completion</span><span class="p">);</span>
	<span class="n">i2400m_net_wake_stop</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">i2400m_dev_shutdown</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure no report hooks are running *before* we stop the</span>
<span class="cm">	 * communication infrastructure with the device.</span>
<span class="cm">	 */</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* nobody can queue work anymore */</span>
	<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* see i2400m-&gt;ready&#39;s documentation  */</span>
	<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">work_queue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_dev_stop</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_dev_stop</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">work_queue</span><span class="p">);</span>
	<span class="n">i2400m_rx_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">i2400m_tx_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">wimax_state_change</span><span class="p">(</span><span class="n">wimax_dev</span><span class="p">,</span> <span class="n">WIMAX_ST_DOWN</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Watch out -- we only need to stop if there is a need for it. The</span>
<span class="cm"> * device could have reset itself and failed to come up again (see</span>
<span class="cm"> * _i2400m_dev_reset_handle()).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_dev_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__i2400m_dev_stop</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">alive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>	<span class="cm">/* see i2400m-&gt;updown and i2400m-&gt;alive&#39;s doc */</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Listen to PM events to cache the firmware before suspend/hibernation</span>
<span class="cm"> *</span>
<span class="cm"> * When the device comes out of suspend, it might go into reset and</span>
<span class="cm"> * firmware has to be uploaded again. At resume, most of the times, we</span>
<span class="cm"> * can&#39;t load firmware images from disk, so we need to cache it.</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_fw_cache() will allocate a kobject and attach the firmware</span>
<span class="cm"> * to it; that way we don&#39;t have to worry too much about the fw loader</span>
<span class="cm"> * hitting a race condition.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: modus operandi stolen from the Orinoco driver; thx.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_pm_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">notifier</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pm_event</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">notifier</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">pm_notifier</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p pm_event %lx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">pm_event</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pm_event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PM_HIBERNATION_PREPARE</span>:
	<span class="k">case</span> <span class="n">PM_SUSPEND_PREPARE</span>:
		<span class="n">i2400m_fw_cache</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PM_POST_RESTORE</span>:
		<span class="cm">/* Restore from hibernation failed. We need to clean</span>
<span class="cm">		 * up in exactly the same way, so fall through. */</span>
	<span class="k">case</span> <span class="n">PM_POST_HIBERNATION</span>:
	<span class="k">case</span> <span class="n">PM_POST_SUSPEND</span>:
		<span class="n">i2400m_fw_uncache</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PM_RESTORE_PREPARE</span>:
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p pm_event %lx) = void</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">pm_event</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * pre-reset is called before a device is going on reset</span>
<span class="cm"> *</span>
<span class="cm"> * This has to be followed by a call to i2400m_post_reset(), otherwise</span>
<span class="cm"> * bad things might happen.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pre-reset shut down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_tx_disable</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="n">__i2400m_dev_stop</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* down&#39;t set updown to zero -- this way</span>
<span class="cm">		 * post_reset can restore properly */</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_pre_reset</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Restore device state after a reset</span>
<span class="cm"> *</span>
<span class="cm"> * Do the work needed after a device reset to bring it up to the same</span>
<span class="cm"> * state as it was before the reset.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this requires i2400m-&gt;init_mutex taken</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;post-reset start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_setup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_setup</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bus-specific setup failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_bus_setup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__i2400m_dev_start</span><span class="p">(</span>
			<span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_BRI_SOFT</span> <span class="o">|</span> <span class="n">I2400M_BRI_MAC_REINIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_dev_start</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="nl">error_dev_start:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="cm">/* even if the device was up, it could not be recovered, so we</span>
<span class="cm">	 * mark it as down. */</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* see i2400m-&gt;updown&#39;s documentation  */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
<span class="nl">error_bus_setup:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_post_reset</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * The device has rebooted; fix up the device and the driver</span>
<span class="cm"> *</span>
<span class="cm"> * Tear down the driver communication with the device, reload the</span>
<span class="cm"> * firmware and reinitialize the communication with the device.</span>
<span class="cm"> *</span>
<span class="cm"> * If someone calls a reset when the device&#39;s firmware is down, in</span>
<span class="cm"> * theory we won&#39;t see it because we are not listening. However, just</span>
<span class="cm"> * in case, leave the code to handle it.</span>
<span class="cm"> *</span>
<span class="cm"> * If there is a reset context, use it; this means someone is waiting</span>
<span class="cm"> * for us to tell him when the reset operation is complete and the</span>
<span class="cm"> * device is ready to rock again.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: if we are in the process of bringing up or down the</span>
<span class="cm"> *       communication with the device [running i2400m_dev_start() or</span>
<span class="cm"> *       _stop()], don&#39;t do anything, let it fail and handle it.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is ran always in a thread context</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets passed, as payload to i2400m_work() a &#39;const</span>
<span class="cm"> * char *&#39; ptr with a &quot;reason&quot; why the reset happened (for messages).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">__i2400m_dev_reset_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">reset_ws</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_reason</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_reset_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(ws %p i2400m %p reason %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>

	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">boot_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* Make sure i2400m_msg_to_dev() sees boot_mode */</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We are still in i2400m_dev_start() [let it fail] or</span>
<span class="cm">		 * i2400m_dev_stop() [we are shutting down anyway, so</span>
<span class="cm">		 * ignore it] or we are resetting somewhere else. */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device rebooted somewhere else?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">i2400m_msg_to_dev_cancel_wait</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="o">-</span><span class="n">EL3RST</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">msg_completion</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: reinitializing driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
	<span class="n">rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__i2400m_dev_stop</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* see i2400m-&gt;updown&#39;s documentation  */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">alive</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__i2400m_dev_start</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span>
				    <span class="n">I2400M_BRI_SOFT</span> <span class="o">|</span> <span class="n">I2400M_BRI_MAC_REINIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cannot start the device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">reason</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_reset_retries</span><span class="p">)</span>
					<span class="o">&gt;=</span> <span class="n">I2400M_BUS_RESET_RETRIES</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;tried too many times to &quot;</span>
					<span class="s">&quot;reset the device, giving up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EUCLEAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We come here because the reset during operational mode</span>
<span class="cm">		 * wasn&#39;t successfully done and need to proceed to a bus</span>
<span class="cm">		 * reset. For the dev_reset_handle() to be able to handle</span>
<span class="cm">		 * the reset event later properly, we restore boot_mode back</span>
<span class="cm">		 * to the state before previous reset. ie: just like we are</span>
<span class="cm">		 * issuing the bus reset for the first time</span>
<span class="cm">		 */</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">boot_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>

		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_reset_retries</span><span class="p">);</span>
		<span class="cm">/* ops, need to clean up [w/ init_mutex not held] */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_reset</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_RT_BUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rmb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">alive</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* great, we expect the device state up and</span>
<span class="cm">			 * dev_start() actually brings the device state up */</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_reset_retries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(ws %p i2400m %p reason %s) = void</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ws</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_dev_reset_handle - Handle a device&#39;s reset in a thread context</span>
<span class="cm"> *</span>
<span class="cm"> * Schedule a device reset handling out on a thread context, so it</span>
<span class="cm"> * is safe to call from atomic context. We can&#39;t use the i2400m&#39;s</span>
<span class="cm"> * queue as we are going to destroy it and reinitialize it as part of</span>
<span class="cm"> * the driver bringup/bringup process.</span>
<span class="cm"> *</span>
<span class="cm"> * See __i2400m_dev_reset_handle() for details; that takes care of</span>
<span class="cm"> * reinitializing the driver to handle the reset, calling into the</span>
<span class="cm"> * bus-specific functions ops as needed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_dev_reset_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_reason</span> <span class="o">=</span> <span class="n">reason</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_ws</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_dev_reset_handle</span><span class="p">);</span>


 <span class="cm">/*</span>
<span class="cm"> * The actual work of error recovery.</span>
<span class="cm"> *</span>
<span class="cm"> * The current implementation of error recovery is to trigger a bus reset.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">__i2400m_error_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">recovery_ws</span><span class="p">);</span>

	<span class="n">i2400m_reset</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_RT_BUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Schedule a work struct for error recovery.</span>
<span class="cm"> *</span>
<span class="cm"> * The intention of error recovery is to bring back the device to some</span>
<span class="cm"> * known state whenever TX sees -110 (-ETIMEOUT) on copying the data to</span>
<span class="cm"> * the device. The TX failure could mean a device bus stuck, so the current</span>
<span class="cm"> * error recovery implementation is to trigger a bus reset to the device</span>
<span class="cm"> * and hopefully it can bring back the device.</span>
<span class="cm"> *</span>
<span class="cm"> * The actual work of error recovery has to be in a thread context because</span>
<span class="cm"> * it is kicked off in the TX thread (i2400ms-&gt;tx_workqueue) which is to be</span>
<span class="cm"> * destroyed by the error recovery mechanism (currently a bus reset).</span>
<span class="cm"> *</span>
<span class="cm"> * Also, there may be already a queue of TX works that all hit</span>
<span class="cm"> * the -ETIMEOUT error condition because the device is stuck already.</span>
<span class="cm"> * Since bus reset is used as the error recovery mechanism and we don&#39;t</span>
<span class="cm"> * want consecutive bus resets simply because the multiple TX works</span>
<span class="cm"> * in the queue all hit the same device erratum, the flag &quot;error_recovery&quot;</span>
<span class="cm"> * is introduced for preventing unwanted consecutive bus resets.</span>
<span class="cm"> *</span>
<span class="cm"> * Error recovery shall only be invoked again if previous one was completed.</span>
<span class="cm"> * The flag error_recovery is set when error recovery mechanism is scheduled,</span>
<span class="cm"> * and is checked when we need to schedule another error recovery. If it is</span>
<span class="cm"> * in place already, then we shouldn&#39;t schedule another one.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_error_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_return</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">error_recovery</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">recovery_ws</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">error_recovery</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_error_recovery</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Alloc the command and ack buffers for boot mode</span>
<span class="cm"> *</span>
<span class="cm"> * Get the buffers needed to deal with boot mode messages.  These</span>
<span class="cm"> * buffers need to be allocated before the sdio receive irq is setup.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_bm_buf_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">I2400M_BM_CMD_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_bm_cmd_kzalloc</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_ack_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">I2400M_BM_ACK_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_ack_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_bm_ack_buf_kzalloc</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_bm_ack_buf_kzalloc:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span><span class="p">);</span>
<span class="nl">error_bm_cmd_kzalloc:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Free boot mode command and ack buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_bm_buf_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_ack_buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_init - Initialize a &#39;struct i2400m&#39; from all zeroes</span>
<span class="cm"> *</span>
<span class="cm"> * This is a bus-generic API call.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wimax_dev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">);</span>

	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">boot_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_reorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">state_wq</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_pl_min</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_size_min</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_pl_min</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_size_min</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_reports</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_report_ws</span><span class="p">,</span> <span class="n">i2400m_report_hook_work</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">msg_mutex</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">msg_completion</span><span class="p">);</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="cm">/* wake_tx_ws is initialized in i2400m_tx_setup() */</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_ws</span><span class="p">,</span> <span class="n">__i2400m_dev_reset_handle</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">recovery_ws</span><span class="p">,</span> <span class="n">__i2400m_error_recovery</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_reset_retries</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">alive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* initialize error_recovery to 1 for denoting we</span>
<span class="cm">	 * are not yet ready to take any error recovery */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">error_recovery</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_init</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">i2400m_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_reset_type</span> <span class="n">rt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we stop TXs and down the carrier before</span>
<span class="cm">	 * resetting; this is needed to avoid things like</span>
<span class="cm">	 * i2400m_wake_tx() scheduling stuff in parallel.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_tx_disable</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_reset</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_reset</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_setup - bus-generic setup function for the i2400m device</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor (bus-specific parts have been initialized)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if ok, &lt; 0 errno code on error.</span>
<span class="cm"> *</span>
<span class="cm"> * Sets up basic device comunication infrastructure, boots the ROM to</span>
<span class="cm"> * read the MAC address, registers with the WiMAX and network stacks</span>
<span class="cm"> * and then brings up the device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="n">bm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">wimax_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wimax_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span>
		 <span class="s">&quot;i2400m-%s:%s&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_bm_buf_alloc</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot allocate bootmode scratch buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_bm_buf_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_setup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_setup</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bus-specific setup failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">result</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_bus_setup</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_bootrom_init</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bm_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;read mac addr: bootrom init &quot;</span>
			<span class="s">&quot;failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_bootrom_init</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_read_mac_addr</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_read_mac_addr</span><span class="p">;</span>
	<span class="n">random_ether_addr</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">src_mac_addr</span><span class="p">);</span>

	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">pm_notifier</span><span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">i2400m_pm_notifier</span><span class="p">;</span>
	<span class="n">register_pm_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">pm_notifier</span><span class="p">);</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>	<span class="cm">/* Okey dokey, bring it up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot register i2400m network device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_register_netdev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">op_msg_from_user</span> <span class="o">=</span> <span class="n">i2400m_op_msg_from_user</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">op_rfkill_sw_toggle</span> <span class="o">=</span> <span class="n">i2400m_op_rfkill_sw_toggle</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">op_reset</span> <span class="o">=</span> <span class="n">i2400m_op_reset</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">wimax_dev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_wimax_dev_add</span><span class="p">;</span>

	<span class="cm">/* Now setup all that requires a registered net and wimax device. */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2400m_dev_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot setup i2400m&#39;s sysfs: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_sysfs_setup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_debugfs_add</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot setup i2400m&#39;s debugfs: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_debugfs_setup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_dev_start</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bm_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_dev_start</span><span class="p">;</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="nl">error_dev_start:</span>
	<span class="n">i2400m_debugfs_rm</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
<span class="nl">error_debugfs_setup:</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">i2400m_dev_attr_group</span><span class="p">);</span>
<span class="nl">error_sysfs_setup:</span>
	<span class="n">wimax_dev_rm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">);</span>
<span class="nl">error_wimax_dev_add:</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
<span class="nl">error_register_netdev:</span>
	<span class="n">unregister_pm_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">pm_notifier</span><span class="p">);</span>
<span class="nl">error_read_mac_addr:</span>
<span class="nl">error_bootrom_init:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
<span class="nl">error_bus_setup:</span>
	<span class="n">i2400m_bm_buf_free</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
<span class="nl">error_bm_buf_alloc:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_setup</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_release - release the bus-generic driver resources</span>
<span class="cm"> *</span>
<span class="cm"> * Sends a disconnect message and undoes any setup done by i2400m_setup()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">i2400m_dev_stop</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">reset_ws</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">recovery_ws</span><span class="p">);</span>

	<span class="n">i2400m_debugfs_rm</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">sysfs_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">i2400m_dev_attr_group</span><span class="p">);</span>
	<span class="n">wimax_dev_rm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">);</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">unregister_pm_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">pm_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">i2400m_bm_buf_free</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = void</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_release</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Debug levels control; see debug.h</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">d_level</span> <span class="n">D_LEVEL</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">control</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">driver</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">debugfs</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">fw</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">netdev</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">rfkill</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">rx</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">sysfs</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">tx</span><span class="p">),</span>
<span class="p">};</span>
<span class="kt">size_t</span> <span class="n">D_LEVEL_SIZE</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">D_LEVEL</span><span class="p">);</span>


<span class="k">static</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">i2400m_driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d_parse_params</span><span class="p">(</span><span class="n">D_LEVEL</span><span class="p">,</span> <span class="n">D_LEVEL_SIZE</span><span class="p">,</span> <span class="n">i2400m_debug_params</span><span class="p">,</span>
		       <span class="s">&quot;i2400m.debug&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i2400m_barker_db_init</span><span class="p">(</span><span class="n">i2400m_barkers_params</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">i2400m_driver_init</span><span class="p">);</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i2400m_driver_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">i2400m_barker_db_exit</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i2400m_driver_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Intel Corporation &lt;linux-wimax@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel 2400M WiMAX networking bus-generic driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
