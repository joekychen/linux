<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wimax › i2400m › fw.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>fw.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Intel Wireless WiMAX Connection 2400m</span>
<span class="cm"> * Firmware uploader</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *     the documentation and/or other materials provided with the</span>
<span class="cm"> *     distribution.</span>
<span class="cm"> *   * Neither the name of Intel Corporation nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Intel Corporation &lt;linux-wimax@intel.com&gt;</span>
<span class="cm"> * Yanir Lubetkin &lt;yanirx.lubetkin@intel.com&gt;</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *  - Initial implementation</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * THE PROCEDURE</span>
<span class="cm"> *</span>
<span class="cm"> * The 2400m and derived devices work in two modes: boot-mode or</span>
<span class="cm"> * normal mode. In boot mode we can execute only a handful of commands</span>
<span class="cm"> * targeted at uploading the firmware and launching it.</span>
<span class="cm"> *</span>
<span class="cm"> * The 2400m enters boot mode when it is first connected to the</span>
<span class="cm"> * system, when it crashes and when you ask it to reboot. There are</span>
<span class="cm"> * two submodes of the boot mode: signed and non-signed. Signed takes</span>
<span class="cm"> * firmwares signed with a certain private key, non-signed takes any</span>
<span class="cm"> * firmware. Normal hardware takes only signed firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * On boot mode, in USB, we write to the device using the bulk out</span>
<span class="cm"> * endpoint and read from it in the notification endpoint. In SDIO we</span>
<span class="cm"> * talk to it via the write address and read from the read address.</span>
<span class="cm"> *</span>
<span class="cm"> * Upon entrance to boot mode, the device sends (preceded with a few</span>
<span class="cm"> * zero length packets (ZLPs) on the notification endpoint in USB) a</span>
<span class="cm"> * reboot barker (4 le32 words with the same value). We ack it by</span>
<span class="cm"> * sending the same barker to the device. The device acks with a</span>
<span class="cm"> * reboot ack barker (4 le32 words with value I2400M_ACK_BARKER) and</span>
<span class="cm"> * then is fully booted. At this point we can upload the firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that different iterations of the device and EEPROM</span>
<span class="cm"> * configurations will send different [re]boot barkers; these are</span>
<span class="cm"> * collected in i2400m_barker_db along with the firmware</span>
<span class="cm"> * characteristics they require.</span>
<span class="cm"> *</span>
<span class="cm"> * This process is accomplished by the i2400m_bootrom_init()</span>
<span class="cm"> * function. All the device interaction happens through the</span>
<span class="cm"> * i2400m_bm_cmd() [boot mode command]. Special return values will</span>
<span class="cm"> * indicate if the device did reset during the process.</span>
<span class="cm"> *</span>
<span class="cm"> * After this, we read the MAC address and then (if needed)</span>
<span class="cm"> * reinitialize the device. We need to read it ahead of time because</span>
<span class="cm"> * in the future, we might not upload the firmware until userspace</span>
<span class="cm"> * &#39;ifconfig up&#39;s the device.</span>
<span class="cm"> *</span>
<span class="cm"> * We can then upload the firmware file. The file is composed of a BCF</span>
<span class="cm"> * header (basic data, keys and signatures) and a list of write</span>
<span class="cm"> * commands and payloads. Optionally more BCF headers might follow the</span>
<span class="cm"> * main payload. We first upload the header [i2400m_dnload_init()] and</span>
<span class="cm"> * then pass the commands and payloads verbatim to the i2400m_bm_cmd()</span>
<span class="cm"> * function [i2400m_dnload_bcf()]. Then we tell the device to jump to</span>
<span class="cm"> * the new firmware [i2400m_dnload_finalize()].</span>
<span class="cm"> *</span>
<span class="cm"> * Once firmware is uploaded, we are good to go :)</span>
<span class="cm"> *</span>
<span class="cm"> * When we don&#39;t know in which mode we are, we first try by sending a</span>
<span class="cm"> * warm reset request that will take us to boot-mode. If we time out</span>
<span class="cm"> * waiting for a reboot barker, that means maybe we are already in</span>
<span class="cm"> * boot mode, so we send a reboot barker.</span>
<span class="cm"> *</span>
<span class="cm"> * COMMAND EXECUTION</span>
<span class="cm"> *</span>
<span class="cm"> * This code (and process) is single threaded; for executing commands,</span>
<span class="cm"> * we post a URB to the notification endpoint, post the command, wait</span>
<span class="cm"> * for data on the notification buffer. We don&#39;t need to worry about</span>
<span class="cm"> * others as we know we are the only ones in there.</span>
<span class="cm"> *</span>
<span class="cm"> * BACKEND IMPLEMENTATION</span>
<span class="cm"> *</span>
<span class="cm"> * This code is bus-generic; the bus-specific driver provides back end</span>
<span class="cm"> * implementations to send a boot mode command to the device and to</span>
<span class="cm"> * read an acknolwedgement from it (or an asynchronous notification)</span>
<span class="cm"> * from it.</span>
<span class="cm"> *</span>
<span class="cm"> * FIRMWARE LOADING</span>
<span class="cm"> *</span>
<span class="cm"> * Note that in some cases, we can&#39;t just load a firmware file (for</span>
<span class="cm"> * example, when resuming). For that, we might cache the firmware</span>
<span class="cm"> * file. Thus, when doing the bootstrap, if there is a cache firmware</span>
<span class="cm"> * file, it is used; if not, loading from disk is attempted.</span>
<span class="cm"> *</span>
<span class="cm"> * ROADMAP</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_barker_db_init              Called by i2400m_driver_init()</span>
<span class="cm"> *   i2400m_barker_db_add</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_barker_db_exit              Called by i2400m_driver_exit()</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_dev_bootstrap               Called by __i2400m_dev_start()</span>
<span class="cm"> *   request_firmware</span>
<span class="cm"> *   i2400m_fw_bootstrap</span>
<span class="cm"> *     i2400m_fw_check</span>
<span class="cm"> *       i2400m_fw_hdr_check</span>
<span class="cm"> *     i2400m_fw_dnload</span>
<span class="cm"> *   release_firmware</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_fw_dnload</span>
<span class="cm"> *   i2400m_bootrom_init</span>
<span class="cm"> *     i2400m_bm_cmd</span>
<span class="cm"> *     i2400m_reset</span>
<span class="cm"> *   i2400m_dnload_init</span>
<span class="cm"> *     i2400m_dnload_init_signed</span>
<span class="cm"> *     i2400m_dnload_init_nonsigned</span>
<span class="cm"> *       i2400m_download_chunk</span>
<span class="cm"> *         i2400m_bm_cmd</span>
<span class="cm"> *   i2400m_dnload_bcf</span>
<span class="cm"> *     i2400m_bm_cmd</span>
<span class="cm"> *   i2400m_dnload_finalize</span>
<span class="cm"> *     i2400m_bm_cmd</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_bm_cmd</span>
<span class="cm"> *   i2400m-&gt;bus_bm_cmd_send()</span>
<span class="cm"> *   i2400m-&gt;bus_bm_wait_for_ack</span>
<span class="cm"> *   __i2400m_bm_ack_verify</span>
<span class="cm"> *     i2400m_is_boot_barker</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_bm_cmd_prepare              Used by bus-drivers to prep</span>
<span class="cm"> *                                    commands before sending</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_pm_notifier                 Called on Power Management events</span>
<span class="cm"> *   i2400m_fw_cache</span>
<span class="cm"> *   i2400m_fw_uncache</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &quot;i2400m.h&quot;</span>


<span class="cp">#define D_SUBMODULE fw</span>
<span class="cp">#include &quot;debug-levels.h&quot;</span>


<span class="k">static</span> <span class="k">const</span> <span class="n">__le32</span> <span class="n">i2400m_ACK_BARKER</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_ACK_BARKER</span><span class="p">),</span>
	<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_ACK_BARKER</span><span class="p">),</span>
	<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_ACK_BARKER</span><span class="p">),</span>
	<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_ACK_BARKER</span><span class="p">)</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * Prepare a boot-mode command for delivery</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: pointer to bootrom header to prepare</span>
<span class="cm"> *</span>
<span class="cm"> * Computes checksum if so needed. After calling this function, DO NOT</span>
<span class="cm"> * modify the command or header as the checksum won&#39;t work anymore.</span>
<span class="cm"> *</span>
<span class="cm"> * We do it from here because some times we cannot do it in the</span>
<span class="cm"> * original context the command was sent (it is a const), so when we</span>
<span class="cm"> * copy it to our staging buffer, we add the checksum there.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_bm_cmd_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_brh_get_use_checksum</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">checksum_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">checksum</span> <span class="o">+=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">*</span><span class="n">checksum_ptr</span><span class="o">++</span><span class="p">);</span>
		<span class="n">checksum</span> <span class="o">+=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">target_addr</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">block_checksum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">checksum</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_bm_cmd_prepare</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Database of known barkers.</span>
<span class="cm"> *</span>
<span class="cm"> * A barker is what the device sends indicating he is ready to be</span>
<span class="cm"> * bootloaded. Different versions of the device will send different</span>
<span class="cm"> * barkers. Depending on the barker, it might mean the device wants</span>
<span class="cm"> * some kind of firmware or the other.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">i2400m_barker_db</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">}</span> <span class="o">*</span><span class="n">i2400m_barker_db</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">i2400m_barker_db_used</span><span class="p">,</span> <span class="n">i2400m_barker_db_size</span><span class="p">;</span>


<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_zrealloc_2x</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">_count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">el_size</span><span class="p">,</span>
		       <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">old_count</span> <span class="o">=</span> <span class="o">*</span><span class="n">_count</span><span class="p">,</span>
		<span class="n">new_count</span> <span class="o">=</span> <span class="n">old_count</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">old_count</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">old_size</span> <span class="o">=</span> <span class="n">el_size</span> <span class="o">*</span> <span class="n">old_count</span><span class="p">,</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="n">el_size</span> <span class="o">*</span> <span class="n">new_count</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">nptr</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* zero the other half or the whole thing if old_count</span>
<span class="cm">		 * was zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">nptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">nptr</span> <span class="o">+</span> <span class="n">old_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">old_size</span><span class="p">);</span>
		<span class="o">*</span><span class="n">_count</span> <span class="o">=</span> <span class="n">new_count</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">nptr</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Add a barker to the database</span>
<span class="cm"> *</span>
<span class="cm"> * This cannot used outside of this module and only at at module_init</span>
<span class="cm"> * time. This is to avoid the need to do locking.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_barker_db_add</span><span class="p">(</span><span class="n">u32</span> <span class="n">barker_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">i2400m_barker_db</span> <span class="o">*</span><span class="n">barker</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_barker_db_used</span> <span class="o">&gt;=</span> <span class="n">i2400m_barker_db_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_zrealloc_2x</span><span class="p">(</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">i2400m_barker_db</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2400m_barker_db_size</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_barker_db</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">barker</span> <span class="o">=</span> <span class="n">i2400m_barker_db</span> <span class="o">+</span> <span class="n">i2400m_barker_db_used</span><span class="o">++</span><span class="p">;</span>
	<span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">barker_id</span><span class="p">);</span>
	<span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">barker_id</span><span class="p">);</span>
	<span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">barker_id</span><span class="p">);</span>
	<span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">barker_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">i2400m_barker_db_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m_barker_db</span><span class="p">);</span>
	<span class="n">i2400m_barker_db</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">i2400m_barker_db_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i2400m_barker_db_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Helper function to add all the known stable barkers to the barker</span>
<span class="cm"> * database.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_barker_db_known_barkers</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_barker_db_add</span><span class="p">(</span><span class="n">I2400M_NBOOT_BARKER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_add</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_barker_db_add</span><span class="p">(</span><span class="n">I2400M_SBOOT_BARKER</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_add</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_barker_db_add</span><span class="p">(</span><span class="n">I2400M_SBOOT_BARKER_6050</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_add</span><span class="p">;</span>
<span class="nl">error_add:</span>
       <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Initialize the barker database</span>
<span class="cm"> *</span>
<span class="cm"> * This can only be used from the module_init function for this</span>
<span class="cm"> * module; this is to avoid the need to do locking.</span>
<span class="cm"> *</span>
<span class="cm"> * @options: command line argument with extra barkers to</span>
<span class="cm"> *     recognize. This is a comma-separated list of 32-bit hex</span>
<span class="cm"> *     numbers. They are appended to the existing list. Setting 0</span>
<span class="cm"> *     cleans the existing list and starts a new one.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_barker_db_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">_options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">options</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">options_orig</span><span class="p">,</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>

	<span class="n">i2400m_barker_db</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">i2400m_barker_db_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i2400m_barker_db_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_barker_db_known_barkers</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_add</span><span class="p">;</span>
	<span class="cm">/* parse command line options from i2400m.barkers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_options</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">barker</span><span class="p">;</span>

		<span class="n">options_orig</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">_options</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">options_orig</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_parse</span><span class="p">;</span>
		<span class="n">options</span> <span class="o">=</span> <span class="n">options_orig</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">token</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">token</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>	<span class="cm">/* eat joint commas */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="s">&quot;%x&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">barker</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>
			    <span class="o">||</span> <span class="n">barker</span> <span class="o">&gt;</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: can&#39;t recognize &quot;</span>
				       <span class="s">&quot;i2400m.barkers value &#39;%s&#39; as &quot;</span>
				       <span class="s">&quot;a 32-bit number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span> <span class="n">token</span><span class="p">);</span>
				<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">error_parse</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">barker</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* clean list and start new */</span>
				<span class="n">i2400m_barker_db_exit</span><span class="p">();</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_barker_db_add</span><span class="p">(</span><span class="n">barker</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error_add</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">options_orig</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_parse:</span>
<span class="nl">error_add:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m_barker_db</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Recognize a boot barker</span>
<span class="cm"> *</span>
<span class="cm"> * @buf: buffer where the boot barker.</span>
<span class="cm"> * @buf_size: size of the buffer (has to be 16 bytes). It is passed</span>
<span class="cm"> *     here so the function can check it for the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that as a side effect, upon identifying the obtained boot</span>
<span class="cm"> * barker, this function will set i2400m-&gt;barker to point to the right</span>
<span class="cm"> * barker database entry. Subsequent calls to the function will result</span>
<span class="cm"> * in verifying that the same type of boot barker is returned when the</span>
<span class="cm"> * device [re]boots (as long as the same device instance is used).</span>
<span class="cm"> *</span>
<span class="cm"> * Return: 0 if @buf matches a known boot barker. -ENOENT if the</span>
<span class="cm"> *     buffer in @buf doesn&#39;t match any boot barker in the database or</span>
<span class="cm"> *     -EILSEQ if the buffer doesn&#39;t have the right size.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_is_boot_barker</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_barker_db</span> <span class="o">*</span><span class="n">barker</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_barker_db</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Short circuit if we have already discovered the barker</span>
<span class="cm">	 * associated with the device. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span>
	    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span> <span class="o">-</span> <span class="n">i2400m_barker_db</span><span class="p">)</span>
			<span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="p">);</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot barker cache-confirmed #%u/%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">index</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i2400m_barker_db_used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">barker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400m_barker_db</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">16</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span> <span class="o">=</span> <span class="n">barker</span><span class="p">;</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot barker set to #%u/%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">i</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">I2400M_NBOOT_BARKER</span><span class="p">))</span>
				<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">sboot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">sboot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span> <span class="o">!=</span> <span class="n">barker</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HW inconsistency: device &quot;</span>
				<span class="s">&quot;reports a different boot barker &quot;</span>
				<span class="s">&quot;than set (from %08x to %08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot barker confirmed #%u/%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">i</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_is_boot_barker</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Verify the ack data received</span>
<span class="cm"> *</span>
<span class="cm"> * Given a reply to a boot mode command, chew it and verify everything</span>
<span class="cm"> * is ok.</span>
<span class="cm"> *</span>
<span class="cm"> * @opcode: opcode which generated this ack. For error messages.</span>
<span class="cm"> * @ack: pointer to ack data we received</span>
<span class="cm"> * @ack_size: size of that data buffer</span>
<span class="cm"> * @flags: I2400M_BM_CMD_* flags we called the command with.</span>
<span class="cm"> *</span>
<span class="cm"> * Way too long function -- maybe it should be further split</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">ssize_t</span> <span class="nf">__i2400m_bm_ack_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">ack</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">ack_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p opcode %d ack %p size %zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ack_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ack</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: HW BUG? notification didn&#39;t &quot;</span>
			<span class="s">&quot;return enough data (%zu bytes vs %zu expected)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">opcode</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ack</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_ack_short</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_is_boot_barker</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: HW boot barker</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opcode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_reboot</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ack_size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_ACK_BARKER</span><span class="p">)</span>
		 <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">i2400m_ACK_BARKER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ack</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: HW reboot ack barker</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">opcode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_reboot_ack</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2400M_BM_CMD_RAW</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_raw</span><span class="p">;</span>
	<span class="n">ack</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ack</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
	<span class="n">ack</span><span class="o">-&gt;</span><span class="n">target_addr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ack</span><span class="o">-&gt;</span><span class="n">target_addr</span><span class="p">);</span>
	<span class="n">ack</span><span class="o">-&gt;</span><span class="n">block_checksum</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ack</span><span class="o">-&gt;</span><span class="n">block_checksum</span><span class="p">);</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: notification for opcode %u &quot;</span>
		 <span class="s">&quot;response %u csum %u rr %u da %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">opcode</span><span class="p">,</span> <span class="n">i2400m_brh_get_opcode</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span>
		 <span class="n">i2400m_brh_get_response</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span>
		 <span class="n">i2400m_brh_get_use_checksum</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span>
		 <span class="n">i2400m_brh_get_response_required</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span>
		 <span class="n">i2400m_brh_get_direct_access</span><span class="p">(</span><span class="n">ack</span><span class="p">));</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_brh_get_signature</span><span class="p">(</span><span class="n">ack</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xcbbc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: HW BUG? wrong signature &quot;</span>
			<span class="s">&quot;0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">i2400m_brh_get_signature</span><span class="p">(</span><span class="n">ack</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_ack_signature</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">opcode</span> <span class="o">!=</span> <span class="n">i2400m_brh_get_opcode</span><span class="p">(</span><span class="n">ack</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: HW BUG? &quot;</span>
			<span class="s">&quot;received response for opcode %u, expected %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">opcode</span><span class="p">,</span> <span class="n">i2400m_brh_get_opcode</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span> <span class="n">opcode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_ack_opcode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_brh_get_response</span><span class="p">(</span><span class="n">ack</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* failed? */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: error; hw response %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">opcode</span><span class="p">,</span> <span class="n">i2400m_brh_get_response</span><span class="p">(</span><span class="n">ack</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_ack_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ack_size</span> <span class="o">&lt;</span> <span class="n">ack</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ack</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: SW BUG &quot;</span>
			<span class="s">&quot;driver provided only %zu bytes for %zu bytes &quot;</span>
			<span class="s">&quot;of data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ack</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ack</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">error_ack_short_buffer</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">ack_size</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t you love this stack of empty targets? Well, I don&#39;t</span>
<span class="cm">	 * either, but it helps track exactly who comes in here and</span>
<span class="cm">	 * why :) */</span>
<span class="nl">error_ack_short_buffer:</span>
<span class="nl">error_ack_failed:</span>
<span class="nl">error_ack_opcode:</span>
<span class="nl">error_ack_signature:</span>
<span class="nl">out_raw:</span>
<span class="nl">error_reboot_ack:</span>
<span class="nl">error_reboot:</span>
<span class="nl">error_ack_short:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p opcode %d ack %p size %zu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_bm_cmd - Execute a boot mode command</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd: buffer containing the command data (pointing at the header).</span>
<span class="cm"> *     This data can be ANYWHERE (for USB, we will copy it to an</span>
<span class="cm"> *     specific buffer). Make sure everything is in proper little</span>
<span class="cm"> *     endian.</span>
<span class="cm"> *</span>
<span class="cm"> *     A raw buffer can be also sent, just cast it and set flags to</span>
<span class="cm"> *     I2400M_BM_CMD_RAW.</span>
<span class="cm"> *</span>
<span class="cm"> *     This function will generate a checksum for you if the</span>
<span class="cm"> *     checksum bit in the command is set (unless I2400M_BM_CMD_RAW</span>
<span class="cm"> *     is set).</span>
<span class="cm"> *</span>
<span class="cm"> *     You can use the i2400m-&gt;bm_cmd_buf to stage your commands and</span>
<span class="cm"> *     send them.</span>
<span class="cm"> *</span>
<span class="cm"> *     If NULL, no command is sent (we just wait for an ack).</span>
<span class="cm"> *</span>
<span class="cm"> * @cmd_size: size of the command. Will be auto padded to the</span>
<span class="cm"> *     bus-specific drivers padding requirements.</span>
<span class="cm"> *</span>
<span class="cm"> * @ack: buffer where to place the acknowledgement. If it is a regular</span>
<span class="cm"> *     command response, all fields will be returned with the right,</span>
<span class="cm"> *     native endianess.</span>
<span class="cm"> *</span>
<span class="cm"> *     You *cannot* use i2400m-&gt;bm_ack_buf for this buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * @ack_size: size of @ack, 16 aligned; you need to provide at least</span>
<span class="cm"> *     sizeof(*ack) bytes and then enough to contain the return data</span>
<span class="cm"> *     from the command</span>
<span class="cm"> *</span>
<span class="cm"> * @flags: see I2400M_BM_CMD_* above.</span>
<span class="cm"> *</span>
<span class="cm"> * @returns: bytes received by the notification; if &lt; 0, an errno code</span>
<span class="cm"> *     denoting an error or:</span>
<span class="cm"> *</span>
<span class="cm"> *     -ERESTARTSYS  The device has rebooted</span>
<span class="cm"> *</span>
<span class="cm"> * Executes a boot-mode command and waits for a response, doing basic</span>
<span class="cm"> * validation on it; if a zero length response is received, it retries</span>
<span class="cm"> * waiting for a response until a non-zero one is received (timing out</span>
<span class="cm"> * after %I2400M_BOOT_RETRIES retries).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">ssize_t</span> <span class="nf">i2400m_bm_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cmd_size</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">ack</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ack_size</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">,</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">i2400m_brh_get_opcode</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p cmd %p size %zu ack %p size %zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ack_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ack</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">boot_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* send the command */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_cmd_send</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_cmd_send</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2400M_BM_CMD_RAW</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;boot-mode cmd %d csum %u rr %u da %u: &quot;</span>
				 <span class="s">&quot;addr 0x%04x size %u block csum 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">opcode</span><span class="p">,</span> <span class="n">i2400m_brh_get_use_checksum</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
				 <span class="n">i2400m_brh_get_response_required</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
				 <span class="n">i2400m_brh_get_direct_access</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
				 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">target_addr</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">,</span>
				 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">block_checksum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_wait_for_ack</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;boot-mode cmd %d: error waiting for an ack: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">opcode</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">result</span><span class="p">);</span>	<span class="cm">/* bah, %zd doesn&#39;t work */</span>
		<span class="k">goto</span> <span class="n">error_wait_for_ack</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="cm">/* verify the ack and read more if necessary [result is the</span>
<span class="cm">	 * final amount of bytes we get in the ack]  */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__i2400m_bm_ack_verify</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_bad_ack</span><span class="p">;</span>
	<span class="cm">/* Don&#39;t you love this stack of empty targets? Well, I don&#39;t</span>
<span class="cm">	 * either, but it helps track exactly who comes in here and</span>
<span class="cm">	 * why :) */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">rx_bytes</span><span class="p">;</span>
<span class="nl">error_bad_ack:</span>
<span class="nl">error_wait_for_ack:</span>
<span class="nl">error_cmd_send:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p cmd %p size %zu ack %p size %zu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_download_chunk - write a single chunk of data to the device&#39;s memory</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> * @buf: the buffer to write</span>
<span class="cm"> * @buf_len: length of the buffer to write</span>
<span class="cm"> * @addr: address in the device memory space</span>
<span class="cm"> * @direct: bootrom write mode</span>
<span class="cm"> * @do_csum: should a checksum validation be performed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">i2400m_download_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">__chunk_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">direct</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">do_csum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">chunk_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">__chunk_len</span><span class="p">,</span> <span class="n">I2400M_PL_ALIGN</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">cmd_payload</span><span class="p">[</span><span class="n">chunk_len</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">__packed</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">ack</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p chunk %p __chunk_len %zu addr 0x%08lx &quot;</span>
		  <span class="s">&quot;direct %u do_csum %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">__chunk_len</span><span class="p">,</span>
		  <span class="n">addr</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">do_csum</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">cmd_payload</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">__chunk_len</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">cmd_payload</span> <span class="o">+</span> <span class="n">__chunk_len</span><span class="p">,</span> <span class="mh">0xad</span><span class="p">,</span> <span class="n">chunk_len</span> <span class="o">-</span> <span class="n">__chunk_len</span><span class="p">);</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">i2400m_brh_command</span><span class="p">(</span><span class="n">I2400M_BRH_WRITE</span><span class="p">,</span>
					      <span class="n">__chunk_len</span> <span class="o">&amp;</span> <span class="mh">0x3</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">do_csum</span><span class="p">,</span>
					      <span class="n">__chunk_len</span> <span class="o">&amp;</span> <span class="mh">0xf</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">direct</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">target_addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">__chunk_len</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="o">+</span> <span class="n">chunk_len</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p chunk %p __chunk_len %zu addr 0x%08lx &quot;</span>
		<span class="s">&quot;direct %u do_csum %u) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">__chunk_len</span><span class="p">,</span>
		<span class="n">addr</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">do_csum</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Download a BCF file&#39;s sections to the device</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> * @bcf: pointer to firmware data (first header followed by the</span>
<span class="cm"> *     payloads). Assumed verified and consistent.</span>
<span class="cm"> * @bcf_len: length (in bytes) of the @bcf buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: &lt; 0 errno code on error or the offset to the jump instruction.</span>
<span class="cm"> *</span>
<span class="cm"> * Given a BCF file, downloads each section (a command and a payload)</span>
<span class="cm"> * to the device&#39;s address space. Actually, it just executes each</span>
<span class="cm"> * command i the BCF file.</span>
<span class="cm"> *</span>
<span class="cm"> * The section size has to be aligned to 4 bytes AND the padding has</span>
<span class="cm"> * to be taken from the firmware file, as the signature takes it into</span>
<span class="cm"> * account.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">ssize_t</span> <span class="nf">i2400m_dnload_bcf</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bcf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">offset</span><span class="p">,</span>		<span class="cm">/* iterator offset */</span>
		<span class="n">data_size</span><span class="p">,</span>	<span class="cm">/* Size of the data payload */</span>
		<span class="n">section_size</span><span class="p">,</span>	<span class="cm">/* Size of the whole section (cmd + payload) */</span>
		<span class="n">section</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">ack</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p bcf %p bcf_len %zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">bcf_len</span><span class="p">);</span>
	<span class="cm">/* Iterate over the command blocks in the BCF file that start</span>
<span class="cm">	 * after the header */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf</span><span class="o">-&gt;</span><span class="n">header_len</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* start sending the file */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">bcf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">data_size</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
		<span class="n">section_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bh</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;downloading section #%zu (@%zu %zu B) to 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">section</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bh</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">,</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">target_addr</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * We look for JUMP cmd from the bootmode header,</span>
<span class="cm">		 * either I2400M_BRH_SIGNED_JUMP for secure boot</span>
<span class="cm">		 * or I2400M_BRH_JUMP for unsecure boot, the last chunk</span>
<span class="cm">		 * should be the bootmode header with JUMP cmd.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_brh_get_opcode</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">==</span> <span class="n">I2400M_BRH_SIGNED_JUMP</span> <span class="o">||</span>
			<span class="n">i2400m_brh_get_opcode</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">==</span> <span class="n">I2400M_BRH_JUMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>  <span class="s">&quot;jump found @%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">section_size</span> <span class="o">&gt;</span> <span class="n">bcf_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fw %s: bad section #%zu, &quot;</span>
				<span class="s">&quot;end (@%zu) beyond EOF (@%zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span>
				<span class="n">offset</span> <span class="o">+</span> <span class="n">section_size</span><span class="p">,</span>  <span class="n">bcf_len</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_section_beyond_eof</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__i2400m_msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">section_size</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span> <span class="n">I2400M_BM_CMD_RAW</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fw %s: section #%zu (@%zu %zu B) &quot;</span>
				<span class="s">&quot;failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span>
				<span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bh</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_send</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">section_size</span><span class="p">;</span>
		<span class="n">section</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
<span class="nl">error_section_beyond_eof:</span>
<span class="nl">error_send:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p bcf %p bcf_len %zu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">bcf_len</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Indicate if the device emitted a reboot barker that indicates</span>
<span class="cm"> * &quot;signed boot&quot;</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_boot_is_signed</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">likely</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">sboot</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Do the final steps of uploading firmware</span>
<span class="cm"> *</span>
<span class="cm"> * @bcf_hdr: BCF header we are actually using</span>
<span class="cm"> * @bcf: pointer to the firmware image (which matches the first header</span>
<span class="cm"> *     that is followed by the actual payloads).</span>
<span class="cm"> * @offset: [byte] offset into @bcf for the command we need to send.</span>
<span class="cm"> *</span>
<span class="cm"> * Depending on the boot mode (signed vs non-signed), different</span>
<span class="cm"> * actions need to be taken.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_dnload_finalize</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf_hdr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">ack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">cmd_pl</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">__packed</span> <span class="o">*</span><span class="n">cmd_buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">signature_block_offset</span><span class="p">,</span> <span class="n">signature_block_size</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;offset %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">bcf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_boot_is_signed</span><span class="p">(</span><span class="n">i2400m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">jump_ack</span><span class="p">;</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unsecure boot, jumping to 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">target_addr</span><span class="p">));</span>
		<span class="n">cmd_buf</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">));</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
		<span class="cm">/* now cmd points to the actual bootrom_header in cmd_buf */</span>
		<span class="n">i2400m_brh_set_opcode</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">I2400M_BRH_JUMP</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">),</span>
				    <span class="o">&amp;</span><span class="n">jump_ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jump_ack</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;secure boot, jumping to 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">target_addr</span><span class="p">));</span>
		<span class="n">cmd_buf</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">));</span>
		<span class="n">signature_block_offset</span> <span class="o">=</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bcf_hdr</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">key_size</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">exponent_size</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="n">signature_block_size</span> <span class="o">=</span>
			<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">modulus_size</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd_pl</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">bcf_hdr</span> <span class="o">+</span> <span class="n">signature_block_offset</span><span class="p">,</span>
		       <span class="n">signature_block_size</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="o">+</span> <span class="n">signature_block_size</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span> <span class="n">I2400M_BM_CMD_RAW</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;returning %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_bootrom_init - Reboots a powered device into boot mode</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> * @flags:</span>
<span class="cm"> *      I2400M_BRI_SOFT: a reboot barker has been seen</span>
<span class="cm"> *          already, so don&#39;t wait for it.</span>
<span class="cm"> *</span>
<span class="cm"> *      I2400M_BRI_NO_REBOOT: Don&#39;t send a reboot command, but wait</span>
<span class="cm"> *          for a reboot barker notification. This is a one shot; if</span>
<span class="cm"> *          the state machine needs to send a reboot command it will.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *</span>
<span class="cm"> *     &lt; 0 errno code on error, 0 if ok.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *</span>
<span class="cm"> * Tries hard enough to put the device in boot-mode. There are two</span>
<span class="cm"> * main phases to this:</span>
<span class="cm"> *</span>
<span class="cm"> * a. (1) send a reboot command and (2) get a reboot barker</span>
<span class="cm"> *</span>
<span class="cm"> * b. (1) echo/ack the reboot sending the reboot barker back and (2)</span>
<span class="cm"> *        getting an ack barker in return</span>
<span class="cm"> *</span>
<span class="cm"> * We want to skip (a) in some cases [soft]. The state machine is</span>
<span class="cm"> * horrible, but it is basically: on each phase, send what has to be</span>
<span class="cm"> * sent (if any), wait for the answer and act on the answer. We might</span>
<span class="cm"> * have to backtrack and retry, so we keep a max tries counter for</span>
<span class="cm"> * that.</span>
<span class="cm"> *</span>
<span class="cm"> * It sucks because we don&#39;t know ahead of time which is going to be</span>
<span class="cm"> * the reboot barker (the device might send different ones depending</span>
<span class="cm"> * on its EEPROM config) and once the device reboots and waits for the</span>
<span class="cm"> * echo/ack reboot barker being sent back, it doesn&#39;t understand</span>
<span class="cm"> * anything else. So we can be left at the point where we don&#39;t know</span>
<span class="cm"> * what to send to it -- cold reset and bus reset seem to have little</span>
<span class="cm"> * effect. So the function iterates (in this case) through all the</span>
<span class="cm"> * known barkers and tries them all until an ACK is</span>
<span class="cm"> * received. Otherwise, it gives up.</span>
<span class="cm"> *</span>
<span class="cm"> * If we get a timeout after sending a warm reset, we do it again.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_bootrom_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">ack</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_retries</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ack_timeout_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_barker_db</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">data</span><span class="p">));</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_ACK_BARKER</span><span class="p">));</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p flags 0x%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2400M_BRI_SOFT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">do_reboot_ack</span><span class="p">;</span>
<span class="nl">do_reboot:</span>
	<span class="n">ack_timeout_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_timeout</span><span class="p">;</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reboot: reboot command [%d # left]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2400M_BRI_NO_REBOOT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">i2400m_reset</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_RT_WARM</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span>
			       <span class="n">I2400M_BM_CMD_RAW</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I2400M_BRI_NO_REBOOT</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ERESTARTSYS</span>:
		<span class="cm">/*</span>
<span class="cm">		 * at this point, i2400m_bm_cmd(), through</span>
<span class="cm">		 * __i2400m_bm_ack_process(), has updated</span>
<span class="cm">		 * i2400m-&gt;barker and we are good to go.</span>
<span class="cm">		 */</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reboot: got reboot barker</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EISCONN</span>:	<span class="cm">/* we don&#39;t know how it got here...but we follow it */</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reboot: got ack barker - whatever</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">do_reboot</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Device has timed out, we might be in boot mode</span>
<span class="cm">		 * already and expecting an ack; if we don&#39;t know what</span>
<span class="cm">		 * the barker is, we just send them all. Cold reset</span>
<span class="cm">		 * and bus reset don&#39;t work. Beats me.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device boot: reboot barker timed out, &quot;</span>
				<span class="s">&quot;trying (set) %08x echo/ack</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="k">goto</span> <span class="n">do_reboot_ack</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i2400m_barker_db_used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">i2400m_barker_db</span> <span class="o">*</span><span class="n">barker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400m_barker_db</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">),</span>
					       <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span>
					       <span class="n">I2400M_BM_CMD_RAW</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device boot: got ack barker &quot;</span>
					 <span class="s">&quot;after sending echo/ack barker &quot;</span>
					 <span class="s">&quot;#%d/%08x; rebooting j.i.c.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">i</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
				<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I2400M_BRI_NO_REBOOT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">do_reboot</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device boot: tried all the echo/acks, could &quot;</span>
			<span class="s">&quot;not get device to respond; giving up&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPROTO</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:	<span class="cm">/* dev is gone */</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EINTR</span>:		<span class="cm">/* user cancelled */</span>
		<span class="k">goto</span> <span class="n">error_dev_gone</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reboot: error %d while waiting &quot;</span>
			<span class="s">&quot;for reboot barker - rebooting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">d_dump</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">do_reboot</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* At this point we ack back with 4 REBOOT barkers and expect</span>
<span class="cm">	 * 4 ACK barkers. This is ugly, as we send a raw command --</span>
<span class="cm">	 * hence the cast. _bm_cmd() will catch the reboot ack</span>
<span class="cm">	 * notification and report it as -EISCONN. */</span>
<span class="nl">do_reboot_ack:</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reboot ack: sending ack [%d # left]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">),</span>
			       <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span> <span class="n">I2400M_BM_CMD_RAW</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ERESTARTSYS</span>:
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reboot ack: got reboot barker - retrying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_timeout</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_reboot_ack</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EISCONN</span>:
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reboot ack: got ack barker - good</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">ETIMEDOUT</span>:	<span class="cm">/* no response, maybe it is the other type? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ack_timeout_cnt</span><span class="o">--</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reboot ack timedout: retrying</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">do_reboot_ack</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reboot ack timedout too long: &quot;</span>
				<span class="s">&quot;trying reboot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">do_reboot</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="o">-</span><span class="n">EPROTO</span>:
	<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:	<span class="cm">/* dev is gone */</span>
		<span class="k">goto</span> <span class="n">error_dev_gone</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reboot ack: error %d while waiting for &quot;</span>
			<span class="s">&quot;reboot ack barker - rebooting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">do_reboot</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device reboot ack: got ack barker - boot done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">exit_timeout:</span>
<span class="nl">error_dev_gone:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p flags 0x%08x) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="nl">error_timeout:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Timed out waiting for reboot ack</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">exit_timeout</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Read the MAC addr</span>
<span class="cm"> *</span>
<span class="cm"> * The position this function reads is fixed in device memory and</span>
<span class="cm"> * always available, even without firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * Note we specify we want to read only six bytes, but provide space</span>
<span class="cm"> * for 16, as we always get it rounded up.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_read_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">ack</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">ack_pl</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">__packed</span> <span class="n">ack_buf</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">i2400m_brh_command</span><span class="p">(</span><span class="n">I2400M_BRH_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">target_addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x00203fe8</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">),</span>
			       <span class="o">&amp;</span><span class="n">ack_buf</span><span class="p">.</span><span class="n">ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack_buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BM: read mac addr failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_read_mac</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mac addr is %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ack_buf</span><span class="p">.</span><span class="n">ack_pl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_mac_addr_impaired</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ack_buf</span><span class="p">.</span><span class="n">ack_pl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">ack_buf</span><span class="p">.</span><span class="n">ack_pl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x16</span><span class="p">;</span>
		<span class="n">ack_buf</span><span class="p">.</span><span class="n">ack_pl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xd3</span><span class="p">;</span>
		<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ack_buf</span><span class="p">.</span><span class="n">ack_pl</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BM is MAC addr impaired, faking MAC addr to &quot;</span>
			<span class="s">&quot;mac addr is %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ack_buf</span><span class="p">.</span><span class="n">ack_pl</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">=</span> <span class="n">ETH_ALEN</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">ack_buf</span><span class="p">.</span><span class="n">ack_pl</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ack_buf</span><span class="p">.</span><span class="n">ack_pl</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
<span class="nl">error_read_mac:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Initialize a non signed boot</span>
<span class="cm"> *</span>
<span class="cm"> * This implies sending some magic values to the device&#39;s memory. Note</span>
<span class="cm"> * we convert the values to little endian in the same array</span>
<span class="cm"> * declaration.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_dnload_init_nonsigned</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_pokes_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_pokes_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_download_chunk</span><span class="p">(</span>
				<span class="n">i2400m</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_pokes_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_pokes_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">),</span>
				<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_pokes_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">address</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Initialize the signed boot process</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * @bcf_hdr: pointer to the firmware header; assumes it is fully in</span>
<span class="cm"> *     memory (it has gone through basic validation).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if ok, &lt; 0 errno code on error, -ERESTARTSYS if the hw</span>
<span class="cm"> *     rebooted.</span>
<span class="cm"> *</span>
<span class="cm"> * This writes the firmware BCF header to the device using the</span>
<span class="cm"> * HASH_PAYLOAD_ONLY command.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_dnload_init_signed</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="n">cmd_pl</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__packed</span> <span class="o">*</span><span class="n">cmd_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="n">ack</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p bcf_hdr %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf_hdr</span><span class="p">);</span>
	<span class="n">cmd_buf</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bm_cmd_buf</span><span class="p">;</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span>
		<span class="n">i2400m_brh_command</span><span class="p">(</span><span class="n">I2400M_BRH_HASH_PAYLOAD_ONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">target_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd_pl</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd_pl</span><span class="p">,</span> <span class="n">bcf_hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bcf_hdr</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_bm_cmd</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_buf</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cmd_buf</span><span class="p">),</span>
			    <span class="o">&amp;</span><span class="n">ack</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p bcf_hdr %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf_hdr</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Initialize the firmware download at the device size</span>
<span class="cm"> *</span>
<span class="cm"> * Multiplex to the one that matters based on the device&#39;s mode</span>
<span class="cm"> * (signed or non-signed).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_dnload_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_boot_is_signed</span><span class="p">(</span><span class="n">i2400m</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;signed boot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_dnload_init_signed</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf_hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s: signed boot download &quot;</span>
				<span class="s">&quot;initialization failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* non-signed boot process without pokes */</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;non-signed boot</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_dnload_init_nonsigned</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s: non-signed download &quot;</span>
				<span class="s">&quot;initialization failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Run consistency tests on the firmware file and load up headers</span>
<span class="cm"> *</span>
<span class="cm"> * Check for the firmware being made for the i2400m device,</span>
<span class="cm"> * etc...These checks are mostly informative, as the device will make</span>
<span class="cm"> * them too; but the driver&#39;s response is more informative on what</span>
<span class="cm"> * went wrong.</span>
<span class="cm"> *</span>
<span class="cm"> * This will also look at all the headers present on the firmware</span>
<span class="cm"> * file, and update i2400m-&gt;fw_bcf_hdr to point to them.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_fw_hdr_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf_hdr</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="n">module_type</span><span class="p">,</span> <span class="n">header_len</span><span class="p">,</span> <span class="n">major_version</span><span class="p">,</span> <span class="n">minor_version</span><span class="p">,</span>
		<span class="n">module_id</span><span class="p">,</span> <span class="n">module_vendor</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">module_type</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">module_type</span><span class="p">);</span>
	<span class="n">header_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">header_len</span><span class="p">);</span>
	<span class="n">major_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">header_version</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span>
		<span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">minor_version</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">header_version</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0000ffff</span><span class="p">;</span>
	<span class="n">module_id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">module_id</span><span class="p">);</span>
	<span class="n">module_vendor</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">module_vendor</span><span class="p">);</span>
	<span class="n">date</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">date</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s #%zd@%08zx: BCF header &quot;</span>
		 <span class="s">&quot;type:vendor:id 0x%x:%x:%x v%u.%u (%u/%u B) built %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
		 <span class="n">module_type</span><span class="p">,</span> <span class="n">module_vendor</span><span class="p">,</span> <span class="n">module_id</span><span class="p">,</span>
		 <span class="n">major_version</span><span class="p">,</span> <span class="n">minor_version</span><span class="p">,</span> <span class="n">header_len</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">date</span><span class="p">);</span>

	<span class="cm">/* Hard errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">major_version</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s #%zd@%08zx: major header version &quot;</span>
			<span class="s">&quot;v%u.%u not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">major_version</span><span class="p">,</span> <span class="n">minor_version</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">module_type</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* built for the right hardware? */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s #%zd@%08zx: unexpected module &quot;</span>
			<span class="s">&quot;type 0x%x; aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">module_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">module_vendor</span> <span class="o">!=</span> <span class="mh">0x8086</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s #%zd@%08zx: unexpected module &quot;</span>
			<span class="s">&quot;vendor 0x%x; aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">module_vendor</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">date</span> <span class="o">&lt;</span> <span class="mh">0x20080300</span><span class="p">)</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s #%zd@%08zx: build date %08x &quot;</span>
			 <span class="s">&quot;too old; unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">date</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Run consistency tests on the firmware file and load up headers</span>
<span class="cm"> *</span>
<span class="cm"> * Check for the firmware being made for the i2400m device,</span>
<span class="cm"> * etc...These checks are mostly informative, as the device will make</span>
<span class="cm"> * them too; but the driver&#39;s response is more informative on what</span>
<span class="cm"> * went wrong.</span>
<span class="cm"> *</span>
<span class="cm"> * This will also look at all the headers present on the firmware</span>
<span class="cm"> * file, and update i2400m-&gt;fw_hdrs to point to them.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_fw_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bcf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bcf_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">headers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf_hdr</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">itr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">slots</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">used_slots</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">itr</span> <span class="o">=</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">top</span> <span class="o">=</span> <span class="n">itr</span> <span class="o">+</span> <span class="n">bcf_size</span><span class="p">;</span>
	     <span class="n">itr</span> <span class="o">&lt;</span> <span class="n">top</span><span class="p">;</span>
	     <span class="n">headers</span><span class="o">++</span><span class="p">,</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">leftover</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">header_len</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">leftover</span> <span class="o">=</span> <span class="n">top</span> <span class="o">-</span> <span class="n">itr</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">itr</span> <span class="o">-</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">bcf</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leftover</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bcf_hdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s: %zu B left at @%zx, &quot;</span>
				<span class="s">&quot;not enough for BCF header</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">leftover</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bcf_hdr</span> <span class="o">=</span> <span class="n">itr</span><span class="p">;</span>
		<span class="cm">/* Only the first header is supposed to be followed by</span>
<span class="cm">		 * payload */</span>
		<span class="n">header_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">header_len</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">headers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">itr</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">itr</span> <span class="o">+</span> <span class="n">header_len</span><span class="p">;</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_fw_hdr_check</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf_hdr</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">used_slots</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">slots</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* +1 -&gt; we need to account for the one we&#39;ll</span>
<span class="cm">			 * occupy and at least an extra one for</span>
<span class="cm">			 * always being NULL */</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_zrealloc_2x</span><span class="p">(</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_hdrs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slots</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_hdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error_zrealloc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_hdrs</span><span class="p">[</span><span class="n">used_slots</span><span class="p">]</span> <span class="o">=</span> <span class="n">bcf_hdr</span><span class="p">;</span>
		<span class="n">used_slots</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">headers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s: no usable headers found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_zrealloc:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Match a barker to a BCF header module ID</span>
<span class="cm"> *</span>
<span class="cm"> * The device sends a barker which tells the firmware loader which</span>
<span class="cm"> * header in the BCF file has to be used. This does the matching.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_bcf_hdr_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">barker</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">module_id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">module_id</span><span class="p">)</span>
		<span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="p">;</span>	<span class="cm">/* high bit used for something else */</span>

	<span class="cm">/* special case for 5x50 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">barker</span> <span class="o">==</span> <span class="n">I2400M_SBOOT_BARKER</span> <span class="o">&amp;&amp;</span> <span class="n">module_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">module_id</span> <span class="o">==</span> <span class="n">barker</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="nf">i2400m_bcf_hdr_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">**</span><span class="n">bcf_itr</span><span class="p">,</span> <span class="o">*</span><span class="n">bcf_hdr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">barker</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">barker</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;finding BCF header for barker %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">barker</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">barker</span> <span class="o">==</span> <span class="n">I2400M_NBOOT_BARKER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcf_hdr</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_hdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;using BCF header #%u/%08x for non-signed &quot;</span>
			 <span class="s">&quot;barker</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">module_id</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">bcf_hdr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bcf_itr</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_hdrs</span><span class="p">;</span> <span class="o">*</span><span class="n">bcf_itr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">bcf_itr</span><span class="o">++</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bcf_hdr</span> <span class="o">=</span> <span class="o">*</span><span class="n">bcf_itr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_bcf_hdr_match</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf_hdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hit on BCF hdr #%u/%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">i</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">module_id</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">bcf_hdr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;miss on BCF hdr #%u/%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">i</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">module_id</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot find a matching BCF header for barker %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">barker</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Download the firmware to the device</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> * @bcf: pointer to loaded (and minimally verified for consistency)</span>
<span class="cm"> *    firmware</span>
<span class="cm"> * @bcf_size: size of the @bcf buffer (header plus payloads)</span>
<span class="cm"> *</span>
<span class="cm"> * The process for doing this is described in this file&#39;s header.</span>
<span class="cm"> *</span>
<span class="cm"> * Note we only reinitialize boot-mode if the flags say so. Some hw</span>
<span class="cm"> * iterations need it, some don&#39;t. In any case, if we loop, we always</span>
<span class="cm"> * need to reinitialize the boot room, hence the flags modification.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_fw_dnload</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">fw_size</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_retries</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf_hdr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bcf_size</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p bcf %p fw size %zu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">fw_size</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">boot_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* Make sure other readers see it */</span>
<span class="nl">hw_reboot:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device rebooted too many times, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_too_many_reboots</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">I2400M_BRI_MAC_REINIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_bootrom_init</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;bootrom init failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_bootrom_init</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">I2400M_BRI_MAC_REINIT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the download, push the bytes to the device and</span>
<span class="cm">	 * then jump to the new firmware. Note @ret is passed with the</span>
<span class="cm">	 * offset of the jump instruction to _dnload_finalize()</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note we need to use the BCF header in the firmware image</span>
<span class="cm">	 * that matches the barker that the device sent when it</span>
<span class="cm">	 * rebooted, so it has to be passed along.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">bcf_hdr</span> <span class="o">=</span> <span class="n">i2400m_bcf_hdr_find</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcf_hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_bcf_hdr_find</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_dnload_init</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_dev_rebooted</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_dnload_init</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * bcf_size refers to one header size plus the fw sections size</span>
<span class="cm">	 * indicated by the header,ie. if there are other extended headers</span>
<span class="cm">	 * at the tail, they are not counted</span>
<span class="cm">	 */</span>
	<span class="n">bcf_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bcf_hdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_dnload_bcf</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">bcf_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_dev_rebooted</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fw %s: download failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_dnload_bcf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_dnload_finalize</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf_hdr</span><span class="p">,</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_dev_rebooted</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fw %s: &quot;</span>
			<span class="s">&quot;download finalization failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_dnload_finalize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fw %s successfully uploaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">boot_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span>		<span class="cm">/* Make sure i2400m_msg_to_dev() sees boot_mode */</span>
<span class="nl">error_dnload_finalize:</span>
<span class="nl">error_dnload_bcf:</span>
<span class="nl">error_dnload_init:</span>
<span class="nl">error_bcf_hdr_find:</span>
<span class="nl">error_bootrom_init:</span>
<span class="nl">error_too_many_reboots:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p bcf %p size %zu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">fw_size</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">error_dev_rebooted:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device rebooted, %d tries left</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="cm">/* we got the notification already, no need to wait for it again */</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">I2400M_BRI_SOFT</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">hw_reboot</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_fw_bootstrap</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf</span><span class="p">;</span>	<span class="cm">/* Firmware data */</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">bcf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_fw_check</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_fw_dnload</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">bcf</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: cannot use: %d, skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_hdrs</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_hdrs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Refcounted container for firmware data */</span>
<span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_fw_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="o">*</span><span class="n">i2400m_fw</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400m_fw</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">i2400m_fw</span><span class="o">-&gt;</span><span class="n">fw</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m_fw</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span>
<span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="o">*</span><span class="nf">i2400m_fw_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="o">*</span><span class="n">i2400m_fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_fw</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">i2400m_fw</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m_fw</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i2400m_fw</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_fw_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="o">*</span><span class="n">i2400m_fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m_fw</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">i2400m_fw_destroy</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_dev_bootstrap - Bring the device to a known state and upload firmware</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: &gt;= 0 if ok, &lt; 0 errno code on error.</span>
<span class="cm"> *</span>
<span class="cm"> * This sets up the firmware upload environment, loads the firmware</span>
<span class="cm"> * file from disk, verifies and then calls the firmware upload process</span>
<span class="cm"> * per se.</span>
<span class="cm"> *</span>
<span class="cm"> * Can be called either from probe, or after a warm reset.  Can not be</span>
<span class="cm"> * called from within an interrupt.  All the flow in this code is</span>
<span class="cm"> * single-threade; all I/Os are synchronous.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_dev_bootstrap</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">itr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="o">*</span><span class="n">i2400m_fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">*</span><span class="n">bcf</span><span class="p">;</span>	<span class="cm">/* Firmware data */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fw_name</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>
	<span class="n">i2400m_fw</span> <span class="o">=</span> <span class="n">i2400m_fw_get</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_cached</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_fw</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;can&#39;t load firmware now!&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i2400m_fw</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s: loading from cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_fw_bootstrap</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">i2400m_fw</span><span class="o">-&gt;</span><span class="n">fw</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">i2400m_fw_put</span><span class="p">(</span><span class="n">i2400m_fw</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Load firmware files to memory. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bcf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span> <span class="p">;</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fw_name</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_fw_names</span><span class="p">[</span><span class="n">itr</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fw_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not find a usable firmware image</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;trying firmware %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fw_name</span><span class="p">,</span> <span class="n">itr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">fw_name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fw %s: cannot load file: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fw_name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span> <span class="o">=</span> <span class="n">fw_name</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">i2400m_fw_bootstrap</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* firmware loaded successfully */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_dev_bootstrap</span><span class="p">);</span>


<span class="kt">void</span> <span class="nf">i2400m_fw_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="o">*</span><span class="n">i2400m_fw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="cm">/* if there is anything there, free it -- now, this&#39;d be weird */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>
	<span class="n">i2400m_fw</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_cached</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_fw</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">i2400m_fw</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2400m_fw_put</span><span class="p">(</span><span class="n">i2400m_fw</span><span class="p">);</span>
		<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s:%u: still cached fw still present?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">__func__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware n/a: can&#39;t cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">i2400m_fw</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i2400m_fw</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">i2400m_fw</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_fw</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m_fw</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m_fw</span><span class="o">-&gt;</span><span class="n">fw</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s: failed to cache: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m_fw</span><span class="p">);</span>
		<span class="n">i2400m_fw</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;firmware %s: cached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_cached</span> <span class="o">=</span> <span class="n">i2400m_fw</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">i2400m_fw_uncache</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="o">*</span><span class="n">i2400m_fw</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>
	<span class="n">i2400m_fw</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_cached</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_cached</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">rx_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m_fw</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">i2400m_fw</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">~</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">i2400m_fw_put</span><span class="p">(</span><span class="n">i2400m_fw</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
