<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wimax › i2400m › tx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>tx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Intel Wireless WiMAX Connection 2400m</span>
<span class="cm"> * Generic (non-bus specific) TX handling</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *     the documentation and/or other materials provided with the</span>
<span class="cm"> *     distribution.</span>
<span class="cm"> *   * Neither the name of Intel Corporation nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Intel Corporation &lt;linux-wimax@intel.com&gt;</span>
<span class="cm"> * Yanir Lubetkin &lt;yanirx.lubetkin@intel.com&gt;</span>
<span class="cm"> *  - Initial implementation</span>
<span class="cm"> *</span>
<span class="cm"> * Intel Corporation &lt;linux-wimax@intel.com&gt;</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *  - Rewritten to use a single FIFO to lower the memory allocation</span>
<span class="cm"> *    pressure and optimize cache hits when copying to the queue, as</span>
<span class="cm"> *    well as splitting out bus-specific code.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Implements data transmission to the device; this is done through a</span>
<span class="cm"> * software FIFO, as data/control frames can be coalesced (while the</span>
<span class="cm"> * device is reading the previous tx transaction, others accumulate).</span>
<span class="cm"> *</span>
<span class="cm"> * A FIFO is used because at the end it is resource-cheaper that trying</span>
<span class="cm"> * to implement scatter/gather over USB. As well, most traffic is going</span>
<span class="cm"> * to be download (vs upload).</span>
<span class="cm"> *</span>
<span class="cm"> * The format for sending/receiving data to/from the i2400m is</span>
<span class="cm"> * described in detail in rx.c:PROTOCOL FORMAT. In here we implement</span>
<span class="cm"> * the transmission of that. This is split between a bus-independent</span>
<span class="cm"> * part that just prepares everything and a bus-specific part that</span>
<span class="cm"> * does the actual transmission over the bus to the device (in the</span>
<span class="cm"> * bus-specific driver).</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The general format of a device-host transaction is MSG-HDR, PLD1,</span>
<span class="cm"> * PLD2...PLDN, PL1, PL2,...PLN, PADDING.</span>
<span class="cm"> *</span>
<span class="cm"> * Because we need the send payload descriptors and then payloads and</span>
<span class="cm"> * because it is kind of expensive to do scatterlists in USB (one URB</span>
<span class="cm"> * per node), it becomes cheaper to append all the data to a FIFO</span>
<span class="cm"> * (copying to a FIFO potentially in cache is cheaper).</span>
<span class="cm"> *</span>
<span class="cm"> * Then the bus-specific code takes the parts of that FIFO that are</span>
<span class="cm"> * written and passes them to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * So the concepts to keep in mind there are:</span>
<span class="cm"> *</span>
<span class="cm"> * We use a FIFO to queue the data in a linear buffer. We first append</span>
<span class="cm"> * a MSG-HDR, space for I2400M_TX_PLD_MAX payload descriptors and then</span>
<span class="cm"> * go appending payloads until we run out of space or of payload</span>
<span class="cm"> * descriptors. Then we append padding to make the whole transaction a</span>
<span class="cm"> * multiple of i2400m-&gt;bus_tx_block_size (as defined by the bus layer).</span>
<span class="cm"> *</span>
<span class="cm"> * - A TX message: a combination of a message header, payload</span>
<span class="cm"> *   descriptors and payloads.</span>
<span class="cm"> *</span>
<span class="cm"> *     Open: it is marked as active (i2400m-&gt;tx_msg is valid) and we</span>
<span class="cm"> *       can keep adding payloads to it.</span>
<span class="cm"> *</span>
<span class="cm"> *     Closed: we are not appending more payloads to this TX message</span>
<span class="cm"> *       (exahusted space in the queue, too many payloads or</span>
<span class="cm"> *       whichever).  We have appended padding so the whole message</span>
<span class="cm"> *       length is aligned to i2400m-&gt;bus_tx_block_size (as set by the</span>
<span class="cm"> *       bus/transport layer).</span>
<span class="cm"> *</span>
<span class="cm"> * - Most of the time we keep a TX message open to which we append</span>
<span class="cm"> *   payloads.</span>
<span class="cm"> *</span>
<span class="cm"> * - If we are going to append and there is no more space (we are at</span>
<span class="cm"> *   the end of the FIFO), we close the message, mark the rest of the</span>
<span class="cm"> *   FIFO space unusable (skip_tail), create a new message at the</span>
<span class="cm"> *   beginning of the FIFO (if there is space) and append the message</span>
<span class="cm"> *   there.</span>
<span class="cm"> *</span>
<span class="cm"> *   This is because we need to give linear TX messages to the bus</span>
<span class="cm"> *   engine. So we don&#39;t write a message to the remaining FIFO space</span>
<span class="cm"> *   until the tail and continue at the head of it.</span>
<span class="cm"> *</span>
<span class="cm"> * - We overload one of the fields in the message header to use it as</span>
<span class="cm"> *   &#39;size&#39; of the TX message, so we can iterate over them. It also</span>
<span class="cm"> *   contains a flag that indicates if we have to skip it or not.</span>
<span class="cm"> *   When we send the buffer, we update that to its real on-the-wire</span>
<span class="cm"> *   value.</span>
<span class="cm"> *</span>
<span class="cm"> * - The MSG-HDR PLD1...PLD2 stuff has to be a size multiple of 16.</span>
<span class="cm"> *</span>
<span class="cm"> *   It follows that if MSG-HDR says we have N messages, the whole</span>
<span class="cm"> *   header + descriptors is 16 + 4*N; for those to be a multiple of</span>
<span class="cm"> *   16, it follows that N can be 4, 8, 12, ... (32, 48, 64, 80...</span>
<span class="cm"> *   bytes).</span>
<span class="cm"> *</span>
<span class="cm"> *   So if we have only 1 payload, we have to submit a header that in</span>
<span class="cm"> *   all truth has space for 4.</span>
<span class="cm"> *</span>
<span class="cm"> *   The implication is that we reserve space for 12 (64 bytes); but</span>
<span class="cm"> *   if we fill up only (eg) 2, our header becomes 32 bytes only. So</span>
<span class="cm"> *   the TX engine has to shift those 32 bytes of msg header and 2</span>
<span class="cm"> *   payloads and padding so that right after it the payloads start</span>
<span class="cm"> *   and the TX engine has to know about that.</span>
<span class="cm"> *</span>
<span class="cm"> *   It is cheaper to move the header up than the whole payloads down.</span>
<span class="cm"> *</span>
<span class="cm"> *   We do this in i2400m_tx_close(). See &#39;i2400m_msg_hdr-&gt;offset&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * - Each payload has to be size-padded to 16 bytes; before appending</span>
<span class="cm"> *   it, we just do it.</span>
<span class="cm"> *</span>
<span class="cm"> * - The whole message has to be padded to i2400m-&gt;bus_tx_block_size;</span>
<span class="cm"> *   we do this at close time. Thus, when reserving space for the</span>
<span class="cm"> *   payload, we always make sure there is also free space for this</span>
<span class="cm"> *   padding that sooner or later will happen.</span>
<span class="cm"> *</span>
<span class="cm"> * When we append a message, we tell the bus specific code to kick in</span>
<span class="cm"> * TXs. It will TX (in parallel) until the buffer is exhausted--hence</span>
<span class="cm"> * the lockin we do. The TX code will only send a TX message at the</span>
<span class="cm"> * time (which remember, might contain more than one payload). Of</span>
<span class="cm"> * course, when the bus-specific driver attempts to TX a message that</span>
<span class="cm"> * is still open, it gets closed first.</span>
<span class="cm"> *</span>
<span class="cm"> * Gee, this is messy; well a picture. In the example below we have a</span>
<span class="cm"> * partially full FIFO, with a closed message ready to be delivered</span>
<span class="cm"> * (with a moved message header to make sure it is size-aligned to</span>
<span class="cm"> * 16), TAIL room that was unusable (and thus is marked with a message</span>
<span class="cm"> * header that says &#39;skip this&#39;) and at the head of the buffer, an</span>
<span class="cm"> * incomplete message with a couple of payloads.</span>
<span class="cm"> *</span>
<span class="cm"> * N   ___________________________________________________</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |     TAIL room                                     |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |  msg_hdr to skip (size |= 0x80000)                |</span>
<span class="cm"> *    |---------------------------------------------------|-------</span>
<span class="cm"> *    |                                                   |  /|\</span>
<span class="cm"> *    |                                                   |   |</span>
<span class="cm"> *    |  TX message padding                               |   |</span>
<span class="cm"> *    |                                                   |   |</span>
<span class="cm"> *    |                                                   |   |</span>
<span class="cm"> *    |- - - - - - - - - - - - - - - - - - - - - - - - - -|   |</span>
<span class="cm"> *    |                                                   |   |</span>
<span class="cm"> *    |  payload 1                                        |   |</span>
<span class="cm"> *    |                                                   | N * tx_block_size</span>
<span class="cm"> *    |                                                   |   |</span>
<span class="cm"> *    |- - - - - - - - - - - - - - - - - - - - - - - - - -|   |</span>
<span class="cm"> *    |                                                   |   |</span>
<span class="cm"> *    |  payload 1                                        |   |</span>
<span class="cm"> *    |                                                   |   |</span>
<span class="cm"> *    |                                                   |   |</span>
<span class="cm"> *    |- - - - - - - - - - - - - - - - - - - - - - - - - -|- -|- - - -</span>
<span class="cm"> *    |  padding 3                  /|\                   |   |   /|\</span>
<span class="cm"> *    |  padding 2                   |                    |   |    |</span>
<span class="cm"> *    |  pld 1                32 bytes (2 * 16)           |   |    |</span>
<span class="cm"> *    |  pld 0                       |                    |   |    |</span>
<span class="cm"> *    |  moved msg_hdr              \|/                   |  \|/   |</span>
<span class="cm"> *    |- - - - - - - - - - - - - - - - - - - - - - - - - -|- - -   |</span>
<span class="cm"> *    |                                                   |    _PLD_SIZE</span>
<span class="cm"> *    |  unused                                           |        |</span>
<span class="cm"> *    |                                                   |        |</span>
<span class="cm"> *    |- - - - - - - - - - - - - - - - - - - - - - - - - -|        |</span>
<span class="cm"> *    |  msg_hdr (size X)       [this message is closed]  |       \|/</span>
<span class="cm"> *    |===================================================|========== &lt;=== OUT</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |          Free rooom                               |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |===================================================|========== &lt;=== IN</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |  payload 1                                        |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |- - - - - - - - - - - - - - - - - - - - - - - - - -|</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |  payload 0                                        |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |                                                   |</span>
<span class="cm"> *    |- - - - - - - - - - - - - - - - - - - - - - - - - -|</span>
<span class="cm"> *    |  pld 11                     /|\                   |</span>
<span class="cm"> *    |  ...                         |                    |</span>
<span class="cm"> *    |  pld 1                64 bytes (2 * 16)           |</span>
<span class="cm"> *    |  pld 0                       |                    |</span>
<span class="cm"> *    |  msg_hdr (size X)           \|/ [message is open] |</span>
<span class="cm"> * 0   ---------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * ROADMAP</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_tx_setup()           Called by i2400m_setup</span>
<span class="cm"> * i2400m_tx_release()         Called by i2400m_release()</span>
<span class="cm"> *</span>
<span class="cm"> *  i2400m_tx()                 Called to send data or control frames</span>
<span class="cm"> *    i2400m_tx_fifo_push()     Allocates append-space in the FIFO</span>
<span class="cm"> *    i2400m_tx_new()           Opens a new message in the FIFO</span>
<span class="cm"> *    i2400m_tx_fits()          Checks if a new payload fits in the message</span>
<span class="cm"> *    i2400m_tx_close()         Closes an open message in the FIFO</span>
<span class="cm"> *    i2400m_tx_skip_tail()     Marks unusable FIFO tail space</span>
<span class="cm"> *    i2400m-&gt;bus_tx_kick()</span>
<span class="cm"> *</span>
<span class="cm"> * Now i2400m-&gt;bus_tx_kick() is the the bus-specific driver backend</span>
<span class="cm"> * implementation; that would do:</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m-&gt;bus_tx_kick()</span>
<span class="cm"> *   i2400m_tx_msg_get()	Gets first message ready to go</span>
<span class="cm"> *   ...sends it...</span>
<span class="cm"> *   i2400m_tx_msg_sent()       Ack the message is sent; repeat from</span>
<span class="cm"> *                              _tx_msg_get() until it returns NULL</span>
<span class="cm"> *                               (FIFO empty).</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &quot;i2400m.h&quot;</span>


<span class="cp">#define D_SUBMODULE tx</span>
<span class="cp">#include &quot;debug-levels.h&quot;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/**</span>
<span class="cm">	 * TX Buffer size</span>
<span class="cm">	 *</span>
<span class="cm">	 * Doc says maximum transaction is 16KiB. If we had 16KiB en</span>
<span class="cm">	 * route and 16KiB being queued, it boils down to needing</span>
<span class="cm">	 * 32KiB.</span>
<span class="cm">	 * 32KiB is insufficient for 1400 MTU, hence increasing</span>
<span class="cm">	 * tx buffer size to 64KiB.</span>
<span class="cm">	 */</span>
	<span class="n">I2400M_TX_BUF_SIZE</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">,</span>
	<span class="cm">/**</span>
<span class="cm">	 * Message header and payload descriptors have to be 16</span>
<span class="cm">	 * aligned (16 + 4 * N = 16 * M). If we take that average sent</span>
<span class="cm">	 * packets are MTU size (~1400-~1500) it follows that we could</span>
<span class="cm">	 * fit at most 10-11 payloads in one transaction. To meet the</span>
<span class="cm">	 * alignment requirement, that means we need to leave space</span>
<span class="cm">	 * for 12 (64 bytes). To simplify, we leave space for that. If</span>
<span class="cm">	 * at the end there are less, we pad up to the nearest</span>
<span class="cm">	 * multiple of 16.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * According to Intel Wimax i3200, i5x50 and i6x50 specification</span>
<span class="cm">	 * documents, the maximum number of payloads per message can be</span>
<span class="cm">	 * up to 60. Increasing the number of payloads to 60 per message</span>
<span class="cm">	 * helps to accommodate smaller payloads in a single transaction.</span>
<span class="cm">	 */</span>
	<span class="n">I2400M_TX_PLD_MAX</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
	<span class="n">I2400M_TX_PLD_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_msg_hdr</span><span class="p">)</span>
	<span class="o">+</span> <span class="n">I2400M_TX_PLD_MAX</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_pld</span><span class="p">),</span>
	<span class="n">I2400M_TX_SKIP</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * According to Intel Wimax i3200, i5x50 and i6x50 specification</span>
<span class="cm">	 * documents, the maximum size of each message can be up to 16KiB.</span>
<span class="cm">	 */</span>
	<span class="n">I2400M_TX_MSG_SIZE</span> <span class="o">=</span> <span class="mi">16384</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define TAIL_FULL ((void *)~(unsigned long)NULL)</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate how much tail room is available</span>
<span class="cm"> *</span>
<span class="cm"> * Note the trick here. This path is ONLY caleed for Case A (see</span>
<span class="cm"> * i2400m_tx_fifo_push() below), where we have:</span>
<span class="cm"> *</span>
<span class="cm"> *       Case A</span>
<span class="cm"> * N  ___________</span>
<span class="cm"> *   | tail room |</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   |&lt;-  IN   -&gt;|</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   |   data    |</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   |&lt;-  OUT  -&gt;|</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   | head room |</span>
<span class="cm"> * 0  -----------</span>
<span class="cm"> *</span>
<span class="cm"> * When calculating the tail_room, tx_in might get to be zero if</span>
<span class="cm"> * i2400m-&gt;tx_in is right at the end of the buffer (really full</span>
<span class="cm"> * buffer) if there is no head room. In this case, tail_room would be</span>
<span class="cm"> * I2400M_TX_BUF_SIZE, although it is actually zero. Hence the final</span>
<span class="cm"> * mod (%) operation. However, when doing this kind of optimization,</span>
<span class="cm"> * i2400m-&gt;tx_in being zero would fail, so we treat is an a special</span>
<span class="cm"> * case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">size_t</span> <span class="nf">__i2400m_tx_tail_room</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">tail_room</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tx_in</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
	<span class="n">tx_in</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">%</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
	<span class="n">tail_room</span> <span class="o">=</span> <span class="n">I2400M_TX_BUF_SIZE</span> <span class="o">-</span> <span class="n">tx_in</span><span class="p">;</span>
	<span class="n">tail_room</span> <span class="o">%=</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tail_room</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Allocate @size bytes in the TX fifo, return a pointer to it</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> * @size: size of the buffer we need to allocate</span>
<span class="cm"> * @padding: ensure that there is at least this many bytes of free</span>
<span class="cm"> *     contiguous space in the fifo. This is needed because later on</span>
<span class="cm"> *     we might need to add padding.</span>
<span class="cm"> * @try_head: specify either to allocate head room or tail room space</span>
<span class="cm"> *     in the TX FIFO. This boolean is required to avoids a system hang</span>
<span class="cm"> *     due to an infinite loop caused by i2400m_tx_fifo_push().</span>
<span class="cm"> *     The caller must always try to allocate tail room space first by</span>
<span class="cm"> *     calling this routine with try_head = 0. In case if there</span>
<span class="cm"> *     is not enough tail room space but there is enough head room space,</span>
<span class="cm"> *     (i2400m_tx_fifo_push() returns TAIL_FULL) try to allocate head</span>
<span class="cm"> *     room space, by calling this routine again with try_head = 1.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *</span>
<span class="cm"> *     Pointer to the allocated space. NULL if there is no</span>
<span class="cm"> *     space. TAIL_FULL if there is no space at the tail but there is at</span>
<span class="cm"> *     the head (Case B below).</span>
<span class="cm"> *</span>
<span class="cm"> * These are the two basic cases we need to keep an eye for -- it is</span>
<span class="cm"> * much better explained in linux/kernel/kfifo.c, but this code</span>
<span class="cm"> * basically does the same. No rocket science here.</span>
<span class="cm"> *</span>
<span class="cm"> *       Case A               Case B</span>
<span class="cm"> * N  ___________          ___________</span>
<span class="cm"> *   | tail room |        |   data    |</span>
<span class="cm"> *   |           |        |           |</span>
<span class="cm"> *   |&lt;-  IN   -&gt;|        |&lt;-  OUT  -&gt;|</span>
<span class="cm"> *   |           |        |           |</span>
<span class="cm"> *   |   data    |        |   room    |</span>
<span class="cm"> *   |           |        |           |</span>
<span class="cm"> *   |&lt;-  OUT  -&gt;|        |&lt;-  IN   -&gt;|</span>
<span class="cm"> *   |           |        |           |</span>
<span class="cm"> *   | head room |        |   data    |</span>
<span class="cm"> * 0  -----------          -----------</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate only *contiguous* space.</span>
<span class="cm"> *</span>
<span class="cm"> * We can allocate only from &#39;room&#39;. In Case B, it is simple; in case</span>
<span class="cm"> * A, we only try from the tail room; if it is not enough, we just</span>
<span class="cm"> * fail and return TAIL_FULL and let the caller figure out if we wants to</span>
<span class="cm"> * skip the tail room and try to allocate from the head.</span>
<span class="cm"> *</span>
<span class="cm"> * There is a corner case, wherein i2400m_tx_new() can get into</span>
<span class="cm"> * an infinite loop calling i2400m_tx_fifo_push().</span>
<span class="cm"> * In certain situations, tx_in would have reached on the top of TX FIFO</span>
<span class="cm"> * and i2400m_tx_tail_room() returns 0, as described below:</span>
<span class="cm"> *</span>
<span class="cm"> * N  ___________ tail room is zero</span>
<span class="cm"> *   |&lt;-  IN   -&gt;|</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   |   data    |</span>
<span class="cm"> *   |&lt;-  OUT  -&gt;|</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   |           |</span>
<span class="cm"> *   | head room |</span>
<span class="cm"> * 0  -----------</span>
<span class="cm"> * During such a time, where tail room is zero in the TX FIFO and if there</span>
<span class="cm"> * is a request to add a payload to TX FIFO, which calls:</span>
<span class="cm"> * i2400m_tx()</span>
<span class="cm"> *         -&gt;calls i2400m_tx_close()</span>
<span class="cm"> *         -&gt;calls i2400m_tx_skip_tail()</span>
<span class="cm"> *         goto try_new;</span>
<span class="cm"> *         -&gt;calls i2400m_tx_new()</span>
<span class="cm"> *                    |----&gt; [try_head:]</span>
<span class="cm"> *     infinite loop  |     -&gt;calls i2400m_tx_fifo_push()</span>
<span class="cm"> *                    |                if (tail_room &lt; needed)</span>
<span class="cm"> *                    |                   if (head_room =&gt; needed)</span>
<span class="cm"> *                    |                       return TAIL_FULL;</span>
<span class="cm"> *                    |&lt;----  goto try_head;</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_tx() calls i2400m_tx_close() to close the message, since there</span>
<span class="cm"> * is no tail room to accommodate the payload and calls</span>
<span class="cm"> * i2400m_tx_skip_tail() to skip the tail space. Now i2400m_tx() calls</span>
<span class="cm"> * i2400m_tx_new() to allocate space for new message header calling</span>
<span class="cm"> * i2400m_tx_fifo_push() that returns TAIL_FULL, since there is no tail space</span>
<span class="cm"> * to accommodate the message header, but there is enough head space.</span>
<span class="cm"> * The i2400m_tx_new() keeps re-retrying by calling i2400m_tx_fifo_push()</span>
<span class="cm"> * ending up in a loop causing system freeze.</span>
<span class="cm"> *</span>
<span class="cm"> * This corner case is avoided by using a try_head boolean,</span>
<span class="cm"> * as an argument to i2400m_tx_fifo_push().</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> *</span>
<span class="cm"> *     Assumes i2400m-&gt;tx_lock is taken, and we use that as a barrier</span>
<span class="cm"> *</span>
<span class="cm"> *     The indexes keep increasing and we reset them to zero when we</span>
<span class="cm"> *     pop data off the queue</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">i2400m_tx_fifo_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">padding</span><span class="p">,</span> <span class="n">bool</span> <span class="n">try_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">room</span><span class="p">,</span> <span class="n">tail_room</span><span class="p">,</span> <span class="n">needed_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">needed_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">padding</span><span class="p">;</span>
	<span class="n">room</span> <span class="o">=</span> <span class="n">I2400M_TX_BUF_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">-</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">room</span> <span class="o">&lt;</span> <span class="n">needed_size</span><span class="p">)</span>	<span class="p">{</span> <span class="cm">/* this takes care of Case B */</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fifo push %zu/%zu: no space</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">size</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Is there space at the tail? */</span>
	<span class="n">tail_room</span> <span class="o">=</span> <span class="n">__i2400m_tx_tail_room</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_head</span> <span class="o">&amp;&amp;</span> <span class="n">tail_room</span> <span class="o">&lt;</span> <span class="n">needed_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the tail room space is not enough to push the message</span>
<span class="cm">		 * in the TX FIFO, then there are two possibilities:</span>
<span class="cm">		 * 1. There is enough head room space to accommodate</span>
<span class="cm">		 * this message in the TX FIFO.</span>
<span class="cm">		 * 2. There is not enough space in the head room and</span>
<span class="cm">		 * in tail room of the TX FIFO to accommodate the message.</span>
<span class="cm">		 * In the case (1), return TAIL_FULL so that the caller</span>
<span class="cm">		 * can figure out, if the caller wants to push the message</span>
<span class="cm">		 * into the head room space.</span>
<span class="cm">		 * In the case (2), return NULL, indicating that the TX FIFO</span>
<span class="cm">		 * cannot accommodate the message.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">room</span> <span class="o">-</span> <span class="n">tail_room</span> <span class="o">&gt;=</span> <span class="n">needed_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fifo push %zu/%zu: tail full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">size</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">TAIL_FULL</span><span class="p">;</span>	<span class="cm">/* There might be head space */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fifo push %zu/%zu: no head space</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">size</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* There is no space */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">+</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">%</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;fifo push %zu/%zu: at @%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span>
		 <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">%</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Mark the tail of the FIFO buffer as &#39;to-skip&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * We should never hit the BUG_ON() because all the sizes we push to</span>
<span class="cm"> * the FIFO are padded to be a multiple of 16 -- the size of *msg</span>
<span class="cm"> * (I2400M_PL_PAD for the payloads, I2400M_TX_PLD_SIZE for the</span>
<span class="cm"> * header).</span>
<span class="cm"> *</span>
<span class="cm"> * Tail room can get to be zero if a message was opened when there was</span>
<span class="cm"> * space only for a header. _tx_close() will mark it as to-skip (as it</span>
<span class="cm"> * will have no payloads) and there will be no more space to flush, so</span>
<span class="cm"> * nothing has to be done here. This is probably cheaper than ensuring</span>
<span class="cm"> * in _tx_new() that there is some space for payloads...as we could</span>
<span class="cm"> * always possibly hit the same problem if the payload wouldn&#39;t fit.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> *</span>
<span class="cm"> *     Assumes i2400m-&gt;tx_lock is taken, and we use that as a barrier</span>
<span class="cm"> *</span>
<span class="cm"> *     This path is only taken for Case A FIFO situations [see</span>
<span class="cm"> *     i2400m_tx_fifo_push()]</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_tx_skip_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">tx_in</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">%</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tail_room</span> <span class="o">=</span> <span class="n">__i2400m_tx_tail_room</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">+</span> <span class="n">tx_in</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tail_room</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tail_room</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">));</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">tail_room</span> <span class="o">|</span> <span class="n">I2400M_TX_SKIP</span><span class="p">;</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;skip tail: skipping %zu bytes @%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">tail_room</span><span class="p">,</span> <span class="n">tx_in</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">+=</span> <span class="n">tail_room</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Check if a skb will fit in the TX queue&#39;s current active TX</span>
<span class="cm"> * message (if there are still descriptors left unused).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *     0 if the message won&#39;t fit, 1 if it will.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> *</span>
<span class="cm"> *     Assumes a TX message is active (i2400m-&gt;tx_msg).</span>
<span class="cm"> *</span>
<span class="cm"> *     Assumes i2400m-&gt;tx_lock is taken, and we use that as a barrier</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_tx_fits</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">msg_hdr</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">msg_hdr</span><span class="o">-&gt;</span><span class="n">num_pls</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">I2400M_TX_PLD_MAX</span><span class="p">;</span>

<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Start a new TX message header in the queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Reserve memory from the base FIFO engine and then just initialize</span>
<span class="cm"> * the message header.</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate the biggest TX message header we might need (one that&#39;d</span>
<span class="cm"> * fit I2400M_TX_PLD_MAX payloads) -- when it is closed it will be</span>
<span class="cm"> * &#39;ironed it out&#39; and the unneeded parts removed.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE:</span>
<span class="cm"> *</span>
<span class="cm"> *     Assumes that the previous message is CLOSED (eg: either</span>
<span class="cm"> *     there was none or &#39;i2400m_tx_close()&#39; was called on it).</span>
<span class="cm"> *</span>
<span class="cm"> *     Assumes i2400m-&gt;tx_lock is taken, and we use that as a barrier</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_tx_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">tx_msg</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">try_head</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * In certain situations, TX queue might have enough space to</span>
<span class="cm">	 * accommodate the new message header I2400M_TX_PLD_SIZE, but</span>
<span class="cm">	 * might not have enough space to accommodate the payloads.</span>
<span class="cm">	 * Adding bus_tx_room_min padding while allocating a new TX message</span>
<span class="cm">	 * increases the possibilities of including at least one payload of the</span>
<span class="cm">	 * size &lt;= bus_tx_room_min.</span>
<span class="cm">	 */</span>
<span class="nl">try_head:</span>
	<span class="n">tx_msg</span> <span class="o">=</span> <span class="n">i2400m_tx_fifo_push</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_TX_PLD_SIZE</span><span class="p">,</span>
				     <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_tx_room_min</span><span class="p">,</span> <span class="n">try_head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tx_msg</span> <span class="o">==</span> <span class="n">TAIL_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i2400m_tx_skip_tail</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;new TX message: tail full, trying head</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">try_head</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">try_head</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tx_msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">I2400M_TX_PLD_SIZE</span><span class="p">);</span>
	<span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">I2400M_TX_PLD_SIZE</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span> <span class="o">=</span> <span class="n">tx_msg</span><span class="p">;</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;new TX message: %p @%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">tx_msg</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">tx_msg</span> <span class="o">-</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Finalize the current TX message header</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the message header to be at the proper location depending on</span>
<span class="cm"> * how many descriptors we have (check documentation at the file&#39;s</span>
<span class="cm"> * header for more info on that).</span>
<span class="cm"> *</span>
<span class="cm"> * Appends padding bytes to make sure the whole TX message (counting</span>
<span class="cm"> * from the &#39;relocated&#39; message header) is aligned to</span>
<span class="cm"> * tx_block_size. We assume the _append() code has left enough space</span>
<span class="cm"> * in the FIFO for that. If there are no payloads, just pass, as it</span>
<span class="cm"> * won&#39;t be transferred.</span>
<span class="cm"> *</span>
<span class="cm"> * The amount of padding bytes depends on how many payloads are in the</span>
<span class="cm"> * TX message, as the &quot;msg header and payload descriptors&quot; will be</span>
<span class="cm"> * shifted up in the buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_tx_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">tx_msg</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">tx_msg_moved</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">aligned_size</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">pad_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">num_pls</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">I2400M_TX_SKIP</span><span class="p">)</span>	<span class="cm">/* a skipper? nothing to do */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">num_pls</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">num_pls</span><span class="p">);</span>
	<span class="cm">/* We can get this situation when a new message was started</span>
<span class="cm">	 * and there was no space to add payloads before hitting the</span>
<span class="cm">	 tail (and taking padding into consideration). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_pls</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">|=</span> <span class="n">I2400M_TX_SKIP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Relocate the message header</span>
<span class="cm">	 *</span>
<span class="cm">	 * Find the current header size, align it to 16 and if we need</span>
<span class="cm">	 * to move it so the tail is next to the payloads, move it and</span>
<span class="cm">	 * set the offset.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If it moved, this header is good only for transmission; the</span>
<span class="cm">	 * original one (it is kept if we moved) is still used to</span>
<span class="cm">	 * figure out where the next TX message starts (and where the</span>
<span class="cm">	 * offset to the moved header is).</span>
<span class="cm">	 */</span>
	<span class="n">hdr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tx_msg</span><span class="p">)</span>
		<span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">num_pls</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">pld</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">hdr_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">hdr_size</span><span class="p">,</span> <span class="n">I2400M_PL_ALIGN</span><span class="p">);</span>
	<span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">I2400M_TX_PLD_SIZE</span> <span class="o">-</span> <span class="n">hdr_size</span><span class="p">;</span>
	<span class="n">tx_msg_moved</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">tx_msg</span> <span class="o">+</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">tx_msg_moved</span><span class="p">,</span> <span class="n">tx_msg</span><span class="p">,</span> <span class="n">hdr_size</span><span class="p">);</span>
	<span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now figure out how much we have to add to the (moved!)</span>
<span class="cm">	 * message so the size is a multiple of i2400m-&gt;bus_tx_block_size.</span>
<span class="cm">	 */</span>
	<span class="n">aligned_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_tx_block_size</span><span class="p">);</span>
	<span class="n">padding</span> <span class="o">=</span> <span class="n">aligned_size</span> <span class="o">-</span> <span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">padding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pad_buf</span> <span class="o">=</span> <span class="n">i2400m_tx_fifo_push</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">pad_buf</span> <span class="o">==</span> <span class="nb">NULL</span>
				     <span class="o">||</span> <span class="n">pad_buf</span> <span class="o">==</span> <span class="n">TAIL_FULL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* This should not happen -- append should verify</span>
<span class="cm">			 * there is always space left at least to append</span>
<span class="cm">			 * tx_block_size */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;SW BUG! Possible data leakage from memory the &quot;</span>
				<span class="s">&quot;device should not read for padding - &quot;</span>
				<span class="s">&quot;size %lu aligned_size %zu tx_buf %p in &quot;</span>
				<span class="s">&quot;%zu out %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
				<span class="n">aligned_size</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span><span class="p">,</span>
				<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">pad_buf</span><span class="p">,</span> <span class="mh">0xad</span><span class="p">,</span> <span class="n">padding</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">padding</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">padding</span><span class="p">);</span>
	<span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">padding</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_msg</span> <span class="o">!=</span> <span class="n">tx_msg_moved</span><span class="p">)</span>
		<span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">padding</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_tx - send the data in a buffer to the device</span>
<span class="cm"> *</span>
<span class="cm"> * @buf: pointer to the buffer to transmit</span>
<span class="cm"> *</span>
<span class="cm"> * @buf_len: buffer size</span>
<span class="cm"> *</span>
<span class="cm"> * @pl_type: type of the payload we are sending.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *     0 if ok, &lt; 0 errno code on error (-ENOSPC, if there is no more</span>
<span class="cm"> *     room for the message in the queue).</span>
<span class="cm"> *</span>
<span class="cm"> * Appends the buffer to the TX FIFO and notifies the bus-specific</span>
<span class="cm"> * part of the driver that there is new data ready to transmit.</span>
<span class="cm"> * Once this function returns, the buffer has been copied, so it can</span>
<span class="cm"> * be reused.</span>
<span class="cm"> *</span>
<span class="cm"> * The steps followed to append are explained in detail in the file</span>
<span class="cm"> * header.</span>
<span class="cm"> *</span>
<span class="cm"> * Whenever we write to a message, we increase msg-&gt;size, so it</span>
<span class="cm"> * reflects exactly how big the message is. This is needed so that if</span>
<span class="cm"> * we concatenate two messages before they can be sent, the code that</span>
<span class="cm"> * sends the messages can find the boundaries (and it will replace the</span>
<span class="cm"> * size with the real barker before sending).</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> *</span>
<span class="cm"> *     Cold and warm reset payloads need to be sent as a single</span>
<span class="cm"> *     payload, so we handle that.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">,</span>
	      <span class="k">enum</span> <span class="n">i2400m_pt</span> <span class="n">pl_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">padded_len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">try_head</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">is_singleton</span> <span class="o">=</span> <span class="n">pl_type</span> <span class="o">==</span> <span class="n">I2400M_PT_RESET_WARM</span>
		<span class="o">||</span> <span class="n">pl_type</span> <span class="o">==</span> <span class="n">I2400M_PT_RESET_COLD</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p skb %p [%zu bytes] pt %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">pl_type</span><span class="p">);</span>
	<span class="n">padded_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">buf_len</span><span class="p">,</span> <span class="n">I2400M_PL_ALIGN</span><span class="p">);</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;padded_len %zd buf_len %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">padded_len</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="cm">/* If there is no current TX message, create one; if the</span>
<span class="cm">	 * current one is out of payload slots or we have a singleton,</span>
<span class="cm">	 * close it and start a new one */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* If tx_buf is NULL, device is shutdown */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_tx_new</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">try_new:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">i2400m_tx_new</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">i2400m_tx_fits</span><span class="p">(</span><span class="n">i2400m</span><span class="p">)</span>
			  <span class="o">||</span> <span class="p">(</span><span class="n">is_singleton</span> <span class="o">&amp;&amp;</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">num_pls</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;closing TX message (fits %u singleton &quot;</span>
			 <span class="s">&quot;%u num_pls %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m_tx_fits</span><span class="p">(</span><span class="n">i2400m</span><span class="p">),</span>
			 <span class="n">is_singleton</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">num_pls</span><span class="p">);</span>
		<span class="n">i2400m_tx_close</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">i2400m_tx_new</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_tx_new</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if this skb will fit in the TX queue&#39;s current active</span>
<span class="cm">	 * TX message. The total message size must not exceed the maximum</span>
<span class="cm">	 * size of each message I2400M_TX_MSG_SIZE. If it exceeds,</span>
<span class="cm">	 * close the current message and push this skb into the new message.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">padded_len</span> <span class="o">&gt;</span> <span class="n">I2400M_TX_MSG_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX: message too big, going new</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">i2400m_tx_close</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">i2400m_tx_new</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_tx_new</span><span class="p">;</span>
	<span class="cm">/* So we have a current message header; now append space for</span>
<span class="cm">	 * the message -- if there is not enough, try the head */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">i2400m_tx_fifo_push</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">padded_len</span><span class="p">,</span>
				  <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_tx_block_size</span><span class="p">,</span> <span class="n">try_head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">TAIL_FULL</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Tail is full, try head */</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pl append: tail full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">i2400m_tx_close</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">i2400m_tx_skip_tail</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">try_head</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">try_new</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* All full */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pl append: all full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="cm">/* Got space, copy it, set padding */</span>
		<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">tx_msg</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">num_pls</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">num_pls</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">buf_len</span><span class="p">,</span> <span class="mh">0xad</span><span class="p">,</span> <span class="n">padded_len</span> <span class="o">-</span> <span class="n">buf_len</span><span class="p">);</span>
		<span class="n">i2400m_pld_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">pld</span><span class="p">[</span><span class="n">num_pls</span><span class="p">],</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">pl_type</span><span class="p">);</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pld 0x%08x (type 0x%1x len 0x%04zx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">pld</span><span class="p">[</span><span class="n">num_pls</span><span class="p">].</span><span class="n">val</span><span class="p">),</span>
			 <span class="n">pl_type</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
		<span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">num_pls</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">num_pls</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">padded_len</span><span class="p">;</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX: appended %zu b (up to %u b) pl #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">padded_len</span><span class="p">,</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">num_pls</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;TX: appended hdr @%zu %zu b pl #%u @%zu %zu/%zu b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tx_msg</span> <span class="o">-</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
			 <span class="n">num_pls</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">-</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">padded_len</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_singleton</span><span class="p">)</span>
			<span class="n">i2400m_tx_close</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">error_tx_new:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* kick in most cases, except when the TX subsys is down, as</span>
<span class="cm">	 * it might free space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">))</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_tx_kick</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p skb %p [%zu bytes] pt %u) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">pl_type</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_tx</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_tx_msg_get - Get the first TX message in the FIFO to start sending it</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptors</span>
<span class="cm"> * @bus_size: where to place the size of the TX message</span>
<span class="cm"> *</span>
<span class="cm"> * Called by the bus-specific driver to get the first TX message at</span>
<span class="cm"> * the FIF that is ready for transmission.</span>
<span class="cm"> *</span>
<span class="cm"> * It sets the state in @i2400m to indicate the bus-specific driver is</span>
<span class="cm"> * transferring that message (i2400m-&gt;tx_msg_size).</span>
<span class="cm"> *</span>
<span class="cm"> * Once the transfer is completed, call i2400m_tx_msg_sent().</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *</span>
<span class="cm"> *     The size of the TX message to be transmitted might be smaller than</span>
<span class="cm"> *     that of the TX message in the FIFO (in case the header was</span>
<span class="cm"> *     shorter). Hence, we copy it in @bus_size, for the bus layer to</span>
<span class="cm"> *     use. We keep the message&#39;s size in i2400m-&gt;tx_msg_size so that</span>
<span class="cm"> *     when the bus later is done transferring we know how much to</span>
<span class="cm"> *     advance the fifo.</span>
<span class="cm"> *</span>
<span class="cm"> *     We collect statistics here as all the data is available and we</span>
<span class="cm"> *     assume it is going to work [see i2400m_tx_msg_sent()].</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="nf">i2400m_tx_msg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="o">*</span><span class="n">bus_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">tx_msg</span><span class="p">,</span> <span class="o">*</span><span class="n">tx_msg_moved</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pls</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p bus_size %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">bus_size</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">tx_msg_moved</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
<span class="nl">skip:</span>
	<span class="n">tx_msg_moved</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">==</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Empty FIFO? */</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX: FIFO empty: resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tx_msg</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">+</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">%</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">I2400M_TX_SKIP</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* skip? */</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX: skip: msg @%zu (%zu b)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">%</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">I2400M_TX_SKIP</span><span class="p">);</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">+=</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">I2400M_TX_SKIP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">num_pls</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* No payloads? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_msg</span> <span class="o">==</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* open, we are done */</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;TX: FIFO empty: open msg w/o payloads @%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">tx_msg</span> <span class="o">-</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">);</span>
			<span class="n">tx_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>			<span class="cm">/* closed, skip it */</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;TX: skip msg w/o payloads @%zu (%zu b)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">tx_msg</span> <span class="o">-</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">+=</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">I2400M_TX_SKIP</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_msg</span> <span class="o">==</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span><span class="p">)</span>		<span class="cm">/* open msg? */</span>
		<span class="n">i2400m_tx_close</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="cm">/* Now we have a valid TX message (with payloads) to TX */</span>
	<span class="n">tx_msg_moved</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">tx_msg</span> <span class="o">+</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg_size</span> <span class="o">=</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="o">*</span><span class="n">bus_size</span> <span class="o">=</span> <span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX: pid %d msg hdr at @%zu offset +@%zu &quot;</span>
		 <span class="s">&quot;size %zu bus_size %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">tx_msg</span> <span class="o">-</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">tx_msg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">barker</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">I2400M_H2D_PREVIEW_BARKER</span><span class="p">);</span>
	<span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_sequence</span><span class="o">++</span><span class="p">);</span>

	<span class="n">pls</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tx_msg_moved</span><span class="o">-&gt;</span><span class="n">num_pls</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_pl_num</span> <span class="o">+=</span> <span class="n">pls</span><span class="p">;</span>		<span class="cm">/* Update stats */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pls</span> <span class="o">&gt;</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_pl_max</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_pl_max</span> <span class="o">=</span> <span class="n">pls</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pls</span> <span class="o">&lt;</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_pl_min</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_pl_min</span> <span class="o">=</span> <span class="n">pls</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_num</span><span class="o">++</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_size_acc</span> <span class="o">+=</span> <span class="o">*</span><span class="n">bus_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_size</span> <span class="o">&lt;</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_size_min</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_size_min</span> <span class="o">=</span> <span class="o">*</span><span class="n">bus_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_size</span> <span class="o">&gt;</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_size_max</span><span class="p">)</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_size_max</span> <span class="o">=</span> <span class="o">*</span><span class="n">bus_size</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p bus_size %p [%zu]) = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">bus_size</span><span class="p">,</span> <span class="o">*</span><span class="n">bus_size</span><span class="p">,</span> <span class="n">tx_msg_moved</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tx_msg_moved</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_tx_msg_get</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_tx_msg_sent - indicate the transmission of a TX message</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> *</span>
<span class="cm"> * Called by the bus-specific driver when a message has been sent;</span>
<span class="cm"> * this pops it from the FIFO; and as there is space, start the queue</span>
<span class="cm"> * in case it was stopped.</span>
<span class="cm"> *</span>
<span class="cm"> * Should be called even if the message send failed and we are</span>
<span class="cm"> * dropping this TX message.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_tx_msg_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">+=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg_size</span><span class="p">;</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX: sent %zu b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg_size</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">&gt;</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span><span class="p">);</span>
	<span class="cm">/* level them FIFO markers off */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">/</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">%=</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">-=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = void</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_tx_msg_sent</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_tx_setup - Initialize the TX queue and infrastructure</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure we reset the TX sequence to zero, as when this function</span>
<span class="cm"> * is called, the firmware has been just restarted. Same rational</span>
<span class="cm"> * for tx_in, tx_out, tx_msg_size and tx_msg. We reset them since</span>
<span class="cm"> * the memory for TX queue is reallocated.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">i2400m_tx_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tx_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Do this here only once -- can&#39;t do on</span>
<span class="cm">	 * i2400m_hard_start_xmit() as we&#39;ll cause race conditions if</span>
<span class="cm">	 * the WS was scheduled on another CPU */</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_ws</span><span class="p">,</span> <span class="n">i2400m_wake_tx_work</span><span class="p">);</span>

	<span class="n">tx_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">I2400M_TX_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_kmalloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fail the build if we can&#39;t fit at least two maximum size messages</span>
<span class="cm">	 * on the TX FIFO [one being delivered while one is constructed].</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">I2400M_TX_MSG_SIZE</span> <span class="o">&gt;</span> <span class="n">I2400M_TX_BUF_SIZE</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_sequence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">tx_buf</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Huh? the bus layer has to define this... */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_tx_block_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">error_kmalloc:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_tx_release - Tear down the TX queue and infrastructure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_tx_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
