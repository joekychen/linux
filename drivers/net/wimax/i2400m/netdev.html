<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wimax › i2400m › netdev.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>netdev.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Intel Wireless WiMAX Connection 2400m</span>
<span class="cm"> * Glue with the networking stack</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Intel Corporation &lt;linux-wimax@intel.com&gt;</span>
<span class="cm"> * Yanir Lubetkin &lt;yanirx.lubetkin@intel.com&gt;</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * This implements an ethernet device for the i2400m.</span>
<span class="cm"> *</span>
<span class="cm"> * We fake being an ethernet device to simplify the support from user</span>
<span class="cm"> * space and from the other side. The world is (sadly) configured to</span>
<span class="cm"> * take in only Ethernet devices...</span>
<span class="cm"> *</span>
<span class="cm"> * Because of this, when using firmwares &lt;= v1.3, there is an</span>
<span class="cm"> * copy-each-rxed-packet overhead on the RX path. Each IP packet has</span>
<span class="cm"> * to be reallocated to add an ethernet header (as there is no space</span>
<span class="cm"> * in what we get from the device). This is a known drawback and</span>
<span class="cm"> * firmwares &gt;= 1.4 add header space that can be used to insert the</span>
<span class="cm"> * ethernet header without having to reallocate and copy.</span>
<span class="cm"> *</span>
<span class="cm"> * TX error handling is tricky; because we have to FIFO/queue the</span>
<span class="cm"> * buffers for transmission (as the hardware likes it aggregated), we</span>
<span class="cm"> * just give the skb to the TX subsystem and by the time it is</span>
<span class="cm"> * transmitted, we have long forgotten about it. So we just don&#39;t care</span>
<span class="cm"> * too much about it.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that when the device is in idle mode with the basestation, we</span>
<span class="cm"> * need to negotiate coming back up online. That involves negotiation</span>
<span class="cm"> * and possible user space interaction. Thus, we defer to a workqueue</span>
<span class="cm"> * to do all that. By default, we only queue a single packet and drop</span>
<span class="cm"> * the rest, as potentially the time to go back from idle to normal is</span>
<span class="cm"> * long.</span>
<span class="cm"> *</span>
<span class="cm"> * ROADMAP</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_open         Called on ifconfig up</span>
<span class="cm"> * i2400m_stop         Called on ifconfig down</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_hard_start_xmit Called by the network stack to send a packet</span>
<span class="cm"> *   i2400m_net_wake_tx	  Wake up device from basestation-IDLE &amp; TX</span>
<span class="cm"> *     i2400m_wake_tx_work</span>
<span class="cm"> *       i2400m_cmd_exit_idle</span>
<span class="cm"> *       i2400m_tx</span>
<span class="cm"> *   i2400m_net_tx        TX a data frame</span>
<span class="cm"> *     i2400m_tx</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_change_mtu      Called on ifconfig mtu XXX</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_tx_timeout      Called when the device times out</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_net_rx          Called by the RX code when a data frame is</span>
<span class="cm"> *                        available (firmware &lt;= 1.3)</span>
<span class="cm"> * i2400m_net_erx         Called by the RX code when a data frame is</span>
<span class="cm"> *                        available (firmware &gt;= 1.4).</span>
<span class="cm"> * i2400m_netdev_setup    Called to setup all the netdev stuff from</span>
<span class="cm"> *                        alloc_netdev.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &quot;i2400m.h&quot;</span>


<span class="cp">#define D_SUBMODULE netdev</span>
<span class="cp">#include &quot;debug-levels.h&quot;</span>

<span class="k">enum</span> <span class="p">{</span>
<span class="cm">/* netdev interface */</span>
	<span class="cm">/* 20 secs? yep, this is the maximum timeout that the device</span>
<span class="cm">	 * might take to get out of IDLE / negotiate it with the base</span>
<span class="cm">	 * station. We add 1sec for good measure. */</span>
	<span class="n">I2400M_TX_TIMEOUT</span> <span class="o">=</span> <span class="mi">21</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 * Experimentation has determined that, 20 to be a good value</span>
<span class="cm">	 * for minimizing the jitter in the throughput.</span>
<span class="cm">	 */</span>
	<span class="n">I2400M_TX_QLEN</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">net_dev_to_i2400m</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(net_dev %p [i2400m %p])</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="cm">/* Make sure we wait until init is complete... */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">updown</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">init_mutex</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(net_dev %p [i2400m %p]) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">net_dev</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">net_dev_to_i2400m</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(net_dev %p [i2400m %p])</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">i2400m_net_wake_stop</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(net_dev %p [i2400m %p]) = 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Wake up the device and transmit a held SKB, then restart the net queue</span>
<span class="cm"> *</span>
<span class="cm"> * When the device goes into basestation-idle mode, we need to tell it</span>
<span class="cm"> * to exit that mode; it will negotiate with the base station, user</span>
<span class="cm"> * space may have to intervene to rehandshake crypto and then tell us</span>
<span class="cm"> * when it is ready to transmit the packet we have &quot;queued&quot;. Still we</span>
<span class="cm"> * need to give it sometime after it reports being ok.</span>
<span class="cm"> *</span>
<span class="cm"> * On error, there is not much we can do. If the error was on TX, we</span>
<span class="cm"> * still wake the queue up to see if the next packet will be luckier.</span>
<span class="cm"> *</span>
<span class="cm"> * If _cmd_exit_idle() fails...well, it could be many things; most</span>
<span class="cm"> * commonly it is that something else took the device out of IDLE mode</span>
<span class="cm"> * (for example, the base station). In that case we get an -EILSEQ and</span>
<span class="cm"> * we are just going to ignore that one. If the device is back to</span>
<span class="cm"> * connected, then fine -- if it is someother state, the packet will</span>
<span class="cm"> * be dropped anyway.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_wake_tx_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">wake_tx_ws</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_skb</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(ws %p i2400m %p skb %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WAKE&amp;TX: skb disappeared!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If we have, somehow, lost the connection after this was</span>
<span class="cm">	 * queued, don&#39;t do anything; this might be the device got</span>
<span class="cm">	 * reset or just disconnected. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">net_dev</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_kfree</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_cmd_exit_idle</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WAKE&amp;TX: device didn&#39;t get out of idle: &quot;</span>
			<span class="s">&quot;%d - resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">i2400m_reset</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_RT_BUS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">state_wq</span><span class="p">,</span>
				    <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">I2400M_SS_IDLE</span><span class="p">,</span>
				    <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">-</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WAKE&amp;TX: error waiting for device to exit IDLE: &quot;</span>
			<span class="s">&quot;%d - resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">i2400m_reset</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_RT_BUS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>	<span class="cm">/* device still needs some time or it drops it */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_tx</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">I2400M_PT_DATA</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
<span class="nl">out_kfree:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>	<span class="cm">/* refcount transferred by _hard_start_xmit() */</span>
<span class="nl">out_put:</span>
	<span class="n">i2400m_put</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(ws %p i2400m %p skb %p) = void [%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ws</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Prepare the data payload TX header</span>
<span class="cm"> *</span>
<span class="cm"> * The i2400m expects a 4 byte header in front of a data packet.</span>
<span class="cm"> *</span>
<span class="cm"> * Because we pretend to be an ethernet device, this packet comes with</span>
<span class="cm"> * an ethernet header. Pull it and push our header.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_tx_prep_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m_pl_data_hdr</span> <span class="o">*</span><span class="n">pl_hdr</span><span class="p">;</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="n">pl_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_pl_data_hdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pl_hdr</span><span class="p">));</span>
	<span class="n">pl_hdr</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/*</span>
<span class="cm"> * Cleanup resources acquired during i2400m_net_wake_tx()</span>
<span class="cm"> *</span>
<span class="cm"> * This is called by __i2400m_dev_stop and means we have to make sure</span>
<span class="cm"> * the workqueue is flushed from any pending work.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_net_wake_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="cm">/* See i2400m_hard_start_xmit(), references are taken there</span>
<span class="cm">	 * and here we release them if the work was still</span>
<span class="cm">	 * pending. Note we can&#39;t differentiate work not pending vs</span>
<span class="cm">	 * never scheduled, so the NULL check does that. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_ws</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
	    <span class="o">&amp;&amp;</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">wake_tx_skb</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">wake_tx_skb</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_skb</span><span class="p">;</span>	<span class="cm">/* compat help */</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* compat help */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">i2400m_put</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">wake_tx_skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = void</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * TX an skb to an idle device</span>
<span class="cm"> *</span>
<span class="cm"> * When the device is in basestation-idle mode, we need to wake it up</span>
<span class="cm"> * and then TX. So we queue a work_struct for doing so.</span>
<span class="cm"> *</span>
<span class="cm"> * We need to get an extra ref for the skb (so it is not dropped), as</span>
<span class="cm"> * well as be careful not to queue more than one request (won&#39;t help</span>
<span class="cm"> * at all). If more than one request comes or there are errors, we</span>
<span class="cm"> * just drop the packets (see i2400m_hard_start_xmit()).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_net_wake_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(skb %p net_dev %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WAKE&amp;NETTX: &quot;</span>
			 <span class="s">&quot;skb %p sending %d bytes to radio</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">d_dump</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* We hold a ref count for i2400m and skb, so when</span>
<span class="cm">	 * stopping() the device, we need to cancel that work</span>
<span class="cm">	 * and if pending, release those resources. */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_ws</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
		<span class="n">i2400m_get</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
		<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_skb</span> <span class="o">=</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>	<span class="cm">/* transfer ref count */</span>
		<span class="n">i2400m_tx_prep_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wake_tx_ws</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Yes, this happens even if we stopped the</span>
<span class="cm">		 * queue -- blame the queue disciplines that</span>
<span class="cm">		 * queue without looking -- I guess there is a reason</span>
<span class="cm">		 * for that. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NETTX: device exiting idle, &quot;</span>
				 <span class="s">&quot;dropping skb %p, queue running %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">skb</span><span class="p">,</span> <span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">net_dev</span><span class="p">));</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(skb %p net_dev %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Transmit a packet to the base station on behalf of the network stack.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if ok, &lt; 0 errno code on error.</span>
<span class="cm"> *</span>
<span class="cm"> * We need to pull the ethernet header and add the hardware header,</span>
<span class="cm"> * which is currently set to all zeroes and reserved.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_net_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p net_dev %p skb %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="cm">/* FIXME: check eth hdr, only IPv4 is routed by the device as of now */</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">i2400m_tx_prep_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NETTX: skb %p sending %d bytes to radio</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">d_dump</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_tx</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">I2400M_PT_DATA</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p net_dev %p skb %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Transmit a packet to the base station on behalf of the network stack</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: NETDEV_TX_OK (always, even in case of error)</span>
<span class="cm"> *</span>
<span class="cm"> * In case of error, we just drop it. Reasons:</span>
<span class="cm"> *</span>
<span class="cm"> *  - we add a hw header to each skb, and if the network stack</span>
<span class="cm"> *    retries, we have no way to know if that skb has it or not.</span>
<span class="cm"> *</span>
<span class="cm"> *  - network protocols have their own drop-recovery mechanisms</span>
<span class="cm"> *</span>
<span class="cm"> *  - there is not much else we can do</span>
<span class="cm"> *</span>
<span class="cm"> * If the device is idle, we need to wake it up; that is an operation</span>
<span class="cm"> * that will sleep. See i2400m_net_wake_tx() for details.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="n">netdev_tx_t</span> <span class="nf">i2400m_hard_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">net_dev_to_i2400m</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(skb %p net_dev %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
	    <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">I2400M_SS_IDLE</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_net_wake_tx</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_net_tx</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">drop:</span>
		<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(skb %p net_dev %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400m_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">net_dev_to_i2400m</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&gt;=</span> <span class="n">I2400M_MAX_MTU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot change MTU to %d (max is %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">new_mtu</span><span class="p">,</span> <span class="n">I2400M_MAX_MTU</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We might want to kick the device</span>
<span class="cm">	 *</span>
<span class="cm">	 * There is not much we can do though, as the device requires</span>
<span class="cm">	 * that we send the data aggregated. By the time we receive</span>
<span class="cm">	 * this, there might be data pending to be sent or not...</span>
<span class="cm">	 */</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Create a fake ethernet header</span>
<span class="cm"> *</span>
<span class="cm"> * For emulating an ethernet device, every received IP header has to</span>
<span class="cm"> * be prefixed with an ethernet header. Fake it with the given</span>
<span class="cm"> * protocol.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400m_rx_fake_eth_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">_eth_hdr</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">net_dev_to_i2400m</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eth_hdr</span> <span class="o">=</span> <span class="n">_eth_hdr</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">eth_hdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">eth_hdr</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">eth_hdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">src_mac_addr</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="n">eth_hdr</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">));</span>
	<span class="n">eth_hdr</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * i2400m_net_rx - pass a network packet to the stack</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device instance</span>
<span class="cm"> * @skb_rx: the skb where the buffer pointed to by @buf is</span>
<span class="cm"> * @i: 1 if payload is the only one</span>
<span class="cm"> * @buf: pointer to the buffer containing the data</span>
<span class="cm"> * @len: buffer&#39;s length</span>
<span class="cm"> *</span>
<span class="cm"> * This is only used now for the v1.3 firmware. It will be deprecated</span>
<span class="cm"> * in &gt;= 2.6.31.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that due to firmware limitations, we don&#39;t have space to add</span>
<span class="cm"> * an ethernet header, so we need to copy each packet. Firmware</span>
<span class="cm"> * versions &gt;= v1.4 fix this [see i2400m_net_erx()].</span>
<span class="cm"> *</span>
<span class="cm"> * We just clone the skb and set it up so that it&#39;s skb-&gt;data pointer</span>
<span class="cm"> * points to &quot;buf&quot; and it&#39;s length.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if the payload is the last (or the only one) in a</span>
<span class="cm"> * multi-payload message, we don&#39;t clone the SKB but just reuse it.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is normally run from a thread context. However, we</span>
<span class="cm"> * still use netif_rx() instead of netif_receive_skb() as was</span>
<span class="cm"> * recommended in the mailing list. Reason is in some stress tests</span>
<span class="cm"> * when sending/receiving a lot of data we seem to hit a softlock in</span>
<span class="cm"> * the kernel&#39;s TCP implementation [aroudn tcp_delay_timer()]. Using</span>
<span class="cm"> * netif_rx() took care of the issue.</span>
<span class="cm"> *</span>
<span class="cm"> * This is, of course, still open to do more research on why running</span>
<span class="cm"> * with netif_receive_skb() hits this softlock. FIXME.</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: currently we don&#39;t do any efforts at distinguishing if what</span>
<span class="cm"> * we got was an IPv4 or IPv6 header, to setup the protocol field</span>
<span class="cm"> * correctly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_net_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb_rx</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buf_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p buf %p buf_len %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_get</span><span class="p">(</span><span class="n">skb_rx</span><span class="p">);</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RX: reusing first payload skb %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buf</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_end_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Yes, this is bad -- a lot of overhead -- see</span>
<span class="cm">		 * comments at the top of the file */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">__netdev_alloc_skb</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NETRX: no memory to realloc skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_skb_realloc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">),</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">i2400m_rx_fake_eth_header</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">,</span>
				  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">ETH_HLEN</span><span class="p">,</span>
				  <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">));</span>
	<span class="n">skb_set_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">buf_len</span><span class="p">;</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;NETRX: receiving %d bytes to network stack</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">buf_len</span><span class="p">);</span>
	<span class="n">d_dump</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="n">netif_rx_ni</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>	<span class="cm">/* see notes in function header */</span>
<span class="nl">error_skb_realloc:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p buf %p buf_len %d) = void</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * i2400m_net_erx - pass a network packet to the stack (extended version)</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400m: device descriptor</span>
<span class="cm"> * @skb: the skb where the packet is - the skb should be set to point</span>
<span class="cm"> *     at the IP packet; this function will add ethernet headers if</span>
<span class="cm"> *     needed.</span>
<span class="cm"> * @cs: packet type</span>
<span class="cm"> *</span>
<span class="cm"> * This is only used now for firmware &gt;= v1.4. Note it is quite</span>
<span class="cm"> * similar to i2400m_net_rx() (used only for v1.3 firmware).</span>
<span class="cm"> *</span>
<span class="cm"> * This function is normally run from a thread context. However, we</span>
<span class="cm"> * still use netif_rx() instead of netif_receive_skb() as was</span>
<span class="cm"> * recommended in the mailing list. Reason is in some stress tests</span>
<span class="cm"> * when sending/receiving a lot of data we seem to hit a softlock in</span>
<span class="cm"> * the kernel&#39;s TCP implementation [aroudn tcp_delay_timer()]. Using</span>
<span class="cm"> * netif_rx() took care of the issue.</span>
<span class="cm"> *</span>
<span class="cm"> * This is, of course, still open to do more research on why running</span>
<span class="cm"> * with netif_receive_skb() hits this softlock. FIXME.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_net_erx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		    <span class="k">enum</span> <span class="n">i2400m_cs</span> <span class="n">cs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">protocol</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p skb %p [%u] cs %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">i2400m</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">cs</span><span class="p">);</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">I2400M_CS_IPV4_0</span>:
	<span class="k">case</span> <span class="n">I2400M_CS_IPV4</span>:
		<span class="n">protocol</span> <span class="o">=</span> <span class="n">ETH_P_IP</span><span class="p">;</span>
		<span class="n">i2400m_rx_fake_eth_header</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">,</span>
					  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">ETH_HLEN</span><span class="p">,</span>
					  <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">));</span>
		<span class="n">skb_set_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="n">ETH_HLEN</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
		<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ERX: BUG? CS type %u unsupported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cs</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">d_printf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ERX: receiving %d bytes to the network stack</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">d_dump</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">netif_rx_ni</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>	<span class="cm">/* see notes in function header */</span>
<span class="nl">error:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p skb %p [%u] cs %d) = void</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">i2400m</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">cs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">i2400m_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">i2400m_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">i2400m_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">i2400m_hard_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span> <span class="o">=</span> <span class="n">i2400m_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span> <span class="o">=</span> <span class="n">i2400m_change_mtu</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">i2400m_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">net_dev_to_i2400m</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span>
	        <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_name</span> <span class="o">?</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">i2400m_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_drvinfo</span> <span class="o">=</span> <span class="n">i2400m_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span> <span class="o">=</span> <span class="n">ethtool_op_get_link</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * i2400m_netdev_setup - Setup setup @net_dev&#39;s i2400m private data</span>
<span class="cm"> *</span>
<span class="cm"> * Called by alloc_netdev()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">i2400m_netdev_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;(net_dev %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
	<span class="n">ether_setup</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">I2400M_MAX_MTU</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="n">I2400M_TX_QLEN</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span>
		  <span class="n">NETIF_F_VLAN_CHALLENGED</span>
		<span class="o">|</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span>
		<span class="n">IFF_NOARP</span>		<span class="cm">/* i2400m is apure IP device */</span>
		<span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">IFF_BROADCAST</span>	<span class="cm">/* i2400m is P2P */</span>
		   <span class="o">&amp;</span> <span class="o">~</span><span class="n">IFF_MULTICAST</span><span class="p">);</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">I2400M_TX_TIMEOUT</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400m_netdev_ops</span><span class="p">;</span>
	<span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400m_ethtool_ops</span><span class="p">;</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;(net_dev %p) = void</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net_dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">i2400m_netdev_setup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
