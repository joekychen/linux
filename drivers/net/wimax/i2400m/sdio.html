<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wimax › i2400m › sdio.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>sdio.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Intel Wireless WiMAX Connection 2400m</span>
<span class="cm"> * Linux driver model glue for the SDIO device, reset &amp; fw upload</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Intel Corporation &lt;linux-wimax@intel.com&gt;</span>
<span class="cm"> * Dirk Brandewie &lt;dirk.j.brandewie@intel.com&gt;</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> * Yanir Lubetkin &lt;yanirx.lubetkin@intel.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * See i2400m-sdio.h for a general description of this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * This file implements driver model glue, and hook ups for the</span>
<span class="cm"> * generic driver to implement the bus-specific functions (device</span>
<span class="cm"> * communication setup/tear down, firmware upload and resetting).</span>
<span class="cm"> *</span>
<span class="cm"> * ROADMAP</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_probe()</span>
<span class="cm"> *   alloc_netdev()</span>
<span class="cm"> *     i2400ms_netdev_setup()</span>
<span class="cm"> *       i2400ms_init()</span>
<span class="cm"> *       i2400m_netdev_setup()</span>
<span class="cm"> *   i2400ms_enable_function()</span>
<span class="cm"> *   i2400m_setup()</span>
<span class="cm"> *</span>
<span class="cm"> * i2400m_remove()</span>
<span class="cm"> *     i2400m_release()</span>
<span class="cm"> *     free_netdev(net_dev)</span>
<span class="cm"> *</span>
<span class="cm"> * i2400ms_bus_reset()            Called by i2400m_reset</span>
<span class="cm"> *   __i2400ms_reset()</span>
<span class="cm"> *     __i2400ms_send_barker()</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/mmc/sdio_ids.h&gt;</span>
<span class="cp">#include &lt;linux/mmc/sdio.h&gt;</span>
<span class="cp">#include &lt;linux/mmc/sdio_func.h&gt;</span>
<span class="cp">#include &quot;i2400m-sdio.h&quot;</span>
<span class="cp">#include &lt;linux/wimax/i2400m.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#define D_SUBMODULE main</span>
<span class="cp">#include &quot;sdio-debug-levels.h&quot;</span>

<span class="cm">/* IOE WiMAX function timeout in seconds */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ioe_timeout</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ioe_timeout</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">i2400ms_debug_params</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">i2400ms_debug_params</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400ms_debug_params</span><span class="p">),</span>
		    <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span>
		 <span class="s">&quot;String of space-separated NAME:VALUE pairs, where NAMEs &quot;</span>
		 <span class="s">&quot;are the different debug submodules and VALUE are the &quot;</span>
		 <span class="s">&quot;initial debug value to set.&quot;</span><span class="p">);</span>

<span class="cm">/* Our firmware file name list */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">i2400ms_bus_fw_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#define I2400MS_FW_FILE_NAME &quot;i2400m-fw-sdio-1.3.sbcf&quot;</span>
	<span class="n">I2400MS_FW_FILE_NAME</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_poke_table</span> <span class="n">i2400ms_pokes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">I2400M_FW_POKE</span><span class="p">(</span><span class="mh">0x6BE260</span><span class="p">,</span> <span class="mh">0x00000088</span><span class="p">),</span>
	<span class="n">I2400M_FW_POKE</span><span class="p">(</span><span class="mh">0x080550</span><span class="p">,</span> <span class="mh">0x00000005</span><span class="p">),</span>
	<span class="n">I2400M_FW_POKE</span><span class="p">(</span><span class="mh">0xAE0000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">),</span>
	<span class="n">I2400M_FW_POKE</span><span class="p">(</span><span class="mh">0x000000</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">),</span> <span class="cm">/* MUST be 0 terminated or bad</span>
<span class="cm">					       * things will happen */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Enable the SDIO function</span>
<span class="cm"> *</span>
<span class="cm"> * Tries to enable the SDIO function; might fail if it is still not</span>
<span class="cm"> * ready (in some hardware, the SDIO WiMAX function is only enabled</span>
<span class="cm"> * when we ask it to explicitly doing). Tries until a timeout is</span>
<span class="cm"> * reached.</span>
<span class="cm"> *</span>
<span class="cm"> * The @maxtries argument indicates how many times (at most) it should</span>
<span class="cm"> * be tried to enable the function. 0 means forever. This acts along</span>
<span class="cm"> * with the timeout (ie: it&#39;ll stop trying as soon as the maximum</span>
<span class="cm"> * number of tries is reached _or_ as soon as the timeout is reached).</span>
<span class="cm"> *</span>
<span class="cm"> * The reverse of this is...sdio_disable_function()</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if the SDIO function was enabled, &lt; 0 errno code on</span>
<span class="cm"> *     error (-ENODEV when it was unable to enable the function).</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400ms_enable_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">maxtries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(func %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="cm">/* Setup timeout (FIXME: This needs to read the CIS table to</span>
<span class="cm">	 * get a real timeout) and then wait for the device to signal</span>
<span class="cm">	 * it is ready */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">get_jiffies_64</span><span class="p">()</span> <span class="o">+</span> <span class="n">ioe_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">time_before64</span><span class="p">(</span><span class="n">get_jiffies_64</span><span class="p">(),</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sdio_claim_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * There is a sillicon bug on the IWMC3200, where the</span>
<span class="cm">		 * IOE timeout will cause problems on Moorestown</span>
<span class="cm">		 * platforms (system hang). We explicitly overwrite</span>
<span class="cm">		 * func-&gt;enable_timeout here to work around the issue.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">iwmc3200</span><span class="p">)</span>
			<span class="n">func</span><span class="o">-&gt;</span><span class="n">enable_timeout</span> <span class="o">=</span> <span class="n">IWMC3200_IOR_TIMEOUT</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sdio_enable_func</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdio_release_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
			<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SDIO function enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">function_enabled</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SDIO function failed to enable: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">sdio_release_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maxtries</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">tries</span> <span class="o">&gt;=</span> <span class="n">maxtries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="n">I2400MS_INIT_SLEEP_INTERVAL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* If timed out, device is not there yet -- get -ENODEV so</span>
<span class="cm">	 * the device driver core will retry later on. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Can&#39;t enable WiMAX function; &quot;</span>
			<span class="s">&quot; has the function been enabled?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">function_enabled:</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(func %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Setup minimal device communication infrastructure needed to at</span>
<span class="cm"> * least be able to update the firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * Note the ugly trick: if we are in the probe path</span>
<span class="cm"> * (i2400ms-&gt;debugfs_dentry == NULL), we only retry function</span>
<span class="cm"> * enablement one, to avoid racing with the iwmc3200 top controller.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400ms_bus_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400ms</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span><span class="p">;</span>

	<span class="n">sdio_claim_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sdio_set_block_size</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">I2400MS_BLK_SIZE</span><span class="p">);</span>
	<span class="n">sdio_release_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Failed to set block size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_set_blk_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">iwmc3200</span> <span class="o">&amp;&amp;</span> <span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">retries</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400ms_enable_function</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">,</span> <span class="n">retries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot enable SDIO function: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_func_enable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400ms_tx_setup</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_tx_setup</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400ms_rx_setup</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_rx_setup</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_rx_setup:</span>
	<span class="n">i2400ms_tx_release</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">);</span>
<span class="nl">error_tx_setup:</span>
	<span class="n">sdio_claim_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="n">sdio_disable_func</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="n">sdio_release_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
<span class="nl">error_func_enable:</span>
<span class="nl">error_set_blk_size:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Tear down minimal device communication infrastructure needed to at</span>
<span class="cm"> * least be able to update the firmware.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400ms_bus_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400ms</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>

	<span class="n">i2400ms_rx_release</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">);</span>
	<span class="n">i2400ms_tx_release</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">);</span>
	<span class="n">sdio_claim_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="n">sdio_disable_func</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="n">sdio_release_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Setup driver resources needed to communicate with the device</span>
<span class="cm"> *</span>
<span class="cm"> * The fw needs some time to settle, and it was just uploaded,</span>
<span class="cm"> * so give it a break first. I&#39;d prefer to just wait for the device to</span>
<span class="cm"> * send something, but seems the poking we do to enable SDIO stuff</span>
<span class="cm"> * interferes with it, so just give it a break before starting...</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400ms_bus_dev_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400ms</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;(i2400m %p) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Sends a barker buffer to the device</span>
<span class="cm"> *</span>
<span class="cm"> * This helper will allocate a kmalloced buffer and use it to transmit</span>
<span class="cm"> * (then free it). Reason for this is that the SDIO host controller</span>
<span class="cm"> * expects alignment (unknown exactly which) which the stack won&#39;t</span>
<span class="cm"> * really provide and certain arches/host-controller combinations</span>
<span class="cm"> * cannot use stack/vmalloc/text areas for DMA transfers.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">__i2400ms_send_barker</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">barker</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">barker_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>  <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">I2400MS_BLK_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_kzalloc</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">barker</span><span class="p">,</span> <span class="n">barker_size</span><span class="p">);</span>
	<span class="n">sdio_claim_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sdio_memcpy_toio</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">I2400MS_BLK_SIZE</span><span class="p">);</span>
	<span class="n">sdio_release_host</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">d_printf</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;E: barker error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="nl">error_kzalloc:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Reset a device at different levels (warm, cold or bus)</span>
<span class="cm"> *</span>
<span class="cm"> * @i2400ms: device descriptor</span>
<span class="cm"> * @reset_type: soft, warm or bus reset (I2400M_RT_WARM/SOFT/BUS)</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: not tested -- need to confirm expected effects</span>
<span class="cm"> *</span>
<span class="cm"> * Warm and cold resets get an SDIO reset if they fail (unimplemented)</span>
<span class="cm"> *</span>
<span class="cm"> * Warm reset:</span>
<span class="cm"> *</span>
<span class="cm"> * The device will be fully reset internally, but won&#39;t be</span>
<span class="cm"> * disconnected from the bus (so no reenumeration will</span>
<span class="cm"> * happen). Firmware upload will be necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * The device will send a reboot barker that will trigger the driver</span>
<span class="cm"> * to reinitialize the state via __i2400m_dev_reset_handle.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Cold and bus reset:</span>
<span class="cm"> *</span>
<span class="cm"> * The device will be fully reset internally, disconnected from the</span>
<span class="cm"> * bus an a reenumeration will happen. Firmware upload will be</span>
<span class="cm"> * necessary. Thus, we don&#39;t do any locking or struct</span>
<span class="cm"> * reinitialization, as we are going to be fully disconnected and</span>
<span class="cm"> * reenumerated.</span>
<span class="cm"> *</span>
<span class="cm"> * Note we need to return -ENODEV if a warm reset was requested and we</span>
<span class="cm"> * had to resort to a bus reset. See i2400m_op_reset(), wimax_reset()</span>
<span class="cm"> * and wimax_dev-&gt;op_reset.</span>
<span class="cm"> *</span>
<span class="cm"> * WARNING: no driver state saved/fixed</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400ms_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_reset_type</span> <span class="n">rt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400ms</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">i2400m_dev</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">__le32</span> <span class="n">i2400m_WARM_BOOT_BARKER</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_WARM_RESET_BARKER</span><span class="p">),</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_WARM_RESET_BARKER</span><span class="p">),</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_WARM_RESET_BARKER</span><span class="p">),</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_WARM_RESET_BARKER</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">__le32</span> <span class="n">i2400m_COLD_BOOT_BARKER</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_COLD_RESET_BARKER</span><span class="p">),</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_COLD_RESET_BARKER</span><span class="p">),</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_COLD_RESET_BARKER</span><span class="p">),</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">I2400M_COLD_RESET_BARKER</span><span class="p">),</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="n">I2400M_RT_WARM</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__i2400ms_send_barker</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">,</span> <span class="n">i2400m_WARM_BOOT_BARKER</span><span class="p">,</span>
					       <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_WARM_BOOT_BARKER</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="n">I2400M_RT_COLD</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__i2400ms_send_barker</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">,</span> <span class="n">i2400m_COLD_BOOT_BARKER</span><span class="p">,</span>
					       <span class="k">sizeof</span><span class="p">(</span><span class="n">i2400m_COLD_BOOT_BARKER</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="n">I2400M_RT_BUS</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">do_bus_reset:</span>

		<span class="n">i2400ms_bus_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>

		<span class="cm">/* Wait for the device to settle */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span>  <span class="n">i2400ms_bus_setup</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rt</span> <span class="o">!=</span> <span class="n">I2400M_RT_BUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s reset failed (%d); trying SDIO reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rt</span> <span class="o">==</span> <span class="n">I2400M_RT_WARM</span> <span class="o">?</span> <span class="s">&quot;warm&quot;</span> <span class="o">:</span> <span class="s">&quot;cold&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="n">rt</span> <span class="o">=</span> <span class="n">I2400M_RT_BUS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_bus_reset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400ms_netdev_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="n">net_dev_to_i2400m</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400ms</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">i2400ms_init</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">);</span>
	<span class="n">i2400m_netdev_setup</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Debug levels control; see debug.h</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">d_level</span> <span class="n">D_LEVEL</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">main</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">tx</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">rx</span><span class="p">),</span>
	<span class="n">D_SUBMODULE_DEFINE</span><span class="p">(</span><span class="n">fw</span><span class="p">),</span>
<span class="p">};</span>
<span class="kt">size_t</span> <span class="n">D_LEVEL_SIZE</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">D_LEVEL</span><span class="p">);</span>


<span class="cp">#define __debugfs_register(prefix, name, parent)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	result = d_level_register_debugfs(prefix, name, parent);	\</span>
<span class="cp">	if (result &lt; 0)							\</span>
<span class="cp">		goto error;						\</span>
<span class="cp">} while (0)</span>


<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400ms_debugfs_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">i2400m</span><span class="p">.</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">debugfs_dentry</span><span class="p">;</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;i2400m-sdio&quot;</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* No debugfs support */</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">__debugfs_register</span><span class="p">(</span><span class="s">&quot;dl_&quot;</span><span class="p">,</span> <span class="n">main</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">__debugfs_register</span><span class="p">(</span><span class="s">&quot;dl_&quot;</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">__debugfs_register</span><span class="p">(</span><span class="s">&quot;dl_&quot;</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="n">__debugfs_register</span><span class="p">(</span><span class="s">&quot;dl_&quot;</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">);</span>
	<span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">device_type</span> <span class="n">i2400ms_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;wimax&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Probe a i2400m interface and register it</span>
<span class="cm"> *</span>
<span class="cm"> * @func:    SDIO function</span>
<span class="cm"> * @id:      SDIO device ID</span>
<span class="cm"> * @returns: 0 if ok, &lt; 0 errno code on error.</span>
<span class="cm"> *</span>
<span class="cm"> * Alloc a net device, initialize the bus-specific details and then</span>
<span class="cm"> * calls the bus-generic initialization routine. That will register</span>
<span class="cm"> * the wimax and netdev devices, upload the firmware [using</span>
<span class="cm"> * _bus_bm_*()], call _bus_dev_start() to finalize the setup of the</span>
<span class="cm"> * communication with the device and then will start to talk to it to</span>
<span class="cm"> * finnish setting it up.</span>
<span class="cm"> *</span>
<span class="cm"> * Initialization is tricky; some instances of the hw are packed with</span>
<span class="cm"> * others in a way that requires a third driver that enables the WiMAX</span>
<span class="cm"> * function. In those cases, we can&#39;t enable the SDIO function and</span>
<span class="cm"> * we&#39;ll return with -ENODEV. When the driver that enables the WiMAX</span>
<span class="cm"> * function does its thing, it has to do a bus_rescan_devices() on the</span>
<span class="cm"> * SDIO bus so this driver is called again to enumerate the WiMAX</span>
<span class="cm"> * function.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="kt">int</span> <span class="nf">i2400ms_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span>
		  <span class="k">const</span> <span class="k">struct</span> <span class="n">sdio_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span><span class="p">;</span>

	<span class="cm">/* Allocate instance [calls i2400m_netdev_setup() on it]. */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">net_dev</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">i2400ms</span><span class="p">),</span> <span class="s">&quot;wmx%d&quot;</span><span class="p">,</span>
			       <span class="n">i2400ms_netdev_setup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no memory for network device instance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_alloc_netdev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">SET_NETDEV_DEVTYPE</span><span class="p">(</span><span class="n">net_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i2400ms_type</span><span class="p">);</span>
	<span class="n">i2400m</span> <span class="o">=</span> <span class="n">net_dev_to_i2400m</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">i2400ms</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400ms</span><span class="p">,</span> <span class="n">i2400m</span><span class="p">);</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">net_dev</span><span class="p">;</span>
	<span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
	<span class="n">sdio_set_drvdata</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">i2400ms</span><span class="p">);</span>

	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_tx_block_size</span> <span class="o">=</span> <span class="n">I2400MS_BLK_SIZE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Room required in the TX queue for SDIO message to accommodate</span>
<span class="cm">	 * a smallest payload while allocating header space is 224 bytes,</span>
<span class="cm">	 * which is the smallest message size(the block size 256 bytes)</span>
<span class="cm">	 * minus the smallest message header size(32 bytes).</span>
<span class="cm">	 */</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_tx_room_min</span> <span class="o">=</span> <span class="n">I2400MS_BLK_SIZE</span> <span class="o">-</span> <span class="n">I2400M_PL_ALIGN</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_pl_size_max</span> <span class="o">=</span> <span class="n">I2400MS_PL_SIZE_MAX</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_setup</span> <span class="o">=</span> <span class="n">i2400ms_bus_setup</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_dev_start</span> <span class="o">=</span> <span class="n">i2400ms_bus_dev_start</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_dev_stop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_release</span> <span class="o">=</span> <span class="n">i2400ms_bus_release</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_tx_kick</span> <span class="o">=</span> <span class="n">i2400ms_bus_tx_kick</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_reset</span> <span class="o">=</span> <span class="n">i2400ms_bus_reset</span><span class="p">;</span>
	<span class="cm">/* The iwmc3200-wimax sometimes requires the driver to try</span>
<span class="cm">	 * hard when we paint it into a corner. */</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_retries</span> <span class="o">=</span> <span class="n">I2400M_SDIO_BOOT_RETRIES</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_cmd_send</span> <span class="o">=</span> <span class="n">i2400ms_bus_bm_cmd_send</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_wait_for_ack</span> <span class="o">=</span> <span class="n">i2400ms_bus_bm_wait_for_ack</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_fw_names</span> <span class="o">=</span> <span class="n">i2400ms_bus_fw_names</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_mac_addr_impaired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">bus_bm_pokes_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400ms_pokes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX</span>:
	<span class="k">case</span> <span class="n">SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX_2G5</span>:
		<span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">iwmc3200</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">iwmc3200</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400m_setup</span><span class="p">(</span><span class="n">i2400m</span><span class="p">,</span> <span class="n">I2400M_BRI_NO_REBOOT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot setup device: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_setup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">i2400ms_debugfs_add</span><span class="p">(</span><span class="n">i2400ms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot create SDIO debugfs: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">result</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_debugfs_add</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_debugfs_add:</span>
	<span class="n">i2400m_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
<span class="nl">error_setup:</span>
	<span class="n">sdio_set_drvdata</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
<span class="nl">error_alloc_netdev:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span>
<span class="kt">void</span> <span class="nf">i2400ms_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">sdio_func</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400ms</span> <span class="o">*</span><span class="n">i2400ms</span> <span class="o">=</span> <span class="n">sdio_get_drvdata</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">i2400m</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span> <span class="o">=</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">;</span>

	<span class="n">d_fnstart</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SDIO func %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="n">debugfs_remove_recursive</span><span class="p">(</span><span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span><span class="p">);</span>
	<span class="n">i2400ms</span><span class="o">-&gt;</span><span class="n">debugfs_dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">i2400m_release</span><span class="p">(</span><span class="n">i2400m</span><span class="p">);</span>
	<span class="n">sdio_set_drvdata</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="n">d_fnend</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;SDIO func %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">sdio_device_id</span> <span class="n">i2400ms_sdio_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* Intel: i2400m WiMAX (iwmc3200) over SDIO */</span>
	<span class="p">{</span> <span class="n">SDIO_DEVICE</span><span class="p">(</span><span class="n">SDIO_VENDOR_ID_INTEL</span><span class="p">,</span>
		      <span class="n">SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">SDIO_DEVICE</span><span class="p">(</span><span class="n">SDIO_VENDOR_ID_INTEL</span><span class="p">,</span>
		      <span class="n">SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX_2G5</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="cm">/* end: all zeroes */</span> <span class="p">},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">sdio</span><span class="p">,</span> <span class="n">i2400ms_sdio_ids</span><span class="p">);</span>


<span class="k">static</span>
<span class="k">struct</span> <span class="n">sdio_driver</span> <span class="n">i2400m_sdio_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">KBUILD_MODNAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">i2400ms_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">i2400ms_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">i2400ms_sdio_ids</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">i2400ms_driver_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">d_parse_params</span><span class="p">(</span><span class="n">D_LEVEL</span><span class="p">,</span> <span class="n">D_LEVEL_SIZE</span><span class="p">,</span> <span class="n">i2400ms_debug_params</span><span class="p">,</span>
		       <span class="s">&quot;i2400m_sdio.debug&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sdio_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m_sdio_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">i2400ms_driver_init</span><span class="p">);</span>


<span class="k">static</span>
<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">i2400ms_driver_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sdio_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i2400m_sdio_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">i2400ms_driver_exit</span><span class="p">);</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Intel Corporation &lt;linux-wimax@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel 2400M WiMAX networking for SDIO&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="n">I2400MS_FW_FILE_NAME</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
