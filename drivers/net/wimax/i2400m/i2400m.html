<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › wimax › i2400m › i2400m.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>i2400m.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Intel Wireless WiMAX Connection 2400m</span>
<span class="cm"> * Declarations for bus-generic internal APIs</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007-2008 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> *</span>
<span class="cm"> *   * Redistributions of source code must retain the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> *   * Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *     notice, this list of conditions and the following disclaimer in</span>
<span class="cm"> *     the documentation and/or other materials provided with the</span>
<span class="cm"> *     distribution.</span>
<span class="cm"> *   * Neither the name of Intel Corporation nor the names of its</span>
<span class="cm"> *     contributors may be used to endorse or promote products derived</span>
<span class="cm"> *     from this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Intel Corporation &lt;linux-wimax@intel.com&gt;</span>
<span class="cm"> * Inaky Perez-Gonzalez &lt;inaky.perez-gonzalez@intel.com&gt;</span>
<span class="cm"> * Yanir Lubetkin &lt;yanirx.lubetkin@intel.com&gt;</span>
<span class="cm"> *  - Initial implementation</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * GENERAL DRIVER ARCHITECTURE</span>
<span class="cm"> *</span>
<span class="cm"> * The i2400m driver is split in the following two major parts:</span>
<span class="cm"> *</span>
<span class="cm"> *  - bus specific driver</span>
<span class="cm"> *  - bus generic driver (this part)</span>
<span class="cm"> *</span>
<span class="cm"> * The bus specific driver sets up stuff specific to the bus the</span>
<span class="cm"> * device is connected to (USB, SDIO, PCI, tam-tam...non-authoritative</span>
<span class="cm"> * nor binding list) which is basically the device-model management</span>
<span class="cm"> * (probe/disconnect, etc), moving data from device to kernel and</span>
<span class="cm"> * back, doing the power saving details and reseting the device.</span>
<span class="cm"> *</span>
<span class="cm"> * For details on each bus-specific driver, see it&#39;s include file,</span>
<span class="cm"> * i2400m-BUSNAME.h</span>
<span class="cm"> *</span>
<span class="cm"> * The bus-generic functionality break up is:</span>
<span class="cm"> *</span>
<span class="cm"> *  - Firmware upload: fw.c - takes care of uploading firmware to the</span>
<span class="cm"> *        device. bus-specific driver just needs to provides a way to</span>
<span class="cm"> *        execute boot-mode commands and to reset the device.</span>
<span class="cm"> *</span>
<span class="cm"> *  - RX handling: rx.c - receives data from the bus-specific code and</span>
<span class="cm"> *        feeds it to the network or WiMAX stack or uses it to modify</span>
<span class="cm"> *        the driver state. bus-specific driver only has to receive</span>
<span class="cm"> *        frames and pass them to this module.</span>
<span class="cm"> *</span>
<span class="cm"> *  - TX handling: tx.c - manages the TX FIFO queue and provides means</span>
<span class="cm"> *        for the bus-specific TX code to pull data from the FIFO</span>
<span class="cm"> *        queue. bus-specific code just pulls frames from this module</span>
<span class="cm"> *        to sends them to the device.</span>
<span class="cm"> *</span>
<span class="cm"> *  - netdev glue: netdev.c - interface with Linux networking</span>
<span class="cm"> *        stack. Pass around data frames, and configure when the</span>
<span class="cm"> *        device is up and running or shutdown (through ifconfig up /</span>
<span class="cm"> *        down). Bus-generic only.</span>
<span class="cm"> *</span>
<span class="cm"> *  - control ops: control.c - implements various commands for</span>
<span class="cm"> *        controlling the device. bus-generic only.</span>
<span class="cm"> *</span>
<span class="cm"> *  - device model glue: driver.c - implements helpers for the</span>
<span class="cm"> *        device-model glue done by the bus-specific layer</span>
<span class="cm"> *        (setup/release the driver resources), turning the device on</span>
<span class="cm"> *        and off, handling the device reboots/resets and a few simple</span>
<span class="cm"> *        WiMAX stack ops.</span>
<span class="cm"> *</span>
<span class="cm"> * Code is also broken up in linux-glue / device-glue.</span>
<span class="cm"> *</span>
<span class="cm"> * Linux glue contains functions that deal mostly with gluing with the</span>
<span class="cm"> * rest of the Linux kernel.</span>
<span class="cm"> *</span>
<span class="cm"> * Device-glue are functions that deal mostly with the way the device</span>
<span class="cm"> * does things and talk the device&#39;s language.</span>
<span class="cm"> *</span>
<span class="cm"> * device-glue code is licensed BSD so other open source OSes can take</span>
<span class="cm"> * it to implement their drivers.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * APIs AND HEADER FILES</span>
<span class="cm"> *</span>
<span class="cm"> * This bus generic code exports three APIs:</span>
<span class="cm"> *</span>
<span class="cm"> *  - HDI (host-device interface) definitions common to all busses</span>
<span class="cm"> *    (include/linux/wimax/i2400m.h); these can be also used by user</span>
<span class="cm"> *    space code.</span>
<span class="cm"> *  - internal API for the bus-generic code</span>
<span class="cm"> *  - external API for the bus-specific drivers</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * LIFE CYCLE:</span>
<span class="cm"> *</span>
<span class="cm"> * When the bus-specific driver probes, it allocates a network device</span>
<span class="cm"> * with enough space for it&#39;s data structue, that must contain a</span>
<span class="cm"> * &amp;struct i2400m at the top.</span>
<span class="cm"> *</span>
<span class="cm"> * On probe, it needs to fill the i2400m members marked as [fill], as</span>
<span class="cm"> * well as i2400m-&gt;wimax_dev.net_dev and call i2400m_setup(). The</span>
<span class="cm"> * i2400m driver will only register with the WiMAX and network stacks;</span>
<span class="cm"> * the only access done to the device is to read the MAC address so we</span>
<span class="cm"> * can register a network device.</span>
<span class="cm"> *</span>
<span class="cm"> * The high-level call flow is:</span>
<span class="cm"> *</span>
<span class="cm"> * bus_probe()</span>
<span class="cm"> *   i2400m_setup()</span>
<span class="cm"> *     i2400m-&gt;bus_setup()</span>
<span class="cm"> *     boot rom initialization / read mac addr</span>
<span class="cm"> *     network / WiMAX stacks registration</span>
<span class="cm"> *     i2400m_dev_start()</span>
<span class="cm"> *       i2400m-&gt;bus_dev_start()</span>
<span class="cm"> *       i2400m_dev_initialize()</span>
<span class="cm"> *</span>
<span class="cm"> * The reverse applies for a disconnect() call:</span>
<span class="cm"> *</span>
<span class="cm"> * bus_disconnect()</span>
<span class="cm"> *   i2400m_release()</span>
<span class="cm"> *     i2400m_dev_stop()</span>
<span class="cm"> *       i2400m_dev_shutdown()</span>
<span class="cm"> *       i2400m-&gt;bus_dev_stop()</span>
<span class="cm"> *     network / WiMAX stack unregistration</span>
<span class="cm"> *     i2400m-&gt;bus_release()</span>
<span class="cm"> *</span>
<span class="cm"> * At this point, control and data communications are possible.</span>
<span class="cm"> *</span>
<span class="cm"> * While the device is up, it might reset. The bus-specific driver has</span>
<span class="cm"> * to catch that situation and call i2400m_dev_reset_handle() to deal</span>
<span class="cm"> * with it (reset the internal driver structures and go back to square</span>
<span class="cm"> * one).</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __I2400M_H__</span>
<span class="cp">#define __I2400M_H__</span>

<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;net/wimax.h&gt;</span>
<span class="cp">#include &lt;linux/wimax/i2400m.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="k">enum</span> <span class="p">{</span>
<span class="cm">/* netdev interface */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Out of NWG spec (R1_v1.2.2), 3.3.3 ASN Bearer Plane MTU Size</span>
<span class="cm">	 *</span>
<span class="cm">	 * The MTU is 1400 or less</span>
<span class="cm">	 */</span>
	<span class="n">I2400M_MAX_MTU</span> <span class="o">=</span> <span class="mi">1400</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Misc constants */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Size of the Boot Mode Command buffer */</span>
	<span class="n">I2400M_BM_CMD_BUF_SIZE</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
	<span class="n">I2400M_BM_ACK_BUF_SIZE</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="cm">/* Maximum number of bus reset can be retried */</span>
	<span class="n">I2400M_BUS_RESET_RETRIES</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct i2400m_poke_table - Hardware poke table for the Intel 2400m</span>
<span class="cm"> *</span>
<span class="cm"> * This structure will be used to create a device specific poke table</span>
<span class="cm"> * to put the device in a consistent state at boot time.</span>
<span class="cm"> *</span>
<span class="cm"> * @address: The device address to poke</span>
<span class="cm"> *</span>
<span class="cm"> * @data: The data value to poke to the device address</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2400m_poke_table</span><span class="p">{</span>
	<span class="n">__le32</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define I2400M_FW_POKE(a, d) {		\</span>
<span class="cp">	.address = cpu_to_le32(a),	\</span>
<span class="cp">	.data = cpu_to_le32(d)		\</span>
<span class="cp">}</span>


<span class="cm">/**</span>
<span class="cm"> * i2400m_reset_type - methods to reset a device</span>
<span class="cm"> *</span>
<span class="cm"> * @I2400M_RT_WARM: Reset without device disconnection, device handles</span>
<span class="cm"> *     are kept valid but state is back to power on, with firmware</span>
<span class="cm"> *     re-uploaded.</span>
<span class="cm"> * @I2400M_RT_COLD: Tell the device to disconnect itself from the bus</span>
<span class="cm"> *     and reconnect. Renders all device handles invalid.</span>
<span class="cm"> * @I2400M_RT_BUS: Tells the bus to reset the device; last measure</span>
<span class="cm"> *     used when both types above don&#39;t work.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">i2400m_reset_type</span> <span class="p">{</span>
	<span class="n">I2400M_RT_WARM</span><span class="p">,</span>	<span class="cm">/* first measure */</span>
	<span class="n">I2400M_RT_COLD</span><span class="p">,</span>	<span class="cm">/* second measure */</span>
	<span class="n">I2400M_RT_BUS</span><span class="p">,</span>	<span class="cm">/* call in artillery */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">i2400m_reset_ctx</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">i2400m_roq</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">i2400m_barker_db</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct i2400m - descriptor for an Intel 2400m</span>
<span class="cm"> *</span>
<span class="cm"> * Members marked with [fill] must be filled out/initialized before</span>
<span class="cm"> * calling i2400m_setup().</span>
<span class="cm"> *</span>
<span class="cm"> * Note the @bus_setup/@bus_release, @bus_dev_start/@bus_dev_release</span>
<span class="cm"> * call pairs are very much doing almost the same, and depending on</span>
<span class="cm"> * the underlying bus, some stuff has to be put in one or the</span>
<span class="cm"> * other. The idea of setup/release is that they setup the minimal</span>
<span class="cm"> * amount needed for loading firmware, where us dev_start/stop setup</span>
<span class="cm"> * the rest needed to do full data/control traffic.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_tx_block_size: [fill] SDIO imposes a 256 block size, USB 16,</span>
<span class="cm"> *     so we have a tx_blk_size variable that the bus layer sets to</span>
<span class="cm"> *     tell the engine how much of that we need.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_tx_room_min: [fill] Minimum room required while allocating</span>
<span class="cm"> *     TX queue&#39;s buffer space for message header. SDIO requires</span>
<span class="cm"> *     224 bytes and USB 16 bytes. Refer bus specific driver code</span>
<span class="cm"> *     for details.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_pl_size_max: [fill] Maximum payload size.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_setup: [optional fill] Function called by the bus-generic code</span>
<span class="cm"> *     [i2400m_setup()] to setup the basic bus-specific communications</span>
<span class="cm"> *     to the the device needed to load firmware. See LIFE CYCLE above.</span>
<span class="cm"> *</span>
<span class="cm"> *     NOTE: Doesn&#39;t need to upload the firmware, as that is taken</span>
<span class="cm"> *     care of by the bus-generic code.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_release: [optional fill] Function called by the bus-generic</span>
<span class="cm"> *     code [i2400m_release()] to shutdown the basic bus-specific</span>
<span class="cm"> *     communications to the the device needed to load firmware. See</span>
<span class="cm"> *     LIFE CYCLE above.</span>
<span class="cm"> *</span>
<span class="cm"> *     This function does not need to reset the device, just tear down</span>
<span class="cm"> *     all the host resources created to  handle communication with</span>
<span class="cm"> *     the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_dev_start: [optional fill] Function called by the bus-generic</span>
<span class="cm"> *     code [i2400m_dev_start()] to do things needed to start the</span>
<span class="cm"> *     device. See LIFE CYCLE above.</span>
<span class="cm"> *</span>
<span class="cm"> *     NOTE: Doesn&#39;t need to upload the firmware, as that is taken</span>
<span class="cm"> *     care of by the bus-generic code.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_dev_stop: [optional fill] Function called by the bus-generic</span>
<span class="cm"> *     code [i2400m_dev_stop()] to do things needed for stopping the</span>
<span class="cm"> *     device. See LIFE CYCLE above.</span>
<span class="cm"> *</span>
<span class="cm"> *     This function does not need to reset the device, just tear down</span>
<span class="cm"> *     all the host resources created to handle communication with</span>
<span class="cm"> *     the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_tx_kick: [fill] Function called by the bus-generic code to let</span>
<span class="cm"> *     the bus-specific code know that there is data available in the</span>
<span class="cm"> *     TX FIFO for transmission to the device.</span>
<span class="cm"> *</span>
<span class="cm"> *     This function cannot sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_reset: [fill] Function called by the bus-generic code to reset</span>
<span class="cm"> *     the device in in various ways. Doesn&#39;t need to wait for the</span>
<span class="cm"> *     reset to finish.</span>
<span class="cm"> *</span>
<span class="cm"> *     If warm or cold reset fail, this function is expected to do a</span>
<span class="cm"> *     bus-specific reset (eg: USB reset) to get the device to a</span>
<span class="cm"> *     working state (even if it implies device disconecction).</span>
<span class="cm"> *</span>
<span class="cm"> *     Note the warm reset is used by the firmware uploader to</span>
<span class="cm"> *     reinitialize the device.</span>
<span class="cm"> *</span>
<span class="cm"> *     IMPORTANT: this is called very early in the device setup</span>
<span class="cm"> *     process, so it cannot rely on common infrastructure being laid</span>
<span class="cm"> *     out.</span>
<span class="cm"> *</span>
<span class="cm"> *     IMPORTANT: don&#39;t call reset on RT_BUS with i2400m-&gt;init_mutex</span>
<span class="cm"> *     held, as the .pre/.post reset handlers will deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_bm_retries: [fill] How many times shall a firmware upload /</span>
<span class="cm"> *     device initialization be retried? Different models of the same</span>
<span class="cm"> *     device might need different values, hence it is set by the</span>
<span class="cm"> *     bus-specific driver. Note this value is used in two places,</span>
<span class="cm"> *     i2400m_fw_dnload() and __i2400m_dev_start(); they won&#39;t become</span>
<span class="cm"> *     multiplicative (__i2400m_dev_start() calling N times</span>
<span class="cm"> *     i2400m_fw_dnload() and this trying N times to download the</span>
<span class="cm"> *     firmware), as if __i2400m_dev_start() only retries if the</span>
<span class="cm"> *     firmware crashed while initializing the device (not in a</span>
<span class="cm"> *     general case).</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_bm_cmd_send: [fill] Function called to send a boot-mode</span>
<span class="cm"> *     command. Flags are defined in &#39;enum i2400m_bm_cmd_flags&#39;. This</span>
<span class="cm"> *     is synchronous and has to return 0 if ok or &lt; 0 errno code in</span>
<span class="cm"> *     any error condition.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_bm_wait_for_ack: [fill] Function called to wait for a</span>
<span class="cm"> *     boot-mode notification (that can be a response to a previously</span>
<span class="cm"> *     issued command or an asynchronous one). Will read until all the</span>
<span class="cm"> *     indicated size is read or timeout. Reading more or less data</span>
<span class="cm"> *     than asked for is an error condition. Return 0 if ok, &lt; 0 errno</span>
<span class="cm"> *     code on error.</span>
<span class="cm"> *</span>
<span class="cm"> *     The caller to this function will check if the response is a</span>
<span class="cm"> *     barker that indicates the device going into reset mode.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_fw_names: [fill] a NULL-terminated array with the names of the</span>
<span class="cm"> *     firmware images to try loading. This is made a list so we can</span>
<span class="cm"> *     support backward compatibility of firmware releases (eg: if we</span>
<span class="cm"> *     can&#39;t find the default v1.4, we try v1.3). In general, the name</span>
<span class="cm"> *     should be i2400m-fw-X-VERSION.sbcf, where X is the bus name.</span>
<span class="cm"> *     The list is tried in order and the first one that loads is</span>
<span class="cm"> *     used. The fw loader will set i2400m-&gt;fw_name to point to the</span>
<span class="cm"> *     active firmware image.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_bm_mac_addr_impaired: [fill] Set to true if the device&#39;s MAC</span>
<span class="cm"> *     address provided in boot mode is kind of broken and needs to</span>
<span class="cm"> *     be re-read later on.</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_bm_pokes_table: [fill/optional] A table of device addresses</span>
<span class="cm"> *     and values that will be poked at device init time to move the</span>
<span class="cm"> *     device to the correct state for the type of boot/firmware being</span>
<span class="cm"> *     used.  This table MUST be terminated with (0x000000,</span>
<span class="cm"> *     0x00000000) or bad things will happen.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * @wimax_dev: WiMAX generic device for linkage into the kernel WiMAX</span>
<span class="cm"> *     stack. Due to the way a net_device is allocated, we need to</span>
<span class="cm"> *     force this to be the first field so that we can get from</span>
<span class="cm"> *     netdev_priv() the right pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * @updown: the device is up and ready for transmitting control and</span>
<span class="cm"> *     data packets. This implies @ready (communication infrastructure</span>
<span class="cm"> *     with the device is ready) and the device&#39;s firmware has been</span>
<span class="cm"> *     loaded and the device initialized.</span>
<span class="cm"> *</span>
<span class="cm"> *     Write to it only inside a i2400m-&gt;init_mutex protected area</span>
<span class="cm"> *     followed with a wmb(); rmb() before accesing (unless locked</span>
<span class="cm"> *     inside i2400m-&gt;init_mutex). Read access can be loose like that</span>
<span class="cm"> *     [just using rmb()] because the paths that use this also do</span>
<span class="cm"> *     other error checks later on.</span>
<span class="cm"> *</span>
<span class="cm"> * @ready: Communication infrastructure with the device is ready, data</span>
<span class="cm"> *     frames can start to be passed around (this is lighter than</span>
<span class="cm"> *     using the WiMAX state for certain hot paths).</span>
<span class="cm"> *</span>
<span class="cm"> *     Write to it only inside a i2400m-&gt;init_mutex protected area</span>
<span class="cm"> *     followed with a wmb(); rmb() before accesing (unless locked</span>
<span class="cm"> *     inside i2400m-&gt;init_mutex). Read access can be loose like that</span>
<span class="cm"> *     [just using rmb()] because the paths that use this also do</span>
<span class="cm"> *     other error checks later on.</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_reorder: 1 if RX reordering is enabled; this can only be</span>
<span class="cm"> *     set at probe time.</span>
<span class="cm"> *</span>
<span class="cm"> * @state: device&#39;s state (as reported by it)</span>
<span class="cm"> *</span>
<span class="cm"> * @state_wq: waitqueue that is woken up whenever the state changes</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_lock: spinlock to protect TX members</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_buf: FIFO buffer for TX; we queue data here</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_in: FIFO index for incoming data. Note this doesn&#39;t wrap around</span>
<span class="cm"> *     and it is always greater than @tx_out.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_out: FIFO index for outgoing data</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_msg: current TX message that is active in the FIFO for</span>
<span class="cm"> *     appending payloads.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_sequence: current sequence number for TX messages from the</span>
<span class="cm"> *     device to the host.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_msg_size: size of the current message being transmitted by the</span>
<span class="cm"> *     bus-specific code.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_pl_num: total number of payloads sent</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_pl_max: maximum number of payloads sent in a TX message</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_pl_min: minimum number of payloads sent in a TX message</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_num: number of TX messages sent</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_size_acc: number of bytes in all TX messages sent</span>
<span class="cm"> *     (this is different to net_dev&#39;s statistics as it also counts</span>
<span class="cm"> *     control messages).</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_size_min: smallest TX message sent.</span>
<span class="cm"> *</span>
<span class="cm"> * @tx_size_max: biggest TX message sent.</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_lock: spinlock to protect RX members and rx_roq_refcount.</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_pl_num: total number of payloads received</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_pl_max: maximum number of payloads received in a RX message</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_pl_min: minimum number of payloads received in a RX message</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_num: number of RX messages received</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_size_acc: number of bytes in all RX messages received</span>
<span class="cm"> *     (this is different to net_dev&#39;s statistics as it also counts</span>
<span class="cm"> *     control messages).</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_size_min: smallest RX message received.</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_size_max: buggest RX message received.</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_roq: RX ReOrder queues. (fw &gt;= v1.4) When packets are received</span>
<span class="cm"> *     out of order, the device will ask the driver to hold certain</span>
<span class="cm"> *     packets until the ones that are received out of order can be</span>
<span class="cm"> *     delivered. Then the driver can release them to the host. See</span>
<span class="cm"> *     drivers/net/i2400m/rx.c for details.</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_roq_refcount: refcount rx_roq. This refcounts any access to</span>
<span class="cm"> *     rx_roq thus preventing rx_roq being destroyed when rx_roq</span>
<span class="cm"> *     is being accessed. rx_roq_refcount is protected by rx_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_reports: reports received from the device that couldn&#39;t be</span>
<span class="cm"> *     processed because the driver wasn&#39;t still ready; when ready,</span>
<span class="cm"> *     they are pulled from here and chewed.</span>
<span class="cm"> *</span>
<span class="cm"> * @rx_reports_ws: Work struct used to kick a scan of the RX reports</span>
<span class="cm"> *     list and to process each.</span>
<span class="cm"> *</span>
<span class="cm"> * @src_mac_addr: MAC address used to make ethernet packets be coming</span>
<span class="cm"> *     from. This is generated at i2400m_setup() time and used during</span>
<span class="cm"> *     the life cycle of the instance. See i2400m_fake_eth_header().</span>
<span class="cm"> *</span>
<span class="cm"> * @init_mutex: Mutex used for serializing the device bringup</span>
<span class="cm"> *     sequence; this way if the device reboots in the middle, we</span>
<span class="cm"> *     don&#39;t try to do a bringup again while we are tearing down the</span>
<span class="cm"> *     one that failed.</span>
<span class="cm"> *</span>
<span class="cm"> *     Can&#39;t reuse @msg_mutex because from within the bringup sequence</span>
<span class="cm"> *     we need to send messages to the device and thus use @msg_mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * @msg_mutex: mutex used to send control commands to the device (we</span>
<span class="cm"> *     only allow one at a time, per host-device interface design).</span>
<span class="cm"> *</span>
<span class="cm"> * @msg_completion: used to wait for an ack to a control command sent</span>
<span class="cm"> *     to the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @ack_skb: used to store the actual ack to a control command if the</span>
<span class="cm"> *     reception of the command was successful. Otherwise, a ERR_PTR()</span>
<span class="cm"> *     errno code that indicates what failed with the ack reception.</span>
<span class="cm"> *</span>
<span class="cm"> *     Only valid after @msg_completion is woken up. Only updateable</span>
<span class="cm"> *     if @msg_completion is armed. Only touched by</span>
<span class="cm"> *     i2400m_msg_to_dev().</span>
<span class="cm"> *</span>
<span class="cm"> *     Protected by @rx_lock. In theory the command execution flow is</span>
<span class="cm"> *     sequential, but in case the device sends an out-of-phase or</span>
<span class="cm"> *     very delayed response, we need to avoid it trampling current</span>
<span class="cm"> *     execution.</span>
<span class="cm"> *</span>
<span class="cm"> * @bm_cmd_buf: boot mode command buffer for composing firmware upload</span>
<span class="cm"> *     commands.</span>
<span class="cm"> *</span>
<span class="cm"> *     USB can&#39;t r/w to stack, vmalloc, etc...as well, we end up</span>
<span class="cm"> *     having to alloc/free a lot to compose commands, so we use these</span>
<span class="cm"> *     for stagging and not having to realloc all the time.</span>
<span class="cm"> *</span>
<span class="cm"> *     This assumes the code always runs serialized. Only one thread</span>
<span class="cm"> *     can call i2400m_bm_cmd() at the same time.</span>
<span class="cm"> *</span>
<span class="cm"> * @bm_ack_buf: boot mode acknoledge buffer for staging reception of</span>
<span class="cm"> *     responses to commands.</span>
<span class="cm"> *</span>
<span class="cm"> *     See @bm_cmd_buf.</span>
<span class="cm"> *</span>
<span class="cm"> * @work_queue: work queue for processing device reports. This</span>
<span class="cm"> *     workqueue cannot be used for processing TX or RX to the device,</span>
<span class="cm"> *     as from it we&#39;ll process device reports, which might require</span>
<span class="cm"> *     further communication with the device.</span>
<span class="cm"> *</span>
<span class="cm"> * @debugfs_dentry: hookup for debugfs files.</span>
<span class="cm"> *     These have to be in a separate directory, a child of</span>
<span class="cm"> *     (wimax_dev-&gt;debugfs_dentry) so they can be removed when the</span>
<span class="cm"> *     module unloads, as we don&#39;t keep each dentry.</span>
<span class="cm"> *</span>
<span class="cm"> * @fw_name: name of the firmware image that is currently being used.</span>
<span class="cm"> *</span>
<span class="cm"> * @fw_version: version of the firmware interface, Major.minor,</span>
<span class="cm"> *     encoded in the high word and low word (major &lt;&lt; 16 | minor).</span>
<span class="cm"> *</span>
<span class="cm"> * @fw_hdrs: NULL terminated array of pointers to the firmware</span>
<span class="cm"> *     headers. This is only available during firmware load time.</span>
<span class="cm"> *</span>
<span class="cm"> * @fw_cached: Used to cache firmware when the system goes to</span>
<span class="cm"> *     suspend/standby/hibernation (as on resume we can&#39;t read it). If</span>
<span class="cm"> *     NULL, no firmware was cached, read it. If ~0, you can&#39;t read</span>
<span class="cm"> *     any firmware files (the system still didn&#39;t come out of suspend</span>
<span class="cm"> *     and failed to cache one), so abort; otherwise, a valid cached</span>
<span class="cm"> *     firmware to be used. Access to this variable is protected by</span>
<span class="cm"> *     the spinlock i2400m-&gt;rx_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * @barker: barker type that the device uses; this is initialized by</span>
<span class="cm"> *     i2400m_is_boot_barker() the first time it is called. Then it</span>
<span class="cm"> *     won&#39;t change during the life cycle of the device and every time</span>
<span class="cm"> *     a boot barker is received, it is just verified for it being the</span>
<span class="cm"> *     same.</span>
<span class="cm"> *</span>
<span class="cm"> * @pm_notifier: used to register for PM events</span>
<span class="cm"> *</span>
<span class="cm"> * @bus_reset_retries: counter for the number of bus resets attempted for</span>
<span class="cm"> *	this boot. It&#39;s not for tracking the number of bus resets during</span>
<span class="cm"> *	the whole driver life cycle (from insmod to rmmod) but for the</span>
<span class="cm"> *	number of dev_start() executed until dev_start() returns a success</span>
<span class="cm"> *	(ie: a good boot means a dev_stop() followed by a successful</span>
<span class="cm"> *	dev_start()). dev_reset_handler() increments this counter whenever</span>
<span class="cm"> *	it is triggering a bus reset. It checks this counter to decide if a</span>
<span class="cm"> *	subsequent bus reset should be retried. dev_reset_handler() retries</span>
<span class="cm"> *	the bus reset until dev_start() succeeds or the counter reaches</span>
<span class="cm"> *	I2400M_BUS_RESET_RETRIES. The counter is cleared to 0 in</span>
<span class="cm"> *	dev_reset_handle() when dev_start() returns a success,</span>
<span class="cm"> *	ie: a successul boot is completed.</span>
<span class="cm"> *</span>
<span class="cm"> * @alive: flag to denote if the device *should* be alive. This flag is</span>
<span class="cm"> *	everything like @updown (see doc for @updown) except reflecting</span>
<span class="cm"> *	the device state *we expect* rather than the actual state as denoted</span>
<span class="cm"> *	by @updown. It is set 1 whenever @updown is set 1 in dev_start().</span>
<span class="cm"> *	Then the device is expected to be alive all the time</span>
<span class="cm"> *	(i2400m-&gt;alive remains 1) until the driver is removed. Therefore</span>
<span class="cm"> *	all the device reboot events detected can be still handled properly</span>
<span class="cm"> *	by either dev_reset_handle() or .pre_reset/.post_reset as long as</span>
<span class="cm"> *	the driver presents. It is set 0 along with @updown in dev_stop().</span>
<span class="cm"> *</span>
<span class="cm"> * @error_recovery: flag to denote if we are ready to take an error recovery.</span>
<span class="cm"> *	0 for ready to take an error recovery; 1 for not ready. It is</span>
<span class="cm"> *	initialized to 1 while probe() since we don&#39;t tend to take any error</span>
<span class="cm"> *	recovery during probe(). It is decremented by 1 whenever dev_start()</span>
<span class="cm"> *	succeeds to indicate we are ready to take error recovery from now on.</span>
<span class="cm"> *	It is checked every time we wanna schedule an error recovery. If an</span>
<span class="cm"> *	error recovery is already in place (error_recovery was set 1), we</span>
<span class="cm"> *	should not schedule another one until the last one is done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">i2400m</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">wimax_dev</span> <span class="n">wimax_dev</span><span class="p">;</span>	<span class="cm">/* FIRST! See doc */</span>

	<span class="kt">unsigned</span> <span class="n">updown</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Network device is up or down */</span>
	<span class="kt">unsigned</span> <span class="n">boot_mode</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* is the device in boot mode? */</span>
	<span class="kt">unsigned</span> <span class="n">sboot</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* signed or unsigned fw boot */</span>
	<span class="kt">unsigned</span> <span class="n">ready</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Device comm infrastructure ready */</span>
	<span class="kt">unsigned</span> <span class="n">rx_reorder</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* RX reorder is enabled */</span>
	<span class="n">u8</span> <span class="n">trace_msg_from_user</span><span class="p">;</span>		<span class="cm">/* echo rx msgs to &#39;trace&#39; pipe */</span>
					<span class="cm">/* typed u8 so /sys/kernel/debug/u8 can tweak */</span>
	<span class="k">enum</span> <span class="n">i2400m_system_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">state_wq</span><span class="p">;</span>	<span class="cm">/* Woken up when on state updates */</span>

	<span class="kt">size_t</span> <span class="n">bus_tx_block_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bus_tx_room_min</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bus_pl_size_max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bus_bm_retries</span><span class="p">;</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_dev_start</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_dev_stop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_tx_kick</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_reset</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_reset_type</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_bm_cmd_send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="p">,</span>
				   <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">bus_bm_wait_for_ack</span><span class="p">)(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">bus_fw_names</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bus_bm_mac_addr_impaired</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_poke_table</span> <span class="o">*</span><span class="n">bus_bm_pokes_table</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">tx_lock</span><span class="p">;</span>		<span class="cm">/* protect TX state */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">tx_buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tx_in</span><span class="p">,</span> <span class="n">tx_out</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">tx_msg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">tx_sequence</span><span class="p">,</span> <span class="n">tx_msg_size</span><span class="p">;</span>
	<span class="cm">/* TX stats */</span>
	<span class="kt">unsigned</span> <span class="n">tx_pl_num</span><span class="p">,</span> <span class="n">tx_pl_max</span><span class="p">,</span> <span class="n">tx_pl_min</span><span class="p">,</span>
		<span class="n">tx_num</span><span class="p">,</span> <span class="n">tx_size_acc</span><span class="p">,</span> <span class="n">tx_size_min</span><span class="p">,</span> <span class="n">tx_size_max</span><span class="p">;</span>

	<span class="cm">/* RX stuff */</span>
	<span class="cm">/* protect RX state and rx_roq_refcount */</span>
	<span class="n">spinlock_t</span> <span class="n">rx_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">rx_pl_num</span><span class="p">,</span> <span class="n">rx_pl_max</span><span class="p">,</span> <span class="n">rx_pl_min</span><span class="p">,</span>
		<span class="n">rx_num</span><span class="p">,</span> <span class="n">rx_size_acc</span><span class="p">,</span> <span class="n">rx_size_min</span><span class="p">,</span> <span class="n">rx_size_max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_roq</span> <span class="o">*</span><span class="n">rx_roq</span><span class="p">;</span>	<span class="cm">/* access is refcounted */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">rx_roq_refcount</span><span class="p">;</span>	<span class="cm">/* refcount access to rx_roq */</span>
	<span class="n">u8</span> <span class="n">src_mac_addr</span><span class="p">[</span><span class="n">ETH_HLEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rx_reports</span><span class="p">;</span>	<span class="cm">/* under rx_lock! */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">rx_report_ws</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">msg_mutex</span><span class="p">;</span>		<span class="cm">/* serialize command execution */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">msg_completion</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ack_skb</span><span class="p">;</span>	<span class="cm">/* protected by rx_lock */</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">bm_ack_buf</span><span class="p">;</span>		<span class="cm">/* for receiving acks over USB */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bm_cmd_buf</span><span class="p">;</span>		<span class="cm">/* for issuing commands over USB */</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">work_queue</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">init_mutex</span><span class="p">;</span>	<span class="cm">/* protect bringup seq */</span>
	<span class="k">struct</span> <span class="n">i2400m_reset_ctx</span> <span class="o">*</span><span class="n">reset_ctx</span><span class="p">;</span>	<span class="cm">/* protected by init_mutex */</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">wake_tx_ws</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">wake_tx_skb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">reset_ws</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reset_reason</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">recovery_ws</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debugfs_dentry</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fw_name</span><span class="p">;</span>		<span class="cm">/* name of the current firmware image */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fw_version</span><span class="p">;</span>	<span class="cm">/* version of the firmware interface */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bcf_hdr</span> <span class="o">**</span><span class="n">fw_hdrs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">i2400m_fw</span> <span class="o">*</span><span class="n">fw_cached</span><span class="p">;</span>	<span class="cm">/* protected by rx_lock */</span>
	<span class="k">struct</span> <span class="n">i2400m_barker_db</span> <span class="o">*</span><span class="n">barker</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">pm_notifier</span><span class="p">;</span>

	<span class="cm">/* counting bus reset retries in this boot */</span>
	<span class="n">atomic_t</span> <span class="n">bus_reset_retries</span><span class="p">;</span>

	<span class="cm">/* if the device is expected to be alive */</span>
	<span class="kt">unsigned</span> <span class="n">alive</span><span class="p">;</span>

	<span class="cm">/* 0 if we are ready for error recovery; 1 if not ready  */</span>
	<span class="n">atomic_t</span> <span class="n">error_recovery</span><span class="p">;</span>

<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Bus-generic internal APIs</span>
<span class="cm"> * -------------------------</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="nf">wimax_dev_to_i2400m</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="n">wimax_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">wimax_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">i2400m</span><span class="p">,</span> <span class="n">wimax_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="nf">net_dev_to_i2400m</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wimax_dev_to_i2400m</span><span class="p">(</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">net_dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Boot mode support</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * i2400m_bm_cmd_flags - flags to i2400m_bm_cmd()</span>
<span class="cm"> *</span>
<span class="cm"> * @I2400M_BM_CMD_RAW: send the command block as-is, without doing any</span>
<span class="cm"> *     extra processing for adding CRC.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">i2400m_bm_cmd_flags</span> <span class="p">{</span>
	<span class="n">I2400M_BM_CMD_RAW</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * i2400m_bri - Boot-ROM indicators</span>
<span class="cm"> *</span>
<span class="cm"> * Flags for i2400m_bootrom_init() and i2400m_dev_bootstrap() [which</span>
<span class="cm"> * are passed from things like i2400m_setup()]. Can be combined with</span>
<span class="cm"> * |.</span>
<span class="cm"> *</span>
<span class="cm"> * @I2400M_BRI_SOFT: The device rebooted already and a reboot</span>
<span class="cm"> *     barker received, proceed directly to ack the boot sequence.</span>
<span class="cm"> * @I2400M_BRI_NO_REBOOT: Do not reboot the device and proceed</span>
<span class="cm"> *     directly to wait for a reboot barker from the device.</span>
<span class="cm"> * @I2400M_BRI_MAC_REINIT: We need to reinitialize the boot</span>
<span class="cm"> *     rom after reading the MAC address. This is quite a dirty hack,</span>
<span class="cm"> *     if you ask me -- the device requires the bootrom to be</span>
<span class="cm"> *     initialized after reading the MAC address.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="p">{</span>
	<span class="n">I2400M_BRI_SOFT</span>       <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">I2400M_BRI_NO_REBOOT</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">I2400M_BRI_MAC_REINIT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_bm_cmd_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_dev_bootstrap</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_read_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_bootrom_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_is_boot_barker</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">int</span> <span class="nf">i2400m_is_d2h_barker</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__le32</span> <span class="o">*</span><span class="n">barker</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">barker</span><span class="p">)</span> <span class="o">==</span> <span class="n">I2400M_D2H_MSG_BARKER</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_unknown_barker</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="cm">/* Make/grok boot-rom header commands */</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="n">__le32</span> <span class="nf">i2400m_brh_command</span><span class="p">(</span><span class="k">enum</span> <span class="n">i2400m_brh_opcode</span> <span class="n">opcode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">use_checksum</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="n">direct_access</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
		<span class="n">I2400M_BRH_SIGNATURE</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">direct_access</span> <span class="o">?</span> <span class="n">I2400M_BRH_DIRECT_ACCESS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">|</span> <span class="n">I2400M_BRH_RESPONSE_REQUIRED</span> <span class="cm">/* response always required */</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">use_checksum</span> <span class="o">?</span> <span class="n">I2400M_BRH_USE_CHECKSUM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">I2400M_BRH_OPCODE_MASK</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">i2400m_brh_set_opcode</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">i2400m_brh_opcode</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
		<span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">I2400M_BRH_OPCODE_MASK</span><span class="p">)</span>
		<span class="o">|</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">I2400M_BRH_OPCODE_MASK</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_brh_get_opcode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I2400M_BRH_OPCODE_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_brh_get_response</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I2400M_BRH_RESPONSE_MASK</span><span class="p">)</span>
		<span class="o">&gt;&gt;</span> <span class="n">I2400M_BRH_RESPONSE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_brh_get_use_checksum</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I2400M_BRH_USE_CHECKSUM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_brh_get_response_required</span><span class="p">(</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I2400M_BRH_RESPONSE_REQUIRED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_brh_get_direct_access</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I2400M_BRH_DIRECT_ACCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_brh_get_signature</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_bootrom_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I2400M_BRH_SIGNATURE_MASK</span><span class="p">)</span>
		<span class="o">&gt;&gt;</span> <span class="n">I2400M_BRH_SIGNATURE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Driver / device setup and internal functions</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_reset_type</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_netdev_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net_dev</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_sysfs_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_sysfs_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_tx_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_wake_tx_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_tx_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_rx_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_rx_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_fw_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_fw_uncache</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_net_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_net_erx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span>
			   <span class="k">enum</span> <span class="n">i2400m_cs</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_net_wake_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">enum</span> <span class="n">i2400m_pt</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_pt</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_debugfs_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_debugfs_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">i2400m_debugfs_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">i2400m_debugfs_rm</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span> <span class="p">{}</span>
<span class="cp">#endif</span>

<span class="cm">/* Initialize/shutdown the device */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_dev_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_dev_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">i2400m_dev_attr_group</span><span class="p">;</span>


<span class="cm">/* HDI message&#39;s payload description handling */</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">size_t</span> <span class="nf">i2400m_pld_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_pld</span> <span class="o">*</span><span class="n">pld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">I2400M_PLD_SIZE_MASK</span> <span class="o">&amp;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pld</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">enum</span> <span class="n">i2400m_pt</span> <span class="nf">i2400m_pld_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_pld</span> <span class="o">*</span><span class="n">pld</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">I2400M_PLD_TYPE_MASK</span> <span class="o">&amp;</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pld</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span>
		<span class="o">&gt;&gt;</span> <span class="n">I2400M_PLD_TYPE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">i2400m_pld_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m_pld</span> <span class="o">*</span><span class="n">pld</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		    <span class="k">enum</span> <span class="n">i2400m_pt</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pld</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
		<span class="p">((</span><span class="n">type</span> <span class="o">&lt;&lt;</span> <span class="n">I2400M_PLD_TYPE_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">I2400M_PLD_TYPE_MASK</span><span class="p">)</span>
		<span class="o">|</span>  <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">I2400M_PLD_SIZE_MASK</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * API for the bus-specific drivers</span>
<span class="cm"> * --------------------------------</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="nf">i2400m_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_hold</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">i2400m</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">i2400m_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_dev_reset_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_pre_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_error_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * _setup()/_release() are called by the probe/disconnect functions of</span>
<span class="cm"> * the bus-specific drivers.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">i2400m_bri</span> <span class="n">bm_flags</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">i2400m_msg_hdr</span> <span class="o">*</span><span class="n">i2400m_tx_msg_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_tx_msg_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Utility functions</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="nf">i2400m_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">wimax_dev</span><span class="p">.</span><span class="n">net_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_msg_check_status</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_l3l4_hdr</span> <span class="o">*</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_msg_size_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_l3l4_hdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">i2400m_msg_to_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_msg_to_dev_cancel_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_report_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_l3l4_hdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_report_hook_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_cmd_enter_powersave</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_cmd_exit_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">i2400m_get_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_firmware_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_set_idle_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="nf">usb_get_epd</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">ep</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_op_rfkill_sw_toggle</span><span class="p">(</span><span class="k">struct</span> <span class="n">wimax_dev</span> <span class="o">*</span><span class="p">,</span>
				      <span class="k">enum</span> <span class="n">wimax_rf_state</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_report_tlv_rf_switches_status</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">i2400m_tlv_rf_switches_status</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Helpers for firmware backwards compatibility</span>
<span class="cm"> *</span>
<span class="cm"> * As we aim to support at least the firmware version that was</span>
<span class="cm"> * released with the previous kernel/driver release, some code will be</span>
<span class="cm"> * conditionally executed depending on the firmware version. On each</span>
<span class="cm"> * release, the code to support fw releases past the last two ones</span>
<span class="cm"> * will be purged.</span>
<span class="cm"> *</span>
<span class="cm"> * By making it depend on this macros, it is easier to keep it a tab</span>
<span class="cm"> * on what has to go and what not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_le_v1_3</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* running fw is lower or v1.3 */</span>
	<span class="k">return</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_version</span> <span class="o">&lt;=</span> <span class="mh">0x00090001</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">unsigned</span> <span class="nf">i2400m_ge_v1_4</span><span class="p">(</span><span class="k">struct</span> <span class="n">i2400m</span> <span class="o">*</span><span class="n">i2400m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* running fw is higher or v1.4 */</span>
	<span class="k">return</span> <span class="n">i2400m</span><span class="o">-&gt;</span><span class="n">fw_version</span> <span class="o">&gt;=</span> <span class="mh">0x00090002</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Do a millisecond-sleep for allowing wireshark to dump all the data</span>
<span class="cm"> * packets. Used only for debugging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">__i2400m_msleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 1</span>
<span class="cp">#else</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/* module initialization helpers */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">i2400m_barker_db_init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">i2400m_barker_db_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>



<span class="cp">#endif </span><span class="cm">/* #ifndef __I2400M_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
