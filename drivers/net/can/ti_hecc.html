<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › can › ti_hecc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ti_hecc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * TI HECC (CAN) device driver</span>
<span class="cm"> *</span>
<span class="cm"> * This driver supports TI&#39;s HECC (High End CAN Controller module) and the</span>
<span class="cm"> * specs for the same is available at &lt;http://www.ti.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed as is WITHOUT ANY WARRANTY of any</span>
<span class="cm"> * kind, whether express or implied; without even the implied warranty</span>
<span class="cm"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Your platform definitions should specify module ram offsets and interrupt</span>
<span class="cm"> * number to use as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * static struct ti_hecc_platform_data am3517_evm_hecc_pdata = {</span>
<span class="cm"> *         .scc_hecc_offset        = 0,</span>
<span class="cm"> *         .scc_ram_offset         = 0x3000,</span>
<span class="cm"> *         .hecc_ram_offset        = 0x3000,</span>
<span class="cm"> *         .mbx_offset             = 0x2000,</span>
<span class="cm"> *         .int_line               = 0,</span>
<span class="cm"> *         .revision               = 1,</span>
<span class="cm"> *         .transceiver_switch     = hecc_phy_control,</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * Please see include/linux/can/platform/ti_hecc.h for description of</span>
<span class="cm"> * above fields.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/clk.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;linux/can/dev.h&gt;</span>
<span class="cp">#include &lt;linux/can/error.h&gt;</span>
<span class="cp">#include &lt;linux/can/platform/ti_hecc.h&gt;</span>

<span class="cp">#define DRV_NAME &quot;ti_hecc&quot;</span>
<span class="cp">#define HECC_MODULE_VERSION     &quot;0.7&quot;</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">HECC_MODULE_VERSION</span><span class="p">);</span>
<span class="cp">#define DRV_DESC &quot;TI High End CAN Controller Driver &quot; HECC_MODULE_VERSION</span>

<span class="cm">/* TX / RX Mailbox Configuration */</span>
<span class="cp">#define HECC_MAX_MAILBOXES	32	</span><span class="cm">/* hardware mailboxes - do not change */</span><span class="cp"></span>
<span class="cp">#define MAX_TX_PRIO		0x3F	</span><span class="cm">/* hardware value - do not change */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Important Note: TX mailbox configuration</span>
<span class="cm"> * TX mailboxes should be restricted to the number of SKB buffers to avoid</span>
<span class="cm"> * maintaining SKB buffers separately. TX mailboxes should be a power of 2</span>
<span class="cm"> * for the mailbox logic to work.  Top mailbox numbers are reserved for RX</span>
<span class="cm"> * and lower mailboxes for TX.</span>
<span class="cm"> *</span>
<span class="cm"> * HECC_MAX_TX_MBOX	HECC_MB_TX_SHIFT</span>
<span class="cm"> * 4 (default)		2</span>
<span class="cm"> * 8			3</span>
<span class="cm"> * 16			4</span>
<span class="cm"> */</span>
<span class="cp">#define HECC_MB_TX_SHIFT	2 </span><span class="cm">/* as per table above */</span><span class="cp"></span>
<span class="cp">#define HECC_MAX_TX_MBOX	BIT(HECC_MB_TX_SHIFT)</span>

<span class="cp">#define HECC_TX_PRIO_SHIFT	(HECC_MB_TX_SHIFT)</span>
<span class="cp">#define HECC_TX_PRIO_MASK	(MAX_TX_PRIO &lt;&lt; HECC_MB_TX_SHIFT)</span>
<span class="cp">#define HECC_TX_MB_MASK		(HECC_MAX_TX_MBOX - 1)</span>
<span class="cp">#define HECC_TX_MASK		((HECC_MAX_TX_MBOX - 1) | HECC_TX_PRIO_MASK)</span>
<span class="cp">#define HECC_TX_MBOX_MASK	(~(BIT(HECC_MAX_TX_MBOX) - 1))</span>
<span class="cp">#define HECC_DEF_NAPI_WEIGHT	HECC_MAX_RX_MBOX</span>

<span class="cm">/*</span>
<span class="cm"> * Important Note: RX mailbox configuration</span>
<span class="cm"> * RX mailboxes are further logically split into two - main and buffer</span>
<span class="cm"> * mailboxes. The goal is to get all packets into main mailboxes as</span>
<span class="cm"> * driven by mailbox number and receive priority (higher to lower) and</span>
<span class="cm"> * buffer mailboxes are used to receive pkts while main mailboxes are being</span>
<span class="cm"> * processed. This ensures in-order packet reception.</span>
<span class="cm"> *</span>
<span class="cm"> * Here are the recommended values for buffer mailbox. Note that RX mailboxes</span>
<span class="cm"> * start after TX mailboxes:</span>
<span class="cm"> *</span>
<span class="cm"> * HECC_MAX_RX_MBOX		HECC_RX_BUFFER_MBOX	No of buffer mailboxes</span>
<span class="cm"> * 28				12			8</span>
<span class="cm"> * 16				20			4</span>
<span class="cm"> */</span>

<span class="cp">#define HECC_MAX_RX_MBOX	(HECC_MAX_MAILBOXES - HECC_MAX_TX_MBOX)</span>
<span class="cp">#define HECC_RX_BUFFER_MBOX	12 </span><span class="cm">/* as per table above */</span><span class="cp"></span>
<span class="cp">#define HECC_RX_FIRST_MBOX	(HECC_MAX_MAILBOXES - 1)</span>
<span class="cp">#define HECC_RX_HIGH_MBOX_MASK	(~(BIT(HECC_RX_BUFFER_MBOX) - 1))</span>

<span class="cm">/* TI HECC module registers */</span>
<span class="cp">#define HECC_CANME		0x0	</span><span class="cm">/* Mailbox enable */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMD		0x4	</span><span class="cm">/* Mailbox direction */</span><span class="cp"></span>
<span class="cp">#define HECC_CANTRS		0x8	</span><span class="cm">/* Transmit request set */</span><span class="cp"></span>
<span class="cp">#define HECC_CANTRR		0xC	</span><span class="cm">/* Transmit request */</span><span class="cp"></span>
<span class="cp">#define HECC_CANTA		0x10	</span><span class="cm">/* Transmission acknowledge */</span><span class="cp"></span>
<span class="cp">#define HECC_CANAA		0x14	</span><span class="cm">/* Abort acknowledge */</span><span class="cp"></span>
<span class="cp">#define HECC_CANRMP		0x18	</span><span class="cm">/* Receive message pending */</span><span class="cp"></span>
<span class="cp">#define HECC_CANRML		0x1C	</span><span class="cm">/* Remote message lost */</span><span class="cp"></span>
<span class="cp">#define HECC_CANRFP		0x20	</span><span class="cm">/* Remote frame pending */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGAM		0x24	</span><span class="cm">/* SECC only:Global acceptance mask */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMC		0x28	</span><span class="cm">/* Master control */</span><span class="cp"></span>
<span class="cp">#define HECC_CANBTC		0x2C	</span><span class="cm">/* Bit timing configuration */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES		0x30	</span><span class="cm">/* Error and status */</span><span class="cp"></span>
<span class="cp">#define HECC_CANTEC		0x34	</span><span class="cm">/* Transmit error counter */</span><span class="cp"></span>
<span class="cp">#define HECC_CANREC		0x38	</span><span class="cm">/* Receive error counter */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF0		0x3C	</span><span class="cm">/* Global interrupt flag 0 */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIM		0x40	</span><span class="cm">/* Global interrupt mask */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF1		0x44	</span><span class="cm">/* Global interrupt flag 1 */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMIM		0x48	</span><span class="cm">/* Mailbox interrupt mask */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMIL		0x4C	</span><span class="cm">/* Mailbox interrupt level */</span><span class="cp"></span>
<span class="cp">#define HECC_CANOPC		0x50	</span><span class="cm">/* Overwrite protection control */</span><span class="cp"></span>
<span class="cp">#define HECC_CANTIOC		0x54	</span><span class="cm">/* Transmit I/O control */</span><span class="cp"></span>
<span class="cp">#define HECC_CANRIOC		0x58	</span><span class="cm">/* Receive I/O control */</span><span class="cp"></span>
<span class="cp">#define HECC_CANLNT		0x5C	</span><span class="cm">/* HECC only: Local network time */</span><span class="cp"></span>
<span class="cp">#define HECC_CANTOC		0x60	</span><span class="cm">/* HECC only: Time-out control */</span><span class="cp"></span>
<span class="cp">#define HECC_CANTOS		0x64	</span><span class="cm">/* HECC only: Time-out status */</span><span class="cp"></span>
<span class="cp">#define HECC_CANTIOCE		0x68	</span><span class="cm">/* SCC only:Enhanced TX I/O control */</span><span class="cp"></span>
<span class="cp">#define HECC_CANRIOCE		0x6C	</span><span class="cm">/* SCC only:Enhanced RX I/O control */</span><span class="cp"></span>

<span class="cm">/* Mailbox registers */</span>
<span class="cp">#define HECC_CANMID		0x0</span>
<span class="cp">#define HECC_CANMCF		0x4</span>
<span class="cp">#define HECC_CANMDL		0x8</span>
<span class="cp">#define HECC_CANMDH		0xC</span>

<span class="cp">#define HECC_SET_REG		0xFFFFFFFF</span>
<span class="cp">#define HECC_CANID_MASK		0x3FF	</span><span class="cm">/* 18 bits mask for extended id&#39;s */</span><span class="cp"></span>
<span class="cp">#define HECC_CCE_WAIT_COUNT     100	</span><span class="cm">/* Wait for ~1 sec for CCE bit */</span><span class="cp"></span>

<span class="cp">#define HECC_CANMC_SCM		BIT(13)	</span><span class="cm">/* SCC compat mode */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMC_CCR		BIT(12)	</span><span class="cm">/* Change config request */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMC_PDR		BIT(11)	</span><span class="cm">/* Local Power down - for sleep mode */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMC_ABO		BIT(7)	</span><span class="cm">/* Auto Bus On */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMC_STM		BIT(6)	</span><span class="cm">/* Self test mode - loopback */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMC_SRES		BIT(5)	</span><span class="cm">/* Software reset */</span><span class="cp"></span>

<span class="cp">#define HECC_CANTIOC_EN		BIT(3)	</span><span class="cm">/* Enable CAN TX I/O pin */</span><span class="cp"></span>
<span class="cp">#define HECC_CANRIOC_EN		BIT(3)	</span><span class="cm">/* Enable CAN RX I/O pin */</span><span class="cp"></span>

<span class="cp">#define HECC_CANMID_IDE		BIT(31)	</span><span class="cm">/* Extended frame format */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMID_AME		BIT(30)	</span><span class="cm">/* Acceptance mask enable */</span><span class="cp"></span>
<span class="cp">#define HECC_CANMID_AAM		BIT(29)	</span><span class="cm">/* Auto answer mode */</span><span class="cp"></span>

<span class="cp">#define HECC_CANES_FE		BIT(24)	</span><span class="cm">/* form error */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_BE		BIT(23)	</span><span class="cm">/* bit error */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_SA1		BIT(22)	</span><span class="cm">/* stuck at dominant error */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_CRCE		BIT(21)	</span><span class="cm">/* CRC error */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_SE		BIT(20)	</span><span class="cm">/* stuff bit error */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_ACKE		BIT(19)	</span><span class="cm">/* ack error */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_BO		BIT(18)	</span><span class="cm">/* Bus off status */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_EP		BIT(17)	</span><span class="cm">/* Error passive status */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_EW		BIT(16)	</span><span class="cm">/* Error warning status */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_SMA		BIT(5)	</span><span class="cm">/* suspend mode ack */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_CCE		BIT(4)	</span><span class="cm">/* Change config enabled */</span><span class="cp"></span>
<span class="cp">#define HECC_CANES_PDA		BIT(3)	</span><span class="cm">/* Power down mode ack */</span><span class="cp"></span>

<span class="cp">#define HECC_CANBTC_SAM		BIT(7)	</span><span class="cm">/* sample points */</span><span class="cp"></span>

<span class="cp">#define HECC_BUS_ERROR		(HECC_CANES_FE | HECC_CANES_BE |\</span>
<span class="cp">				HECC_CANES_CRCE | HECC_CANES_SE |\</span>
<span class="cp">				HECC_CANES_ACKE)</span>

<span class="cp">#define HECC_CANMCF_RTR		BIT(4)	</span><span class="cm">/* Remote transmit request */</span><span class="cp"></span>

<span class="cp">#define HECC_CANGIF_MAIF	BIT(17)	</span><span class="cm">/* Message alarm interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_TCOIF	BIT(16) </span><span class="cm">/* Timer counter overflow int */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_GMIF	BIT(15)	</span><span class="cm">/* Global mailbox interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_AAIF	BIT(14)	</span><span class="cm">/* Abort ack interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_WDIF	BIT(13)	</span><span class="cm">/* Write denied interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_WUIF	BIT(12)	</span><span class="cm">/* Wake up interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_RMLIF	BIT(11)	</span><span class="cm">/* Receive message lost interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_BOIF	BIT(10)	</span><span class="cm">/* Bus off interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_EPIF	BIT(9)	</span><span class="cm">/* Error passive interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_WLIF	BIT(8)	</span><span class="cm">/* Warning level interrupt */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIF_MBOX_MASK	0x1F	</span><span class="cm">/* Mailbox number mask */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIM_I1EN	BIT(1)	</span><span class="cm">/* Int line 1 enable */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIM_I0EN	BIT(0)	</span><span class="cm">/* Int line 0 enable */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIM_DEF_MASK	0x700	</span><span class="cm">/* only busoff/warning/passive */</span><span class="cp"></span>
<span class="cp">#define HECC_CANGIM_SIL		BIT(2)	</span><span class="cm">/* system interrupts to int line 1 */</span><span class="cp"></span>

<span class="cm">/* CAN Bittiming constants as per HECC specs */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">can_bittiming_const</span> <span class="n">ti_hecc_bittiming_const</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tseg1_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tseg1_max</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tseg2_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tseg2_max</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sjw_max</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">brp_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">brp_max</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
	<span class="p">.</span><span class="n">brp_inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">can_priv</span> <span class="n">can</span><span class="p">;</span>	<span class="cm">/* MUST be first member/field */</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="n">napi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clk</span> <span class="o">*</span><span class="n">clk</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">scc_ram_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hecc_ram_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mbx_offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">int_line</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">mbx_lock</span><span class="p">;</span> <span class="cm">/* CANME register needs protection */</span>
	<span class="n">u32</span> <span class="n">tx_head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_tail</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rx_next</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">transceiver_switch</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_tx_head_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">&amp;</span> <span class="n">HECC_TX_MB_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_tx_tail_mb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">&amp;</span> <span class="n">HECC_TX_MB_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_tx_head_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">&gt;&gt;</span> <span class="n">HECC_TX_PRIO_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MAX_TX_PRIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hecc_write_lam</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">hecc_ram_offset</span> <span class="o">+</span> <span class="n">mbxno</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hecc_write_mbx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mbxno</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_offset</span> <span class="o">+</span> <span class="n">mbxno</span> <span class="o">*</span> <span class="mh">0x10</span> <span class="o">+</span>
			<span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hecc_read_mbx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_offset</span> <span class="o">+</span> <span class="n">mbxno</span> <span class="o">*</span> <span class="mh">0x10</span> <span class="o">+</span>
			<span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hecc_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__raw_writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hecc_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__raw_readl</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hecc_set_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">bit_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="n">bit_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hecc_clear_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">bit_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">bit_mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hecc_get_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bit_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bit_mask</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_get_state</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">can_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_set_btc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">can_bittiming</span> <span class="o">*</span><span class="n">bit_timing</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">bittiming</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">can_btc</span><span class="p">;</span>

	<span class="n">can_btc</span> <span class="o">=</span> <span class="p">(</span><span class="n">bit_timing</span><span class="o">-&gt;</span><span class="n">phase_seg2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">;</span>
	<span class="n">can_btc</span> <span class="o">|=</span> <span class="p">((</span><span class="n">bit_timing</span><span class="o">-&gt;</span><span class="n">phase_seg1</span> <span class="o">+</span> <span class="n">bit_timing</span><span class="o">-&gt;</span><span class="n">prop_seg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">ctrlmode</span> <span class="o">&amp;</span> <span class="n">CAN_CTRLMODE_3_SAMPLES</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bit_timing</span><span class="o">-&gt;</span><span class="n">brp</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">can_btc</span> <span class="o">|=</span> <span class="n">HECC_CANBTC_SAM</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;WARN: Triple&quot;</span>
				<span class="s">&quot;sampling not set due to h/w limitations&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">can_btc</span> <span class="o">|=</span> <span class="p">((</span><span class="n">bit_timing</span><span class="o">-&gt;</span><span class="n">sjw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">can_btc</span> <span class="o">|=</span> <span class="p">((</span><span class="n">bit_timing</span><span class="o">-&gt;</span><span class="n">brp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

	<span class="cm">/* ERM being set to 0 by default meaning resync at falling edge */</span>

	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANBTC</span><span class="p">,</span> <span class="n">can_btc</span><span class="p">);</span>
	<span class="n">netdev_info</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;setting CANBTC=%#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">can_btc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ti_hecc_transceiver_switch</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">transceiver_switch</span><span class="p">)</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">transceiver_switch</span><span class="p">(</span><span class="n">on</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ti_hecc_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;resetting hecc ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="n">HECC_CANMC_SRES</span><span class="p">);</span>

	<span class="cm">/* Set change control request and wait till enabled */</span>
	<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="n">HECC_CANMC_CCR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * INFO: It has been observed that at times CCE bit may not be</span>
<span class="cm">	 * set and hw seems to be ok even if this bit is not set so</span>
<span class="cm">	 * timing out with a timing of 1ms to respect the specs</span>
<span class="cm">	 */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">HECC_CCE_WAIT_COUNT</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">hecc_get_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_CCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">cnt</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: On HECC, BTC can be programmed only in initialization mode, so</span>
<span class="cm">	 * it is expected that the can bittiming parameters are set via ip</span>
<span class="cm">	 * utility before the device is opened</span>
<span class="cm">	 */</span>
	<span class="n">ti_hecc_set_btc</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>

	<span class="cm">/* Clear CCR (and CANMC register) and wait for CCE = 0 enable */</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * INFO: CAN net stack handles bus off and hence disabling auto-bus-on</span>
<span class="cm">	 * hecc_set_bit(priv, HECC_CANMC, HECC_CANMC_ABO);</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * INFO: It has been observed that at times CCE bit may not be</span>
<span class="cm">	 * set and hw seems to be ok even if this bit is not set so</span>
<span class="cm">	 */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">HECC_CCE_WAIT_COUNT</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">hecc_get_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_CCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">cnt</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable TX and RX I/O Control pins */</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANTIOC</span><span class="p">,</span> <span class="n">HECC_CANTIOC_EN</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANRIOC</span><span class="p">,</span> <span class="n">HECC_CANRIOC_EN</span><span class="p">);</span>

	<span class="cm">/* Clear registers for clean operation */</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANTA</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANRMP</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIF0</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIF1</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* SCC compat mode NOT supported (and not needed too) */</span>
	<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="n">HECC_CANMC_SCM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ti_hecc_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">;</span>

	<span class="cm">/* put HECC in initialization mode and set btc */</span>
	<span class="n">ti_hecc_reset</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">=</span> <span class="n">HECC_TX_MASK</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span> <span class="o">=</span> <span class="n">HECC_RX_FIRST_MBOX</span><span class="p">;</span>

	<span class="cm">/* Enable local and global acceptance mask registers */</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGAM</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>

	<span class="cm">/* Prepare configured mailboxes to receive messages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">HECC_MAX_RX_MBOX</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mbxno</span> <span class="o">=</span> <span class="n">HECC_MAX_MAILBOXES</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="n">mbx_mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">mbxno</span><span class="p">);</span>
		<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
		<span class="n">hecc_write_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMID</span><span class="p">,</span> <span class="n">HECC_CANMID_AME</span><span class="p">);</span>
		<span class="n">hecc_write_lam</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
		<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMD</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
		<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
		<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIM</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Prevent message over-write &amp; Enable interrupts */</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANOPC</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_line</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIL</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
		<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIM</span><span class="p">,</span> <span class="n">HECC_CANGIM_DEF_MASK</span> <span class="o">|</span>
			<span class="n">HECC_CANGIM_I1EN</span> <span class="o">|</span> <span class="n">HECC_CANGIM_SIL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIM</span><span class="p">,</span>
			<span class="n">HECC_CANGIM_DEF_MASK</span> <span class="o">|</span> <span class="n">HECC_CANGIM_I0EN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ti_hecc_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="cm">/* Disable interrupts and disable mailboxes */</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_STOPPED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_do_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">,</span> <span class="k">enum</span> <span class="n">can_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CAN_MODE_START</span>:
		<span class="n">ti_hecc_start</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_get_berr_counter</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">can_berr_counter</span> <span class="o">*</span><span class="n">bec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">bec</span><span class="o">-&gt;</span><span class="n">txerr</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANTEC</span><span class="p">);</span>
	<span class="n">bec</span><span class="o">-&gt;</span><span class="n">rxerr</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANREC</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ti_hecc_xmit: HECC Transmit</span>
<span class="cm"> *</span>
<span class="cm"> * The transmit mailboxes start from 0 to HECC_MAX_TX_MBOX. In HECC the</span>
<span class="cm"> * priority of the mailbox for tranmission is dependent upon priority setting</span>
<span class="cm"> * field in mailbox registers. The mailbox with highest value in priority field</span>
<span class="cm"> * is transmitted first. Only when two mailboxes have the same value in</span>
<span class="cm"> * priority field the highest numbered mailbox is transmitted first.</span>
<span class="cm"> *</span>
<span class="cm"> * To utilize the HECC priority feature as described above we start with the</span>
<span class="cm"> * highest numbered mailbox with highest priority level and move on to the next</span>
<span class="cm"> * mailbox with the same priority level and so on. Once we loop through all the</span>
<span class="cm"> * transmit mailboxes we choose the next priority level (lower) and so on</span>
<span class="cm"> * until we reach the lowest priority level on the lowest numbered mailbox</span>
<span class="cm"> * when we stop transmission until all mailboxes are transmitted and then</span>
<span class="cm"> * restart at highest numbered mailbox with highest priority.</span>
<span class="cm"> *</span>
<span class="cm"> * Two counters (head and tail) are used to track the next mailbox to transmit</span>
<span class="cm"> * and to track the echo buffer for already transmitted mailbox. The queue</span>
<span class="cm"> * is stopped when all the mailboxes are busy or when there is a priority</span>
<span class="cm"> * value roll-over happens.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">ti_hecc_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">,</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_dropped_invalid_skb</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

	<span class="n">mbxno</span> <span class="o">=</span> <span class="n">get_tx_head_mb</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">mbx_mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">mbxno</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mbx_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span>
			<span class="s">&quot;BUG: TX mbx not ready tx_head=%08X, tx_tail=%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Prepare mailbox for transmission */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_tx_head_prio</span><span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_RTR_FLAG</span><span class="p">)</span> <span class="cm">/* Remote transmission request */</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">HECC_CANMCF_RTR</span><span class="p">;</span>
	<span class="n">hecc_write_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMCF</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_FLAG</span><span class="p">)</span> <span class="cm">/* Extended frame format */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">HECC_CANMID_IDE</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* Standard frame format */</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_SFF_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">;</span>
	<span class="n">hecc_write_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMID</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">hecc_write_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMDL</span><span class="p">,</span>
		<span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">hecc_write_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMDH</span><span class="p">,</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)));</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">can_put_echo_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ndev</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="o">--</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">get_tx_head_mb</span><span class="p">(</span><span class="n">priv</span><span class="p">)))</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">&amp;</span> <span class="n">HECC_TX_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HECC_TX_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMD</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
	<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIM</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANTRS</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_rx_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mbxno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_can_skb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span>
				<span class="s">&quot;ti_hecc_rx_pkt: alloc_can_skb() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbx_mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">mbxno</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">hecc_read_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">HECC_CANMID_IDE</span><span class="p">)</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">CAN_EFF_FLAG</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CAN_SFF_MASK</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">hecc_read_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMCF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">HECC_CANMCF_RTR</span><span class="p">)</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_RTR_FLAG</span><span class="p">;</span>
	<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">=</span> <span class="n">get_can_dlc</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">hecc_read_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMDL</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">hecc_read_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">HECC_CANMDH</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
	<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANRMP</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
	<span class="cm">/* enable mailbox only if it is part of rx buffer mailboxes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span> <span class="o">&lt;</span> <span class="n">HECC_RX_BUFFER_MBOX</span><span class="p">)</span>
		<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>
	<span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ti_hecc_rx_poll - HECC receive pkts</span>
<span class="cm"> *</span>
<span class="cm"> * The receive mailboxes start from highest numbered mailbox till last xmit</span>
<span class="cm"> * mailbox. On CAN frame reception the hardware places the data into highest</span>
<span class="cm"> * numbered mailbox that matches the CAN ID filter. Since all receive mailboxes</span>
<span class="cm"> * have same filtering (ALL CAN frames) packets will arrive in the highest</span>
<span class="cm"> * available RX mailbox and we need to ensure in-order packet reception.</span>
<span class="cm"> *</span>
<span class="cm"> * To ensure the packets are received in the right order we logically divide</span>
<span class="cm"> * the RX mailboxes into main and buffer mailboxes. Packets are received as per</span>
<span class="cm"> * mailbox priotity (higher to lower) in the main bank and once it is full we</span>
<span class="cm"> * disable further reception into main mailboxes. While the main mailboxes are</span>
<span class="cm"> * processed in NAPI, further packets are received in buffer mailboxes.</span>
<span class="cm"> *</span>
<span class="cm"> * We maintain a RX next mailbox counter to process packets and once all main</span>
<span class="cm"> * mailboxe packets are passed to the upper stack we enable all of them but</span>
<span class="cm"> * continue to process packets received in buffer mailboxes. With each packet</span>
<span class="cm"> * received from buffer mailbox we enable it immediately so as to handle the</span>
<span class="cm"> * overflow from higher mailboxes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_rx_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quota</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">num_pkts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mbx_mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pending_pkts</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">ndev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">pending_pkts</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANRMP</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="n">num_pkts</span> <span class="o">&lt;</span> <span class="n">quota</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mbx_mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span><span class="p">);</span> <span class="cm">/* next rx mailbox to process */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mbx_mask</span> <span class="o">&amp;</span> <span class="n">pending_pkts</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ti_hecc_rx_pkt</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">num_pkts</span><span class="p">;</span>
			<span class="o">++</span><span class="n">num_pkts</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span> <span class="o">&gt;</span> <span class="n">HECC_RX_BUFFER_MBOX</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* pkt not received yet */</span>
		<span class="p">}</span>
		<span class="o">--</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span> <span class="o">==</span> <span class="n">HECC_RX_BUFFER_MBOX</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* enable high bank mailboxes */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">mbx_mask</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">);</span>
			<span class="n">mbx_mask</span> <span class="o">|=</span> <span class="n">HECC_RX_HIGH_MBOX_MASK</span><span class="p">;</span>
			<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span> <span class="o">==</span> <span class="n">HECC_MAX_TX_MBOX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">rx_next</span> <span class="o">=</span> <span class="n">HECC_RX_FIRST_MBOX</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Enable packet interrupt if all pkts are handled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANRMP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="cm">/* Re-enable RX mailbox interrupts */</span>
		<span class="n">mbx_mask</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIM</span><span class="p">);</span>
		<span class="n">mbx_mask</span> <span class="o">|=</span> <span class="n">HECC_TX_MBOX_MASK</span><span class="p">;</span>
		<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIM</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">num_pkts</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">int_status</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">err_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* propagate the error condition to the can stack */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_can_err_skb</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span>
				<span class="s">&quot;ti_hecc_error: alloc_can_err_skb() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANGIF_WLIF</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* warning level int */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">int_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANGIF_BOIF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_WARNING</span><span class="p">;</span>
			<span class="o">++</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">can_stats</span><span class="p">.</span><span class="n">error_warning</span><span class="p">;</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANTEC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">96</span><span class="p">)</span>
				<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_TX_WARNING</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANREC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">96</span><span class="p">)</span>
				<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_RX_WARNING</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_EW</span><span class="p">);</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Error Warning interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="n">HECC_CANMC_CCR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANGIF_EPIF</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* error passive int */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">int_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANGIF_BOIF</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_PASSIVE</span><span class="p">;</span>
			<span class="o">++</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">can_stats</span><span class="p">.</span><span class="n">error_passive</span><span class="p">;</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANTEC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">)</span>
				<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_TX_PASSIVE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANREC</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">127</span><span class="p">)</span>
				<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_RX_PASSIVE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_EP</span><span class="p">);</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;Error passive interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="n">HECC_CANMC_CCR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to check busoff condition in error status register too to</span>
<span class="cm">	 * ensure warning interrupts don&#39;t hog the system</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">int_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANGIF_BOIF</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANES_BO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_BUS_OFF</span><span class="p">;</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_BUSOFF</span><span class="p">;</span>
		<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_BO</span><span class="p">);</span>
		<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="n">HECC_CANMC_CCR</span><span class="p">);</span>
		<span class="cm">/* Disable all interrupts in bus-off to avoid int hog */</span>
		<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">can_bus_off</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">HECC_BUS_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">can_stats</span><span class="p">.</span><span class="n">bus_error</span><span class="p">;</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_BUSERROR</span> <span class="o">|</span> <span class="n">CAN_ERR_PROT</span><span class="p">;</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_PROT_UNSPEC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANES_FE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_FE</span><span class="p">);</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_PROT_FORM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANES_BE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_BE</span><span class="p">);</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_PROT_BIT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANES_SE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_SE</span><span class="p">);</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_PROT_STUFF</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANES_CRCE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_CRCE</span><span class="p">);</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_PROT_LOC_CRC_SEQ</span> <span class="o">|</span>
					<span class="n">CAN_ERR_PROT_LOC_CRC_DEL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANES_ACKE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">,</span> <span class="n">HECC_CANES_ACKE</span><span class="p">);</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_PROT_LOC_ACK</span> <span class="o">|</span>
					<span class="n">CAN_ERR_PROT_LOC_ACK_DEL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ti_hecc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mbxno</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">,</span> <span class="n">int_status</span><span class="p">,</span> <span class="n">err_status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ack</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">int_status</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span>
		<span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_line</span><span class="p">)</span> <span class="o">?</span> <span class="n">HECC_CANGIF1</span> <span class="o">:</span> <span class="n">HECC_CANGIF0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">int_status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">err_status</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HECC_BUS_ERROR</span> <span class="o">|</span> <span class="n">HECC_CANES_BO</span> <span class="o">|</span>
		<span class="n">HECC_CANES_EP</span> <span class="o">|</span> <span class="n">HECC_CANES_EW</span><span class="p">))</span>
			<span class="n">ti_hecc_error</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="n">int_status</span><span class="p">,</span> <span class="n">err_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">int_status</span> <span class="o">&amp;</span> <span class="n">HECC_CANGIF_GMIF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">-</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mbxno</span> <span class="o">=</span> <span class="n">get_tx_tail_mb</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
			<span class="n">mbx_mask</span> <span class="o">=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">mbxno</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mbx_mask</span> <span class="o">&amp;</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANTA</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIM</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
			<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANTA</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANME</span><span class="p">,</span> <span class="n">mbx_mask</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">hecc_read_mbx</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">,</span>
						<span class="n">HECC_CANMCF</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">can_get_echo_skb</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="n">mbxno</span><span class="p">);</span>
			<span class="o">--</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* restart queue if wrap-up or if queue stalled on last pkt */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">==</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">&amp;</span> <span class="n">HECC_TX_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HECC_TX_MASK</span><span class="p">))</span> <span class="o">||</span>
		<span class="p">(((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_tail</span> <span class="o">&amp;</span> <span class="n">HECC_TX_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HECC_TX_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_head</span> <span class="o">&amp;</span> <span class="n">HECC_TX_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">HECC_TX_MASK</span><span class="p">)))</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

		<span class="cm">/* Disable RX mailbox interrupts and let NAPI reenable them */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANRMP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ack</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIM</span><span class="p">);</span>
			<span class="n">ack</span> <span class="o">&amp;=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">HECC_MAX_TX_MBOX</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMIM</span><span class="p">,</span> <span class="n">ack</span><span class="p">);</span>
			<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* clear all interrupt conditions - read back to avoid spurious ints */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_line</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIF1</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
		<span class="n">int_status</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIF1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hecc_write</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIF0</span><span class="p">,</span> <span class="n">HECC_SET_REG</span><span class="p">);</span>
		<span class="n">int_status</span> <span class="o">=</span> <span class="n">hecc_read</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANGIF0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ti_hecc_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ndev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;error requesting interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ti_hecc_transceiver_switch</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Open common can device */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">open_candev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="s">&quot;open_candev() failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">ti_hecc_transceiver_switch</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ndev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ti_hecc_start</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="n">ti_hecc_stop</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ndev</span><span class="p">);</span>
	<span class="n">close_candev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">ti_hecc_transceiver_switch</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">ti_hecc_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">ti_hecc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">ti_hecc_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">ti_hecc_xmit</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ti_hecc_platform_data</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="o">*</span><span class="n">irq</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">pdata</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No platform data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">probe_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mem</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No mem resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">probe_exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_IRQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No irq resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">probe_exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">mem</span><span class="p">),</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HECC region already claimed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">probe_exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">mem</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ioremap failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">probe_exit_free_region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ndev</span> <span class="o">=</span> <span class="n">alloc_candev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ti_hecc_priv</span><span class="p">),</span> <span class="n">HECC_MAX_TX_MBOX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;alloc_candev failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">probe_exit_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">ndev</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">scc_ram_offset</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">scc_ram_offset</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">hecc_ram_offset</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">hecc_ram_offset</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_offset</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">mbx_offset</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">int_line</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">int_line</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">transceiver_switch</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_switch</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">bittiming_const</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ti_hecc_bittiming_const</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">do_set_mode</span> <span class="o">=</span> <span class="n">ti_hecc_do_set_mode</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">do_get_state</span> <span class="o">=</span> <span class="n">ti_hecc_get_state</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">do_get_berr_counter</span> <span class="o">=</span> <span class="n">ti_hecc_get_berr_counter</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">ctrlmode_supported</span> <span class="o">=</span> <span class="n">CAN_CTRLMODE_3_SAMPLES</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mbx_lock</span><span class="p">);</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_ECHO</span><span class="p">;</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ndev</span><span class="p">);</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ti_hecc_netdev_ops</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="n">clk_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hecc_ck&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No clock available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">probe_exit_candev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">clock</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">clk_get_rate</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">ti_hecc_rx_poll</span><span class="p">,</span>
		<span class="n">HECC_DEF_NAPI_WEIGHT</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_candev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;register_candev() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">probe_exit_clk</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device registered (reg_base=%p, irq=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">probe_exit_clk:</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
<span class="nl">probe_exit_candev:</span>
	<span class="n">free_candev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
<span class="nl">probe_exit_iounmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="nl">probe_exit_free_region:</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">mem</span><span class="p">));</span>
<span class="nl">probe_exit:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">ti_hecc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">clk_put</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="n">release_mem_region</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">resource_size</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
	<span class="n">unregister_candev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">free_candev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hecc_set_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="n">HECC_CANMC_PDR</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_SLEEPING</span><span class="p">;</span>

	<span class="n">clk_disable</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ti_hecc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ti_hecc_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">clk_enable</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">clk</span><span class="p">);</span>

	<span class="n">hecc_clear_bit</span><span class="p">(</span><span class="n">priv</span><span class="p">,</span> <span class="n">HECC_CANMC</span><span class="p">,</span> <span class="n">HECC_CANMC_PDR</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define ti_hecc_suspend NULL</span>
<span class="cp">#define ti_hecc_resume NULL</span>
<span class="cp">#endif</span>

<span class="cm">/* TI HECC netdevice driver: platform driver structure */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">ti_hecc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>    <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ti_hecc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ti_hecc_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">ti_hecc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">ti_hecc_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">ti_hecc_driver</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Anant Gole &lt;anantgole@ti.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRV_DESC</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
