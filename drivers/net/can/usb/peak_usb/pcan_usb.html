<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › can › usb › peak_usb › pcan_usb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>pcan_usb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * CAN driver for PEAK System PCAN-USB adapter</span>
<span class="cm"> * Derived from the PCAN project file driver/src/pcan_usb.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2003-2010 PEAK System-Technik GmbH</span>
<span class="cm"> * Copyright (C) 2011-2012 Stephane Grosjean &lt;s.grosjean@peak-system.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Many thanks to Klaus Hitschler &lt;klaus.hitschler@gmx.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published</span>
<span class="cm"> * by the Free Software Foundation; version 2 of the License.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;linux/can.h&gt;</span>
<span class="cp">#include &lt;linux/can/dev.h&gt;</span>
<span class="cp">#include &lt;linux/can/error.h&gt;</span>

<span class="cp">#include &quot;pcan_usb_core.h&quot;</span>

<span class="n">MODULE_SUPPORTED_DEVICE</span><span class="p">(</span><span class="s">&quot;PEAK-System PCAN-USB adapter&quot;</span><span class="p">);</span>

<span class="cm">/* PCAN-USB Endpoints */</span>
<span class="cp">#define PCAN_USB_EP_CMDOUT		1</span>
<span class="cp">#define PCAN_USB_EP_CMDIN		(PCAN_USB_EP_CMDOUT | USB_DIR_IN)</span>
<span class="cp">#define PCAN_USB_EP_MSGOUT		2</span>
<span class="cp">#define PCAN_USB_EP_MSGIN		(PCAN_USB_EP_MSGOUT | USB_DIR_IN)</span>

<span class="cm">/* PCAN-USB command struct */</span>
<span class="cp">#define PCAN_USB_CMD_FUNC		0</span>
<span class="cp">#define PCAN_USB_CMD_NUM		1</span>
<span class="cp">#define PCAN_USB_CMD_ARGS		2</span>
<span class="cp">#define PCAN_USB_CMD_ARGS_LEN		14</span>
<span class="cp">#define PCAN_USB_CMD_LEN		(PCAN_USB_CMD_ARGS + \</span>
<span class="cp">					 PCAN_USB_CMD_ARGS_LEN)</span>

<span class="cm">/* PCAN-USB command timeout (ms.) */</span>
<span class="cp">#define PCAN_USB_COMMAND_TIMEOUT	1000</span>

<span class="cm">/* PCAN-USB startup timeout (ms.) */</span>
<span class="cp">#define PCAN_USB_STARTUP_TIMEOUT	10</span>

<span class="cm">/* PCAN-USB rx/tx buffers size */</span>
<span class="cp">#define PCAN_USB_RX_BUFFER_SIZE		64</span>
<span class="cp">#define PCAN_USB_TX_BUFFER_SIZE		64</span>

<span class="cp">#define PCAN_USB_MSG_HEADER_LEN		2</span>

<span class="cm">/* PCAN-USB adapter internal clock (MHz) */</span>
<span class="cp">#define PCAN_USB_CRYSTAL_HZ		16000000</span>

<span class="cm">/* PCAN-USB USB message record status/len field */</span>
<span class="cp">#define PCAN_USB_STATUSLEN_TIMESTAMP	(1 &lt;&lt; 7)</span>
<span class="cp">#define PCAN_USB_STATUSLEN_INTERNAL	(1 &lt;&lt; 6)</span>
<span class="cp">#define PCAN_USB_STATUSLEN_EXT_ID	(1 &lt;&lt; 5)</span>
<span class="cp">#define PCAN_USB_STATUSLEN_RTR		(1 &lt;&lt; 4)</span>
<span class="cp">#define PCAN_USB_STATUSLEN_DLC		(0xf)</span>

<span class="cm">/* PCAN-USB error flags */</span>
<span class="cp">#define PCAN_USB_ERROR_TXFULL		0x01</span>
<span class="cp">#define PCAN_USB_ERROR_RXQOVR		0x02</span>
<span class="cp">#define PCAN_USB_ERROR_BUS_LIGHT	0x04</span>
<span class="cp">#define PCAN_USB_ERROR_BUS_HEAVY	0x08</span>
<span class="cp">#define PCAN_USB_ERROR_BUS_OFF		0x10</span>
<span class="cp">#define PCAN_USB_ERROR_RXQEMPTY		0x20</span>
<span class="cp">#define PCAN_USB_ERROR_QOVR		0x40</span>
<span class="cp">#define PCAN_USB_ERROR_TXQFULL		0x80</span>

<span class="cm">/* SJA1000 modes */</span>
<span class="cp">#define SJA1000_MODE_NORMAL		0x00</span>
<span class="cp">#define SJA1000_MODE_INIT		0x01</span>

<span class="cm">/*</span>
<span class="cm"> * tick duration = 42.666 us =&gt;</span>
<span class="cm"> * (tick_number * 44739243) &gt;&gt; 20 ~ (tick_number * 42666) / 1000</span>
<span class="cm"> * accuracy = 10^-7</span>
<span class="cm"> */</span>
<span class="cp">#define PCAN_USB_TS_DIV_SHIFTER		20</span>
<span class="cp">#define PCAN_USB_TS_US_PER_TICK		44739243</span>

<span class="cm">/* PCAN-USB messages record types */</span>
<span class="cp">#define PCAN_USB_REC_ERROR		1</span>
<span class="cp">#define PCAN_USB_REC_ANALOG		2</span>
<span class="cp">#define PCAN_USB_REC_BUSLOAD		3</span>
<span class="cp">#define PCAN_USB_REC_TS			4</span>
<span class="cp">#define PCAN_USB_REC_BUSEVT		5</span>

<span class="cm">/* private to PCAN-USB adapter */</span>
<span class="k">struct</span> <span class="n">pcan_usb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">peak_time_ref</span> <span class="n">time_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">restart_timer</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* incoming message context for decoding */</span>
<span class="k">struct</span> <span class="n">pcan_usb_msg_context</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ts16</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">prev_ts8</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rec_cnt</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rec_idx</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rec_data_idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcan_usb</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * send a command</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_send_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">f</span><span class="p">,</span> <span class="n">u8</span> <span class="n">n</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">actual_length</span><span class="p">;</span>

	<span class="cm">/* usb device unregistered? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATE_CONNECTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="p">[</span><span class="n">PCAN_USB_CMD_FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="p">[</span><span class="n">PCAN_USB_CMD_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_buf</span> <span class="o">+</span> <span class="n">PCAN_USB_CMD_ARGS</span><span class="p">,</span>
			<span class="n">p</span><span class="p">,</span> <span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_bulk_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">PCAN_USB_EP_CMDOUT</span><span class="p">),</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="p">,</span> <span class="n">PCAN_USB_CMD_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">actual_length</span><span class="p">,</span>
			<span class="n">PCAN_USB_COMMAND_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
			<span class="s">&quot;sending cmd f=0x%x n=0x%x failure: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * send a command then wait for its response</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_wait_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">f</span><span class="p">,</span> <span class="n">u8</span> <span class="n">n</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">actual_length</span><span class="p">;</span>

	<span class="cm">/* usb device unregistered? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATE_CONNECTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* first, send command */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_send_cmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">usb_bulk_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
		<span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">PCAN_USB_EP_CMDIN</span><span class="p">),</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_buf</span><span class="p">,</span> <span class="n">PCAN_USB_CMD_LEN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">actual_length</span><span class="p">,</span>
		<span class="n">PCAN_USB_COMMAND_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
			<span class="s">&quot;waiting rsp f=0x%x n=0x%x failure: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cmd_buf</span> <span class="o">+</span> <span class="n">PCAN_USB_CMD_ARGS</span><span class="p">,</span>
			<span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_set_sja1000</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">pcan_usb_send_cmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_set_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">onoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">!!</span><span class="n">onoff</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">pcan_usb_send_cmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_set_silent</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">onoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">!!</span><span class="n">onoff</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">pcan_usb_send_cmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_set_ext_vcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">onoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">!!</span><span class="n">onoff</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">pcan_usb_send_cmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set bittiming value to can</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_set_bittiming</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">can_bittiming</span> <span class="o">*</span><span class="n">bt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">btr0</span><span class="p">,</span> <span class="n">btr1</span><span class="p">;</span>

	<span class="n">btr0</span> <span class="o">=</span> <span class="p">((</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">brp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">sjw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">btr1</span> <span class="o">=</span> <span class="p">((</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">prop_seg</span> <span class="o">+</span> <span class="n">bt</span><span class="o">-&gt;</span><span class="n">phase_seg1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(((</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">phase_seg2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">ctrlmode</span> <span class="o">&amp;</span> <span class="n">CAN_CTRLMODE_3_SAMPLES</span><span class="p">)</span>
		<span class="n">btr1</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;setting BTR0=0x%02x BTR1=0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">btr0</span><span class="p">,</span> <span class="n">btr1</span><span class="p">);</span>

	<span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">btr1</span><span class="p">;</span>
	<span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">btr0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pcan_usb_send_cmd</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * init/reset can</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_write_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">onoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_set_bus</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">onoff</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_set_sja1000</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">SJA1000_MODE_INIT</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* the PCAN-USB needs time to init */</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">PCAN_USB_STARTUP_TIMEOUT</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handle end of waiting for the device to reset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcan_usb_restart</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* notify candev and netdev */</span>
	<span class="n">peak_usb_restart_complete</span><span class="p">((</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handle the submission of the restart urb</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcan_usb_restart_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcan_usb</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

	<span class="cm">/* the PCAN-USB needs time to restart */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">restart_timer</span><span class="p">,</span>
			<span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">PCAN_USB_STARTUP_TIMEOUT</span><span class="p">));</span>

	<span class="cm">/* can delete usb resources */</span>
	<span class="n">peak_usb_async_complete</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handle asynchronous restart</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_restart_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcan_usb</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcan_usb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">restart_timer</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* set bus on */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">PCAN_USB_CMD_FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">PCAN_USB_CMD_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">PCAN_USB_CMD_ARGS</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span>
			<span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">PCAN_USB_EP_CMDOUT</span><span class="p">),</span>
			<span class="n">buf</span><span class="p">,</span> <span class="n">PCAN_USB_CMD_LEN</span><span class="p">,</span>
			<span class="n">pcan_usb_restart_pending</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read serial number from device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_get_serial</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">serial_number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_wait_rsp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;getting serial failure: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">serial_number</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">tmp32</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp32</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="o">*</span><span class="n">serial_number</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tmp32</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read device id from device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_get_device_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">device_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="n">PCAN_USB_CMD_ARGS_LEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_wait_rsp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;getting device id failure: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">device_id</span><span class="p">)</span>
		<span class="o">*</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update current time ref with received timestamp</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_update_ts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcan_usb_msg_context</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tmp16</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp16</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tmp16</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">rec_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">peak_usb_update_ts_now</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">time_ref</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">peak_usb_set_ts_now</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">time_ref</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * decode received timestamp</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_decode_ts</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcan_usb_msg_context</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">first_packet</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* only 1st packet supplies a word timestamp */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_packet</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tmp16</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp16</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tmp16</span><span class="p">);</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">prev_ts8</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">ts8</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">ts8</span> <span class="o">=</span> <span class="o">*</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ts8</span> <span class="o">&lt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">prev_ts8</span><span class="p">)</span>
			<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span> <span class="o">+=</span> <span class="mh">0x100</span><span class="p">;</span>

		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span> <span class="o">&amp;=</span> <span class="mh">0xff00</span><span class="p">;</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span> <span class="o">|=</span> <span class="n">ts8</span><span class="p">;</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">prev_ts8</span> <span class="o">=</span> <span class="n">ts8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_decode_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcan_usb_msg_context</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">n</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">status_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">can_state</span> <span class="n">new_state</span><span class="p">;</span>

	<span class="cm">/* ignore this error until 1st ts received */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">PCAN_USB_ERROR_QOVR</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">time_ref</span><span class="p">.</span><span class="n">tick_count</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new_state</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">state</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_ERROR_BUS_LIGHT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_WARNING</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="n">CAN_STATE_ERROR_WARNING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_ERROR_BUS_HEAVY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_PASSIVE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_ERROR_BUS_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_BUS_OFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCAN_USB_ERROR_RXQOVR</span> <span class="o">|</span> <span class="n">PCAN_USB_ERROR_QOVR</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * trick to bypass next comparison and process other</span>
<span class="cm">			 * errors</span>
<span class="cm">			 */</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_MAX</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_ERROR_BUS_LIGHT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* no error (back to active state) */</span>
			<span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CAN_STATE_ERROR_PASSIVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_ERROR_BUS_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_BUS_OFF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_ERROR_BUS_LIGHT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_WARNING</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCAN_USB_ERROR_RXQOVR</span> <span class="o">|</span> <span class="n">PCAN_USB_ERROR_QOVR</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * trick to bypass next comparison and process other</span>
<span class="cm">			 * errors</span>
<span class="cm">			 */</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_MAX</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_ERROR_BUS_HEAVY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* no error (back to active state) */</span>
			<span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* do nothing waiting for restart */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* donot post any error if current state didn&#39;t change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">new_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* allocate an skb to store the error frame */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_can_err_skb</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">new_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CAN_STATE_BUS_OFF</span>:
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_BUSOFF</span><span class="p">;</span>
		<span class="n">can_bus_off</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CAN_STATE_ERROR_PASSIVE</span>:
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_TX_PASSIVE</span> <span class="o">|</span>
			       <span class="n">CAN_ERR_CRTL_RX_PASSIVE</span><span class="p">;</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">can_stats</span><span class="p">.</span><span class="n">error_passive</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CAN_STATE_ERROR_WARNING</span>:
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_TX_WARNING</span> <span class="o">|</span>
			       <span class="n">CAN_ERR_CRTL_RX_WARNING</span><span class="p">;</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">can_stats</span><span class="p">.</span><span class="n">error_warning</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* CAN_STATE_MAX (trick to handle other errors) */</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_RX_OVERFLOW</span><span class="p">;</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>

		<span class="n">new_state</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">state</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status_len</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATUSLEN_TIMESTAMP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">peak_usb_get_ts_tv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">time_ref</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span> <span class="o">=</span> <span class="n">timeval_to_ktime</span><span class="p">(</span><span class="n">tv</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * decode non-data usb message</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_decode_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcan_usb_msg_context</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="n">status_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">rec_len</span> <span class="o">=</span> <span class="n">status_len</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATUSLEN_DLC</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* check whether function and number can be read */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">f</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">PCAN_USB_CMD_FUNC</span><span class="p">];</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">PCAN_USB_CMD_NUM</span><span class="p">];</span>
	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">PCAN_USB_CMD_ARGS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status_len</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATUSLEN_TIMESTAMP</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_decode_ts</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="o">!</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">rec_idx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PCAN_USB_REC_ERROR</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_decode_error</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">status_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCAN_USB_REC_ANALOG</span>:
		<span class="cm">/* analog values (ignored) */</span>
		<span class="n">rec_len</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCAN_USB_REC_BUSLOAD</span>:
		<span class="cm">/* bus load (ignored) */</span>
		<span class="n">rec_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCAN_USB_REC_TS</span>:
		<span class="cm">/* only timestamp */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcan_usb_update_ts</span><span class="p">(</span><span class="n">mc</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">PCAN_USB_REC_BUSEVT</span>:
		<span class="cm">/* error frame/bus event */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_ERROR_TXQFULL</span><span class="p">)</span>
			<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;device Tx queue full)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;unexpected function %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">rec_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">rec_len</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * decode data usb message</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_decode_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcan_usb_msg_context</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">status_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">rec_len</span> <span class="o">=</span> <span class="n">status_len</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATUSLEN_DLC</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_can_skb</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status_len</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATUSLEN_EXT_ID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">tmp32</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">decode_failed</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp32</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">tmp32</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="n">CAN_EFF_FLAG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">tmp16</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">decode_failed</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp16</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">tmp16</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">=</span> <span class="n">get_can_dlc</span><span class="p">(</span><span class="n">rec_len</span><span class="p">);</span>

	<span class="cm">/* first data packet timestamp is a word */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcan_usb_decode_ts</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="o">!</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">rec_data_idx</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">decode_failed</span><span class="p">;</span>

	<span class="cm">/* read data */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status_len</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATUSLEN_RTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_RTR_FLAG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">rec_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">decode_failed</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">rec_len</span><span class="p">);</span>
		<span class="n">mc</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">rec_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* convert timestamp into kernel time */</span>
	<span class="n">peak_usb_get_ts_tv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">time_ref</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">ts16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span> <span class="o">=</span> <span class="n">timeval_to_ktime</span><span class="p">(</span><span class="n">tv</span><span class="p">);</span>

	<span class="cm">/* push the skb */</span>
	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* update statistics */</span>
	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">decode_failed:</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * process incoming message</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_decode_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ibuf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcan_usb_msg_context</span> <span class="n">mc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">rec_cnt</span> <span class="o">=</span> <span class="n">ibuf</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
		<span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ibuf</span> <span class="o">+</span> <span class="n">PCAN_USB_MSG_HEADER_LEN</span><span class="p">,</span>
		<span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">ibuf</span> <span class="o">+</span> <span class="n">lbuf</span><span class="p">,</span>
		<span class="p">.</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcan_usb</span><span class="p">,</span> <span class="n">dev</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mc</span><span class="p">.</span><span class="n">rec_idx</span> <span class="o">&lt;</span> <span class="n">mc</span><span class="p">.</span><span class="n">rec_cnt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">;</span> <span class="n">mc</span><span class="p">.</span><span class="n">rec_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">sl</span> <span class="o">=</span> <span class="o">*</span><span class="n">mc</span><span class="p">.</span><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* handle status and error frames here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sl</span> <span class="o">&amp;</span> <span class="n">PCAN_USB_STATUSLEN_INTERNAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_decode_status</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
		<span class="cm">/* handle normal can frames here */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_decode_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="n">sl</span><span class="p">);</span>
			<span class="n">mc</span><span class="p">.</span><span class="n">rec_data_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * process any incoming buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_decode_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&gt;</span> <span class="n">PCAN_USB_MSG_HEADER_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_decode_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="s">&quot;usb message length error (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * process outgoing packet</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_encode_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">obuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

	<span class="n">obuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">obuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">obuf</span> <span class="o">+</span> <span class="n">PCAN_USB_MSG_HEADER_LEN</span><span class="p">;</span>

	<span class="cm">/* status/len byte */</span>
	<span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_RTR_FLAG</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pc</span> <span class="o">|=</span> <span class="n">PCAN_USB_STATUSLEN_RTR</span><span class="p">;</span>

	<span class="cm">/* can id */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__le32</span> <span class="n">tmp32</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_ERR_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>

		<span class="o">*</span><span class="n">pc</span> <span class="o">|=</span> <span class="n">PCAN_USB_STATUSLEN_EXT_ID</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">++</span><span class="n">pc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp32</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">pc</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__le16</span> <span class="n">tmp16</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_ERR_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">++</span><span class="n">pc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp16</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">pc</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* can data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_RTR_FLAG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">);</span>
		<span class="n">pc</span> <span class="o">+=</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">obuf</span><span class="p">[(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * start interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcan_usb</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcan_usb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* number of bits used in timestamps read from adapter struct */</span>
	<span class="n">peak_usb_init_time_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">time_ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcan_usb</span><span class="p">);</span>

	<span class="cm">/* if revision greater than 3, can put silent mode on/off */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">device_rev</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_set_silent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">ctrlmode</span> <span class="o">&amp;</span> <span class="n">CAN_CTRLMODE_LISTENONLY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pcan_usb_set_ext_vcc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">peak_usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcan_usb</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcan_usb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">serial_number</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* initialize a timer needed to wait for hardware restart */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">restart_timer</span><span class="p">);</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">restart_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">pcan_usb_restart</span><span class="p">;</span>
	<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">restart_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * explicit use of dev_xxx() instead of netdev_xxx() here:</span>
<span class="cm">	 * information displayed are related to the device itself, not</span>
<span class="cm">	 * to the canx netdevice.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pcan_usb_get_serial</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serial_number</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
			<span class="s">&quot;unable to read %s serial number (err %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pcan_usb</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
		 <span class="s">&quot;PEAK-System %s adapter hwrev %u serial %08X (%u channel)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">pcan_usb</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device_rev</span><span class="p">,</span> <span class="n">serial_number</span><span class="p">,</span>
		 <span class="n">pcan_usb</span><span class="p">.</span><span class="n">ctrl_count</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * probe function for new PCAN-USB usb interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcan_usb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">if_desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">if_desc</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="p">;</span>

	<span class="cm">/* check interface endpoint addresses */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">if_desc</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_endpoint_descriptor</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">if_desc</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PCAN_USB_EP_CMDOUT</span>:
		<span class="k">case</span> <span class="n">PCAN_USB_EP_CMDIN</span>:
		<span class="k">case</span> <span class="n">PCAN_USB_EP_MSGOUT</span>:
		<span class="k">case</span> <span class="n">PCAN_USB_EP_MSGIN</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * describe the PCAN-USB adapter</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">peak_usb_adapter</span> <span class="n">pcan_usb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;PCAN-USB&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">PCAN_USB_PRODUCT_ID</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ctrl_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clock</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">PCAN_USB_CRYSTAL_HZ</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">bittiming_const</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;pcan_usb&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tseg1_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tseg1_max</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tseg2_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tseg2_max</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sjw_max</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">brp_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">brp_max</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
		<span class="p">.</span><span class="n">brp_inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="cm">/* size of device private data */</span>
	<span class="p">.</span><span class="n">sizeof_dev_private</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcan_usb</span><span class="p">),</span>

	<span class="cm">/* timestamps usage */</span>
	<span class="p">.</span><span class="n">ts_used_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ts_period</span> <span class="o">=</span> <span class="mi">24575</span><span class="p">,</span> <span class="cm">/* calibration period in ts. */</span>
	<span class="p">.</span><span class="n">us_per_ts_scale</span> <span class="o">=</span> <span class="n">PCAN_USB_TS_US_PER_TICK</span><span class="p">,</span> <span class="cm">/* us=(ts*scale) */</span>
	<span class="p">.</span><span class="n">us_per_ts_shift</span> <span class="o">=</span> <span class="n">PCAN_USB_TS_DIV_SHIFTER</span><span class="p">,</span> <span class="cm">/*  &gt;&gt; shift     */</span>

	<span class="cm">/* give here messages in/out endpoints */</span>
	<span class="p">.</span><span class="n">ep_msg_in</span> <span class="o">=</span> <span class="n">PCAN_USB_EP_MSGIN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ep_msg_out</span> <span class="o">=</span> <span class="p">{</span><span class="n">PCAN_USB_EP_MSGOUT</span><span class="p">},</span>

	<span class="cm">/* size of rx/tx usb buffers */</span>
	<span class="p">.</span><span class="n">rx_buffer_size</span> <span class="o">=</span> <span class="n">PCAN_USB_RX_BUFFER_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tx_buffer_size</span> <span class="o">=</span> <span class="n">PCAN_USB_TX_BUFFER_SIZE</span><span class="p">,</span>

	<span class="cm">/* device callbacks */</span>
	<span class="p">.</span><span class="n">intf_probe</span> <span class="o">=</span> <span class="n">pcan_usb_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_init</span> <span class="o">=</span> <span class="n">pcan_usb_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_set_bus</span> <span class="o">=</span> <span class="n">pcan_usb_write_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_set_bittiming</span> <span class="o">=</span> <span class="n">pcan_usb_set_bittiming</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_get_device_id</span> <span class="o">=</span> <span class="n">pcan_usb_get_device_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_decode_buf</span> <span class="o">=</span> <span class="n">pcan_usb_decode_buf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_encode_msg</span> <span class="o">=</span> <span class="n">pcan_usb_encode_msg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_start</span> <span class="o">=</span> <span class="n">pcan_usb_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_restart_async</span> <span class="o">=</span> <span class="n">pcan_usb_restart_async</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
