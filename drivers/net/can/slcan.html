<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › can › slcan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>slcan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * slcan.c - serial line CAN interface driver (using tty line discipline)</span>
<span class="cm"> *</span>
<span class="cm"> * This file is derived from linux/drivers/net/slip/slip.c</span>
<span class="cm"> *</span>
<span class="cm"> * slip.c Authors  : Laurence Culhane &lt;loz@holmes.demon.co.uk&gt;</span>
<span class="cm"> *                   Fred N. van Kempen &lt;waltje@uwalt.nl.mugnet.org&gt;</span>
<span class="cm"> * slcan.c Author  : Oliver Hartkopp &lt;socketcan@hartkopp.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 59 Temple Place, Suite 330, Boston, MA 02111-1307. You can also get it</span>
<span class="cm"> * at http://www.gnu.org/licenses/gpl.html</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="cm"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="cm"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="cm"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="cm"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="cm"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="cm"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="cm"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="cm"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
<span class="cm"> * DAMAGE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>

<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/tty.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/can.h&gt;</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">banner</span><span class="p">[]</span> <span class="o">=</span>
	<span class="n">KERN_INFO</span> <span class="s">&quot;slcan: serial line CAN interface driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="n">MODULE_ALIAS_LDISC</span><span class="p">(</span><span class="n">N_SLCAN</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;serial line CAN interface&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Oliver Hartkopp &lt;socketcan@hartkopp.net&gt;&quot;</span><span class="p">);</span>

<span class="cp">#define SLCAN_MAGIC 0x53CA</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">maxdev</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>		<span class="cm">/* MAX number of SLCAN channels;</span>
<span class="cm">				   This can be overridden with</span>
<span class="cm">				   insmod slcan.ko maxdev=nnn	*/</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">maxdev</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">maxdev</span><span class="p">,</span> <span class="s">&quot;Maximum number of slcan interfaces&quot;</span><span class="p">);</span>

<span class="cm">/* maximum rx buffer len: extended CAN frame with timestamp */</span>
<span class="cp">#define SLC_MTU (sizeof(&quot;T1111222281122334455667788EA5F\r&quot;)+1)</span>

<span class="k">struct</span> <span class="n">slcan</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">magic</span><span class="p">;</span>

	<span class="cm">/* Various fields. */</span>
	<span class="k">struct</span> <span class="n">tty_struct</span>	<span class="o">*</span><span class="n">tty</span><span class="p">;</span>		<span class="cm">/* ptr to TTY structure	     */</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* easy for intr handling    */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* These are pointers to the malloc()ed frame buffers. */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">rbuff</span><span class="p">[</span><span class="n">SLC_MTU</span><span class="p">];</span>	<span class="cm">/* receiver buffer	     */</span>
	<span class="kt">int</span>			<span class="n">rcount</span><span class="p">;</span>         <span class="cm">/* received chars counter    */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="n">xbuff</span><span class="p">[</span><span class="n">SLC_MTU</span><span class="p">];</span>	<span class="cm">/* transmitter buffer	     */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">xhead</span><span class="p">;</span>         <span class="cm">/* pointer to next XMIT byte */</span>
	<span class="kt">int</span>			<span class="n">xleft</span><span class="p">;</span>          <span class="cm">/* bytes left in XMIT queue  */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Flag values/ mode etc     */</span>
<span class="cp">#define SLF_INUSE		0		</span><span class="cm">/* Channel in use            */</span><span class="cp"></span>
<span class="cp">#define SLF_ERROR		1               </span><span class="cm">/* Parity, etc. error        */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">**</span><span class="n">slcan_devs</span><span class="p">;</span>

 <span class="cm">/************************************************************************</span>
<span class="cm">  *			SLCAN ENCAPSULATION FORMAT			 *</span>
<span class="cm">  ************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * A CAN frame has a can_id (11 bit standard frame format OR 29 bit extended</span>
<span class="cm"> * frame format) a data length code (can_dlc) which can be from 0 to 8</span>
<span class="cm"> * and up to &lt;can_dlc&gt; data bytes as payload.</span>
<span class="cm"> * Additionally a CAN frame may become a remote transmission frame if the</span>
<span class="cm"> * RTR-bit is set. This causes another ECU to send a CAN frame with the</span>
<span class="cm"> * given can_id.</span>
<span class="cm"> *</span>
<span class="cm"> * The SLCAN ASCII representation of these different frame types is:</span>
<span class="cm"> * &lt;type&gt; &lt;id&gt; &lt;dlc&gt; &lt;data&gt;*</span>
<span class="cm"> *</span>
<span class="cm"> * Extended frames (29 bit) are defined by capital characters in the type.</span>
<span class="cm"> * RTR frames are defined as &#39;r&#39; types - normal frames have &#39;t&#39; type:</span>
<span class="cm"> * t =&gt; 11 bit data frame</span>
<span class="cm"> * r =&gt; 11 bit RTR frame</span>
<span class="cm"> * T =&gt; 29 bit data frame</span>
<span class="cm"> * R =&gt; 29 bit RTR frame</span>
<span class="cm"> *</span>
<span class="cm"> * The &lt;id&gt; is 3 (standard) or 8 (extended) bytes in ASCII Hex (base64).</span>
<span class="cm"> * The &lt;dlc&gt; is a one byte ASCII number (&#39;0&#39; - &#39;8&#39;)</span>
<span class="cm"> * The &lt;data&gt; section has at much ASCII Hex bytes as defined by the &lt;dlc&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Examples:</span>
<span class="cm"> *</span>
<span class="cm"> * t1230 : can_id 0x123, can_dlc 0, no data</span>
<span class="cm"> * t4563112233 : can_id 0x456, can_dlc 3, data 0x11 0x22 0x33</span>
<span class="cm"> * T12ABCDEF2AA55 : extended can_id 0x12ABCDEF, can_dlc 2, data 0xAA 0x55</span>
<span class="cm"> * r1230 : can_id 0x123, can_dlc 0, no data, remote transmission request</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

 <span class="cm">/************************************************************************</span>
<span class="cm">  *			STANDARD SLCAN DECAPSULATION			 *</span>
<span class="cm">  ************************************************************************/</span>

<span class="cm">/* Send one completely decapsulated can_frame to the network layer */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slc_bump</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="n">cf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">dlc_pos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ultmp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">!=</span> <span class="sc">&#39;t&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="sc">&#39;T&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="sc">&#39;r&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="sc">&#39;R&#39;</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="cm">/* tiny chars &#39;r&#39; &#39;t&#39; =&gt; standard frame format */</span>
		<span class="n">dlc_pos</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* dlc position tiiid */</span>
	<span class="k">else</span>
		<span class="n">dlc_pos</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="cm">/* dlc position Tiiiiiiiid */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="p">[</span><span class="n">dlc_pos</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="p">[</span><span class="n">dlc_pos</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">&#39;9&#39;</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cf</span><span class="p">.</span><span class="n">can_dlc</span> <span class="o">=</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="p">[</span><span class="n">dlc_pos</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span> <span class="cm">/* get can_dlc from ASCII val */</span>

	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="p">[</span><span class="n">dlc_pos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* terminate can_id string */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strict_strtoul</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ultmp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cf</span><span class="p">.</span><span class="n">can_id</span> <span class="o">=</span> <span class="n">ultmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">))</span> <span class="cm">/* NO tiny chars =&gt; extended frame format */</span>
		<span class="n">cf</span><span class="p">.</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_EFF_FLAG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="p">)</span> <span class="cm">/* RTR frame */</span>
		<span class="n">cf</span><span class="p">.</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_RTR_FLAG</span><span class="p">;</span>

	<span class="o">*</span><span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">cf</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* clear payload */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dlc_pos</span><span class="o">++</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cf</span><span class="p">.</span><span class="n">can_dlc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="p">[</span><span class="n">dlc_pos</span><span class="o">++</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">cf</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="p">[</span><span class="n">dlc_pos</span><span class="o">++</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">cf</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_CAN</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_BROADCAST</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">)),</span>
	       <span class="o">&amp;</span><span class="n">cf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">));</span>
	<span class="n">netif_rx_ni</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">cf</span><span class="p">.</span><span class="n">can_dlc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* parse tty input stream */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slcan_unesc</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">s</span> <span class="o">==</span> <span class="sc">&#39;\r&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="sc">&#39;\a&#39;</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* CR or BEL ends the pdu */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">SLF_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">rcount</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">))</span>  <span class="p">{</span>
			<span class="n">slc_bump</span><span class="p">(</span><span class="n">sl</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sl</span><span class="o">-&gt;</span><span class="n">rcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SLF_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>  <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">rcount</span> <span class="o">&lt;</span> <span class="n">SLC_MTU</span><span class="p">)</span>  <span class="p">{</span>
				<span class="n">sl</span><span class="o">-&gt;</span><span class="n">rbuff</span><span class="p">[</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">rcount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">SLF_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

 <span class="cm">/************************************************************************</span>
<span class="cm">  *			STANDARD SLCAN ENCAPSULATION			 *</span>
<span class="cm">  ************************************************************************/</span>

<span class="cm">/* Encapsulate one can_frame and stuff into a TTY queue. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slc_encaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">cf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_RTR_FLAG</span><span class="p">)</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="sc">&#39;R&#39;</span><span class="p">;</span> <span class="cm">/* becomes &#39;r&#39; in standard frame format */</span>
	<span class="k">else</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="sc">&#39;T&#39;</span><span class="p">;</span> <span class="cm">/* becomes &#39;t&#39; in standard frame format */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_FLAG</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span><span class="p">,</span> <span class="s">&quot;%c%08X%d&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_MASK</span><span class="p">,</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span><span class="p">,</span> <span class="s">&quot;%c%03X%d&quot;</span><span class="p">,</span> <span class="n">cmd</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">,</span>
			<span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_SFF_MASK</span><span class="p">,</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">);</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;%02X&quot;</span><span class="p">,</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">strcat</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">);</span> <span class="cm">/* add terminating character */</span>

	<span class="cm">/* Order of next two lines is *very* important.</span>
<span class="cm">	 * When we are sending a little amount of data,</span>
<span class="cm">	 * the transfer may be completed inside the ops-&gt;write()</span>
<span class="cm">	 * routine, because it&#39;s running with interrupts enabled.</span>
<span class="cm">	 * In this case we *never* got WRITE_WAKEUP event,</span>
<span class="cm">	 * if we did not request it before write operation.</span>
<span class="cm">	 *       14 Oct 1994  Dmitry Gorodchanin.</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">actual</span> <span class="o">=</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">,</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span><span class="p">));</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">xleft</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span><span class="p">)</span> <span class="o">-</span> <span class="n">actual</span><span class="p">;</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">xhead</span> <span class="o">=</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">xbuff</span> <span class="o">+</span> <span class="n">actual</span><span class="p">;</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called by the driver when there&#39;s room for more data.  If we have</span>
<span class="cm"> * more packets to send, we send them here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slcan_write_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>

	<span class="cm">/* First make sure we&#39;re connected. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sl</span> <span class="o">||</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">SLCAN_MAGIC</span> <span class="o">||</span> <span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">xleft</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
		<span class="cm">/* Now serial buffer is almost free &amp; we can start</span>
<span class="cm">		 * transmission of another packet */</span>
		<span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">actual</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">xhead</span><span class="p">,</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">xleft</span><span class="p">);</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">xleft</span> <span class="o">-=</span> <span class="n">actual</span><span class="p">;</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">xhead</span> <span class="o">+=</span> <span class="n">actual</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send a can_frame to a TTY queue. */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">slc_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>  <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: xmit: iface is down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">slc_encaps</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span> <span class="cm">/* encaps &amp; send */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/******************************************</span>
<span class="cm"> *   Routines looking at netdevice side.</span>
<span class="cm"> ******************************************/</span>

<span class="cm">/* Netdevice UP -&gt; DOWN routine */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">slc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TTY discipline is running. */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">TTY_DO_WRITE_WAKEUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">rcount</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">xleft</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Netdevice DOWN -&gt; UP routine */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">slc_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SLF_INUSE</span><span class="p">);</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Hook the destructor so we can free slcan devs at the right point in time */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slc_free_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">slcan_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">slc_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>               <span class="o">=</span> <span class="n">slc_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>               <span class="o">=</span> <span class="n">slc_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>         <span class="o">=</span> <span class="n">slc_xmit</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slc_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">slc_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">destructor</span>		<span class="o">=</span> <span class="n">slc_free_netdev</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span>	<span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span>		<span class="o">=</span> <span class="n">ARPHRD_CAN</span><span class="p">;</span>

	<span class="cm">/* New-style flags. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">IFF_NOARP</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span>           <span class="o">=</span> <span class="n">NETIF_F_HW_CSUM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************</span>
<span class="cm">  Routines looking at TTY side.</span>
<span class="cm"> ******************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Handle the &#39;receiver data ready&#39; interrupt.</span>
<span class="cm"> * This function is called by the &#39;tty_io&#39; module in the kernel when</span>
<span class="cm"> * a block of SLCAN data has been received, which can now be decapsulated</span>
<span class="cm"> * and sent on to some IP layer for further processing. This will not</span>
<span class="cm"> * be re-entered while running but other ldisc functions may be called</span>
<span class="cm"> * in parallel</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slcan_receive_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span>
			      <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sl</span> <span class="o">||</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">SLCAN_MAGIC</span> <span class="o">||</span> <span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Read the characters out of the buffer */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">fp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">SLF_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">slcan_unesc</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/************************************</span>
<span class="cm"> *  slcan_open helper routines.</span>
<span class="cm"> ************************************/</span>

<span class="cm">/* Collect hanged up channels */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">slc_sync</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slcan</span>	  <span class="o">*</span><span class="n">sl</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxdev</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">slcan_devs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">sl</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span>
			<span class="n">dev_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Find a free SLCAN channel, and link in this `tty&#39; line. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="nf">slc_alloc</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slcan</span>       <span class="o">*</span><span class="n">sl</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxdev</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">slcan_devs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="cm">/* Sorry, too many, all slots in use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">maxdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;slcan%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sl</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">slc_setup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span>  <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">sl</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Initialize channel control data */</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">SLCAN_MAGIC</span><span class="p">;</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span>	<span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">slcan_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Open the high-level part of the SLCAN channel.</span>
<span class="cm"> * This function is called by the TTY module when the</span>
<span class="cm"> * SLCAN line discipline is called for.  Because we are</span>
<span class="cm"> * sure the tty line exists, we only have to link it to</span>
<span class="cm"> * a free SLCAN channel...</span>
<span class="cm"> *</span>
<span class="cm"> * Called in process context serialized from other ldisc calls.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slcan_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tty</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* RTnetlink lock is misused here to serialize concurrent</span>
<span class="cm">	   opens of slcan channels. There are better ways, but it is</span>
<span class="cm">	   the simplest one.</span>
<span class="cm">	 */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>

	<span class="cm">/* Collect hanged up channels. */</span>
	<span class="n">slc_sync</span><span class="p">();</span>

	<span class="n">sl</span> <span class="o">=</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="cm">/* First make sure we&#39;re not already connected. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sl</span> <span class="o">&amp;&amp;</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">==</span> <span class="n">SLCAN_MAGIC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>

	<span class="cm">/* OK.  Find a free SLCAN channel to use. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
	<span class="n">sl</span> <span class="o">=</span> <span class="n">slc_alloc</span><span class="p">(</span><span class="n">tty_devnum</span><span class="p">(</span><span class="n">tty</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>

	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="n">tty</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="n">sl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SLF_INUSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Perform the low-level SLCAN initialization. */</span>
		<span class="n">sl</span><span class="o">-&gt;</span><span class="n">rcount</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sl</span><span class="o">-&gt;</span><span class="n">xleft</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">SLF_INUSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdevice</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_free_chan</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Done.  We have linked the TTY line to a channel. */</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">receive_room</span> <span class="o">=</span> <span class="mi">65536</span><span class="p">;</span>	<span class="cm">/* We don&#39;t flow control */</span>

	<span class="cm">/* TTY layer expects 0 on success */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_free_chan:</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SLF_INUSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

<span class="nl">err_exit:</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="cm">/* Count references from TTY module */</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Close down a SLCAN channel.</span>
<span class="cm"> * This means flushing out any pending queues, and then returning. This</span>
<span class="cm"> * call is serialized against other ldisc functions.</span>
<span class="cm"> *</span>
<span class="cm"> * We also use this method for a hangup event.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slcan_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>

	<span class="cm">/* First make sure we&#39;re connected. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sl</span> <span class="o">||</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">SLCAN_MAGIC</span> <span class="o">||</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">!=</span> <span class="n">tty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Flush network side */</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* This will complete via sl_free_netdev */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slcan_hangup</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slcan_close</span><span class="p">(</span><span class="n">tty</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Perform I/O control on an active SLCAN channel. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">slcan_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">tty_struct</span> <span class="o">*</span><span class="n">tty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="p">)</span> <span class="n">tty</span><span class="o">-&gt;</span><span class="n">disc_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* First make sure we&#39;re connected. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sl</span> <span class="o">||</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">SLCAN_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGIFNAME</span>:
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="n">sl</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">tmp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCSIFHWADDR</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">tty_mode_ioctl</span><span class="p">(</span><span class="n">tty</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tty_ldisc_ops</span> <span class="n">slc_ldisc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">magic</span>		<span class="o">=</span> <span class="n">TTY_LDISC_MAGIC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;slcan&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">slcan_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span>		<span class="o">=</span> <span class="n">slcan_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hangup</span>		<span class="o">=</span> <span class="n">slcan_hangup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">slcan_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">receive_buf</span>	<span class="o">=</span> <span class="n">slcan_receive_buf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_wakeup</span>	<span class="o">=</span> <span class="n">slcan_write_wakeup</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">slcan_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">maxdev</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">maxdev</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="cm">/* Sanity */</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">banner</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;slcan: %d dynamic interface channels.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">maxdev</span><span class="p">);</span>

	<span class="n">slcan_devs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">maxdev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slcan_devs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Fill in our line protocol discipline, and register it */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">tty_register_ldisc</span><span class="p">(</span><span class="n">N_SLCAN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slc_ldisc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;slcan: can&#39;t register line discipline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">slcan_devs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">slcan_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slcan</span> <span class="o">*</span><span class="n">sl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slcan_devs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* First of all: check for active disciplines and hangup them.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">busy</span><span class="p">)</span>
			<span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

		<span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxdev</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">slcan_devs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">sl</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">busy</span><span class="o">++</span><span class="p">;</span>
				<span class="n">tty_hangup</span><span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>

	<span class="cm">/* FIXME: hangup is async so we should wait when doing this second</span>
<span class="cm">	   phase */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxdev</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">slcan_devs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">slcan_devs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">sl</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">tty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: tty discipline still running</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="cm">/* Intentionally leak the control block. */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">slcan_devs</span><span class="p">);</span>
	<span class="n">slcan_devs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tty_unregister_ldisc</span><span class="p">(</span><span class="n">N_SLCAN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;slcan: can&#39;t unregister ldisc (err %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">slcan_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">slcan_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
