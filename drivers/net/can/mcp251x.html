<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › can › mcp251x.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mcp251x.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * CAN bus driver for Microchip 251x CAN Controller with SPI Interface</span>
<span class="cm"> *</span>
<span class="cm"> * MCP2510 support and bug fixes by Christian Pellegrin</span>
<span class="cm"> * &lt;chripell@evolware.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2009 Christian Pellegrin EVOL S.r.l.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2007 Raymarine UK, Ltd. All Rights Reserved.</span>
<span class="cm"> * Written under contract by:</span>
<span class="cm"> *   Chris Elston, Katalix Systems, Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on Microchip MCP251x CAN controller driver written by</span>
<span class="cm"> * David Vrabel, Copyright 2006 Arcom Control Systems Ltd.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on CAN bus driver for the CCAN controller written by</span>
<span class="cm"> * - Sascha Hauer, Marc Kleine-Budde, Pengutronix</span>
<span class="cm"> * - Simon Kallweit, intefo AG</span>
<span class="cm"> * Copyright 2007</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the version 2 of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Your platform definition file should specify something like:</span>
<span class="cm"> *</span>
<span class="cm"> * static struct mcp251x_platform_data mcp251x_info = {</span>
<span class="cm"> *         .oscillator_frequency = 8000000,</span>
<span class="cm"> *         .board_specific_setup = &amp;mcp251x_setup,</span>
<span class="cm"> *         .power_enable = mcp251x_power_enable,</span>
<span class="cm"> *         .transceiver_enable = NULL,</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * static struct spi_board_info spi_board_info[] = {</span>
<span class="cm"> *         {</span>
<span class="cm"> *                 .modalias = &quot;mcp2510&quot;,</span>
<span class="cm"> *			// or &quot;mcp2515&quot; depending on your controller</span>
<span class="cm"> *                 .platform_data = &amp;mcp251x_info,</span>
<span class="cm"> *                 .irq = IRQ_EINT13,</span>
<span class="cm"> *                 .max_speed_hz = 2*1000*1000,</span>
<span class="cm"> *                 .chip_select = 2,</span>
<span class="cm"> *         },</span>
<span class="cm"> * };</span>
<span class="cm"> *</span>
<span class="cm"> * Please see mcp251x.h for a description of the fields in</span>
<span class="cm"> * struct mcp251x_platform_data.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/can/core.h&gt;</span>
<span class="cp">#include &lt;linux/can/dev.h&gt;</span>
<span class="cp">#include &lt;linux/can/platform/mcp251x.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spi/spi.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>

<span class="cm">/* SPI interface instruction set */</span>
<span class="cp">#define INSTRUCTION_WRITE	0x02</span>
<span class="cp">#define INSTRUCTION_READ	0x03</span>
<span class="cp">#define INSTRUCTION_BIT_MODIFY	0x05</span>
<span class="cp">#define INSTRUCTION_LOAD_TXB(n)	(0x40 + 2 * (n))</span>
<span class="cp">#define INSTRUCTION_READ_RXB(n)	(((n) == 0) ? 0x90 : 0x94)</span>
<span class="cp">#define INSTRUCTION_RESET	0xC0</span>

<span class="cm">/* MPC251x registers */</span>
<span class="cp">#define CANSTAT	      0x0e</span>
<span class="cp">#define CANCTRL	      0x0f</span>
<span class="cp">#  define CANCTRL_REQOP_MASK	    0xe0</span>
<span class="cp">#  define CANCTRL_REQOP_CONF	    0x80</span>
<span class="cp">#  define CANCTRL_REQOP_LISTEN_ONLY 0x60</span>
<span class="cp">#  define CANCTRL_REQOP_LOOPBACK    0x40</span>
<span class="cp">#  define CANCTRL_REQOP_SLEEP	    0x20</span>
<span class="cp">#  define CANCTRL_REQOP_NORMAL	    0x00</span>
<span class="cp">#  define CANCTRL_OSM		    0x08</span>
<span class="cp">#  define CANCTRL_ABAT		    0x10</span>
<span class="cp">#define TEC	      0x1c</span>
<span class="cp">#define REC	      0x1d</span>
<span class="cp">#define CNF1	      0x2a</span>
<span class="cp">#  define CNF1_SJW_SHIFT   6</span>
<span class="cp">#define CNF2	      0x29</span>
<span class="cp">#  define CNF2_BTLMODE	   0x80</span>
<span class="cp">#  define CNF2_SAM         0x40</span>
<span class="cp">#  define CNF2_PS1_SHIFT   3</span>
<span class="cp">#define CNF3	      0x28</span>
<span class="cp">#  define CNF3_SOF	   0x08</span>
<span class="cp">#  define CNF3_WAKFIL	   0x04</span>
<span class="cp">#  define CNF3_PHSEG2_MASK 0x07</span>
<span class="cp">#define CANINTE	      0x2b</span>
<span class="cp">#  define CANINTE_MERRE 0x80</span>
<span class="cp">#  define CANINTE_WAKIE 0x40</span>
<span class="cp">#  define CANINTE_ERRIE 0x20</span>
<span class="cp">#  define CANINTE_TX2IE 0x10</span>
<span class="cp">#  define CANINTE_TX1IE 0x08</span>
<span class="cp">#  define CANINTE_TX0IE 0x04</span>
<span class="cp">#  define CANINTE_RX1IE 0x02</span>
<span class="cp">#  define CANINTE_RX0IE 0x01</span>
<span class="cp">#define CANINTF	      0x2c</span>
<span class="cp">#  define CANINTF_MERRF 0x80</span>
<span class="cp">#  define CANINTF_WAKIF 0x40</span>
<span class="cp">#  define CANINTF_ERRIF 0x20</span>
<span class="cp">#  define CANINTF_TX2IF 0x10</span>
<span class="cp">#  define CANINTF_TX1IF 0x08</span>
<span class="cp">#  define CANINTF_TX0IF 0x04</span>
<span class="cp">#  define CANINTF_RX1IF 0x02</span>
<span class="cp">#  define CANINTF_RX0IF 0x01</span>
<span class="cp">#  define CANINTF_RX (CANINTF_RX0IF | CANINTF_RX1IF)</span>
<span class="cp">#  define CANINTF_TX (CANINTF_TX2IF | CANINTF_TX1IF | CANINTF_TX0IF)</span>
<span class="cp">#  define CANINTF_ERR (CANINTF_ERRIF)</span>
<span class="cp">#define EFLG	      0x2d</span>
<span class="cp">#  define EFLG_EWARN	0x01</span>
<span class="cp">#  define EFLG_RXWAR	0x02</span>
<span class="cp">#  define EFLG_TXWAR	0x04</span>
<span class="cp">#  define EFLG_RXEP	0x08</span>
<span class="cp">#  define EFLG_TXEP	0x10</span>
<span class="cp">#  define EFLG_TXBO	0x20</span>
<span class="cp">#  define EFLG_RX0OVR	0x40</span>
<span class="cp">#  define EFLG_RX1OVR	0x80</span>
<span class="cp">#define TXBCTRL(n)  (((n) * 0x10) + 0x30 + TXBCTRL_OFF)</span>
<span class="cp">#  define TXBCTRL_ABTF	0x40</span>
<span class="cp">#  define TXBCTRL_MLOA	0x20</span>
<span class="cp">#  define TXBCTRL_TXERR 0x10</span>
<span class="cp">#  define TXBCTRL_TXREQ 0x08</span>
<span class="cp">#define TXBSIDH(n)  (((n) * 0x10) + 0x30 + TXBSIDH_OFF)</span>
<span class="cp">#  define SIDH_SHIFT    3</span>
<span class="cp">#define TXBSIDL(n)  (((n) * 0x10) + 0x30 + TXBSIDL_OFF)</span>
<span class="cp">#  define SIDL_SID_MASK    7</span>
<span class="cp">#  define SIDL_SID_SHIFT   5</span>
<span class="cp">#  define SIDL_EXIDE_SHIFT 3</span>
<span class="cp">#  define SIDL_EID_SHIFT   16</span>
<span class="cp">#  define SIDL_EID_MASK    3</span>
<span class="cp">#define TXBEID8(n)  (((n) * 0x10) + 0x30 + TXBEID8_OFF)</span>
<span class="cp">#define TXBEID0(n)  (((n) * 0x10) + 0x30 + TXBEID0_OFF)</span>
<span class="cp">#define TXBDLC(n)   (((n) * 0x10) + 0x30 + TXBDLC_OFF)</span>
<span class="cp">#  define DLC_RTR_SHIFT    6</span>
<span class="cp">#define TXBCTRL_OFF 0</span>
<span class="cp">#define TXBSIDH_OFF 1</span>
<span class="cp">#define TXBSIDL_OFF 2</span>
<span class="cp">#define TXBEID8_OFF 3</span>
<span class="cp">#define TXBEID0_OFF 4</span>
<span class="cp">#define TXBDLC_OFF  5</span>
<span class="cp">#define TXBDAT_OFF  6</span>
<span class="cp">#define RXBCTRL(n)  (((n) * 0x10) + 0x60 + RXBCTRL_OFF)</span>
<span class="cp">#  define RXBCTRL_BUKT	0x04</span>
<span class="cp">#  define RXBCTRL_RXM0	0x20</span>
<span class="cp">#  define RXBCTRL_RXM1	0x40</span>
<span class="cp">#define RXBSIDH(n)  (((n) * 0x10) + 0x60 + RXBSIDH_OFF)</span>
<span class="cp">#  define RXBSIDH_SHIFT 3</span>
<span class="cp">#define RXBSIDL(n)  (((n) * 0x10) + 0x60 + RXBSIDL_OFF)</span>
<span class="cp">#  define RXBSIDL_IDE   0x08</span>
<span class="cp">#  define RXBSIDL_SRR   0x10</span>
<span class="cp">#  define RXBSIDL_EID   3</span>
<span class="cp">#  define RXBSIDL_SHIFT 5</span>
<span class="cp">#define RXBEID8(n)  (((n) * 0x10) + 0x60 + RXBEID8_OFF)</span>
<span class="cp">#define RXBEID0(n)  (((n) * 0x10) + 0x60 + RXBEID0_OFF)</span>
<span class="cp">#define RXBDLC(n)   (((n) * 0x10) + 0x60 + RXBDLC_OFF)</span>
<span class="cp">#  define RXBDLC_LEN_MASK  0x0f</span>
<span class="cp">#  define RXBDLC_RTR       0x40</span>
<span class="cp">#define RXBCTRL_OFF 0</span>
<span class="cp">#define RXBSIDH_OFF 1</span>
<span class="cp">#define RXBSIDL_OFF 2</span>
<span class="cp">#define RXBEID8_OFF 3</span>
<span class="cp">#define RXBEID0_OFF 4</span>
<span class="cp">#define RXBDLC_OFF  5</span>
<span class="cp">#define RXBDAT_OFF  6</span>
<span class="cp">#define RXFSIDH(n) ((n) * 4)</span>
<span class="cp">#define RXFSIDL(n) ((n) * 4 + 1)</span>
<span class="cp">#define RXFEID8(n) ((n) * 4 + 2)</span>
<span class="cp">#define RXFEID0(n) ((n) * 4 + 3)</span>
<span class="cp">#define RXMSIDH(n) ((n) * 4 + 0x20)</span>
<span class="cp">#define RXMSIDL(n) ((n) * 4 + 0x21)</span>
<span class="cp">#define RXMEID8(n) ((n) * 4 + 0x22)</span>
<span class="cp">#define RXMEID0(n) ((n) * 4 + 0x23)</span>

<span class="cp">#define GET_BYTE(val, byte)			\</span>
<span class="cp">	(((val) &gt;&gt; ((byte) * 8)) &amp; 0xff)</span>
<span class="cp">#define SET_BYTE(val, byte)			\</span>
<span class="cp">	(((val) &amp; 0xff) &lt;&lt; ((byte) * 8))</span>

<span class="cm">/*</span>
<span class="cm"> * Buffer size required for the largest SPI transfer (i.e., reading a</span>
<span class="cm"> * frame)</span>
<span class="cm"> */</span>
<span class="cp">#define CAN_FRAME_MAX_DATA_LEN	8</span>
<span class="cp">#define SPI_TRANSFER_BUF_LEN	(6 + CAN_FRAME_MAX_DATA_LEN)</span>
<span class="cp">#define CAN_FRAME_MAX_BITS	128</span>

<span class="cp">#define TX_ECHO_SKB_MAX	1</span>

<span class="cp">#define DEVICE_NAME &quot;mcp251x&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">mcp251x_enable_dma</span><span class="p">;</span> <span class="cm">/* Enable SPI DMA. Default: 0 (Off) */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">mcp251x_enable_dma</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mcp251x_enable_dma</span><span class="p">,</span> <span class="s">&quot;Enable SPI DMA. Default: 0 (Off)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">can_bittiming_const</span> <span class="n">mcp251x_bittiming_const</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DEVICE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tseg1_min</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tseg1_max</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tseg2_min</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tseg2_max</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sjw_max</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="p">.</span><span class="n">brp_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">brp_max</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
	<span class="p">.</span><span class="n">brp_inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">mcp251x_model</span> <span class="p">{</span>
	<span class="n">CAN_MCP251X_MCP2510</span>	<span class="o">=</span> <span class="mh">0x2510</span><span class="p">,</span>
	<span class="n">CAN_MCP251X_MCP2515</span>	<span class="o">=</span> <span class="mh">0x2515</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">can_priv</span>	   <span class="n">can</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mcp251x_model</span> <span class="n">model</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">mcp_lock</span><span class="p">;</span> <span class="cm">/* SPI device lock */</span>

	<span class="n">u8</span> <span class="o">*</span><span class="n">spi_tx_buf</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">spi_rx_buf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">spi_tx_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">spi_rx_dma</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tx_skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_len</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">tx_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">restart_work</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">force_quit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">after_suspend</span><span class="p">;</span>
<span class="cp">#define AFTER_SUSPEND_UP 1</span>
<span class="cp">#define AFTER_SUSPEND_DOWN 2</span>
<span class="cp">#define AFTER_SUSPEND_POWER 4</span>
<span class="cp">#define AFTER_SUSPEND_RESTART 8</span>
	<span class="kt">int</span> <span class="n">restart_tx</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define MCP251X_IS(_model) \</span>
<span class="cp">static inline int mcp251x_is_##_model(struct spi_device *spi) \</span>
<span class="cp">{ \</span>
<span class="cp">	struct mcp251x_priv *priv = dev_get_drvdata(&amp;spi-&gt;dev); \</span>
<span class="cp">	return priv-&gt;model == CAN_MCP251X_MCP##_model; \</span>
<span class="cp">}</span>

<span class="n">MCP251X_IS</span><span class="p">(</span><span class="mi">2510</span><span class="p">);</span>
<span class="n">MCP251X_IS</span><span class="p">(</span><span class="mi">2515</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">||</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">)</span>
		<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">)</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">)</span>
		<span class="n">can_free_echo_skb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note about handling of error return of mcp251x_spi_trans: accessing</span>
<span class="cm"> * registers via SPI is not really different conceptually than using</span>
<span class="cm"> * normal I/O assembler instructions, although it&#39;s much more</span>
<span class="cm"> * complicated from a practical POV. So it&#39;s not advisable to always</span>
<span class="cm"> * check the return value of this function. Imagine that every</span>
<span class="cm"> * read{b,l}, write{b,l} and friends would be bracketed in &quot;if ( &lt; 0)</span>
<span class="cm"> * error();&quot;, it would be a great mess (well there are some situation</span>
<span class="cm"> * when exception handling C++ like could be useful after all). So we</span>
<span class="cm"> * just check that transfers are OK at the beginning of our</span>
<span class="cm"> * conversation with the chip and to avoid doing really nasty things</span>
<span class="cm"> * (like injecting bogus packets in the network stack).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_spi_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_transfer</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">tx_buf</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">,</span>
		<span class="p">.</span><span class="n">rx_buf</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span><span class="p">,</span>
		<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cs_change</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">spi_message</span> <span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spi_message_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcp251x_enable_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="p">.</span><span class="n">tx_dma</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_dma</span><span class="p">;</span>
		<span class="n">t</span><span class="p">.</span><span class="n">rx_dma</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_dma</span><span class="p">;</span>
		<span class="n">m</span><span class="p">.</span><span class="n">is_dma_mapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spi_message_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spi_sync</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;spi transfer failed: ret = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">mcp251x_read_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INSTRUCTION_READ</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">mcp251x_spi_trans</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_read_2regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">reg</span><span class="p">,</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">v1</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INSTRUCTION_READ</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>

	<span class="n">mcp251x_spi_trans</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="o">*</span><span class="n">v1</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="o">*</span><span class="n">v2</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_write_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INSTRUCTION_WRITE</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">mcp251x_spi_trans</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_write_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INSTRUCTION_BIT_MODIFY</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">mcp251x_spi_trans</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_hw_tx_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_buf_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcp251x_is_2510</span><span class="p">(</span><span class="n">spi</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TXBDAT_OFF</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">TXBCTRL</span><span class="p">(</span><span class="n">tx_buf_idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
					  <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">TXBDAT_OFF</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">mcp251x_spi_trans</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">TXBDAT_OFF</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_hw_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">tx_buf_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sid</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">exide</span><span class="p">,</span> <span class="n">rtr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="n">SPI_TRANSFER_BUF_LEN</span><span class="p">];</span>

	<span class="n">exide</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_FLAG</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Extended ID Enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exide</span><span class="p">)</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">18</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sid</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_SFF_MASK</span><span class="p">;</span> <span class="cm">/* Standard ID */</span>
	<span class="n">eid</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_EFF_MASK</span><span class="p">;</span> <span class="cm">/* Extended ID */</span>
	<span class="n">rtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">&amp;</span> <span class="n">CAN_RTR_FLAG</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Remote transmission */</span>

	<span class="n">buf</span><span class="p">[</span><span class="n">TXBCTRL_OFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">INSTRUCTION_LOAD_TXB</span><span class="p">(</span><span class="n">tx_buf_idx</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">TXBSIDH_OFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">sid</span> <span class="o">&gt;&gt;</span> <span class="n">SIDH_SHIFT</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">TXBSIDL_OFF</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">sid</span> <span class="o">&amp;</span> <span class="n">SIDL_SID_MASK</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">SIDL_SID_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">exide</span> <span class="o">&lt;&lt;</span> <span class="n">SIDL_EXIDE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">((</span><span class="n">eid</span> <span class="o">&gt;&gt;</span> <span class="n">SIDL_EID_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SIDL_EID_MASK</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">TXBEID8_OFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_BYTE</span><span class="p">(</span><span class="n">eid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">TXBEID0_OFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_BYTE</span><span class="p">(</span><span class="n">eid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">TXBDLC_OFF</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rtr</span> <span class="o">&lt;&lt;</span> <span class="n">DLC_RTR_SHIFT</span><span class="p">)</span> <span class="o">|</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">TXBDAT_OFF</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">);</span>
	<span class="n">mcp251x_hw_tx_frame</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">,</span> <span class="n">tx_buf_idx</span><span class="p">);</span>
	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">TXBCTRL</span><span class="p">(</span><span class="n">tx_buf_idx</span><span class="p">),</span> <span class="n">TXBCTRL_TXREQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_hw_rx_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">buf_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcp251x_is_2510</span><span class="p">(</span><span class="n">spi</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RXBDAT_OFF</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">RXBCTRL</span><span class="p">(</span><span class="n">buf_idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">get_can_dlc</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBDLC_OFF</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RXBDLC_LEN_MASK</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">RXBDAT_OFF</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">RXBCTRL</span><span class="p">(</span><span class="n">buf_idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="n">RXBCTRL_OFF</span><span class="p">]</span> <span class="o">=</span> <span class="n">INSTRUCTION_READ_RXB</span><span class="p">(</span><span class="n">buf_idx</span><span class="p">);</span>
		<span class="n">mcp251x_spi_trans</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">SPI_TRANSFER_BUF_LEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span><span class="p">,</span> <span class="n">SPI_TRANSFER_BUF_LEN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_hw_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buf_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">buf</span><span class="p">[</span><span class="n">SPI_TRANSFER_BUF_LEN</span><span class="p">];</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_can_skb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cannot allocate RX skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mcp251x_hw_rx_frame</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBSIDL_OFF</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RXBSIDL_IDE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Extended ID format */</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">=</span> <span class="n">CAN_EFF_FLAG</span><span class="p">;</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span>
			<span class="cm">/* Extended ID part */</span>
			<span class="n">SET_BYTE</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBSIDL_OFF</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RXBSIDL_EID</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">SET_BYTE</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBEID8_OFF</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">SET_BYTE</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBEID0_OFF</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
			<span class="cm">/* Standard ID part */</span>
			<span class="p">(((</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBSIDH_OFF</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">RXBSIDH_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			  <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBSIDL_OFF</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">RXBSIDL_SHIFT</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="p">);</span>
		<span class="cm">/* Remote transmission request */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBDLC_OFF</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RXBDLC_RTR</span><span class="p">)</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_RTR_FLAG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Standard ID format */</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBSIDH_OFF</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">RXBSIDH_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBSIDL_OFF</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">RXBSIDL_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBSIDL_OFF</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RXBSIDL_SRR</span><span class="p">)</span>
			<span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_RTR_FLAG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Data length */</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">=</span> <span class="n">get_can_dlc</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">RXBDLC_OFF</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RXBDLC_LEN_MASK</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">RXBDAT_OFF</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>
	<span class="n">netif_rx_ni</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_hw_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANCTRL</span><span class="p">,</span> <span class="n">CANCTRL_REQOP_SLEEP</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">mcp251x_hard_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">||</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hard_xmit called while tx busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_dropped_invalid_skb</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_do_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">enum</span> <span class="n">can_mode</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CAN_MODE_START</span>:
		<span class="n">mcp251x_clean</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="cm">/* We have to delay work since SPI I/O may sleep */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">restart_tx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">restart_ms</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">=</span> <span class="n">AFTER_SUSPEND_RESTART</span><span class="p">;</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">restart_work</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_set_normal_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="cm">/* Enable interrupts */</span>
	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANINTE</span><span class="p">,</span>
			  <span class="n">CANINTE_ERRIE</span> <span class="o">|</span> <span class="n">CANINTE_TX2IE</span> <span class="o">|</span> <span class="n">CANINTE_TX1IE</span> <span class="o">|</span>
			  <span class="n">CANINTE_TX0IE</span> <span class="o">|</span> <span class="n">CANINTE_RX1IE</span> <span class="o">|</span> <span class="n">CANINTE_RX0IE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">ctrlmode</span> <span class="o">&amp;</span> <span class="n">CAN_CTRLMODE_LOOPBACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Put device into loopback mode */</span>
		<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANCTRL</span><span class="p">,</span> <span class="n">CANCTRL_REQOP_LOOPBACK</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">ctrlmode</span> <span class="o">&amp;</span> <span class="n">CAN_CTRLMODE_LISTENONLY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Put device into listen-only mode */</span>
		<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANCTRL</span><span class="p">,</span> <span class="n">CANCTRL_REQOP_LISTEN_ONLY</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Put device into normal mode */</span>
		<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANCTRL</span><span class="p">,</span> <span class="n">CANCTRL_REQOP_NORMAL</span><span class="p">);</span>

		<span class="cm">/* Wait for the device to enter normal mode */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANSTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CANCTRL_REQOP_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MCP251x didn&#39;t&quot;</span>
					<span class="s">&quot; enter in normal mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_do_set_bittiming</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">can_bittiming</span> <span class="o">*</span><span class="n">bt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">bittiming</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>

	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CNF1</span><span class="p">,</span> <span class="p">((</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">sjw</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">CNF1_SJW_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			  <span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">brp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CNF2</span><span class="p">,</span> <span class="n">CNF2_BTLMODE</span> <span class="o">|</span>
			  <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">ctrlmode</span> <span class="o">&amp;</span> <span class="n">CAN_CTRLMODE_3_SAMPLES</span> <span class="o">?</span>
			   <span class="n">CNF2_SAM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
			  <span class="p">((</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">phase_seg1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">CNF2_PS1_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			  <span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">prop_seg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">mcp251x_write_bits</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CNF3</span><span class="p">,</span> <span class="n">CNF3_PHSEG2_MASK</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">bt</span><span class="o">-&gt;</span><span class="n">phase_seg2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CNF: 0x%02x 0x%02x 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CNF1</span><span class="p">),</span>
		 <span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CNF2</span><span class="p">),</span>
		 <span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CNF3</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcp251x_do_set_bittiming</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">RXBCTRL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			  <span class="n">RXBCTRL_BUKT</span> <span class="o">|</span> <span class="n">RXBCTRL_RXM0</span> <span class="o">|</span> <span class="n">RXBCTRL_RXM1</span><span class="p">);</span>
	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">RXBCTRL</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
			  <span class="n">RXBCTRL_RXM0</span> <span class="o">|</span> <span class="n">RXBCTRL_RXM1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_hw_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INSTRUCTION_RESET</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">spi_write</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reset failed: ret = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for reset to finish */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANSTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CANCTRL_REQOP_MASK</span><span class="p">)</span>
	       <span class="o">!=</span> <span class="n">CANCTRL_REQOP_CONF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MCP251x didn&#39;t&quot;</span>
				<span class="s">&quot; enter in conf mode after reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_hw_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">;</span>

	<span class="n">mcp251x_hw_reset</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Please note that these are &quot;magic values&quot; based on after</span>
<span class="cm">	 * reset defaults taken from data sheet which allows us to see</span>
<span class="cm">	 * if we really have a chip on the bus (we avoid common all</span>
<span class="cm">	 * zeroes or all ones situations)</span>
<span class="cm">	 */</span>
	<span class="n">st1</span> <span class="o">=</span> <span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANSTAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xEE</span><span class="p">;</span>
	<span class="n">st2</span> <span class="o">=</span> <span class="n">mcp251x_read_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANCTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x17</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CANSTAT 0x%02x CANCTRL 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">);</span>

	<span class="cm">/* Check for power up default values */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">st1</span> <span class="o">==</span> <span class="mh">0x80</span> <span class="o">&amp;&amp;</span> <span class="n">st2</span> <span class="o">==</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_open_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp251x_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
	<span class="n">mcp251x_hw_sleep</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">close_candev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp251x_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>

	<span class="n">close_candev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">force_quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>

	<span class="cm">/* Disable and clear pending interrupts */</span>
	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANINTE</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANINTF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

	<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">TXBCTRL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mcp251x_clean</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">mcp251x_hw_sleep</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CAN_STATE_STOPPED</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_error_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">can_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_can_err_skb</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_id</span> <span class="o">|=</span> <span class="n">can_id</span><span class="p">;</span>
		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data1</span><span class="p">;</span>
		<span class="n">netif_rx_ni</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;cannot allocate error skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_tx_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcp251x_priv</span><span class="p">,</span>
						 <span class="n">tx_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">CAN_STATE_BUS_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mcp251x_clean</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">can_frame</span> <span class="o">*</span><span class="p">)</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">&gt;</span> <span class="n">CAN_FRAME_MAX_DATA_LEN</span><span class="p">)</span>
				<span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span> <span class="o">=</span> <span class="n">CAN_FRAME_MAX_DATA_LEN</span><span class="p">;</span>
			<span class="n">mcp251x_hw_tx</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">can_dlc</span><span class="p">;</span>
			<span class="n">can_put_echo_skb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcp251x_restart_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">ws</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcp251x_priv</span><span class="p">,</span>
						 <span class="n">restart_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">mcp251x_hw_reset</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
		<span class="n">mcp251x_setup</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">spi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">&amp;</span> <span class="n">AFTER_SUSPEND_RESTART</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mcp251x_set_normal_mode</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">&amp;</span> <span class="n">AFTER_SUSPEND_UP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
			<span class="n">mcp251x_clean</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
			<span class="n">mcp251x_set_normal_mode</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mcp251x_hw_sleep</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">force_quit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">restart_tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">restart_tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mcp251x_write_reg</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">TXBCTRL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mcp251x_clean</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="n">mcp251x_error_skb</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">CAN_ERR_RESTARTED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">mcp251x_can_ist</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">force_quit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">can_state</span> <span class="n">new_state</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">intf</span><span class="p">,</span> <span class="n">eflag</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">clear_intf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">can_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">mcp251x_read_2regs</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANINTF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eflag</span><span class="p">);</span>

		<span class="cm">/* mask out flags we don&#39;t care about */</span>
		<span class="n">intf</span> <span class="o">&amp;=</span> <span class="n">CANINTF_RX</span> <span class="o">|</span> <span class="n">CANINTF_TX</span> <span class="o">|</span> <span class="n">CANINTF_ERR</span><span class="p">;</span>

		<span class="cm">/* receive buffer 0 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span> <span class="o">&amp;</span> <span class="n">CANINTF_RX0IF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mcp251x_hw_rx</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Free one buffer ASAP</span>
<span class="cm">			 * (The MCP2515 does this automatically.)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mcp251x_is_2510</span><span class="p">(</span><span class="n">spi</span><span class="p">))</span>
				<span class="n">mcp251x_write_bits</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANINTF</span><span class="p">,</span> <span class="n">CANINTF_RX0IF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* receive buffer 1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span> <span class="o">&amp;</span> <span class="n">CANINTF_RX1IF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mcp251x_hw_rx</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/* the MCP2515 does this automatically */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mcp251x_is_2510</span><span class="p">(</span><span class="n">spi</span><span class="p">))</span>
				<span class="n">clear_intf</span> <span class="o">|=</span> <span class="n">CANINTF_RX1IF</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* any error or tx interrupt we need to clear? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CANINTF_ERR</span> <span class="o">|</span> <span class="n">CANINTF_TX</span><span class="p">))</span>
			<span class="n">clear_intf</span> <span class="o">|=</span> <span class="n">intf</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CANINTF_ERR</span> <span class="o">|</span> <span class="n">CANINTF_TX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clear_intf</span><span class="p">)</span>
			<span class="n">mcp251x_write_bits</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">CANINTF</span><span class="p">,</span> <span class="n">clear_intf</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">eflag</span><span class="p">)</span>
			<span class="n">mcp251x_write_bits</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">EFLG</span><span class="p">,</span> <span class="n">eflag</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>

		<span class="cm">/* Update can state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eflag</span> <span class="o">&amp;</span> <span class="n">EFLG_TXBO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_BUS_OFF</span><span class="p">;</span>
			<span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_BUSOFF</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eflag</span> <span class="o">&amp;</span> <span class="n">EFLG_TXEP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_PASSIVE</span><span class="p">;</span>
			<span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
			<span class="n">data1</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_TX_PASSIVE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eflag</span> <span class="o">&amp;</span> <span class="n">EFLG_RXEP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_PASSIVE</span><span class="p">;</span>
			<span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
			<span class="n">data1</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_RX_PASSIVE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eflag</span> <span class="o">&amp;</span> <span class="n">EFLG_TXWAR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_WARNING</span><span class="p">;</span>
			<span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
			<span class="n">data1</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_TX_WARNING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eflag</span> <span class="o">&amp;</span> <span class="n">EFLG_RXWAR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_WARNING</span><span class="p">;</span>
			<span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
			<span class="n">data1</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_RX_WARNING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">new_state</span> <span class="o">=</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Update can state statistics */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CAN_STATE_ERROR_ACTIVE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">&gt;=</span> <span class="n">CAN_STATE_ERROR_WARNING</span> <span class="o">&amp;&amp;</span>
			    <span class="n">new_state</span> <span class="o">&lt;=</span> <span class="n">CAN_STATE_BUS_OFF</span><span class="p">)</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">can_stats</span><span class="p">.</span><span class="n">error_warning</span><span class="o">++</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CAN_STATE_ERROR_WARNING</span>:	<span class="cm">/* fallthrough */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_state</span> <span class="o">&gt;=</span> <span class="n">CAN_STATE_ERROR_PASSIVE</span> <span class="o">&amp;&amp;</span>
			    <span class="n">new_state</span> <span class="o">&lt;=</span> <span class="n">CAN_STATE_BUS_OFF</span><span class="p">)</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">can_stats</span><span class="p">.</span><span class="n">error_passive</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">new_state</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span> <span class="o">&amp;</span> <span class="n">CANINTF_ERRIF</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Handle overflow counters */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eflag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EFLG_RX0OVR</span> <span class="o">|</span> <span class="n">EFLG_RX1OVR</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">eflag</span> <span class="o">&amp;</span> <span class="n">EFLG_RX0OVR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">eflag</span> <span class="o">&amp;</span> <span class="n">EFLG_RX1OVR</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
					<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">can_id</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL</span><span class="p">;</span>
				<span class="n">data1</span> <span class="o">|=</span> <span class="n">CAN_ERR_CRTL_RX_OVERFLOW</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mcp251x_error_skb</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">can_id</span><span class="p">,</span> <span class="n">data1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">CAN_STATE_BUS_OFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">restart_ms</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">force_quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">can_bus_off</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
				<span class="n">mcp251x_hw_sleep</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">intf</span> <span class="o">&amp;</span> <span class="n">CANINTF_TX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">net</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">can_get_echo_skb</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp251x_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">open_candev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;unable to set initial baudrate!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">force_quit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_threaded_irq</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mcp251x_can_ist</span><span class="p">,</span>
		  <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irq_flags</span> <span class="o">?</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">irq_flags</span> <span class="o">:</span> <span class="n">IRQF_TRIGGER_FALLING</span><span class="p">,</span>
		  <span class="n">DEVICE_NAME</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to acquire irq %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">)</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">close_candev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">open_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="n">create_freezable_workqueue</span><span class="p">(</span><span class="s">&quot;mcp251x_wq&quot;</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">tx_work</span><span class="p">,</span> <span class="n">mcp251x_tx_work_handler</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">restart_work</span><span class="p">,</span> <span class="n">mcp251x_restart_work_handler</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcp251x_hw_reset</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcp251x_open_clean</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">open_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcp251x_setup</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">priv</span><span class="p">,</span> <span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcp251x_open_clean</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">open_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcp251x_set_normal_mode</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mcp251x_open_clean</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">open_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

<span class="nl">open_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">mcp251x_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">mcp251x_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">mcp251x_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">mcp251x_hard_start_xmit</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">mcp251x_can_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp251x_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdata</span><span class="p">)</span>
		<span class="cm">/* Platform data is required for osc freq */</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="cm">/* Allocate can/net device */</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">alloc_candev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcp251x_priv</span><span class="p">),</span> <span class="n">TX_ECHO_SKB_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_alloc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcp251x_netdev_ops</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_ECHO</span><span class="p">;</span>

	<span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">bittiming_const</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcp251x_bittiming_const</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">do_set_mode</span> <span class="o">=</span> <span class="n">mcp251x_do_set_mode</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">clock</span><span class="p">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">pdata</span><span class="o">-&gt;</span><span class="n">oscillator_frequency</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">can</span><span class="p">.</span><span class="n">ctrlmode_supported</span> <span class="o">=</span> <span class="n">CAN_CTRLMODE_3_SAMPLES</span> <span class="o">|</span>
		<span class="n">CAN_CTRLMODE_LOOPBACK</span> <span class="o">|</span> <span class="n">CAN_CTRLMODE_LISTENONLY</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">model</span> <span class="o">=</span> <span class="n">spi_get_device_id</span><span class="p">(</span><span class="n">spi</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">;</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi</span> <span class="o">=</span> <span class="n">spi</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">mcp_lock</span><span class="p">);</span>

	<span class="cm">/* If requested, allocate DMA buffers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcp251x_enable_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">coherent_dma_mask</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Minimum coherent DMA allocation is PAGE_SIZE, so allocate</span>
<span class="cm">		 * that much and share it between Tx and Rx DMA buffers.</span>
<span class="cm">		 */</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						      <span class="n">PAGE_SIZE</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_dma</span><span class="p">,</span>
						      <span class="n">GFP_DMA</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span> <span class="o">+</span>
						  <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_dma</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_dma</span> <span class="o">+</span>
							<span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Fall back to non-DMA */</span>
			<span class="n">mcp251x_enable_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate non-DMA buffers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcp251x_enable_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SPI_TRANSFER_BUF_LEN</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_tx_buf</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SPI_TRANSFER_BUF_LEN</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_rx_buf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Call out to platform specific setup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">board_specific_setup</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">board_specific_setup</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Configure the SPI bus */</span>
	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">SPI_MODE_0</span><span class="p">;</span>
	<span class="n">spi</span><span class="o">-&gt;</span><span class="n">bits_per_word</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">spi_setup</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>

	<span class="cm">/* Here is OK to not lock the MCP, no one knows about it yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcp251x_hw_probe</span><span class="p">(</span><span class="n">spi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Probe failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_probe</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mcp251x_hw_sleep</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_candev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;probed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">error_probe:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcp251x_enable_dma</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span><span class="p">);</span>
<span class="nl">error_rx_buf:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcp251x_enable_dma</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">);</span>
<span class="nl">error_tx_buf:</span>
	<span class="n">free_candev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcp251x_enable_dma</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				  <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_dma</span><span class="p">);</span>
<span class="nl">error_alloc:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;probe failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">error_out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">mcp251x_can_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>

	<span class="n">unregister_candev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">free_candev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mcp251x_enable_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				  <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_dma</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_tx_buf</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">spi_rx_buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">)</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_can_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">force_quit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">disable_irq</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Note: at this point neither IST nor workqueues are running.</span>
<span class="cm">	 * open/stop cannot be called anyway so locking is not needed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">net</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

		<span class="n">mcp251x_hw_sleep</span><span class="p">(</span><span class="n">spi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">)</span>
			<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">=</span> <span class="n">AFTER_SUSPEND_UP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">=</span> <span class="n">AFTER_SUSPEND_DOWN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">|=</span> <span class="n">AFTER_SUSPEND_POWER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcp251x_can_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">spi_device</span> <span class="o">*</span><span class="n">spi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcp251x_platform_data</span> <span class="o">*</span><span class="n">pdata</span> <span class="o">=</span> <span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">platform_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcp251x_priv</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">&amp;</span> <span class="n">AFTER_SUSPEND_POWER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">power_enable</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">queue_work</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">restart_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">&amp;</span> <span class="n">AFTER_SUSPEND_UP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">)</span>
				<span class="n">pdata</span><span class="o">-&gt;</span><span class="n">transceiver_enable</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">restart_work</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">after_suspend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">force_quit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">spi</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define mcp251x_can_suspend NULL</span>
<span class="cp">#define mcp251x_can_resume NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">spi_device_id</span> <span class="n">mcp251x_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;mcp2510&quot;</span><span class="p">,</span>	<span class="n">CAN_MCP251X_MCP2510</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;mcp2515&quot;</span><span class="p">,</span>	<span class="n">CAN_MCP251X_MCP2515</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">spi</span><span class="p">,</span> <span class="n">mcp251x_id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spi_driver</span> <span class="n">mcp251x_can_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DEVICE_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spi_bus_type</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>

	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">mcp251x_id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">mcp251x_can_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">mcp251x_can_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">mcp251x_can_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">mcp251x_can_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mcp251x_can_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">spi_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcp251x_can_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">mcp251x_can_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spi_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcp251x_can_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">mcp251x_can_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">mcp251x_can_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Chris Elston &lt;celston@katalix.com&gt;, &quot;</span>
	      <span class="s">&quot;Christian Pellegrin &lt;chripell@evolware.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Microchip 251x CAN driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
