<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › slip › slhc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>slhc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Routines to compress and uncompress tcp packets (for transmission</span>
<span class="cm"> * over low speed serial lines).</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1989 Regents of the University of California.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms are permitted</span>
<span class="cm"> * provided that the above copyright notice and this paragraph are</span>
<span class="cm"> * duplicated in all such forms and that any documentation,</span>
<span class="cm"> * advertising materials, and other materials related to such</span>
<span class="cm"> * distribution and use acknowledge that the software was developed</span>
<span class="cm"> * by the University of California, Berkeley.  The name of the</span>
<span class="cm"> * University may not be used to endorse or promote products derived</span>
<span class="cm"> * from this software without specific prior written permission.</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED ``AS IS&#39;&#39; AND WITHOUT ANY EXPRESS OR</span>
<span class="cm"> * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED</span>
<span class="cm"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="cm"> *</span>
<span class="cm"> *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:</span>
<span class="cm"> *	- Initial distribution.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * modified for KA9Q Internet Software Package by</span>
<span class="cm"> * Katie Stevens (dkstevens@ucdavis.edu)</span>
<span class="cm"> * University of California, Davis</span>
<span class="cm"> * Computing Services</span>
<span class="cm"> *	- 01-31-90	initial adaptation (from 1.19)</span>
<span class="cm"> *	PPP.05	02-15-90 [ks]</span>
<span class="cm"> *	PPP.08	05-02-90 [ks]	use PPP protocol field to signal compression</span>
<span class="cm"> *	PPP.15	09-90	 [ks]	improve mbuf handling</span>
<span class="cm"> *	PPP.16	11-02	 [karn]	substantially rewritten to use NOS facilities</span>
<span class="cm"> *</span>
<span class="cm"> *	- Feb 1991	Bill_Simpson@um.cc.umich.edu</span>
<span class="cm"> *			variable number of conversation slots</span>
<span class="cm"> *			allow zero or one slots</span>
<span class="cm"> *			separate routines</span>
<span class="cm"> *			status display</span>
<span class="cm"> *	- Jul 1994	Dmitry Gorodchanin</span>
<span class="cm"> *			Fixes for memory leaks.</span>
<span class="cm"> *      - Oct 1994      Dmitry Gorodchanin</span>
<span class="cm"> *                      Modularization.</span>
<span class="cm"> *	- Jan 1995	Bjorn Ekwall</span>
<span class="cm"> *			Use ip_fast_csum from ip.h</span>
<span class="cm"> *	- July 1995	Christos A. Polyzols</span>
<span class="cm"> *			Spotted bug in tcp option checking</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *	This module is a difficult issue. It&#39;s clearly inet code but it&#39;s also clearly</span>
<span class="cm"> *	driver code belonging close to PPP and SLIP</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;net/slhc_vj.h&gt;</span>

<span class="cp">#ifdef CONFIG_INET</span>
<span class="cm">/* Entire module is for IP only */</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/termios.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/protocol.h&gt;</span>
<span class="cp">#include &lt;net/icmp.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">encode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">n</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">decode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">cpp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">put16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">x</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">pull16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">cpp</span><span class="p">);</span>

<span class="cm">/* Initialize compression data structure</span>
<span class="cm"> *	slots must be in range 0 to 255 (zero meaning no compression)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span>
<span class="nf">slhc_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">rslots</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tslots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">cstate</span> <span class="o">*</span><span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">;</span>

	<span class="n">comp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">comp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">rslots</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span>  <span class="n">rslots</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">rsize</span> <span class="o">=</span> <span class="n">rslots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cstate</span><span class="p">);</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">rstate</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">rsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">rstate</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">rslot_limit</span> <span class="o">=</span> <span class="n">rslots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">tslots</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span>  <span class="n">tslots</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">tsize</span> <span class="o">=</span> <span class="n">tslots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cstate</span><span class="p">);</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">tstate</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">tsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">tstate</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free2</span><span class="p">;</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">tslot_limit</span> <span class="o">=</span> <span class="n">tslots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">xmit_oldest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">xmit_current</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">recv_current</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * don&#39;t accept any packets with implicit index until we get</span>
<span class="cm">	 * one with an explicit index.  Otherwise the uncompress code</span>
<span class="cm">	 * will try to use connection 255, which is almost certainly</span>
<span class="cm">	 * out of range</span>
<span class="cm">	 */</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLF_TOSS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">tslots</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">ts</span> <span class="o">=</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">tstate</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">tslot_limit</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">){</span>
			<span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cs_this</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">tslot_limit</span><span class="p">]);</span>
		<span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cs_this</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">comp</span><span class="p">;</span>

<span class="nl">out_free2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">rstate</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
<span class="nl">out_fail:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Free a compression data structure */</span>
<span class="kt">void</span>
<span class="nf">slhc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">comp</span> <span class="o">==</span> <span class="n">NULLSLCOMPR</span> <span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">tstate</span> <span class="o">!=</span> <span class="n">NULLSLSTATE</span> <span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">tstate</span> <span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">rstate</span> <span class="o">!=</span> <span class="n">NULLSLSTATE</span> <span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">rstate</span> <span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span> <span class="n">comp</span> <span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* Put a short in host order into a char array in network order */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">put16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cp</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Encode a number */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">encode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">256</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">put16</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pull a 16-bit integer in host order from buffer in network byte order */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span>
<span class="nf">pull16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">cpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">cpp</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">cpp</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decode a number */</span>
<span class="k">static</span> <span class="kt">long</span>
<span class="nf">decode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">cpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

	<span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">cpp</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">pull16</span><span class="p">(</span><span class="n">cpp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>	<span class="cm">/* pull16 returns -1 on error */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>		<span class="cm">/* -1 if PULLCHAR returned error */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * icp and isize are the original packet.</span>
<span class="cm"> * ocp is a place to put a copy if necessary.</span>
<span class="cm"> * cpp is initially a pointer to icp.  If the copy is used,</span>
<span class="cm"> *    change it to ocp.</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">slhc_compress</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">icp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isize</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ocp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">cpp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">compress_cid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">cstate</span> <span class="o">*</span><span class="n">ocs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">tstate</span><span class="p">[</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">xmit_oldest</span><span class="p">]);</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">cstate</span> <span class="o">*</span><span class="n">lcs</span> <span class="o">=</span> <span class="n">ocs</span><span class="p">;</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">cstate</span> <span class="o">*</span><span class="n">cs</span> <span class="o">=</span> <span class="n">lcs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deltaS</span><span class="p">,</span> <span class="n">deltaA</span><span class="p">;</span>
	<span class="k">register</span> <span class="kt">short</span> <span class="n">changes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">new_seq</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">new_seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="o">*</span><span class="n">oth</span><span class="p">;</span>
	<span class="n">__sum16</span> <span class="n">csum</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 *	Don&#39;t play with runt packets.</span>
<span class="cm">	 */</span>

	<span class="k">if</span><span class="p">(</span><span class="n">isize</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">isize</span><span class="p">;</span>

	<span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">icp</span><span class="p">;</span>

	<span class="cm">/* Bail if this packet isn&#39;t TCP, or is an IP fragment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_TCP</span> <span class="o">||</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">frag_off</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3fff</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Send as regular IP */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
			<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_o_nontcp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_o_tcp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">isize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Extract TCP header */</span>

	<span class="n">th</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span><span class="p">)</span> <span class="o">+</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">hlen</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*  Bail if the TCP packet isn&#39;t `compressible&#39; (i.e., ACK isn&#39;t set or</span>
<span class="cm">	 *  some other control bit is set). Also uncompressible if</span>
<span class="cm">	 *  it&#39;s a runt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hlen</span> <span class="o">&gt;</span> <span class="n">isize</span> <span class="o">||</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">||</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span> <span class="o">||</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span> <span class="o">||</span>
	    <span class="o">!</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">)){</span>
		<span class="cm">/* TCP connection stuff; send as regular IP */</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_o_tcp</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">isize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Packet is compressible -- we&#39;re going to send either a</span>
<span class="cm">	 * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way,</span>
<span class="cm">	 * we need to locate (or create) the connection state.</span>
<span class="cm">	 *</span>
<span class="cm">	 * States are kept in a circularly linked list with</span>
<span class="cm">	 * xmit_oldest pointing to the end of the list.  The</span>
<span class="cm">	 * list is kept in lru order by moving a state to the</span>
<span class="cm">	 * head of the list whenever it is referenced.  Since</span>
<span class="cm">	 * the list is short and, empirically, the connection</span>
<span class="cm">	 * we want is almost always near the front, we locate</span>
<span class="cm">	 * states via linear search.  If we don&#39;t find a state</span>
<span class="cm">	 * for the datagram, the oldest state is (re-)used.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">==</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">saddr</span>
		 <span class="o">&amp;&amp;</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">==</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">daddr</span>
		 <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">==</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">.</span><span class="n">source</span>
		 <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">==</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">.</span><span class="n">dest</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

		<span class="cm">/* if current equal oldest, at end of list */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">cs</span> <span class="o">==</span> <span class="n">ocs</span> <span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">lcs</span> <span class="o">=</span> <span class="n">cs</span><span class="p">;</span>
		<span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_o_searches</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Didn&#39;t find it -- re-use oldest cstate.  Send an</span>
<span class="cm">	 * uncompressed packet that tells the other side what</span>
<span class="cm">	 * connection number we&#39;re using for this conversation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that since the state list is circular, the oldest</span>
<span class="cm">	 * state points to the newest and we only need to set</span>
<span class="cm">	 * xmit_oldest to update the lru linkage.</span>
<span class="cm">	 */</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_o_misses</span><span class="o">++</span><span class="p">;</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">xmit_oldest</span> <span class="o">=</span> <span class="n">lcs</span><span class="o">-&gt;</span><span class="n">cs_this</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">uncompressed</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Found it -- move to the front on the connection list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">lcs</span> <span class="o">==</span> <span class="n">ocs</span><span class="p">)</span> <span class="p">{</span>
 		<span class="cm">/* found at most recently used */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cs</span> <span class="o">==</span> <span class="n">ocs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* found at least recently used */</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">xmit_oldest</span> <span class="o">=</span> <span class="n">lcs</span><span class="o">-&gt;</span><span class="n">cs_this</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* more than 2 elements */</span>
		<span class="n">lcs</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">cs</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ocs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">ocs</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure that only what we expect to change changed.</span>
<span class="cm">	 * Check the following:</span>
<span class="cm">	 * IP protocol version, header length &amp; type of service.</span>
<span class="cm">	 * The &quot;Don&#39;t fragment&quot; bit.</span>
<span class="cm">	 * The time-to-live field.</span>
<span class="cm">	 * The TCP header length.</span>
<span class="cm">	 * IP options, if any.</span>
<span class="cm">	 * TCP options, if any.</span>
<span class="cm">	 * If any of these things are different between the previous &amp;</span>
<span class="cm">	 * current datagram, we send the current datagram `uncompressed&#39;.</span>
<span class="cm">	 */</span>
	<span class="n">oth</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">version</span> <span class="o">||</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">!=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">ihl</span>
	 <span class="o">||</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">tos</span> <span class="o">!=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">tos</span>
	 <span class="o">||</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">&amp;</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">frag_off</span> <span class="o">&amp;</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">))</span>
	 <span class="o">||</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ttl</span> <span class="o">!=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">ttl</span>
	 <span class="o">||</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">!=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">.</span><span class="n">doff</span>
	 <span class="o">||</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">ip</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ipopt</span><span class="p">,((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">)</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	 <span class="o">||</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">th</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcpopt</span><span class="p">,((</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span><span class="p">)</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)){</span>
		<span class="k">goto</span> <span class="n">uncompressed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out which of the changing fields changed.  The</span>
<span class="cm">	 * receiver expects changes in the order: urgent, window,</span>
<span class="cm">	 * ack, seq (the order minimizes the number of temporaries</span>
<span class="cm">	 * needed in this section of code).</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">urg</span><span class="p">){</span>
		<span class="n">deltaS</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">urg_ptr</span><span class="p">);</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="n">deltaS</span><span class="p">);</span>
		<span class="n">changes</span> <span class="o">|=</span> <span class="n">NEW_U</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">urg_ptr</span> <span class="o">!=</span> <span class="n">oth</span><span class="o">-&gt;</span><span class="n">urg_ptr</span><span class="p">){</span>
		<span class="cm">/* argh! URG not set but urp changed -- a sensible</span>
<span class="cm">		 * implementation should never do this but RFC793</span>
<span class="cm">		 * doesn&#39;t prohibit the change so we have to deal</span>
<span class="cm">		 * with it. */</span>
		<span class="k">goto</span> <span class="n">uncompressed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">((</span><span class="n">deltaS</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">)</span> <span class="o">-</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">oth</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="n">deltaS</span><span class="p">);</span>
		<span class="n">changes</span> <span class="o">|=</span> <span class="n">NEW_W</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">((</span><span class="n">deltaA</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">oth</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0L</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">deltaA</span> <span class="o">&gt;</span> <span class="mh">0x0000ffff</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">uncompressed</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="n">deltaA</span><span class="p">);</span>
		<span class="n">changes</span> <span class="o">|=</span> <span class="n">NEW_A</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">((</span><span class="n">deltaS</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">oth</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0L</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">deltaS</span> <span class="o">&gt;</span> <span class="mh">0x0000ffff</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">uncompressed</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="n">deltaS</span><span class="p">);</span>
		<span class="n">changes</span> <span class="o">|=</span> <span class="n">NEW_S</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">changes</span><span class="p">){</span>
	<span class="k">case</span> <span class="mi">0</span>:	<span class="cm">/* Nothing changed. If this packet contains data and the</span>
<span class="cm">		 * last one didn&#39;t, this is probably a data packet following</span>
<span class="cm">		 * an ack (normal on an interactive connection) and we send</span>
<span class="cm">		 * it compressed.  Otherwise it&#39;s probably a retransmit,</span>
<span class="cm">		 * retransmitted ack or window probe.  Send it uncompressed</span>
<span class="cm">		 * in case the other side missed the compressed version.</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">!=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">tot_len</span> <span class="o">&amp;&amp;</span>
		   <span class="n">ntohs</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">tot_len</span><span class="p">)</span> <span class="o">==</span> <span class="n">hlen</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">uncompressed</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPECIAL_I</span>:
	<span class="k">case</span> <span class="n">SPECIAL_D</span>:
		<span class="cm">/* actual changes match one of our special case encodings --</span>
<span class="cm">		 * send packet uncompressed.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">uncompressed</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NEW_S</span><span class="o">|</span><span class="n">NEW_A</span>:
		<span class="k">if</span><span class="p">(</span><span class="n">deltaS</span> <span class="o">==</span> <span class="n">deltaA</span> <span class="o">&amp;&amp;</span>
		    <span class="n">deltaS</span> <span class="o">==</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">tot_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">hlen</span><span class="p">){</span>
			<span class="cm">/* special case for echoed terminal traffic */</span>
			<span class="n">changes</span> <span class="o">=</span> <span class="n">SPECIAL_I</span><span class="p">;</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">new_seq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NEW_S</span>:
		<span class="k">if</span><span class="p">(</span><span class="n">deltaS</span> <span class="o">==</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">tot_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">hlen</span><span class="p">){</span>
			<span class="cm">/* special case for data xfer */</span>
			<span class="n">changes</span> <span class="o">=</span> <span class="n">SPECIAL_D</span><span class="p">;</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">new_seq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">deltaS</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">-</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">deltaS</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">){</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">encode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="n">deltaS</span><span class="p">);</span>
		<span class="n">changes</span> <span class="o">|=</span> <span class="n">NEW_I</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">psh</span><span class="p">)</span>
		<span class="n">changes</span> <span class="o">|=</span> <span class="n">TCP_PUSH_BIT</span><span class="p">;</span>
	<span class="cm">/* Grab the cksum before we overwrite it below.  Then update our</span>
<span class="cm">	 * state with this packet&#39;s header.</span>
<span class="cm">	 */</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
	<span class="cm">/* We want to use the original packet as our compressed packet.</span>
<span class="cm">	 * (cp - new_seq) is the number of bytes we need for compressed</span>
<span class="cm">	 * sequence numbers.  In addition we need one byte for the change</span>
<span class="cm">	 * mask, one for the connection id and two for the tcp checksum.</span>
<span class="cm">	 * So, (cp - new_seq) + 4 bytes of header are needed.</span>
<span class="cm">	 */</span>
	<span class="n">deltaS</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">-</span> <span class="n">new_seq</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">compress_cid</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">xmit_current</span> <span class="o">!=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_this</span><span class="p">){</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cpp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">changes</span> <span class="o">|</span> <span class="n">NEW_C</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_this</span><span class="p">;</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">xmit_current</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_this</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cpp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">;</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">changes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="p">(</span><span class="n">__sum16</span> <span class="o">*</span><span class="p">)</span><span class="n">cp</span> <span class="o">=</span> <span class="n">csum</span><span class="p">;</span>
	<span class="n">cp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
<span class="cm">/* deltaS is now the size of the change section of the compressed header */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span><span class="n">new_seq</span><span class="p">,</span><span class="n">deltaS</span><span class="p">);</span>	<span class="cm">/* Write list of deltas */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="o">+</span><span class="n">deltaS</span><span class="p">,</span><span class="n">icp</span><span class="o">+</span><span class="n">hlen</span><span class="p">,</span><span class="n">isize</span><span class="o">-</span><span class="n">hlen</span><span class="p">);</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_o_compressed</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ocp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">SL_TYPE_COMPRESSED_TCP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">isize</span> <span class="o">-</span> <span class="n">hlen</span> <span class="o">+</span> <span class="n">deltaS</span> <span class="o">+</span> <span class="p">(</span><span class="n">cp</span> <span class="o">-</span> <span class="n">ocp</span><span class="p">);</span>

	<span class="cm">/* Update connection state cs &amp; send uncompressed packet (i.e.,</span>
<span class="cm">	 * a regular ip/tcp packet but with the &#39;conversation id&#39; we hope</span>
<span class="cm">	 * to use on future compressed packets in the protocol field).</span>
<span class="cm">	 */</span>
<span class="nl">uncompressed:</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
	  <span class="n">memcpy</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ipopt</span><span class="p">,</span> <span class="n">ip</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">((</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">)</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
	  <span class="n">memcpy</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcpopt</span><span class="p">,</span> <span class="n">th</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">((</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">xmit_current</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_this</span><span class="p">;</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_o_uncompressed</span><span class="o">++</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ocp</span><span class="p">,</span> <span class="n">icp</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cpp</span> <span class="o">=</span> <span class="n">ocp</span><span class="p">;</span>
	<span class="n">ocp</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_this</span><span class="p">;</span>
	<span class="n">ocp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">SL_TYPE_UNCOMPRESSED_TCP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">isize</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span>
<span class="nf">slhc_uncompress</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">icp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">int</span> <span class="n">changes</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">thp</span><span class="p">;</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">cstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">icp</span><span class="p">;</span>

	<span class="cm">/* We&#39;ve got a compressed packet; read the change byte */</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_compressed</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">isize</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">){</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_error</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">changes</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">NEW_C</span><span class="p">){</span>
		<span class="cm">/* Make sure the state index is in range, then grab the state.</span>
<span class="cm">		 * If we have a good state index, clear the &#39;discard&#39; flag.</span>
<span class="cm">		 */</span>
		<span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* Read conn index */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">rslot_limit</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=~</span> <span class="n">SLF_TOSS</span><span class="p">;</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">recv_current</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* this packet has an implicit state index.  If we&#39;ve</span>
<span class="cm">		 * had a line error since the last time we got an</span>
<span class="cm">		 * explicit state index, we have to toss the packet. */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLF_TOSS</span><span class="p">){</span>
			<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_tossed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">rstate</span><span class="p">[</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">recv_current</span><span class="p">];</span>
	<span class="n">thp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">;</span>
	<span class="n">ip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">;</span>

	<span class="n">thp</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__sum16</span> <span class="o">*</span><span class="p">)</span><span class="n">cp</span><span class="p">;</span>
	<span class="n">cp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">thp</span><span class="o">-&gt;</span><span class="n">psh</span> <span class="o">=</span> <span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">TCP_PUSH_BIT</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * we can use the same number for the length of the saved header and</span>
<span class="cm"> * the current one, because the packet wouldn&#39;t have been sent</span>
<span class="cm"> * as compressed unless the options were the same as the previous one</span>
<span class="cm"> */</span>

	<span class="n">hdrlen</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">thp</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">SPECIALS_MASK</span><span class="p">){</span>
	<span class="k">case</span> <span class="n">SPECIAL_I</span>:		<span class="cm">/* Echoed terminal traffic */</span>
		<span class="p">{</span>
		<span class="k">register</span> <span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">;</span>
		<span class="n">thp</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">thp</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SPECIAL_D</span>:			<span class="cm">/* Unidirectional data */</span>
		<span class="n">thp</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span>
				  <span class="n">ntohs</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">tot_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">if</span><span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">NEW_U</span><span class="p">){</span>
			<span class="n">thp</span><span class="o">-&gt;</span><span class="n">urg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span><span class="p">((</span><span class="n">x</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">thp</span><span class="o">-&gt;</span><span class="n">urg_ptr</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">thp</span><span class="o">-&gt;</span><span class="n">urg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">NEW_W</span><span class="p">){</span>
			<span class="k">if</span><span class="p">((</span><span class="n">x</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">thp</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">NEW_A</span><span class="p">){</span>
			<span class="k">if</span><span class="p">((</span><span class="n">x</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">thp</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">NEW_S</span><span class="p">){</span>
			<span class="k">if</span><span class="p">((</span><span class="n">x</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">thp</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">NEW_I</span><span class="p">){</span>
		<span class="k">if</span><span class="p">((</span><span class="n">x</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">htons</span> <span class="p">(</span><span class="n">ntohs</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">htons</span> <span class="p">(</span><span class="n">ntohs</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, cp points to the first byte of data in the</span>
<span class="cm">	 * packet.  Put the reconstructed TCP and IP headers back on the</span>
<span class="cm">	 * packet.  Recalculate IP checksum (but not TCP checksum).</span>
<span class="cm">	 */</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">isize</span> <span class="o">-</span> <span class="p">(</span><span class="n">cp</span> <span class="o">-</span> <span class="n">icp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">ip</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memmove</span><span class="p">(</span><span class="n">icp</span> <span class="o">+</span> <span class="n">hdrlen</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">);</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="n">icp</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">cp</span> <span class="o">+=</span> <span class="mi">20</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ipopt</span><span class="p">,</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	  <span class="n">cp</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">put_unaligned</span><span class="p">(</span><span class="n">ip_fast_csum</span><span class="p">(</span><span class="n">icp</span><span class="p">,</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">),</span>
		      <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)</span><span class="n">icp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">thp</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">cp</span> <span class="o">+=</span> <span class="mi">20</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
	  <span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcpopt</span><span class="p">,</span> <span class="p">((</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">doff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	  <span class="n">cp</span> <span class="o">+=</span> <span class="p">((</span><span class="n">thp</span><span class="o">-&gt;</span><span class="n">doff</span><span class="p">)</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="nl">bad:</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_error</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">slhc_toss</span><span class="p">(</span> <span class="n">comp</span> <span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span>
<span class="nf">slhc_remember</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">icp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="k">struct</span> <span class="n">cstate</span> <span class="o">*</span><span class="n">cs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">ihl</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">isize</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The packet is shorter than a legal IP header */</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_runt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">slhc_toss</span><span class="p">(</span> <span class="n">comp</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Peek at the IP header&#39;s IHL field to find its length */</span>
	<span class="n">ihl</span> <span class="o">=</span> <span class="n">icp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ihl</span> <span class="o">&lt;</span> <span class="mi">20</span> <span class="o">/</span> <span class="mi">4</span><span class="p">){</span>
		<span class="cm">/* The IP header length field is too small */</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_runt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">slhc_toss</span><span class="p">(</span> <span class="n">comp</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">icp</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="n">icp</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip_fast_csum</span><span class="p">(</span><span class="n">icp</span><span class="p">,</span> <span class="n">ihl</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Bad IP header checksum; discard */</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_badcheck</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">slhc_toss</span><span class="p">(</span> <span class="n">comp</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">comp</span><span class="o">-&gt;</span><span class="n">rslot_limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_error</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">slhc_toss</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Update local state */</span>
	<span class="n">cs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">rstate</span><span class="p">[</span><span class="n">comp</span><span class="o">-&gt;</span><span class="n">recv_current</span> <span class="o">=</span> <span class="n">index</span><span class="p">];</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=~</span> <span class="n">SLF_TOSS</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ip</span><span class="p">,</span><span class="n">icp</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">,</span><span class="n">icp</span> <span class="o">+</span> <span class="n">ihl</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ihl</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
	  <span class="n">memcpy</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_ipopt</span><span class="p">,</span> <span class="n">icp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">),</span> <span class="p">(</span><span class="n">ihl</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">.</span><span class="n">doff</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
	  <span class="n">memcpy</span><span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcpopt</span><span class="p">,</span> <span class="n">icp</span> <span class="o">+</span> <span class="n">ihl</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">),</span> <span class="p">(</span><span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">.</span><span class="n">doff</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_hsize</span> <span class="o">=</span> <span class="n">ihl</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cs</span><span class="o">-&gt;</span><span class="n">cs_tcp</span><span class="p">.</span><span class="n">doff</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
	<span class="cm">/* Put headers back on packet</span>
<span class="cm">	 * Neither header checksum is recalculated</span>
<span class="cm">	 */</span>
	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">sls_i_uncompressed</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">isize</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">slhc_toss</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">comp</span> <span class="o">==</span> <span class="n">NULLSLCOMPR</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">comp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLF_TOSS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* CONFIG_INET */</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">slhc_toss</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Called IP function on non IP-system: slhc_toss&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span>
<span class="nf">slhc_uncompress</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">icp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Called IP function on non IP-system: slhc_uncompress&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span>
<span class="nf">slhc_compress</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">icp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isize</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ocp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">**</span><span class="n">cpp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">compress_cid</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Called IP function on non IP-system: slhc_compress&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">slhc_remember</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">icp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Called IP function on non IP-system: slhc_remember&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">slhc_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span><span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Called IP function on non IP-system: slhc_free&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">slcompress</span> <span class="o">*</span>
<span class="nf">slhc_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">rslots</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tslots</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Called IP function on non IP-system: slhc_init&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_INET */</span><span class="cp"></span>

<span class="cm">/* VJ header compression */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">slhc_init</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">slhc_free</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">slhc_remember</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">slhc_compress</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">slhc_uncompress</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">slhc_toss</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;Dual BSD/GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
