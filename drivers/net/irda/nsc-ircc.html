<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › irda › nsc-ircc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>nsc-ircc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *                </span>
<span class="cm"> * Filename:      nsc-ircc.c</span>
<span class="cm"> * Version:       1.0</span>
<span class="cm"> * Description:   Driver for the NSC PC&#39;108 and PC&#39;338 IrDA chipsets</span>
<span class="cm"> * Status:        Stable.</span>
<span class="cm"> * Author:        Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * Created at:    Sat Nov  7 21:43:15 1998</span>
<span class="cm"> * Modified at:   Wed Mar  1 11:29:34 2000</span>
<span class="cm"> * Modified by:   Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> * </span>
<span class="cm"> *     Copyright (c) 1998-2000 Dag Brattli &lt;dagb@cs.uit.no&gt;</span>
<span class="cm"> *     Copyright (c) 1998 Lichen Wang, &lt;lwang@actisys.com&gt;</span>
<span class="cm"> *     Copyright (c) 1998 Actisys Corp., www.actisys.com</span>
<span class="cm"> *     Copyright (c) 2000-2004 Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *     All Rights Reserved</span>
<span class="cm"> *      </span>
<span class="cm"> *     This program is free software; you can redistribute it and/or </span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as </span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of </span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *  </span>
<span class="cm"> *     Neither Dag Brattli nor University of Tromsø admit liability nor</span>
<span class="cm"> *     provide warranty for any of this software. This material is </span>
<span class="cm"> *     provided &quot;AS-IS&quot; and at no charge.</span>
<span class="cm"> *</span>
<span class="cm"> *     Notice that all functions that needs to access the chip in _any_</span>
<span class="cm"> *     way, must save BSR register on entry, and restore it on exit. </span>
<span class="cm"> *     It is _very_ important to follow this policy!</span>
<span class="cm"> *</span>
<span class="cm"> *         __u8 bank;</span>
<span class="cm"> *     </span>
<span class="cm"> *         bank = inb(iobase+BSR);</span>
<span class="cm"> *  </span>
<span class="cm"> *         do_your_stuff_here();</span>
<span class="cm"> *</span>
<span class="cm"> *         outb(bank, iobase+BSR);</span>
<span class="cm"> *</span>
<span class="cm"> *    If you find bugs in this file, its very likely that the same bug</span>
<span class="cm"> *    will also be in w83977af_ir.c since the implementations are quite</span>
<span class="cm"> *    similar.</span>
<span class="cm"> *     </span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/pnp.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;net/irda/wrapper.h&gt;</span>
<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irda_device.h&gt;</span>

<span class="cp">#include &quot;nsc-ircc.h&quot;</span>

<span class="cp">#define CHIP_IO_EXTENT 8</span>
<span class="cp">#define BROKEN_DONGLE_ID</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_name</span> <span class="o">=</span> <span class="s">&quot;nsc-ircc&quot;</span><span class="p">;</span>

<span class="cm">/* Power Management */</span>
<span class="cp">#define NSC_IRCC_DRIVER_NAME                  &quot;nsc-ircc&quot;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">nsc_ircc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">nsc_ircc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">nsc_ircc_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">NSC_IRCC_DRIVER_NAME</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* Module parameters */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">qos_mtt_bits</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">;</span>  <span class="cm">/* 1 ms or more */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dongle_id</span><span class="p">;</span>

<span class="cm">/* Use BIOS settions by default, but user may supply module parameters */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dma</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_probe_108</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_probe_338</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_probe_39x</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_init_108</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_init_338</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_init_39x</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PNP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nsc_ircc_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* These are the known NSC chips */</span>
<span class="k">static</span> <span class="n">nsc_chip_t</span> <span class="n">chips</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*  Name, {cfg registers}, chip id index reg, chip id expected value, revision mask */</span>
	<span class="p">{</span> <span class="s">&quot;PC87108&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="mh">0x150</span><span class="p">,</span> <span class="mh">0x398</span><span class="p">,</span> <span class="mh">0xea</span> <span class="p">},</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0xf0</span><span class="p">,</span> 
	  <span class="n">nsc_ircc_probe_108</span><span class="p">,</span> <span class="n">nsc_ircc_init_108</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;PC87338&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="mh">0x398</span><span class="p">,</span> <span class="mh">0x15c</span><span class="p">,</span> <span class="mh">0x2e</span> <span class="p">},</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> 
	  <span class="n">nsc_ircc_probe_338</span><span class="p">,</span> <span class="n">nsc_ircc_init_338</span> <span class="p">},</span>
	<span class="cm">/* Contributed by Steffen Pingel - IBM X40 */</span>
	<span class="p">{</span> <span class="s">&quot;PC8738x&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="mh">0x164e</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x2e</span> <span class="p">},</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>
	  <span class="n">nsc_ircc_probe_39x</span><span class="p">,</span> <span class="n">nsc_ircc_init_39x</span> <span class="p">},</span>
	<span class="cm">/* Contributed by Jan Frey - IBM A30/A31 */</span>
	<span class="p">{</span> <span class="s">&quot;PC8739x&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">},</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xea</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> 
	  <span class="n">nsc_ircc_probe_39x</span><span class="p">,</span> <span class="n">nsc_ircc_init_39x</span> <span class="p">},</span>
	<span class="cm">/* IBM ThinkPads using PC8738x (T60/X60/Z60) */</span>
	<span class="p">{</span> <span class="s">&quot;IBM-PC8738x&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">},</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>
	  <span class="n">nsc_ircc_probe_39x</span><span class="p">,</span> <span class="n">nsc_ircc_init_39x</span> <span class="p">},</span>
	<span class="cm">/* IBM ThinkPads using PC8394T (T43/R52/?) */</span>
	<span class="p">{</span> <span class="s">&quot;IBM-PC8394T&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x0</span> <span class="p">},</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xf9</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>
	  <span class="n">nsc_ircc_probe_39x</span><span class="p">,</span> <span class="n">nsc_ircc_init_39x</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">dev_self</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dongle_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Differential serial interface&quot;</span><span class="p">,</span>
	<span class="s">&quot;Differential serial interface&quot;</span><span class="p">,</span>
	<span class="s">&quot;Reserved&quot;</span><span class="p">,</span>
	<span class="s">&quot;Reserved&quot;</span><span class="p">,</span>
	<span class="s">&quot;Sharp RY5HD01&quot;</span><span class="p">,</span>
	<span class="s">&quot;Reserved&quot;</span><span class="p">,</span>
	<span class="s">&quot;Single-ended serial interface&quot;</span><span class="p">,</span>
	<span class="s">&quot;Consumer-IR only&quot;</span><span class="p">,</span>
	<span class="s">&quot;HP HSDL-2300, HP HSDL-3600/HSDL-3610&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM31T1100 or Temic TFDS6000/TFDS6500&quot;</span><span class="p">,</span>
	<span class="s">&quot;Reserved&quot;</span><span class="p">,</span>
	<span class="s">&quot;Reserved&quot;</span><span class="p">,</span>
	<span class="s">&quot;HP HSDL-1100/HSDL-2100&quot;</span><span class="p">,</span>
	<span class="s">&quot;HP HSDL-1100/HSDL-2100&quot;</span><span class="p">,</span>
	<span class="s">&quot;Supports SIR Mode only&quot;</span><span class="p">,</span>
	<span class="s">&quot;No dongle connected&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* PNP probing */</span>
<span class="k">static</span> <span class="n">chipio_t</span> <span class="n">pnp_info</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">nsc_ircc_pnp_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;NSC6001&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;HWPC224&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;IBM0071&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="n">NSC_FORCE_DONGLE_TYPE9</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span> <span class="n">nsc_ircc_pnp_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">nsc_ircc_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PNP</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;nsc-ircc&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">nsc_ircc_pnp_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">nsc_ircc_pnp_probe</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Some prototypes */</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_open</span><span class="p">(</span><span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_setup</span><span class="p">(</span><span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nsc_ircc_pio_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_dma_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span> 
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_dma_receive_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iobase</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span>  <span class="n">nsc_ircc_hard_xmit_sir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span>  <span class="n">nsc_ircc_hard_xmit_fir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_pio_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fifo_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nsc_ircc_dma_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iobase</span><span class="p">);</span>
<span class="k">static</span> <span class="n">__u8</span> <span class="n">nsc_ircc_change_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">baud</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_is_receiving</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_read_dongle_id</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nsc_ircc_init_dongle_interface</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dongle_id</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">nsc_ircc_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>

<span class="cm">/* Globals */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pnp_registered</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pnp_succeeded</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_init ()</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize chip. Just try to find out how many chips we are dealing with</span>
<span class="cm"> *    and where they are</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nsc_ircc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">chipio_t</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsc_ircc_driver</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s, Can&#39;t register driver!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>

 	<span class="cm">/* Register with PnP subsystem to detect disable ports */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsc_ircc_pnp_driver</span><span class="p">);</span>

 	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
 		<span class="n">pnp_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Probe for all the NSC chipsets we know about */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">chip</span> <span class="o">=</span> <span class="n">chips</span><span class="p">;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">name</span> <span class="p">;</span> <span class="n">chip</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Probing for %s ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			   <span class="n">chip</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		
		<span class="cm">/* Try all config registers for this chip */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cfg</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">);</span> <span class="n">cfg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cfg_base</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cfg</span><span class="p">[</span><span class="n">cfg</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg_base</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Read index register */</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() no chip at 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			
			<span class="cm">/* Read chip identification register */</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cid_index</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">id</span> <span class="o">&amp;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cid_mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">cid_value</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() Found %s chip, revision=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">__func__</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">id</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">cid_mask</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * If we found a correct PnP setting,</span>
<span class="cm">				 * we first try it.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pnp_succeeded</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chipio_t</span><span class="p">));</span>
					<span class="n">info</span><span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="n">cfg_base</span><span class="p">;</span>
					<span class="n">info</span><span class="p">.</span><span class="n">fir_base</span> <span class="o">=</span> <span class="n">pnp_info</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>
					<span class="n">info</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">pnp_info</span><span class="p">.</span><span class="n">dma</span><span class="p">;</span>
					<span class="n">info</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pnp_info</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">fir_base</span> <span class="o">&lt;</span> <span class="mh">0x2000</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s, chip-&gt;init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>
						<span class="n">chip</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="n">chip</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">nsc_ircc_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Opening based on PnP values failed.</span>
<span class="cm">				 * Let&#39;s fallback to user values, or probe</span>
<span class="cm">				 * the chip.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s, PnP init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chipio_t</span><span class="p">));</span>
					<span class="n">info</span><span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="n">cfg_base</span><span class="p">;</span>
					<span class="n">info</span><span class="p">.</span><span class="n">fir_base</span> <span class="o">=</span> <span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
					<span class="n">info</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
					<span class="n">info</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

					<span class="cm">/*</span>
<span class="cm">					 * If the user supplies the base address, then</span>
<span class="cm">					 * we init the chip, if not we probe the values</span>
<span class="cm">					 * set by the BIOS</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">io</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0x2000</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">chip</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="n">chip</span><span class="o">-&gt;</span><span class="n">probe</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">nsc_ircc_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Wrong chip id=0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> 
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsc_ircc_driver</span><span class="p">);</span>
		<span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsc_ircc_pnp_driver</span><span class="p">);</span>
		<span class="n">pnp_registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_cleanup ()</span>
<span class="cm"> *</span>
<span class="cm"> *    Close all configured chips</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">nsc_ircc_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dev_self</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">nsc_ircc_close</span><span class="p">(</span><span class="n">dev_self</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsc_ircc_driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_registered</span><span class="p">)</span>
 		<span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsc_ircc_pnp_driver</span><span class="p">);</span>

	<span class="n">pnp_registered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">nsc_ircc_sir_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>       <span class="o">=</span> <span class="n">nsc_ircc_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>       <span class="o">=</span> <span class="n">nsc_ircc_net_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">nsc_ircc_hard_xmit_sir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>   <span class="o">=</span> <span class="n">nsc_ircc_net_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">nsc_ircc_fir_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>       <span class="o">=</span> <span class="n">nsc_ircc_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>       <span class="o">=</span> <span class="n">nsc_ircc_net_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">nsc_ircc_hard_xmit_fir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>   <span class="o">=</span> <span class="n">nsc_ircc_net_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_open (iobase, irq)</span>
<span class="cm"> *</span>
<span class="cm"> *    Open driver instance</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nsc_ircc_open</span><span class="p">(</span><span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">chip_index</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>


 	<span class="k">for</span> <span class="p">(</span><span class="n">chip_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chip_index</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dev_self</span><span class="p">);</span> <span class="n">chip_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_self</span><span class="p">[</span><span class="n">chip_index</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip_index</span> <span class="o">==</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dev_self</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), maximum number of supported chips reached!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s, Found chip at base=0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span>
		     <span class="n">info</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">nsc_ircc_setup</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s, driver loaded (Dag Brattli)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_irdadev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), can&#39;t allocate memory for &quot;</span>
			   <span class="s">&quot;control block!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
   
	<span class="cm">/* Need to store self somewhere */</span>
	<span class="n">dev_self</span><span class="p">[</span><span class="n">chip_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">chip_index</span><span class="p">;</span>

	<span class="cm">/* Initialize IO */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">cfg_base</span>  <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span>  <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span><span class="p">;</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span>       <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_ext</span>   <span class="o">=</span> <span class="n">CHIP_IO_EXTENT</span><span class="p">;</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span>       <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fifo_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	
	<span class="cm">/* Reserve the ioports that we need */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_region</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_ext</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), can&#39;t get iobase of 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize QoS for this device */</span>
	<span class="n">irda_init_max_qos_capabilies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">);</span>
	
	<span class="cm">/* The only value we must override it the baudrate */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">IR_9600</span><span class="o">|</span><span class="n">IR_19200</span><span class="o">|</span><span class="n">IR_38400</span><span class="o">|</span><span class="n">IR_57600</span><span class="o">|</span>
		<span class="n">IR_115200</span><span class="o">|</span><span class="n">IR_576000</span><span class="o">|</span><span class="n">IR_1152000</span> <span class="o">|</span><span class="p">(</span><span class="n">IR_4000000</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">qos_mtt_bits</span><span class="p">;</span>
	<span class="n">irda_qos_bits_to_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">);</span>
	
	<span class="cm">/* Max DMA buffer size needed = (data_size + 6) * (window_size) + 6; */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span> <span class="o">=</span> <span class="mi">14384</span><span class="p">;</span> 
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span> <span class="o">=</span> <span class="mi">14384</span><span class="p">;</span>

	<span class="cm">/* Allocate memory if needed */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span>
		<span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">);</span>
	
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span>
		<span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">in_frame</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">OUTSIDE_FRAME</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	
	<span class="cm">/* Reset Tx queue info */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/* Override the network functions we need to use */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nsc_ircc_sir_ops</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), register_netdev() failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;IrDA: Registered device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* Check if user has supplied a valid dongle id or not */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dongle_id</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">dongle_id</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dongle_types</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dongle_id</span> <span class="o">=</span> <span class="n">nsc_ircc_read_dongle_id</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">);</span>
		
		<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s, Found dongle: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span>
			     <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s, Using dongle: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span>
			     <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
	<span class="p">}</span>
	
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dongle_id</span> <span class="o">=</span> <span class="n">dongle_id</span><span class="p">;</span>
	<span class="n">nsc_ircc_init_dongle_interface</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">dongle_id</span><span class="p">);</span>

 	<span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span> <span class="o">=</span> <span class="n">platform_device_register_simple</span><span class="p">(</span><span class="n">NSC_IRCC_DRIVER_NAME</span><span class="p">,</span>
 						      <span class="n">self</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
 	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span><span class="p">))</span> <span class="p">{</span>
 		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span><span class="p">);</span>
 		<span class="k">goto</span> <span class="n">out5</span><span class="p">;</span>
 	<span class="p">}</span>
 	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chip_index</span><span class="p">;</span>

 <span class="nl">out5:</span>
 	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">out4:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
			  <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff_dma</span><span class="p">);</span>
 <span class="nl">out3:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
			  <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff_dma</span><span class="p">);</span>
 <span class="nl">out2:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_ext</span><span class="p">);</span>
 <span class="nl">out1:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_self</span><span class="p">[</span><span class="n">chip_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_close (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Close driver instance</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">nsc_ircc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

        <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span><span class="p">);</span>

	<span class="cm">/* Remove netdevice */</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Release the PORT that this driver is using */</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), Releasing Region %03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">);</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_ext</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
				  <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff_dma</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
				  <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff_dma</span><span class="p">);</span>

	<span class="n">dev_self</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_init_108 (iobase, cfg_base, irq, dma)</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize the NSC &#39;108 chip</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_init_108</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cfg_base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">temp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>      <span class="cm">/* Mode Control Register (MCTL) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* Disable device */</span>
	
	<span class="cm">/* Base Address and Interrupt Control Register (BAIC) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_108_BAIC</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x3e8</span>: <span class="n">outb</span><span class="p">(</span><span class="mh">0x14</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2e8</span>: <span class="n">outb</span><span class="p">(</span><span class="mh">0x15</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x3f8</span>: <span class="n">outb</span><span class="p">(</span><span class="mh">0x16</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2f8</span>: <span class="n">outb</span><span class="p">(</span><span class="mh">0x17</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), invalid base_address&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="cm">/* Control Signal Routing Register (CSRT) */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">3</span>:  <span class="n">temp</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:  <span class="n">temp</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:  <span class="n">temp</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">7</span>:  <span class="n">temp</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">9</span>:  <span class="n">temp</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">11</span>: <span class="n">temp</span> <span class="o">=</span> <span class="mh">0x06</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">15</span>: <span class="n">temp</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), invalid irq&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_108_CSRT</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	
	<span class="k">switch</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>	
	<span class="k">case</span> <span class="mi">0</span>: <span class="n">outb</span><span class="p">(</span><span class="mh">0x08</span><span class="o">+</span><span class="n">temp</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="n">outb</span><span class="p">(</span><span class="mh">0x10</span><span class="o">+</span><span class="n">temp</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="n">outb</span><span class="p">(</span><span class="mh">0x18</span><span class="o">+</span><span class="n">temp</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), invalid dma&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_108_MCTL</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>      <span class="cm">/* Mode Control Register (MCTL) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x03</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* Enable device */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_probe_108 (chip, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    </span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_probe_108</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cfg_base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Read address and interrupt control register (BAIC) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_108_BAIC</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x3e8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x2e8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x3f8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x2f8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sir_base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span><span class="p">;</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), probing fir_base=0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span><span class="p">);</span>

	<span class="cm">/* Read control signals routing register (CSRT) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_108_CSRT</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">7</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), probing irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* Currently we only read Rx DMA but it will also be used for Tx */</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), probing dma=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="cm">/* Read mode control register (MCTL) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_108_MCTL</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="o">!</span><span class="p">((</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_init_338 (chip, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize the NSC &#39;338 chip. Remember that the 87338 needs two </span>
<span class="cm"> *    consecutive writes to the data registers while CPU interrupts are</span>
<span class="cm"> *    disabled. The 97338 does not require this, but shouldn&#39;t be any</span>
<span class="cm"> *    harm if we do it anyway.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_init_338</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="cm">/* No init yet */</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_probe_338 (chip, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    </span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_probe_338</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cfg_base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">com</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pnp</span><span class="p">;</span>

	<span class="cm">/* Read function enable register (FER) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_338_FER</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>

	<span class="cm">/* Check if we are in Legacy or PnP mode */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_338_PNP0</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="n">pnp</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;(), Chip is in PnP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x46</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfe</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">outb</span><span class="p">(</span><span class="mh">0x47</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="n">reg</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Read function address register (FAR) */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">CFG_338_FAR</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		
		<span class="k">switch</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x3f8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x2f8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">com</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">com</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">com</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x3e8</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x2e8</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">com</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x338</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x238</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">com</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x2e8</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x2e0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">com</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x220</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="mh">0x228</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">sir_base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="cm">/* Read PnP register 1 (PNP1) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_338_PNP1</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	
	<span class="cm">/* Read PnP register 3 (PNP3) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_338_PNP3</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Read power and test register (PTR) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_338_PTR</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">suspended</span> <span class="o">=</span> <span class="n">reg</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_init_39x (chip, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    Now that we know it&#39;s a &#39;39x (see probe below), we need to</span>
<span class="cm"> *    configure it so we can use it.</span>
<span class="cm"> *</span>
<span class="cm"> * The NSC &#39;338 chip is a Super I/O chip with a &quot;bank&quot; architecture,</span>
<span class="cm"> * the configuration of the different functionality (serial, parallel,</span>
<span class="cm"> * floppy...) are each in a different bank (Logical Device Number).</span>
<span class="cm"> * The base address, irq and dma configuration registers are common</span>
<span class="cm"> * to all functionalities (index 0x30 to 0x7F).</span>
<span class="cm"> * There is only one configuration register specific to the</span>
<span class="cm"> * serial port, CFG_39X_SPC.</span>
<span class="cm"> * JeanII</span>
<span class="cm"> *</span>
<span class="cm"> * Note : this code was written by Jan Frey &lt;janfrey@web.de&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_init_39x</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cfg_base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">;</span>

	<span class="cm">/* User is sure about his config... accept it. */</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(): nsc_ircc_init_39x (user settings): &quot;</span>
		   <span class="s">&quot;io=0x%04x, irq=%d, dma=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="cm">/* Access bank for SP2 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_LDN</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Configure SP2 */</span>

	<span class="cm">/* We want to enable the device if not enabled */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_ACT</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">enabled</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable the device */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_SIOCF1</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* May want to update info-&gt;enabled. Jean II */</span>
	<span class="p">}</span>

	<span class="cm">/* Enable UART bank switching (bit 7) ; Sets the chip to normal</span>
<span class="cm">	 * power mode (wake up from sleep mode) (bit 1) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_SPC</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x82</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_probe_39x (chip, info)</span>
<span class="cm"> *</span>
<span class="cm"> *    Test if we really have a &#39;39x chip at the given address</span>
<span class="cm"> *</span>
<span class="cm"> * Note : this code was written by Jan Frey &lt;janfrey@web.de&gt;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_probe_39x</span><span class="p">(</span><span class="n">nsc_chip_t</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cfg_base</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irqt</span><span class="p">,</span> <span class="n">dma1</span><span class="p">,</span> <span class="n">dma2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enabled</span><span class="p">,</span> <span class="n">susp</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), nsc_ircc_probe_39x, base=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>

	<span class="cm">/* This function should be executed with irq off to avoid</span>
<span class="cm">	 * another driver messing with the Super I/O bank - Jean II */</span>

	<span class="cm">/* Access bank for SP2 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_LDN</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Read infos about SP2 ; store in info struct */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_BASEH</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg1</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_BASEL</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">reg2</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">reg2</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_IRQNUM</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_IRQSEL</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">irqt</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_DMA0</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">dma1</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_DMA1</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">dma2</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_ACT</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">enabled</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_SPC</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">susp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(): io=0x%02x%02x, irq=%d (type %d), rxdma=%d, txdma=%d, enabled=%d (suspended=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span><span class="n">reg2</span><span class="p">,</span><span class="n">irq</span><span class="p">,</span><span class="n">irqt</span><span class="p">,</span><span class="n">dma1</span><span class="p">,</span><span class="n">dma2</span><span class="p">,</span><span class="n">enabled</span><span class="p">,</span><span class="n">susp</span><span class="p">);</span>

	<span class="cm">/* Configure SP2 */</span>

	<span class="cm">/* We want to enable the device if not enabled */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_ACT</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">enabled</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable the device */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_SIOCF1</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* May want to update info-&gt;enabled. Jean II */</span>
	<span class="p">}</span>

	<span class="cm">/* Enable UART bank switching (bit 7) ; Sets the chip to normal</span>
<span class="cm">	 * power mode (wake up from sleep mode) (bit 1) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">CFG_39X_SPC</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x82</span><span class="p">,</span> <span class="n">cfg_base</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PNP</span>
<span class="cm">/* PNP probing */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnp_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chipio_t</span><span class="p">));</span>
	<span class="n">pnp_info</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">pnp_info</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">pnp_succeeded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">&amp;</span> <span class="n">NSC_FORCE_DONGLE_TYPE9</span><span class="p">)</span>
		<span class="n">dongle_id</span> <span class="o">=</span> <span class="mh">0x9</span><span class="p">;</span>

	<span class="cm">/* There doesn&#39;t seem to be any way of getting the cfg_base.</span>
<span class="cm">	 * On my box, cfg_base is in the PnP descriptor of the</span>
<span class="cm">	 * motherboard. Oh well... Jean II */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_port_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">pnp_port_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_DISABLED</span><span class="p">))</span>
		<span class="n">pnp_info</span><span class="p">.</span><span class="n">fir_base</span> <span class="o">=</span> <span class="n">pnp_port_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_irq_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">pnp_irq_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_DISABLED</span><span class="p">))</span>
		<span class="n">pnp_info</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pnp_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_dma_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">pnp_dma_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_DISABLED</span><span class="p">))</span>
		<span class="n">pnp_info</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">pnp_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() : From PnP, found firbase 0x%03X ; irq %d ; dma %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">pnp_info</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">pnp_info</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">pnp_info</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>

	<span class="k">if</span><span class="p">((</span><span class="n">pnp_info</span><span class="p">.</span><span class="n">fir_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	   <span class="p">(</span><span class="n">pnp_info</span><span class="p">.</span><span class="n">irq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">pnp_info</span><span class="p">.</span><span class="n">dma</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Returning an error will disable the device. Yuck ! */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>return -EINVAL;</p></td><td class="code"><div class="highlight"><pre>		<span class="n">pnp_succeeded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_setup (info)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns non-negative on success.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_setup</span><span class="p">(</span><span class="n">chipio_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="cm">/* Read the Module ID */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK3</span><span class="p">);</span>
	<span class="n">version</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">MID</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() Driver %s Found chip version %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

	<span class="cm">/* Should be 0x2? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="mh">0x20</span> <span class="o">!=</span> <span class="p">(</span><span class="n">version</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s, Wrong chip version %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">driver_name</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Switch to advanced mode */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK2</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">ECR1_EXT_SL</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">ECR1</span><span class="p">);</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	
	<span class="cm">/* Set FIFO threshold to TX17, RX16, reset and enable FIFO&#39;s */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">FCR_RXTH</span><span class="o">|</span><span class="n">FCR_TXTH</span><span class="o">|</span><span class="n">FCR_TXSR</span><span class="o">|</span><span class="n">FCR_RXSR</span><span class="o">|</span><span class="n">FCR_FIFO_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">FCR</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0x03</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">LCR</span><span class="p">);</span> 	<span class="cm">/* 8 bit word length */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">MCR_SIR</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span> 	<span class="cm">/* Start at SIR-mode, also clears LSR*/</span>

	<span class="cm">/* Set FIFO size to 32 */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK2</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">EXCR2_RFSIZ</span><span class="o">|</span><span class="n">EXCR2_TFSIZ</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">EXCR2</span><span class="p">);</span>

	<span class="cm">/* IRCR2: FEND_MD is not set */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK5</span><span class="p">);</span>
 	<span class="n">outb</span><span class="p">(</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Make sure that some defaults are OK */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK6</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">0</span><span class="p">);</span> <span class="cm">/* Set 32 bits FIR CRC */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x0a</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* Set MIR pulse width */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x0d</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span> <span class="cm">/* Set SIR pulse width to 1.6us */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x2a</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span> <span class="cm">/* Set beginning frag, and preamble length */</span>

	<span class="cm">/* Enable receive interrupts */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IER_RXHDL_IE</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_read_dongle_id (void)</span>
<span class="cm"> *</span>
<span class="cm"> * Try to read dongle indentification. This procedure needs to be executed</span>
<span class="cm"> * once after power-on/reset. It also needs to be used whenever you suspect</span>
<span class="cm"> * that the user may have plugged/unplugged the IrDA Dongle.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_read_dongle_id</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dongle_id</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>

	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Select Bank 7 */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK7</span><span class="p">);</span>
	
	<span class="cm">/* IRCFG4: IRSL0_DS and IRSL21_DS are cleared */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span>
	
	<span class="cm">/* ID0, 1, and 2 are pulled up/down very slowly */</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	
	<span class="cm">/* IRCFG1: read the ID bits */</span>
	<span class="n">dongle_id</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>

<span class="cp">#ifdef BROKEN_DONGLE_ID</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dongle_id</span> <span class="o">==</span> <span class="mh">0x0a</span><span class="p">)</span>
		<span class="n">dongle_id</span> <span class="o">=</span> <span class="mh">0x09</span><span class="p">;</span>
<span class="cp">#endif	</span>
	<span class="cm">/* Go back to  bank 0 before returning */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dongle_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_init_dongle_interface (iobase, dongle_id)</span>
<span class="cm"> *</span>
<span class="cm"> *     This function initializes the dongle for the transceiver that is</span>
<span class="cm"> *     used. This procedure needs to be executed once after</span>
<span class="cm"> *     power-on/reset. It also needs to be used whenever you suspect that</span>
<span class="cm"> *     the dongle is changed. </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nsc_ircc_init_dongle_interface</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dongle_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bank</span><span class="p">;</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Select Bank 7 */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK7</span><span class="p">);</span>
	
	<span class="cm">/* IRCFG4: set according to dongle_id */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dongle_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00</span>: <span class="cm">/* same as */</span>
	<span class="k">case</span> <span class="mh">0x01</span>: <span class="cm">/* Differential serial interface */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02</span>: <span class="cm">/* same as */</span>
	<span class="k">case</span> <span class="mh">0x03</span>: <span class="cm">/* Reserved */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x04</span>: <span class="cm">/* Sharp RY5HD01 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x05</span>: <span class="cm">/* Reserved, but this is what the Thinkpad reports */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x06</span>: <span class="cm">/* Single-ended serial interface */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x07</span>: <span class="cm">/* Consumer-IR only */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s is not for IrDA mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x08</span>: <span class="cm">/* HP HSDL-2300, HP HSDL-3600/HSDL-3610 */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x09</span>: <span class="cm">/* IBM31T1100 or Temic TFDS6000/TFDS6500 */</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span> <span class="cm">/* Set irsl[0-2] as output */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0A</span>: <span class="cm">/* same as */</span>
	<span class="k">case</span> <span class="mh">0x0B</span>: <span class="cm">/* Reserved */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0C</span>: <span class="cm">/* same as */</span>
	<span class="k">case</span> <span class="mh">0x0D</span>: <span class="cm">/* HP HSDL-1100/HSDL-2100 */</span>
		<span class="cm">/* </span>
<span class="cm">		 * Set irsl0 as input, irsl[1-2] as output, and separate </span>
<span class="cm">		 * inputs are used for SIR and MIR/FIR </span>
<span class="cm">		 */</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x48</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span> 
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0E</span>: <span class="cm">/* Supports SIR Mode only */</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">7</span><span class="p">);</span> <span class="cm">/* Set irsl[0-2] as output */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0F</span>: <span class="cm">/* No dongle connected */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>

		<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x62</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> 
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), invalid dongle_id %#x&quot;</span><span class="p">,</span> 
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_id</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="cm">/* IRCFG1: IRSL1 and 2 are set to IrDA mode */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
	
<span class="p">}</span> <span class="cm">/* set_up_dongle_interface */</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_change_dongle_speed (iobase, speed, dongle_id)</span>
<span class="cm"> *</span>
<span class="cm"> *    Change speed of the attach dongle</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nsc_ircc_change_dongle_speed</span><span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dongle_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Select Bank 7 */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK7</span><span class="p">);</span>
	
	<span class="cm">/* IRCFG1: set according to dongle_id */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dongle_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x00</span>: <span class="cm">/* same as */</span>
	<span class="k">case</span> <span class="mh">0x01</span>: <span class="cm">/* Differential serial interface */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02</span>: <span class="cm">/* same as */</span>
	<span class="k">case</span> <span class="mh">0x03</span>: <span class="cm">/* Reserved */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x04</span>: <span class="cm">/* Sharp RY5HD01 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x05</span>: <span class="cm">/* Reserved */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x06</span>: <span class="cm">/* Single-ended serial interface */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x07</span>: <span class="cm">/* Consumer-IR only */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s is not for IrDA mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x08</span>: <span class="cm">/* HP HSDL-2300, HP HSDL-3600/HSDL-3610 */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">115200</span><span class="p">)</span>
			<span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x09</span>: <span class="cm">/* IBM31T1100 or Temic TFDS6000/TFDS6500 */</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">4000000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* There was a cli() there, but we now are already</span>
<span class="cm">			 * under spin_lock_irqsave() - JeanII */</span>
			<span class="n">outb</span><span class="p">(</span><span class="mh">0x81</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
			<span class="n">outb</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0A</span>: <span class="cm">/* same as */</span>
	<span class="k">case</span> <span class="mh">0x0B</span>: <span class="cm">/* Reserved */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s not defined by irda yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0C</span>: <span class="cm">/* same as */</span>
	<span class="k">case</span> <span class="mh">0x0D</span>: <span class="cm">/* HP HSDL-1100/HSDL-2100 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0E</span>: <span class="cm">/* Supports SIR Mode only */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x0F</span>: <span class="cm">/* No dongle connected */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), %s is not for IrDA mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">dongle_types</span><span class="p">[</span><span class="n">dongle_id</span><span class="p">]);</span>

		<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span> 
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x62</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> 
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), invalid data_rate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_change_speed (self, baud)</span>
<span class="cm"> *</span>
<span class="cm"> *    Change the speed of the device</span>
<span class="cm"> *</span>
<span class="cm"> * This function *must* be called with irq off and spin-lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__u8</span> <span class="nf">nsc_ircc_change_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">mcr</span> <span class="o">=</span> <span class="n">MCR_SIR</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span> 
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">ier</span><span class="p">;</span>                  <span class="cm">/* Interrupt enable register */</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), speed=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="cm">/* Update accounting for new speed */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Disable interrupts */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span>

	<span class="cm">/* Select Bank 2 */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK2</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BGDH</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">9600</span>:   <span class="n">outb</span><span class="p">(</span><span class="mh">0x0c</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BGDL</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">19200</span>:  <span class="n">outb</span><span class="p">(</span><span class="mh">0x06</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BGDL</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">38400</span>:  <span class="n">outb</span><span class="p">(</span><span class="mh">0x03</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BGDL</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">57600</span>:  <span class="n">outb</span><span class="p">(</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BGDL</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">115200</span>: <span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BGDL</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">576000</span>:
		<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK5</span><span class="p">);</span>
		
		<span class="cm">/* IRCR2: MDRS is set */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x04</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
	       
		<span class="n">mcr</span> <span class="o">=</span> <span class="n">MCR_MIR</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), handling baud of 576000</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1152000</span>:
		<span class="n">mcr</span> <span class="o">=</span> <span class="n">MCR_MIR</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), handling baud of 1152000</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4000000</span>:
		<span class="n">mcr</span> <span class="o">=</span> <span class="n">MCR_FIR</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), handling baud of 4000000</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">mcr</span> <span class="o">=</span> <span class="n">MCR_FIR</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unknown baud rate of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set appropriate speed mode */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">mcr</span> <span class="o">|</span> <span class="n">MCR_TX_DFR</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span>

	<span class="cm">/* Give some hits to the transceiver */</span>
	<span class="n">nsc_ircc_change_dongle_speed</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dongle_id</span><span class="p">);</span>

	<span class="cm">/* Set FIFO threshold to TX17, RX16 */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">FCR</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">FCR_FIFO_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">FCR</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">FCR_RXTH</span><span class="o">|</span>     <span class="cm">/* Set Rx FIFO threshold */</span>
	     <span class="n">FCR_TXTH</span><span class="o">|</span>     <span class="cm">/* Set Tx FIFO threshold */</span>
	     <span class="n">FCR_TXSR</span><span class="o">|</span>     <span class="cm">/* Reset Tx FIFO */</span>
	     <span class="n">FCR_RXSR</span><span class="o">|</span>     <span class="cm">/* Reset Rx FIFO */</span>
	     <span class="n">FCR_FIFO_EN</span><span class="p">,</span>  <span class="cm">/* Enable FIFOs */</span>
	     <span class="n">iobase</span><span class="o">+</span><span class="n">FCR</span><span class="p">);</span>
	
	<span class="cm">/* Set FIFO size to 32 */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK2</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">EXCR2_RFSIZ</span><span class="o">|</span><span class="n">EXCR2_TFSIZ</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">EXCR2</span><span class="p">);</span>
	
	<span class="cm">/* Enable some interrupts so we can receive frames */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span> 
	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">115200</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Install FIR xmit handler */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nsc_ircc_fir_ops</span><span class="p">;</span>
		<span class="n">ier</span> <span class="o">=</span> <span class="n">IER_SFIF_IE</span><span class="p">;</span>
		<span class="n">nsc_ircc_dma_receive</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Install SIR xmit handler */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nsc_ircc_sir_ops</span><span class="p">;</span>
		<span class="n">ier</span> <span class="o">=</span> <span class="n">IER_RXHDL_IE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Set our current interrupt mask */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span>
    	
	<span class="cm">/* Restore BSR */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Make sure interrupt handlers keep the proper interrupt mask */</span>
	<span class="k">return</span> <span class="n">ier</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_hard_xmit (skb, dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    Transmit the frame!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">nsc_ircc_hard_xmit_sir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>
	
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;);</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		
	<span class="cm">/* Make sure tests *&amp; speed change are atomic */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	
	<span class="cm">/* Check if we need to change the speed */</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="n">irda_get_next_speed</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Check for empty frame. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we just sent a frame, we get called before</span>
<span class="cm">			 * the last bytes get out (because of the SIR FIFO).</span>
<span class="cm">			 * If this is the case, let interrupt handler change</span>
<span class="cm">			 * the speed itself... Jean II */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">IO_RECV</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span> 
				<span class="cm">/* TODO : For SIR-&gt;SIR, the next packet</span>
<span class="cm">				 * may get corrupted - Jean II */</span>
				<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
				<span class="cm">/* Queue will be restarted after speed change</span>
<span class="cm">				 * to make sure packets gets through the</span>
<span class="cm">				 * proper xmit handler - Jean II */</span>
			<span class="p">}</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
	
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">async_wrap_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> 
					   <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	
	<span class="cm">/* Add interrupt on tx low level (will fire immediately) */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IER_TXLDL_IE</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span>
	
	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">nsc_ircc_hard_xmit_fir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">__s32</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtt</span><span class="p">,</span> <span class="n">diff</span><span class="p">;</span>
	
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	
	<span class="cm">/* Make sure tests *&amp; speed change are atomic */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Check if we need to change the speed */</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="n">irda_get_next_speed</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Check for empty frame. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we are currently transmitting, defer to</span>
<span class="cm">			 * interrupt handler. - Jean II */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span> 
				<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
				<span class="cm">/* Keep queue stopped :</span>
<span class="cm">				 * the speed change operation may change the</span>
<span class="cm">				 * xmit handler, and we want to make sure</span>
<span class="cm">				 * the next packet get through the proper</span>
<span class="cm">				 * Tx path, so block the Tx queue until</span>
<span class="cm">				 * the speed change has been done.</span>
<span class="cm">				 * Jean II */</span>
			<span class="p">}</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Change speed after current frame */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Register and copy this frame to DMA memory */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">queue</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">queue</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">tail</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">queue</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span><span class="p">].</span><span class="n">start</span><span class="p">,</span>
		      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Start transmit only if there is currently no transmit going on */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if we must wait the min turn time or not */</span>
		<span class="n">mtt</span> <span class="o">=</span> <span class="n">irda_get_mtt</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Check how much time we have used already */</span>
			<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">);</span>
			<span class="n">diff</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> 
				<span class="n">diff</span> <span class="o">+=</span> <span class="mi">1000000</span><span class="p">;</span>
			
			<span class="cm">/* Check if the mtt is larger than the time we have</span>
<span class="cm">			 * already used by all the protocol processing</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtt</span> <span class="o">&gt;</span> <span class="n">diff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mtt</span> <span class="o">-=</span> <span class="n">diff</span><span class="p">;</span>

				<span class="cm">/* </span>
<span class="cm">				 * Use timer if delay larger than 125 us, and</span>
<span class="cm">				 * use udelay for smaller values which should</span>
<span class="cm">				 * be acceptable</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mtt</span> <span class="o">&gt;</span> <span class="mi">125</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Adjust for timer resolution */</span>
					<span class="n">mtt</span> <span class="o">=</span> <span class="n">mtt</span> <span class="o">/</span> <span class="mi">125</span><span class="p">;</span>
					
					<span class="cm">/* Setup timer */</span>
					<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK4</span><span class="p">);</span>
					<span class="n">outb</span><span class="p">(</span><span class="n">mtt</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">TMRL</span><span class="p">);</span>
					<span class="n">outb</span><span class="p">((</span><span class="n">mtt</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">TMRH</span><span class="p">);</span>
					
					<span class="cm">/* Start timer */</span>
					<span class="n">outb</span><span class="p">(</span><span class="n">IRCR1_TMR_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IRCR1</span><span class="p">);</span>
					<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">IO_XMIT</span><span class="p">;</span>
					
					<span class="cm">/* Enable timer interrupt */</span>
					<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
					<span class="n">outb</span><span class="p">(</span><span class="n">IER_TMR_IE</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span>
					
					<span class="cm">/* Timer will take care of the rest */</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span> 
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">udelay</span><span class="p">(</span><span class="n">mtt</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>		
		<span class="cm">/* Enable DMA interrupt */</span>
		<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">IER_DMA_IE</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span>

		<span class="cm">/* Transmit frame */</span>
		<span class="n">nsc_ircc_dma_xmit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="cm">/* Not busy transmitting anymore if window is not full,</span>
<span class="cm">	 * and if we don&#39;t need to change speed */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">MAX_TX_WINDOW</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_dma_xmit (self, iobase)</span>
<span class="cm"> *</span>
<span class="cm"> *    Transmit data using DMA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nsc_ircc_dma_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iobase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bsr</span><span class="p">;</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bsr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Disable DMA */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MCR_DMA_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span>
	
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">IO_XMIT</span><span class="p">;</span>
	
	<span class="cm">/* Choose transmit DMA channel  */</span> 
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK2</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">ECR1_DMASWP</span><span class="o">|</span><span class="n">ECR1_DMANF</span><span class="o">|</span><span class="n">ECR1_EXT_SL</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">ECR1</span><span class="p">);</span>
	
	<span class="n">irda_setup_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> 
		       <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">queue</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">ptr</span><span class="p">].</span><span class="n">start</span> <span class="o">-</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff_dma</span><span class="p">,</span>
		       <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">queue</span><span class="p">[</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">ptr</span><span class="p">].</span><span class="n">len</span><span class="p">,</span> 
		       <span class="n">DMA_TX_MODE</span><span class="p">);</span>

	<span class="cm">/* Enable DMA and SIR interaction pulse */</span>
 	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>	
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">)</span><span class="o">|</span><span class="n">MCR_TX_DFR</span><span class="o">|</span><span class="n">MCR_DMA_EN</span><span class="o">|</span><span class="n">MCR_IR_PLS</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span>

	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bsr</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_pio_xmit (self, iobase)</span>
<span class="cm"> *</span>
<span class="cm"> *    Transmit data using PIO. Returns the number of bytes that actually</span>
<span class="cm"> *    got transferred</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_pio_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fifo_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>
	
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inb_p</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LSR_TXEMP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), warning, FIFO not empty yet!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>

		<span class="cm">/* FIFO may still be filled to the Tx interrupt threshold */</span>
		<span class="n">fifo_size</span> <span class="o">-=</span> <span class="mi">17</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill FIFO with current frame */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">fifo_size</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">actual</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Transmit next byte */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">actual</span><span class="o">++</span><span class="p">],</span> <span class="n">iobase</span><span class="o">+</span><span class="n">TXD</span><span class="p">);</span>
	<span class="p">}</span>
        
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), fifo_size %d ; %d sent of %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		   <span class="n">__func__</span><span class="p">,</span> <span class="n">fifo_size</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	
	<span class="cm">/* Restore bank */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">actual</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_dma_xmit_complete (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    The transfer of a frame in finished. This function will only be called </span>
<span class="cm"> *    by the interrupt handler</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_dma_xmit_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Disable DMA */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
        <span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MCR_DMA_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span>
	
	<span class="cm">/* Check for underrun! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">ASCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ASCR_TXUR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
		
		<span class="cm">/* Clear bit, by writing 1 into it */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">ASCR_TXUR</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">ASCR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Finished with this frame, so prepare for next */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">len</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Any frames to be sent back-to-back? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nsc_ircc_dma_xmit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>
		
		<span class="cm">/* Not finished yet! */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reset Tx FIFO info */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure we have room for more frames and</span>
<span class="cm">	 * that we don&#39;t need to change speed */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">MAX_TX_WINDOW</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Not busy transmitting anymore */</span>
		<span class="cm">/* Tell the network layer, that we can accept more frames */</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Restore bank */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_dma_receive (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Get ready for receiving a frame. The device will initiate a DMA</span>
<span class="cm"> *    if it starts to receive a frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_dma_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bsr</span><span class="p">;</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="cm">/* Reset Tx FIFO info */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_fifo</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bsr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Disable DMA */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MCR_DMA_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span>

	<span class="cm">/* Choose DMA Rx, DMA Fairness, and Advanced mode */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK2</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">ECR1_DMANF</span><span class="o">|</span><span class="n">ECR1_EXT_SL</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">ECR1</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">IO_RECV</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	
	<span class="cm">/* Reset Rx FIFO. This will also flush the ST_FIFO */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">FCR_RXSR</span><span class="o">|</span><span class="n">FCR_FIFO_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">FCR</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">st_fifo</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">st_fifo</span><span class="p">.</span><span class="n">pending_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">st_fifo</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">st_fifo</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="n">irda_setup_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff_dma</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
		       <span class="n">DMA_RX_MODE</span><span class="p">);</span>

	<span class="cm">/* Enable DMA */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">)</span><span class="o">|</span><span class="n">MCR_DMA_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">MCR</span><span class="p">);</span>

	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bsr</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_dma_receive_complete (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Finished with receiving frames</span>
<span class="cm"> *</span>
<span class="cm"> *    </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_dma_receive_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iobase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">st_fifo</span> <span class="o">*</span><span class="n">st_fifo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">st_fifo</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">st_fifo</span><span class="p">;</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
	
	<span class="cm">/* Read all entries in status FIFO */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK5</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">FRM_ST</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">FRM_ST_VLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We must empty the status FIFO no matter what */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">RFLFL</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">RFLFH</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">&gt;=</span> <span class="n">MAX_RX_WINDOW</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), window is full!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
			
		<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
		<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">pending_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">++</span><span class="p">;</span>
		<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Try to process all entries in status FIFO */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get first entry */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">].</span><span class="n">status</span><span class="p">;</span>
		<span class="n">len</span>    <span class="o">=</span> <span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
		<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">pending_bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">++</span><span class="p">;</span>
		<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* Check for errors */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FRM_ST_ERR_MSK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FRM_ST_LOST_FR</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Add number of lost frames to stats */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Skip frame */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
				
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FRM_ST_MAX_LEN</span><span class="p">)</span>
					<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
				
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FRM_ST_PHY_ERR</span><span class="p">)</span> 
					<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
				
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FRM_ST_BAD_CRC</span><span class="p">)</span> 
					<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* The errors below can be reported in both cases */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FRM_ST_OVR1</span><span class="p">)</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">FRM_ST_OVR2</span><span class="p">)</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*  </span>
<span class="cm">			 * First we must make sure that the frame we</span>
<span class="cm">			 * want to deliver is all in main memory. If we</span>
<span class="cm">			 * cannot tell, then we check if the Rx FIFO is</span>
<span class="cm">			 * empty. If not then we will have to take a nap</span>
<span class="cm">			 * and try again later.  </span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">pending_bytes</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fifo_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LSR_RXDA</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Put this entry back in fifo */</span>
					<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">--</span><span class="p">;</span>
					<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
					<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">pending_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
					<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
					<span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">st_fifo</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
					<span class="cm">/*  </span>
<span class="cm">					 * DMA not finished yet, so try again </span>
<span class="cm">					 * later, set timer value, resolution </span>
<span class="cm">					 * 125 us </span>
<span class="cm">					 */</span>
					<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK4</span><span class="p">);</span>
					<span class="n">outb</span><span class="p">(</span><span class="mh">0x02</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">TMRL</span><span class="p">);</span> <span class="cm">/* x 125 us */</span>
					<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">TMRH</span><span class="p">);</span>

					<span class="cm">/* Start timer */</span>
					<span class="n">outb</span><span class="p">(</span><span class="n">IRCR1_TMR_EN</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IRCR1</span><span class="p">);</span>

					<span class="cm">/* Restore bank register */</span>
					<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
					
					<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span> <span class="cm">/* I&#39;ll be back! */</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/* </span>
<span class="cm">			 * Remember the time we received this frame, so we can</span>
<span class="cm">			 * reduce the min turn time a bit since we will know</span>
<span class="cm">			 * how much time we have used for protocol processing</span>
<span class="cm">			 */</span>
			<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">);</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>  <span class="p">{</span>
				<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), memory squeeze, &quot;</span>
					     <span class="s">&quot;dropping frame.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">__func__</span><span class="p">);</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/* Restore bank register */</span>
				<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="p">}</span>
			
			<span class="cm">/* Make sure IP header gets aligned */</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 

			<span class="cm">/* Copy frame without CRC */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mi">4000000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
				<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
							<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
							<span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
				<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
							<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
							<span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Move to next frame */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>

			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
			<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IRDA</span><span class="p">);</span>
			<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_pio_receive (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Receive all data in receiver FIFO</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nsc_ircc_pio_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">__u8</span> <span class="n">byte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>
	
	<span class="cm">/*  Receive all characters in Rx FIFO */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">RXD</span><span class="p">);</span>
		<span class="n">async_unwrap_char</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">,</span> <span class="n">byte</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LSR_RXDA</span><span class="p">);</span> <span class="cm">/* Data available */</span>	
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_sir_interrupt (self, eir)</span>
<span class="cm"> *</span>
<span class="cm"> *    Handle SIR interrupt</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nsc_ircc_sir_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual</span><span class="p">;</span>

	<span class="cm">/* Check if transmit FIFO is low on data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eir</span> <span class="o">&amp;</span> <span class="n">EIR_TXLDL_EV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Write data left in transmit buffer */</span>
		<span class="n">actual</span> <span class="o">=</span> <span class="n">nsc_ircc_pio_write</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> 
					   <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> 
					   <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> 
					   <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fifo_size</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">actual</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span>  <span class="o">-=</span> <span class="n">actual</span><span class="p">;</span>
		
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">IO_XMIT</span><span class="p">;</span>

		<span class="cm">/* Check if finished */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_TXLDL_IE</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span> 

			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_TXEMP_IE</span><span class="p">;</span>
		<span class="p">}</span>
			
	<span class="p">}</span>
	<span class="cm">/* Check if transmission has completed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eir</span> <span class="o">&amp;</span> <span class="n">EIR_TXEMP_EV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Turn around and get ready to receive some data */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">IO_RECV</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_RXHDL_IE</span><span class="p">;</span>
		<span class="cm">/* Check if we need to change the speed?</span>
<span class="cm">		 * Need to be after self-&gt;io.direction to avoid race with</span>
<span class="cm">		 * nsc_ircc_hard_xmit_sir() - Jean II */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), Changing speed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">nsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span>
							  <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

			<span class="cm">/* Check if we are going to FIR */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">115200</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* No need to do anymore SIR stuff */</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Rx FIFO threshold or timeout */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eir</span> <span class="o">&amp;</span> <span class="n">EIR_RXHDL_EV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nsc_ircc_pio_receive</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="cm">/* Keep receiving */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_RXHDL_IE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_fir_interrupt (self, eir)</span>
<span class="cm"> *</span>
<span class="cm"> *    Handle MIR/FIR interrupt</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nsc_ircc_fir_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> 
				   <span class="kt">int</span> <span class="n">eir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>

	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
	
	<span class="cm">/* Status FIFO event*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eir</span> <span class="o">&amp;</span> <span class="n">EIR_SFIF_EV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check if DMA has finished */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsc_ircc_dma_receive_complete</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">iobase</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Wait for next status FIFO interrupt */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_SFIF_IE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_SFIF_IE</span> <span class="o">|</span> <span class="n">IER_TMR_IE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eir</span> <span class="o">&amp;</span> <span class="n">EIR_TMR_EV</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Timer finished */</span>
		<span class="cm">/* Disable timer */</span>
		<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK4</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IRCR1</span><span class="p">);</span>

		<span class="cm">/* Clear timer event */</span>
		<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">ASCR_CTE</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">ASCR</span><span class="p">);</span>

		<span class="cm">/* Check if this is a Tx timer interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">IO_XMIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nsc_ircc_dma_xmit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>

			<span class="cm">/* Interrupt on DMA */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_DMA_IE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Check (again) if DMA has finished */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nsc_ircc_dma_receive_complete</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">iobase</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_SFIF_IE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_SFIF_IE</span> <span class="o">|</span> <span class="n">IER_TMR_IE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eir</span> <span class="o">&amp;</span> <span class="n">EIR_DMA_EV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Finished with all transmissions? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsc_ircc_dma_xmit_complete</span><span class="p">(</span><span class="n">self</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* As we stop the Tx queue, the speed change</span>
<span class="cm">				 * need to be done when the Tx fifo is</span>
<span class="cm">				 * empty. Ask for a Tx done interrupt */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_TXEMP_IE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Check if there are more frames to be</span>
<span class="cm">				 * transmitted */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">irda_device_txqueue_empty</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Prepare for receive */</span>
					<span class="n">nsc_ircc_dma_receive</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
					<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_SFIF_IE</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), potential &quot;</span>
						     <span class="s">&quot;Tx queue lockup !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">__func__</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*  Not finished yet, so interrupt on DMA again */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">IER_DMA_IE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eir</span> <span class="o">&amp;</span> <span class="n">EIR_TXEMP_EV</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The Tx FIFO has totally drained out, so now we can change</span>
<span class="cm">		 * the speed... - Jean II */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">nsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="cm">/* Note : nsc_ircc_change_speed() restarted Rx fifo */</span>
	<span class="p">}</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_interrupt (irq, dev_id, regs)</span>
<span class="cm"> *</span>
<span class="cm"> *    An interrupt from the chip has arrived. Time to do some work</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">nsc_ircc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bsr</span><span class="p">,</span> <span class="n">eir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>	

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">bsr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span> 	<span class="cm">/* Save current bank */</span>

	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>	
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span> 
	<span class="n">eir</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">EIR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">;</span> <span class="cm">/* Mask out the interesting ones */</span> 

	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span> <span class="cm">/* Disable interrupts */</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">eir</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Dispatch interrupt handler for the current speed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">115200</span><span class="p">)</span>
			<span class="n">nsc_ircc_fir_interrupt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">iobase</span><span class="p">,</span> <span class="n">eir</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">nsc_ircc_sir_interrupt</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">eir</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">outb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">ier</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span> <span class="cm">/* Restore interrupts */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bsr</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>       <span class="cm">/* Restore bank register */</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">eir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_is_receiving (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Return TRUE is we are currently receiving a frame</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_is_receiving</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="n">FALSE</span><span class="p">;);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">115200</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

		<span class="cm">/* Check if rx FIFO is not empty */</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
		<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">RXFLV</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We are receiving something */</span>
			<span class="n">status</span> <span class="o">=</span>  <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> 
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">OUTSIDE_FRAME</span><span class="p">);</span>
	
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_net_open (dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    Start the device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">hwname</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>
	
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>
	
	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">nsc_ircc_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s, unable to allocate irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">driver_name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always allocate the DMA channel after the IRQ, and clean up on </span>
<span class="cm">	 * failure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s, unable to allocate dma=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">driver_name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>
	
	<span class="cm">/* turn on interrupts */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IER_LS_IE</span> <span class="o">|</span> <span class="n">IER_RXHDL_IE</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span>

	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Ready to play! */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	
	<span class="cm">/* Give self a hardware name */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">hwname</span><span class="p">,</span> <span class="s">&quot;NSC-FIR @ 0x%03x&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Open new IrLAP layer instance, now that everything should be</span>
<span class="cm">	 * initialized properly </span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="n">irlap_open</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">,</span> <span class="n">hwname</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_net_close (dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    Stop the device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">bank</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

	<span class="cm">/* Stop device */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	
	<span class="cm">/* Stop and remove instance of IrLAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">)</span>
		<span class="n">irlap_close</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">disable_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>

	<span class="cm">/* Save current bank */</span>
	<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="cm">/* Disable interrupts */</span>
	<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span> 
       
	<span class="n">free_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">free_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>

	<span class="cm">/* Restore bank register */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function nsc_ircc_net_ioctl (dev, rq, cmd)</span>
<span class="cm"> *</span>
<span class="cm"> *    Process IOCTL commands for this device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">if_irda_req</span> <span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">if_irda_req</span> <span class="o">*</span><span class="p">)</span> <span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), %s, (cmd=0x%X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCSBANDWIDTH</span>: <span class="cm">/* Set bandwidth */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">nsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">irq</span><span class="o">-&gt;</span><span class="n">ifr_baudrate</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCSMEDIABUSY</span>: <span class="cm">/* Set media busy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">irda_device_set_media_busy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCGRECEIVING</span>: <span class="cm">/* Check if we are receiving right now */</span>
		<span class="cm">/* This is already protected */</span>
		<span class="n">irq</span><span class="o">-&gt;</span><span class="n">ifr_receiving</span> <span class="o">=</span> <span class="n">nsc_ircc_is_receiving</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
     	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 	<span class="kt">int</span> <span class="n">bank</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
 	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s, Suspending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Save current bank */</span>
		<span class="n">bank</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

		<span class="cm">/* Disable interrupts */</span>
		<span class="n">switch_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">BANK0</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">IER</span><span class="p">);</span>

		<span class="cm">/* Restore bank register */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">bank</span><span class="p">,</span> <span class="n">iobase</span><span class="o">+</span><span class="n">BSR</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">disable_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nsc_ircc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
 	<span class="k">struct</span> <span class="n">nsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s, Waking up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">nsc_ircc_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">);</span>
	<span class="n">nsc_ircc_init_dongle_interface</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dongle_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">nsc_ircc_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
 		    	<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s, unable to allocate irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">driver_name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Don&#39;t fail resume process, just kill this</span>
<span class="cm">			 * network interface</span>
<span class="cm">			 */</span>
			<span class="n">unregister_netdevice</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">nsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">nsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">9600</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

 	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Dag Brattli &lt;dagb@cs.uit.no&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;NSC IrDA Device Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>


<span class="n">module_param</span><span class="p">(</span><span class="n">qos_mtt_bits</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">qos_mtt_bits</span><span class="p">,</span> <span class="s">&quot;Minimum Turn Time&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;Base I/O addresses&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="s">&quot;IRQ lines&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="s">&quot;DMA channels&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">dongle_id</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">dongle_id</span><span class="p">,</span> <span class="s">&quot;Type-id of used dongle&quot;</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">nsc_ircc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">nsc_ircc_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
