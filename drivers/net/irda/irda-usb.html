<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › irda › irda-usb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>irda-usb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*****************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Filename:      irda-usb.c</span>
<span class="cm"> * Version:       0.10</span>
<span class="cm"> * Description:   IrDA-USB Driver</span>
<span class="cm"> * Status:        Experimental </span>
<span class="cm"> * Author:        Dag Brattli &lt;dag@brattli.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Copyright (C) 2000, Roman Weissgaerber &lt;weissg@vienna.at&gt;</span>
<span class="cm"> *      Copyright (C) 2001, Dag Brattli &lt;dag@brattli.net&gt;</span>
<span class="cm"> *      Copyright (C) 2001, Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm"> *      Copyright (C) 2004, SigmaTel, Inc. &lt;irquality@sigmatel.com&gt;</span>
<span class="cm"> *      Copyright (C) 2005, Milan Beno &lt;beno@pobox.sk&gt;</span>
<span class="cm"> *      Copyright (C) 2006, Nick Fedchik &lt;nick@fedchik.org.ua&gt;</span>
<span class="cm"> *          </span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *	but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *	GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *	You should have received a copy of the GNU General Public License</span>
<span class="cm"> *	along with this program; if not, write to the Free Software</span>
<span class="cm"> *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> *			    IMPORTANT NOTE</span>
<span class="cm"> *			    --------------</span>
<span class="cm"> *</span>
<span class="cm"> * As of kernel 2.5.20, this is the state of compliance and testing of</span>
<span class="cm"> * this driver (irda-usb) with regards to the USB low level drivers...</span>
<span class="cm"> *</span>
<span class="cm"> * This driver has been tested SUCCESSFULLY with the following drivers :</span>
<span class="cm"> *	o usb-uhci-hcd	(For Intel/Via USB controllers)</span>
<span class="cm"> *	o uhci-hcd	(Alternate/JE driver for Intel/Via USB controllers)</span>
<span class="cm"> *	o ohci-hcd	(For other USB controllers)</span>
<span class="cm"> *</span>
<span class="cm"> * This driver has NOT been tested with the following drivers :</span>
<span class="cm"> *	o ehci-hcd	(USB 2.0 controllers)</span>
<span class="cm"> *</span>
<span class="cm"> * Note that all HCD drivers do URB_ZERO_PACKET and timeout properly,</span>
<span class="cm"> * so we don&#39;t have to worry about that anymore.</span>
<span class="cm"> * One common problem is the failure to set the address on the dongle,</span>
<span class="cm"> * but this happens before the driver gets loaded...</span>
<span class="cm"> *</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>

<span class="cm">/*------------------------------------------------------------------*/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>

<span class="cp">#include &quot;irda-usb.h&quot;</span>

<span class="cm">/*------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">qos_mtt_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* These are the currently known IrDA USB dongles. Add new dongles here */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">dongles</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* ACTiSYS Corp.,  ACT-IR2000U FIR-USB Adapter */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x9c4</span><span class="p">,</span> <span class="mh">0x011</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">IUC_SPEED_BUG</span> <span class="o">|</span> <span class="n">IUC_NO_WINDOW</span> <span class="p">},</span>
	<span class="cm">/* Look like ACTiSYS, Report : IBM Corp., IBM UltraPort IrDA */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x4428</span><span class="p">,</span> <span class="mh">0x012</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">IUC_SPEED_BUG</span> <span class="o">|</span> <span class="n">IUC_NO_WINDOW</span> <span class="p">},</span>
	<span class="cm">/* KC Technology Inc.,  KC-180 USB IrDA Device */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x50f</span><span class="p">,</span> <span class="mh">0x180</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">IUC_SPEED_BUG</span> <span class="o">|</span> <span class="n">IUC_NO_WINDOW</span> <span class="p">},</span>
	<span class="cm">/* Extended Systems, Inc.,  XTNDAccess IrDA USB (ESI-9685) */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x8e9</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">IUC_SPEED_BUG</span> <span class="o">|</span> <span class="n">IUC_NO_WINDOW</span> <span class="p">},</span>
	<span class="cm">/* SigmaTel STIR4210/4220/4116 USB IrDA (VFIR) Bridge */</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x66f</span><span class="p">,</span> <span class="mh">0x4210</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">IUC_STIR421X</span> <span class="o">|</span> <span class="n">IUC_SPEED_BUG</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x66f</span><span class="p">,</span> <span class="mh">0x4220</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">IUC_STIR421X</span> <span class="o">|</span> <span class="n">IUC_SPEED_BUG</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x66f</span><span class="p">,</span> <span class="mh">0x4116</span><span class="p">),</span> <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">IUC_STIR421X</span> <span class="o">|</span> <span class="n">IUC_SPEED_BUG</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">match_flags</span> <span class="o">=</span> <span class="n">USB_DEVICE_ID_MATCH_INT_CLASS</span> <span class="o">|</span>
	  <span class="n">USB_DEVICE_ID_MATCH_INT_SUBCLASS</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">bInterfaceClass</span> <span class="o">=</span> <span class="n">USB_CLASS_APP_SPEC</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">bInterfaceSubClass</span> <span class="o">=</span> <span class="n">USB_CLASS_IRDA</span><span class="p">,</span>
	  <span class="p">.</span><span class="n">driver_info</span> <span class="o">=</span> <span class="n">IUC_DEFAULT</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span> <span class="cm">/* The end */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Important note :</span>
<span class="cm"> * Devices based on the SigmaTel chipset (0x66f, 0x4200) are not designed</span>
<span class="cm"> * using the &quot;USB-IrDA specification&quot; (yes, there exist such a thing), and</span>
<span class="cm"> * therefore not supported by this driver (don&#39;t add them above).</span>
<span class="cm"> * There is a Linux driver, stir4200, that support those USB devices.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">dongles</span><span class="p">);</span>

<span class="cm">/*------------------------------------------------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_usb_init_qos</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span> <span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">irda_class_desc</span> <span class="o">*</span><span class="n">irda_usb_find_class_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irda_usb_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irda_usb_change_speed_xbofs</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">irda_usb_hard_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irda_usb_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irda_usb_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">speed_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">write_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irda_usb_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irda_usb_rx_defer_expired</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irda_usb_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irda_usb_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">irda_usb_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">irda_usb_net_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/************************ TRANSMIT ROUTINES ************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Receive packets from the IrDA stack and send them on the USB pipe.</span>
<span class="cm"> * Handle speed change, timeout and lot&#39;s of ugliness...</span>
<span class="cm"> */</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Function irda_usb_build_header(self, skb, header)</span>
<span class="cm"> *</span>
<span class="cm"> *   Builds USB-IrDA outbound header</span>
<span class="cm"> *</span>
<span class="cm"> * When we send an IrDA frame over an USB pipe, we add to it a 1 byte</span>
<span class="cm"> * header. This function create this header with the proper values.</span>
<span class="cm"> *</span>
<span class="cm"> * Important note : the USB-IrDA spec 1.0 say very clearly in chapter 5.4.2.2</span>
<span class="cm"> * that the setting of the link speed and xbof number in this outbound header</span>
<span class="cm"> * should be applied *AFTER* the frame has been sent.</span>
<span class="cm"> * Unfortunately, some devices are not compliant with that... It seems that</span>
<span class="cm"> * reading the spec is far too difficult...</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_usb_build_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				  <span class="n">__u8</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span>
				  <span class="kt">int</span>	<span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Here we check if we have an STIR421x chip,</span>
<span class="cm">	 * and if either speed or xbofs (or both) needs</span>
<span class="cm">	 * to be changed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_STIR421X</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/* With STIR421x, speed and xBOFs must be set at the same</span>
<span class="cm">		 * time, even if only one of them changes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">xbofs</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the link speed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Hum... Ugly hack :-(</span>
<span class="cm">		 * Some device are not compliant with the spec and change</span>
<span class="cm">		 * parameters *before* sending the frame. - Jean II</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_SPEED_BUG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">force</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* No speed and xbofs change here</span>
<span class="cm">			 * (we&#39;ll do it later in the write callback) */</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), not changing speed yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), changing speed to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">;</span>
		<span class="cm">/* We will do ` self-&gt;new_speed = -1; &#39; in the completion</span>
<span class="cm">		 * handler just in case the current URB fail - Jean II */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">2400</span>:
		        <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_2400</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
		<span class="k">case</span> <span class="mi">9600</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_9600</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">19200</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_19200</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">38400</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_38400</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">57600</span>:
		        <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_57600</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">115200</span>:
		        <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_115200</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">576000</span>:
		        <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_576000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1152000</span>:
		        <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_1152000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4000000</span>:
		        <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_4000000</span><span class="p">;</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">16000000</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">SPEED_16000000</span><span class="p">;</span>
  			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  			<span class="k">break</span><span class="p">;</span>
  		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* No change */</span>
		<span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="cm">/* Set the negotiated additional XBOFS */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), changing xbofs to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">xbofs</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span><span class="p">;</span>
		<span class="cm">/* We will do ` self-&gt;new_xbofs = -1; &#39; in the completion</span>
<span class="cm">		 * handler just in case the current URB fail - Jean II */</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">xbofs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">48</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">28</span>:
		<span class="k">case</span> <span class="mi">24</span>:	<span class="cm">/* USB spec 1.0 says 24 */</span>
			<span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x20</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
		<span class="k">case</span> <span class="mi">12</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x30</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">5</span>: <span class="cm">/* Bug in IrLAP spec? (should be 6) */</span>
		<span class="k">case</span> <span class="mi">6</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x40</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x50</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x60</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x70</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="o">*</span><span class="n">header</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">*   calculate turnaround time for SigmaTel header</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">__u8</span> <span class="nf">get_turnaround_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">turnaround_time</span> <span class="o">=</span> <span class="n">irda_get_mtt</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">turnaround_time</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">turnaround_time</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">turnaround_time</span> <span class="o">&lt;=</span> <span class="mi">50</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">turnaround_time</span> <span class="o">&lt;=</span> <span class="mi">100</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">turnaround_time</span> <span class="o">&lt;=</span> <span class="mi">500</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">turnaround_time</span> <span class="o">&lt;=</span> <span class="mi">1000</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">turnaround_time</span> <span class="o">&lt;=</span> <span class="mi">5000</span> <span class="p">)</span>
		<span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Send a command to change the speed of the dongle</span>
<span class="cm"> * Need to be called with spinlock on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_usb_change_speed_xbofs</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), speed=%d, xbofs=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span><span class="p">);</span>

	<span class="cm">/* Grab the speed URB */</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), URB still in use!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate the fake frame */</span>
	<span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_buff</span><span class="p">;</span>

	<span class="cm">/* Set the new speed and xbofs in this fake frame */</span>
	<span class="n">irda_usb_build_header</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_STIR421X</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span> <span class="c1">// do nothing if no change</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// other parameters don&#39;t change here</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Submit the 0 length IrDA frame to trigger new speed settings */</span>
        <span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span>
		      <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_ep</span><span class="p">),</span>
                      <span class="n">frame</span><span class="p">,</span> <span class="n">IRDA_USB_SPEED_MTU</span><span class="p">,</span>
                      <span class="n">speed_bulk_callback</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Irq disabled -&gt; GFP_ATOMIC */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), failed Speed URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Speed URB callback</span>
<span class="cm"> * Now, we can only get called for the speed URB.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">speed_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* We should always have a context */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="cm">/* We should always be called for the speed URB */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Check for timeout and other USB nasties */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* I get a lot of -ECONNABORTED = -103 here - Jean II */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), URB complete status %d, transfer_flags 0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">);</span>

		<span class="cm">/* Don&#39;t do anything here, that might confuse the USB layer.</span>
<span class="cm">		 * Instead, we will wait for irda_usb_net_timeout(), the</span>
<span class="cm">		 * network layer watchdog, to fix the situation.</span>
<span class="cm">		 * Jean II */</span>
		<span class="cm">/* A reset of the dongle might be welcomed here - Jean II */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* urb is now available */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>urb->status = 0; -> tested above</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* New speed and xbof is now committed in hardware */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Allow the stack to send more packets */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Send an IrDA frame to the USB dongle (for transmission)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">irda_usb_hard_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">s16</span> <span class="n">xbofs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">,</span> <span class="n">mtt</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s() on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Protect us from USB callbacks, net watchdog and else. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Check if the device is still there.</span>
<span class="cm">	 * We need to check self-&gt;present under the spinlock because</span>
<span class="cm">	 * of irda_usb_disconnect() is synchronous - Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Device is gone...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if we need to change the number of xbofs */</span>
        <span class="n">xbofs</span> <span class="o">=</span> <span class="n">irda_get_next_xbofs</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">xbofs</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">xbofs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">xbofs</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">=</span> <span class="n">xbofs</span><span class="p">;</span>
	<span class="p">}</span>

        <span class="cm">/* Check if we need to change the speed */</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="n">irda_get_next_speed</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Set the desired speed */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>

		<span class="cm">/* Check for empty frame */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* IrLAP send us an empty frame to make us change the</span>
<span class="cm">			 * speed. Changing speed with the USB adapter is in</span>
<span class="cm">			 * fact sending an empty frame to the adapter, so we</span>
<span class="cm">			 * could just let the present function do its job.</span>
<span class="cm">			 * However, we would wait for min turn time,</span>
<span class="cm">			 * do an extra memcpy and increment packet counters...</span>
<span class="cm">			 * Jean II */</span>
			<span class="n">irda_usb_change_speed_xbofs</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="cm">/* Will netif_wake_queue() in callback */</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), URB still in use!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Change setting for next frame */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_STIR421X</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__u8</span> <span class="n">turnaround_time</span><span class="p">;</span>
		<span class="n">__u8</span><span class="o">*</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">;</span>
		<span class="n">turnaround_time</span> <span class="o">=</span> <span class="n">get_turnaround_time</span><span class="p">(</span> <span class="n">skb</span> <span class="p">);</span>
		<span class="n">irda_usb_build_header</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">frame</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">turnaround_time</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">%</span> <span class="mi">128</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">%</span> <span class="mi">512</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* add extra byte for special SigmaTel feature */</span>
			<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">irda_usb_build_header</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME: Make macro out of this one */</span>
	<span class="p">((</span><span class="k">struct</span> <span class="n">irda_skb_cb</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>

	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span>
		      <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_ep</span><span class="p">),</span>
                      <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">,</span>
                      <span class="n">write_bulk_callback</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* This flag (URB_ZERO_PACKET) indicates that what we send is not</span>
<span class="cm">	 * a continuous stream of data but separate packets.</span>
<span class="cm">	 * In this case, the USB layer will insert an empty USB frame (TD)</span>
<span class="cm">	 * after each of our packets that is exact multiple of the frame size.</span>
<span class="cm">	 * This is how the dongle will detect the end of packet - Jean II */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">=</span> <span class="n">URB_ZERO_PACKET</span><span class="p">;</span>

	<span class="cm">/* Generate min turn time. FIXME: can we do better than this? */</span>
	<span class="cm">/* Trying to a turnaround time at this level is trying to measure</span>
<span class="cm">	 * processor clock cycle with a wrist-watch, approximate at best...</span>
<span class="cm">	 *</span>
<span class="cm">	 * What we know is the last time we received a frame over USB.</span>
<span class="cm">	 * Due to latency over USB that depend on the USB load, we don&#39;t</span>
<span class="cm">	 * know when this frame was received over IrDA (a few ms before ?)</span>
<span class="cm">	 * Then, same story for our outgoing frame...</span>
<span class="cm">	 *</span>
<span class="cm">	 * In theory, the USB dongle is supposed to handle the turnaround</span>
<span class="cm">	 * by itself (spec 1.0, chater 4, page 6). Who knows ??? That&#39;s</span>
<span class="cm">	 * why this code is enabled only for dongles that doesn&#39;t meet</span>
<span class="cm">	 * the spec.</span>
<span class="cm">	 * Jean II */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_NO_TURN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mtt</span> <span class="o">=</span> <span class="n">irda_get_mtt</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtt</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">diff</span><span class="p">;</span>
			<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">);</span>
			<span class="n">diff</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
<span class="cp">#ifdef IU_USB_MIN_RTT</span>
			<span class="cm">/* Factor in USB delays -&gt; Get rid of udelay() that</span>
<span class="cm">			 * would be lost in the noise - Jean II */</span>
			<span class="n">diff</span> <span class="o">+=</span> <span class="n">IU_USB_MIN_RTT</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IU_USB_MIN_RTT */</span><span class="cp"></span>
			<span class="cm">/* If the usec counter did wraparound, the diff will</span>
<span class="cm">			 * go negative (tv_usec is a long), so we need to</span>
<span class="cm">			 * correct it by one second. Jean II */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">diff</span> <span class="o">+=</span> <span class="mi">1000000</span><span class="p">;</span>

		        <span class="cm">/* Check if the mtt is larger than the time we have</span>
<span class="cm">			 * already used by all the protocol processing</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mtt</span> <span class="o">&gt;</span> <span class="n">diff</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mtt</span> <span class="o">-=</span> <span class="n">diff</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mtt</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">)</span>
					<span class="n">mdelay</span><span class="p">(</span><span class="n">mtt</span><span class="o">/</span><span class="mi">1000</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">udelay</span><span class="p">(</span><span class="n">mtt</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="cm">/* Ask USB to send the packet - Irq disabled -&gt; GFP_ATOMIC */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), failed Tx URB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Let USB recover : We will catch that in the watchdog */</span>
		<span class="cm">/*netif_start_queue(netdev);*/</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Increment packet stats */</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
                <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

<span class="nl">drop:</span>
	<span class="cm">/* Drop silently the skb and exit */</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Note : this function will be called only for tx_urb...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_bulk_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">irda_skb_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* We should always have a context */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="cm">/* We should always be called for the speed URB */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">urb</span> <span class="o">==</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Free up the skb */</span>
	<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check for timeout and other USB nasties */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* I get a lot of -ECONNABORTED = -103 here - Jean II */</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), URB complete status %d, transfer_flags 0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">);</span>

		<span class="cm">/* Don&#39;t do anything here, that might confuse the USB layer,</span>
<span class="cm">		 * and we could go in recursion and blow the kernel stack...</span>
<span class="cm">		 * Instead, we will wait for irda_usb_net_timeout(), the</span>
<span class="cm">		 * network layer watchdog, to fix the situation.</span>
<span class="cm">		 * Jean II */</span>
		<span class="cm">/* A reset of the dongle might be welcomed here - Jean II */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* urb is now available */</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>urb->status = 0; -> tested above</p></td><td class="code"><div class="highlight"><pre>	<span class="cm">/* Make sure we read self-&gt;present properly */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* If the network is closed, stop everything */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netopen</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Network is gone...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If changes to speed or xbofs is pending... */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">xbofs</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* We haven&#39;t changed speed yet (because of</span>
<span class="cm">			 * IUC_SPEED_BUG), so do it now - Jean II */</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), Changing speed now...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">irda_usb_change_speed_xbofs</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* New speed and xbof is now committed in hardware */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Done, waiting for next packet */</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Otherwise, allow the stack to send more packets */</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Watchdog timer from the network layer.</span>
<span class="cm"> * After a predetermined timeout, if we don&#39;t give confirmation that</span>
<span class="cm"> * the packet has been sent (i.e. no call to netif_wake_queue()),</span>
<span class="cm"> * the network layer will call this function.</span>
<span class="cm"> * Note that URB that we submit have also a timeout. When the URB timeout</span>
<span class="cm"> * expire, the normal URB callback is called (write_bulk_callback()).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_usb_net_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* If we have made any progress */</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Network layer thinks we timed out!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Protect us from USB callbacks, net Tx and else. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* self-&gt;present *MUST* be read under spinlock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), device not present!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check speed URB */</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: Speed change timed out, urb-&gt;status=%d, urb-&gt;transfer_flags=0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
			<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
			<span class="cm">/* Note : above will  *NOT* call netif_wake_queue()</span>
<span class="cm">			 * in completion handler, we will come back here.</span>
<span class="cm">			 * Jean II */</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:			<span class="cm">/* urb unlinked by us */</span>
		<span class="nl">default:</span>			<span class="cm">/* ??? - Play safe */</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check Tx URB */</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s: Tx timed out, urb-&gt;status=%d, urb-&gt;transfer_flags=0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">);</span>

		<span class="cm">/* Increase error count */</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#ifdef IU_BUG_KICK_TIMEOUT</span>
		<span class="cm">/* Can&#39;t be a bad idea to reset the speed ;-) - Jean II */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">xbofs</span><span class="p">;</span>
		<span class="n">irda_usb_change_speed_xbofs</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* IU_BUG_KICK_TIMEOUT */</span><span class="cp"></span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EINPROGRESS</span>:
			<span class="n">usb_unlink_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
			<span class="cm">/* Note : above will  *NOT* call netif_wake_queue()</span>
<span class="cm">			 * in completion handler, because urb-&gt;status will</span>
<span class="cm">			 * be -ENOENT. We will fix that at the next watchdog,</span>
<span class="cm">			 * leaving more time to USB to recover...</span>
<span class="cm">			 * Jean II */</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:			<span class="cm">/* urb unlinked by us */</span>
		<span class="nl">default:</span>			<span class="cm">/* ??? - Play safe */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Maybe we need a reset */</span>
	<span class="cm">/* Note : Some drivers seem to use a usb_set_interface() when they</span>
<span class="cm">	 * need to reset the hardware. Hum...</span>
<span class="cm">	 */</span>

	<span class="cm">/* if(done == 0) */</span>
<span class="p">}</span>

<span class="cm">/************************* RECEIVE ROUTINES *************************/</span>
<span class="cm">/*</span>
<span class="cm"> * Receive packets from the USB layer stack and pass them to the IrDA stack.</span>
<span class="cm"> * Try to work around USB failures...</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Note :</span>
<span class="cm"> * Some of you may have noticed that most dongle have an interrupt in pipe</span>
<span class="cm"> * that we don&#39;t use. Here is the little secret...</span>
<span class="cm"> * When we hang a Rx URB on the bulk in pipe, it generates some USB traffic</span>
<span class="cm"> * in every USB frame. This is unnecessary overhead.</span>
<span class="cm"> * The interrupt in pipe will generate an event every time a packet is</span>
<span class="cm"> * received. Reading an interrupt pipe adds minimal overhead, but has some</span>
<span class="cm"> * latency (~1ms).</span>
<span class="cm"> * If we are connected (speed != 9600), we want to minimise latency, so</span>
<span class="cm"> * we just always hang the Rx URB and ignore the interrupt.</span>
<span class="cm"> * If we are not connected (speed == 9600), there is usually no Rx traffic,</span>
<span class="cm"> * and we want to minimise the USB overhead. In this case we should wait</span>
<span class="cm"> * on the interrupt pipe and hang the Rx URB only when an interrupt is</span>
<span class="cm"> * received.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> *</span>
<span class="cm"> * Note : don&#39;t read the above as what we are currently doing, but as</span>
<span class="cm"> * something we could do with KC dongle. Also don&#39;t forget that the</span>
<span class="cm"> * interrupt pipe is not part of the original standard, so this would</span>
<span class="cm"> * need to be optional...</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Submit a Rx URB to the USB layer to handle reception of a frame</span>
<span class="cm"> * Mostly called by the completion callback of the previous URB.</span>
<span class="cm"> *</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_usb_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_skb_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* This should never happen */</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">urb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Save ourselves in the skb */</span>
	<span class="n">cb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irda_skb_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>

	<span class="cm">/* Reinitialize URB */</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> 
		      <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_in_ep</span><span class="p">),</span> 
		      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">IRDA_SKB_MAX_MTU</span><span class="p">,</span>
                      <span class="n">irda_usb_receive</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Can be called from irda_usb_receive (irq handler) -&gt; GFP_ATOMIC */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If this ever happen, we are in deep s***.</span>
<span class="cm">		 * Basically, the Rx path will stop... */</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), Failed to submit Rx URB %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Function irda_usb_receive(urb)</span>
<span class="cm"> *</span>
<span class="cm"> *     Called by the USB subsystem when a frame has been received</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_usb_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span> 
	<span class="k">struct</span> <span class="n">irda_skb_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newskb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">dataskb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">next_urb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">docopy</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
	
	<span class="cm">/* Find ourselves */</span>
	<span class="n">cb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irda_skb_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">cb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* If the network is closed or the device gone, stop everything */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netopen</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Network is gone!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* Don&#39;t re-submit the URB : will stall the Rx path */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/* Check the status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EILSEQ</span>:
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* Also precursor to a hot-unplug on UHCI. */</span>
			<span class="cm">/* Fallthrough... */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ECONNRESET</span>:
			<span class="cm">/* Random error, if I remember correctly */</span>
			<span class="cm">/* uhci_cleanup_unlink() is going to kill the Rx</span>
<span class="cm">			 * URB just after we return. No problem, at this</span>
<span class="cm">			 * point the URB will be idle ;-) - Jean II */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ESHUTDOWN</span>:
			<span class="cm">/* That&#39;s usually a hot-unplug. Submit will fail... */</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ETIME</span>:
			<span class="cm">/* Usually precursor to a hot-unplug on OHCI. */</span>
		<span class="nl">default:</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), RX status %d, transfer_flags 0x%04X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* If we received an error, we don&#39;t want to resubmit the</span>
<span class="cm">		 * Rx URB straight away but to give the USB layer a little</span>
<span class="cm">		 * bit of breathing room.</span>
<span class="cm">		 * We are in the USB thread context, therefore there is a</span>
<span class="cm">		 * danger of recursion (new URB we submit fails, we come</span>
<span class="cm">		 * back here).</span>
<span class="cm">		 * With recent USB stack (2.6.15+), I&#39;m seeing that on</span>
<span class="cm">		 * hot unplug of the dongle...</span>
<span class="cm">		 * Lowest effective timer is 10ms...</span>
<span class="cm">		 * Jean II */</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_defer_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">irda_usb_rx_defer_expired</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_defer_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">urb</span><span class="p">;</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_defer_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/* Check for empty frames */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), empty frame!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  </span>
<span class="cm">	 * Remember the time we received this frame, so we can</span>
<span class="cm">	 * reduce the min turn time a bit since we will know</span>
<span class="cm">	 * how much time we have used for protocol processing</span>
<span class="cm">	 */</span>
        <span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">stamp</span><span class="p">);</span>

	<span class="cm">/* Check if we need to copy the data to a new skb or not.</span>
<span class="cm">	 * For most frames, we use ZeroCopy and pass the already</span>
<span class="cm">	 * allocated skb up the stack.</span>
<span class="cm">	 * If the frame is small, it is more efficient to copy it</span>
<span class="cm">	 * to save memory (copy will be fast anyway - that&#39;s</span>
<span class="cm">	 * called Rx-copy-break). Jean II */</span>
	<span class="n">docopy</span> <span class="o">=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&lt;</span> <span class="n">IRDA_RX_COPY_THRESHOLD</span><span class="p">);</span>

	<span class="cm">/* Allocate a new skb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_STIR421X</span><span class="p">)</span>
		<span class="n">newskb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">docopy</span> <span class="o">?</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">:</span>
				       <span class="n">IRDA_SKB_MAX_MTU</span> <span class="o">+</span>
				       <span class="n">USB_IRDA_STIR421X_HEADER</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">newskb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">docopy</span> <span class="o">?</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">:</span>
				       <span class="n">IRDA_SKB_MAX_MTU</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newskb</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* We could deliver the current skb, but this would stall</span>
<span class="cm">		 * the Rx path. Better drop the packet... Jean II */</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>  
	<span class="p">}</span>

	<span class="cm">/* Make sure IP header get aligned (IrDA header is 5 bytes) */</span>
	<span class="cm">/* But IrDA-USB header is 1 byte. Jean II */</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>skb<em>reserve(newskb, USB</em>IRDA_HEADER - 1);</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span><span class="p">(</span><span class="n">docopy</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy packet, so we can recycle the original */</span>
		<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
		<span class="cm">/* Deliver this new skb */</span>
		<span class="n">dataskb</span> <span class="o">=</span> <span class="n">newskb</span><span class="p">;</span>
		<span class="cm">/* And hook the old skb to the URB</span>
<span class="cm">		 * Note : we don&#39;t need to &quot;clean up&quot; the old skb,</span>
<span class="cm">		 * as we never touched it. Jean II */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We are using ZeroCopy. Deliver old skb */</span>
		<span class="n">dataskb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="cm">/* And hook the new skb to the URB */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">newskb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set proper length on skb &amp; remove USB-IrDA header */</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">dataskb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">dataskb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">);</span>

	<span class="cm">/* Ask the networking layer to queue the packet for the IrDA stack */</span>
	<span class="n">dataskb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">dataskb</span><span class="p">);</span>
	<span class="n">dataskb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IRDA</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">dataskb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">netif_rx</span><span class="p">(</span><span class="n">dataskb</span><span class="p">);</span>

	<span class="cm">/* Keep stats up to date */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="cm">/* Note : at this point, the URB we&#39;ve just received (urb)</span>
<span class="cm">	 * is still referenced by the USB layer. For example, if we</span>
<span class="cm">	 * have received a -ECONNRESET, uhci_cleanup_unlink() will</span>
<span class="cm">	 * continue to process it (in fact, cleaning it up).</span>
<span class="cm">	 * If we were to submit this URB, disaster would ensue.</span>
<span class="cm">	 * Therefore, we submit our idle URB, and put this URB in our</span>
<span class="cm">	 * idle slot....</span>
<span class="cm">	 * Jean II */</span>
	<span class="cm">/* Note : with this scheme, we could submit the idle URB before</span>
<span class="cm">	 * processing the Rx URB. I don&#39;t think it would buy us anything as</span>
<span class="cm">	 * we are running in the USB thread context. Jean II */</span>
	<span class="n">next_urb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">idle_rx_urb</span><span class="p">;</span>

	<span class="cm">/* Recycle Rx URB : Now, the idle URB is the present one */</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">idle_rx_urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

	<span class="cm">/* Submit the idle URB to replace the URB we&#39;ve just received.</span>
<span class="cm">	 * Do it last to avoid race conditions... Jean II */</span>
	<span class="n">irda_usb_submit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">next_urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * In case of errors, we want the USB layer to have time to recover.</span>
<span class="cm"> * Now, it is time to resubmit ouur Rx URB...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_usb_rx_defer_expired</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span> 
	<span class="k">struct</span> <span class="n">irda_skb_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">next_urb</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Find ourselves */</span>
	<span class="n">cb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irda_skb_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">;</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">cb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="p">)</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="cm">/* Same stuff as when Rx is done, see above... */</span>
	<span class="n">next_urb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">idle_rx_urb</span><span class="p">;</span>
	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">idle_rx_urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>
	<span class="n">irda_usb_submit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">next_urb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Callbak from IrDA layer. IrDA wants to know if we have</span>
<span class="cm"> * started receiving anything.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_usb_is_receiving</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Note : because of the way UHCI works, it&#39;s almost impossible</span>
<span class="cm">	 * to get this info. The Controller DMA directly to memory and</span>
<span class="cm">	 * signal only when the whole frame is finished. To know if the</span>
<span class="cm">	 * first TD of the URB has been filled or not seems hard work...</span>
<span class="cm">	 *</span>
<span class="cm">	 * The other solution would be to use the &quot;receiving&quot; command</span>
<span class="cm">	 * on the default decriptor with a usb_control_msg(), but that</span>
<span class="cm">	 * would add USB traffic and would return result only in the</span>
<span class="cm">	 * next USB frame (~1ms).</span>
<span class="cm">	 *</span>
<span class="cm">	 * I&#39;ve been told that current dongles send status info on their</span>
<span class="cm">	 * interrupt endpoint, and that&#39;s what the Windows driver uses</span>
<span class="cm">	 * to know this info. Unfortunately, this is not yet in the spec...</span>
<span class="cm">	 *</span>
<span class="cm">	 * Jean II</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* For now */</span>
<span class="p">}</span>

<span class="cp">#define STIR421X_PATCH_PRODUCT_VER     &quot;Product Version: &quot;</span>
<span class="cp">#define STIR421X_PATCH_STMP_TAG        &quot;STMP&quot;</span>
<span class="cp">#define STIR421X_PATCH_CODE_OFFSET     512 </span><span class="cm">/* patch image starts before here */</span><span class="cp"></span>
<span class="cm">/* marks end of patch file header (PC DOS text file EOF character) */</span>
<span class="cp">#define STIR421X_PATCH_END_OF_HDR_TAG  0x1A</span>
<span class="cp">#define STIR421X_PATCH_BLOCK_SIZE      1023</span>

<span class="cm">/*</span>
<span class="cm"> * Function stir421x_fwupload (struct irda_usb_cb *self,</span>
<span class="cm"> *                             unsigned char *patch,</span>
<span class="cm"> *                             const unsigned int patch_len)</span>
<span class="cm"> *</span>
<span class="cm"> *   Upload firmware code to SigmaTel 421X IRDA-USB dongle</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">stir421x_fw_upload</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">patch</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">patch_len</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">actual_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">patch_block</span><span class="p">;</span>

        <span class="n">patch_block</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">STIR421X_PATCH_BLOCK_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">patch_block</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* break up patch into 1023-byte sections */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">patch_len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">block_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_size</span> <span class="o">=</span> <span class="n">patch_len</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block_size</span> <span class="o">&gt;</span> <span class="n">STIR421X_PATCH_BLOCK_SIZE</span><span class="p">)</span>
			<span class="n">block_size</span> <span class="o">=</span> <span class="n">STIR421X_PATCH_BLOCK_SIZE</span><span class="p">;</span>

		<span class="cm">/* upload the patch section */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">patch_block</span><span class="p">,</span> <span class="n">patch</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_bulk_msg</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span>
				   <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span>
						   <span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_ep</span><span class="p">),</span>
				   <span class="n">patch_block</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">actual_len</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;%s(): Bulk send %u bytes, ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">actual_len</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">patch_block</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
 <span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function stir421x_patch_device(struct irda_usb_cb *self)</span>
<span class="cm"> *</span>
<span class="cm"> * Get a firmware code from userspase using hotplug request_firmware() call</span>
<span class="cm">  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">stir421x_patch_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">stir421x_fw_name</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fw_version_ptr</span><span class="p">;</span> <span class="cm">/* pointer to version string */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fw_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * Known firmware patch file names for STIR421x dongles</span>
<span class="cm">         * are &quot;42101001.sb&quot; or &quot;42101002.sb&quot;</span>
<span class="cm">         */</span>
        <span class="n">sprintf</span><span class="p">(</span><span class="n">stir421x_fw_name</span><span class="p">,</span> <span class="s">&quot;4210%4X.sb&quot;</span><span class="p">,</span>
                <span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">stir421x_fw_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

        <span class="cm">/* We get a patch from userspace */</span>
        <span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s(): Received firmware %s (%zu bytes)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                     <span class="n">__func__</span><span class="p">,</span> <span class="n">stir421x_fw_name</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Get the bcd product version */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">STIR421X_PATCH_PRODUCT_VER</span><span class="p">,</span>
                    <span class="k">sizeof</span><span class="p">(</span><span class="n">STIR421X_PATCH_PRODUCT_VER</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">fw_version_ptr</span> <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">STIR421X_PATCH_PRODUCT_VER</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

                <span class="cm">/* Let&#39;s check if the product version is dotted */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fw_version_ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fw_version_ptr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">build</span><span class="p">;</span>
			<span class="n">major</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">fw_version_ptr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">minor</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">fw_version_ptr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
			<span class="n">build</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">fw_version_ptr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

			<span class="n">fw_version</span> <span class="o">=</span> <span class="p">(</span><span class="n">major</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span>
				<span class="o">+</span> <span class="p">(</span><span class="n">minor</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
				<span class="o">+</span> <span class="p">((</span><span class="n">build</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span>
				<span class="o">+</span> <span class="p">(</span><span class="n">build</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>

			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s(): Firmware Product version %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                                   <span class="n">__func__</span><span class="p">,</span> <span class="n">fw_version</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span> <span class="o">==</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">fw_version</span><span class="p">))</span> <span class="p">{</span>
                <span class="cm">/*</span>
<span class="cm">		 * If we&#39;re here, we&#39;ve found a correct patch</span>
<span class="cm">                 * The actual image starts after the &quot;STMP&quot; keyword</span>
<span class="cm">                 * so forward to the firmware header tag</span>
<span class="cm">                 */</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span>
			     <span class="n">STIR421X_PATCH_END_OF_HDR_TAG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">;</span>
                <span class="cm">/* here we check for the out of buffer case */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">STIR421X_PATCH_CODE_OFFSET</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;&amp;</span>
				<span class="n">STIR421X_PATCH_END_OF_HDR_TAG</span> <span class="o">==</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">STIR421X_PATCH_STMP_TAG</span><span class="p">,</span>
                                    <span class="k">sizeof</span><span class="p">(</span><span class="n">STIR421X_PATCH_STMP_TAG</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>

				<span class="cm">/* We can upload the patch to the target */</span>
				<span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">STIR421X_PATCH_STMP_TAG</span><span class="p">);</span>
                                <span class="n">ret</span> <span class="o">=</span> <span class="n">stir421x_fw_upload</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							 <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/********************** IRDA DEVICE CALLBACKS **********************/</span>
<span class="cm">/*</span>
<span class="cm"> * Main calls from the IrDA/Network subsystem.</span>
<span class="cm"> * Mostly registering a new irda-usb device and removing it....</span>
<span class="cm"> * We only deal with the IrDA side of the business, the USB side will</span>
<span class="cm"> * be dealt with below...</span>
<span class="cm"> */</span>


<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Function irda_usb_net_open (dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    Network device is taken up. Usually this is done by &quot;ifconfig irda0 up&quot; </span>
<span class="cm"> *   </span>
<span class="cm"> * Note : don&#39;t mess with self-&gt;netopen - Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_usb_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">hwname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">netdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* Can only open the device if it&#39;s there */</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), device not present!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">needspatch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), device needs patch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialise default speed and xbofs value</span>
<span class="cm">	 * (IrLAP will change that soon) */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">xbofs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_xbofs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* To do *before* submitting Rx urbs and starting net Tx queue</span>
<span class="cm">	 * Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netopen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* </span>
<span class="cm">	 * Now that everything should be initialized properly,</span>
<span class="cm">	 * Open new IrLAP layer instance to take care of us...</span>
<span class="cm">	 * Note : will send immediately a speed change...</span>
<span class="cm">	 */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">hwname</span><span class="p">,</span> <span class="s">&quot;usb#%d&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="n">irlap_open</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">,</span> <span class="n">hwname</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Allow IrLAP to send data to us */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* We submit all the Rx URB except for one that we keep idle.</span>
<span class="cm">	 * Need to be initialised before submitting other USBs, because</span>
<span class="cm">	 * in some cases as soon as we submit the URBs the USB layer</span>
<span class="cm">	 * will trigger a dummy receive - Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">idle_rx_urb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">IU_MAX_ACTIVE_RX_URBS</span><span class="p">];</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">idle_rx_urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Now that we can pass data to IrLAP, allow the USB layer</span>
<span class="cm">	 * to send us some data... */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IU_MAX_ACTIVE_RX_URBS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">IRDA_SKB_MAX_MTU</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If this ever happen, we are in deep s***.</span>
<span class="cm">			 * Basically, we can&#39;t start the Rx path... */</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), Failed to allocate Rx skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>skb<em>reserve(newskb, USB</em>IRDA_HEADER - 1);</p></td><td class="code"><div class="highlight"><pre>		<span class="n">irda_usb_submit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="cm">/* Ready to play !!! */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Function irda_usb_net_close (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Network device is taken down. Usually this is done by </span>
<span class="cm"> *    &quot;ifconfig irda0 down&quot; </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_usb_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">netdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="cm">/* Clear this flag *before* unlinking the urbs and *before*</span>
<span class="cm">	 * stopping the network Tx queue - Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netopen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Stop network Tx queue */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Kill defered Rx URB */</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_defer_timer</span><span class="p">);</span>

	<span class="cm">/* Deallocate all the Rx path buffers (URBs and skb) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
		<span class="cm">/* Cancel the receive command */</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="cm">/* The skb is ours, free it */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Cancel Tx and speed URB - need to be synchronous to avoid races */</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">);</span>

	<span class="cm">/* Stop and remove instance of IrLAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">)</span>
		<span class="n">irlap_close</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * IOCTLs : Extra out-of-band network commands...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_usb_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">if_irda_req</span> <span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">if_irda_req</span> <span class="o">*</span><span class="p">)</span> <span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), %s, (cmd=0x%X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCSBANDWIDTH</span>: <span class="cm">/* Set bandwidth */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="cm">/* Protect us from USB callbacks, net watchdog and else. */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* Check if the device is still there */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">present</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Set the desired speed */</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">irq</span><span class="o">-&gt;</span><span class="n">ifr_baudrate</span><span class="p">;</span>
			<span class="n">irda_usb_change_speed_xbofs</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCSMEDIABUSY</span>: <span class="cm">/* Set media busy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="cm">/* Check if the IrDA stack is still there */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netopen</span><span class="p">)</span>
			<span class="n">irda_device_set_media_busy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCGRECEIVING</span>: <span class="cm">/* Check if we are receiving right now */</span>
		<span class="n">irq</span><span class="o">-&gt;</span><span class="n">ifr_receiving</span> <span class="o">=</span> <span class="n">irda_usb_is_receiving</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>

<span class="cm">/********************* IRDA CONFIG SUBROUTINES *********************/</span>
<span class="cm">/*</span>
<span class="cm"> * Various subroutines dealing with IrDA and network stuff we use to</span>
<span class="cm"> * configure and initialise each irda-usb instance.</span>
<span class="cm"> * These functions are used below in the main calls of the driver...</span>
<span class="cm"> */</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Set proper values in the IrDA QOS structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irda_usb_init_qos</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_class_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	
	<span class="n">desc</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">irda_desc</span><span class="p">;</span>
	
	<span class="cm">/* Initialize QoS for this device */</span>
	<span class="n">irda_init_max_qos_capabilies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">);</span>

	<span class="cm">/* See spec section 7.2 for meaning.</span>
<span class="cm">	 * Values are little endian (as most USB stuff), the IrDA stack</span>
<span class="cm">	 * use it in native order (see parameters.c). - Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span>       <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wBaudRate</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span>   <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmMinTurnaroundTime</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAdditionalBOFs</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span>     <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmWindowSize</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span>       <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmDataSize</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), dongle says speed=0x%X, size=0x%X, window=0x%X, bofs=0x%X, turn=0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
		<span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t always trust what the dongle tell us */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_SIR_ONLY</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span>	<span class="o">&amp;=</span> <span class="mh">0x00ff</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_SMALL_PKT</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">data_size</span><span class="p">.</span><span class="n">bits</span>	 <span class="o">=</span> <span class="mh">0x07</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_NO_WINDOW</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span>	 <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_MAX_WINDOW</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span>	 <span class="o">=</span> <span class="mh">0x7f</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_MAX_XBOFS</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">additional_bofs</span><span class="p">.</span><span class="n">bits</span>	 <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>

<span class="cp">#if 1</span>
	<span class="cm">/* Module parameter can override the rx window size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qos_mtt_bits</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">qos_mtt_bits</span><span class="p">;</span>
<span class="cp">#endif	    </span>
	<span class="cm">/* </span>
<span class="cm">	 * Note : most of those values apply only for the receive path,</span>
<span class="cm">	 * the transmit path will be set differently - Jean II </span>
<span class="cm">	 */</span>
	<span class="n">irda_qos_bits_to_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">irda_usb_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>       <span class="o">=</span> <span class="n">irda_usb_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>       <span class="o">=</span> <span class="n">irda_usb_net_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>   <span class="o">=</span> <span class="n">irda_usb_net_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">irda_usb_hard_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>	<span class="o">=</span> <span class="n">irda_usb_net_timeout</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Initialise the network side of the irda-usb instance</span>
<span class="cm"> * Called when a new USB instance is registered in irda_usb_probe()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irda_usb_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">irda_usb_netdev_ops</span><span class="p">;</span>

	<span class="n">irda_usb_init_qos</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Cleanup the network side of the irda-usb instance</span>
<span class="cm"> * Called when a USB instance is removed in irda_usb_disconnect()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irda_usb_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Remove netdevice */</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Remove the speed buffer */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_buff</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_buff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/********************** USB CONFIG SUBROUTINES **********************/</span>
<span class="cm">/*</span>
<span class="cm"> * Various subroutines dealing with USB stuff we use to configure and</span>
<span class="cm"> * initialise each irda-usb instance.</span>
<span class="cm"> * These functions are used below in the main calls of the driver...</span>
<span class="cm"> */</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Function irda_usb_parse_endpoints(dev, ifnum)</span>
<span class="cm"> *</span>
<span class="cm"> *    Parse the various endpoints and find the one we need.</span>
<span class="cm"> *</span>
<span class="cm"> * The endpoint are the pipes used to communicate with the USB device.</span>
<span class="cm"> * The spec defines 2 endpoints of type bulk transfer, one in, and one out.</span>
<span class="cm"> * These are used to pass frames back and forth with the dongle.</span>
<span class="cm"> * Most dongle have also an interrupt endpoint, that will be probably</span>
<span class="cm"> * documented in the next spec...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">irda_usb_parse_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">endpoint</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ennum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>		<span class="cm">/* Endpoint index in table */</span>
		
	<span class="cm">/* Init : no endpoints */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_in_ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_int_ep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Let&#39;s look at all those endpoints */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ennum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* All those variables will get optimised by the compiler,</span>
<span class="cm">		 * so let&#39;s aim for clarity... - Jean II */</span>
		<span class="n">__u8</span> <span class="n">ep</span><span class="p">;</span>	<span class="cm">/* Endpoint address */</span>
		<span class="n">__u8</span> <span class="n">dir</span><span class="p">;</span>	<span class="cm">/* Endpoint direction */</span>
		<span class="n">__u8</span> <span class="n">attr</span><span class="p">;</span>	<span class="cm">/* Endpoint attribute */</span>
		<span class="n">__u16</span> <span class="n">psize</span><span class="p">;</span>	<span class="cm">/* Endpoint max packet size in bytes */</span>

		<span class="cm">/* Get endpoint address, direction and attribute */</span>
		<span class="n">ep</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_NUMBER_MASK</span><span class="p">;</span>
		<span class="n">dir</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_ENDPOINT_DIR_MASK</span><span class="p">;</span>
		<span class="n">attr</span> <span class="o">=</span> <span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bmAttributes</span><span class="p">;</span>
		<span class="n">psize</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">endpoint</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">wMaxPacketSize</span><span class="p">);</span>

		<span class="cm">/* Is it a bulk endpoint ??? */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">attr</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_BULK</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We need to find an IN and an OUT */</span>
			<span class="k">if</span><span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">USB_DIR_IN</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* This is our Rx endpoint */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_in_ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* This is our Tx endpoint */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_mtu</span> <span class="o">=</span> <span class="n">psize</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">((</span><span class="n">attr</span> <span class="o">==</span> <span class="n">USB_ENDPOINT_XFER_INT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">USB_DIR_IN</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* This is our interrupt endpoint */</span>
				<span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_int_ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), Unrecognised endpoint %02X.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), And our endpoints are : in=%02X, out=%02X (%d), int=%02X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_in_ep</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_ep</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_mtu</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_int_ep</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_in_ep</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">bulk_out_ep</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef IU_DUMP_CLASS_DESC</span>
<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Function usb_irda_dump_class_desc(desc)</span>
<span class="cm"> *</span>
<span class="cm"> *    Prints out the contents of the IrDA class descriptor</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">irda_usb_dump_class_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">irda_class_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Values are little endian */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bLength=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bLength</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bDescriptorType=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bcdSpecRevision=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bcdSpecRevision</span><span class="p">));</span> 
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bmDataSize=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmDataSize</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bmWindowSize=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmWindowSize</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bmMinTurnaroundTime=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmMinTurnaroundTime</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;wBaudRate=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">wBaudRate</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bmAdditionalBOFs=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bmAdditionalBOFs</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bIrdaRateSniff=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bIrdaRateSniff</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;bMaxUnicastList=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bMaxUnicastList</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IU_DUMP_CLASS_DESC */</span><span class="cp"></span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Function irda_usb_find_class_desc(intf)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns instance of IrDA class descriptor, or NULL if not found</span>
<span class="cm"> *</span>
<span class="cm"> * The class descriptor is some extra info that IrDA USB devices will</span>
<span class="cm"> * offer to us, describing their IrDA characteristics. We will use that in</span>
<span class="cm"> * irda_usb_init_qos()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">irda_class_desc</span> <span class="o">*</span><span class="nf">irda_usb_find_class_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span> <span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irda_class_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* USB-IrDA class spec 1.0:</span>
<span class="cm">	 *	6.1.3: Standard &quot;Get Descriptor&quot; Device Request is not</span>
<span class="cm">	 *	       appropriate to retrieve class-specific descriptor</span>
<span class="cm">	 *	6.2.5: Class Specific &quot;Get Class Descriptor&quot; Interface Request</span>
<span class="cm">	 *	       is mandatory and returns the USB-IrDA class descriptor</span>
<span class="cm">	 */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
		<span class="n">IU_REQ_GET_CLASS_DESC</span><span class="p">,</span>
		<span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_CLASS</span> <span class="o">|</span> <span class="n">USB_RECIP_INTERFACE</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">),</span> <span class="mi">500</span><span class="p">);</span>
	
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(), ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;usb-irda: class_descriptor read %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">ret</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;failed&quot;</span> <span class="o">:</span> <span class="s">&quot;too short&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDescriptorType</span> <span class="o">!=</span> <span class="n">USB_DT_IRDA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;usb-irda: bad class_descriptor type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef IU_DUMP_CLASS_DESC</span>
		<span class="n">irda_usb_dump_class_desc</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* IU_DUMP_CLASS_DESC */</span><span class="cp"></span>

		<span class="k">return</span> <span class="n">desc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*********************** USB DEVICE CALLBACKS ***********************/</span>
<span class="cm">/*</span>
<span class="cm"> * Main calls from the USB subsystem.</span>
<span class="cm"> * Mostly registering a new irda-usb device and removing it....</span>
<span class="cm"> */</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * This routine is called by the USB subsystem for each new device</span>
<span class="cm"> * in the system. We need to check if the device is ours, and in</span>
<span class="cm"> * this case start handling it.</span>
<span class="cm"> * The USB layer protect us from reentrancy (via BKL), so we don&#39;t need</span>
<span class="cm"> * to spinlock in there... Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_usb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">usb_host_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_class_desc</span> <span class="o">*</span><span class="n">irda_desc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>		<span class="cm">/* Driver instance index / Rx URB index */</span>

	<span class="cm">/* Note : the probe make sure to call us only for devices that</span>
<span class="cm">	 * matches the list of dongle (top of the file). So, we</span>
<span class="cm">	 * don&#39;t need to check if the dongle is really ours.</span>
<span class="cm">	 * Jean II */</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;IRDA-USB found at address %d, Vendor: %x, Product: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">),</span>
		     <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">));</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">alloc_irdadev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">self</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="p">)</span> 
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_defer_timer</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_info</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">needspatch</span> <span class="o">=</span> <span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_STIR421X</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Create all of the needed urbs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">capability</span> <span class="o">&amp;</span> <span class="n">IUC_STIR421X</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span> <span class="o">=</span> <span class="n">IU_SIGMATEL_MAX_RX_URBS</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">=</span> <span class="n">USB_IRDA_STIR421X_HEADER</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span> <span class="o">=</span> <span class="n">IU_MAX_RX_URBS</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">=</span> <span class="n">USB_IRDA_HEADER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="p">),</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_free_net</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">err_out_1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">err_out_1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">err_out_2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is this really necessary? (no, except maybe for broken devices) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usb_reset_configuration</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reset_configuration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is this really necessary? */</span>
	<span class="cm">/* Note : some driver do hardcode the interface number, some others</span>
<span class="cm">	 * specify an alternate, but very few driver do like this.</span>
<span class="cm">	 * Jean II */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_set_interface</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;usb-irda: set interface %d result %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bInterfaceNumber</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:		<span class="cm">/* -EPIPE = -32 */</span>
			<span class="cm">/* Martin Diehl says if we get a -EPIPE we should</span>
<span class="cm">			 * be fine and we don&#39;t need to do a usb_clear_halt().</span>
<span class="cm">			 * - Jean II */</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Received -EPIPE, ignoring...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Unknown error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find our endpoints */</span>
	<span class="n">interface</span> <span class="o">=</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">irda_usb_parse_endpoints</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">interface</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">,</span>
				     <span class="n">interface</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s(), Bogus endpoints...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Find IrDA class descriptor */</span>
	<span class="n">irda_desc</span> <span class="o">=</span> <span class="n">irda_usb_find_class_desc</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irda_desc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">needspatch</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				       <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;usb_control_msg failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">irda_desc</span> <span class="o">=</span>  <span class="n">irda_desc</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netopen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">usbintf</span> <span class="o">=</span> <span class="n">intf</span><span class="p">;</span>

	<span class="cm">/* Allocate the buffer for speed changes */</span>
	<span class="cm">/* Don&#39;t change this buffer size and allocation without doing</span>
<span class="cm">	 * some heavy and complete testing. Don&#39;t ask why :-(</span>
<span class="cm">	 * Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_buff</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">IRDA_USB_SPEED_MTU</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_buff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_3</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">IRDA_SKB_MAX_MTU</span> <span class="o">+</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_4</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">irda_usb_open</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> 
		<span class="k">goto</span> <span class="n">err_out_5</span><span class="p">;</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;IrDA: Registered device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">needspatch</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Now we fetch and upload the firmware patch */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">stir421x_patch_device</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">needspatch</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">needspatch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;STIR421X: Couldn&#39;t upload patch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_6</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* replace IrDA class descriptor with what patched device is now reporting */</span>
		<span class="n">irda_desc</span> <span class="o">=</span> <span class="n">irda_usb_find_class_desc</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">usbintf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irda_desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out_6</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irda_desc</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">irda_desc</span> <span class="o">=</span> <span class="n">irda_desc</span><span class="p">;</span>
		<span class="n">irda_usb_init_qos</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_out_6:</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">err_out_5:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">);</span>
<span class="nl">err_out_4:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_buff</span><span class="p">);</span>
<span class="nl">err_out_3:</span>
	<span class="cm">/* Free all urbs that we may have created */</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">);</span>
<span class="nl">err_out_2:</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
<span class="nl">err_out_1:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span>
<span class="nl">err_free_net:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * The current irda-usb device is removed, the USB layer tell us</span>
<span class="cm"> * to shut it down...</span>
<span class="cm"> * One of the constraints is that when we exit this function,</span>
<span class="cm"> * we cannot use the usb_device no more. Gone. Destroyed. kfree().</span>
<span class="cm"> * Most other subsystem allow you to destroy the instance at a time</span>
<span class="cm"> * when it&#39;s convenient to you, to postpone it to a later date, but</span>
<span class="cm"> * not the USB subsystem.</span>
<span class="cm"> * So, we must make bloody sure that everything gets deactivated.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">irda_usb_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Make sure that the Tx path is not executing. - Jean II */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Oups ! We are not there any more.</span>
<span class="cm">	 * This will stop/desactivate the Tx path. - Jean II */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Kill defered Rx URB */</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_defer_timer</span><span class="p">);</span>

	<span class="cm">/* We need to have irq enabled to unlink the URBs. That&#39;s OK,</span>
<span class="cm">	 * at this point the Tx path is gone - Jean II */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Hum... Check if networking is still active (avoid races) */</span>
	<span class="k">if</span><span class="p">((</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netopen</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Accept no more transmissions */</span>
		<span class="cm">/*netif_device_detach(self-&gt;netdev);*/</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="cm">/* Stop all the receive URBs. Must be synchronous. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="cm">/* Cancel Tx and speed URB.</span>
<span class="cm">		 * Make sure it&#39;s synchronous to avoid races. */</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Cleanup the device stuff */</span>
	<span class="n">irda_usb_close</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="cm">/* No longer attached to USB bus */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">usbdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">usbintf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Clean up our urbs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span>
	<span class="cm">/* Clean up Tx and speed URB */</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">);</span>

	<span class="cm">/* Free self and network device */</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), USB IrDA Disconnected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/* USB suspend, so power off the transmitter/receiver */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_usb_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">speed_urb</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Coming out of suspend, so reset hardware */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">irda_usb_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">irda_usb_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">max_rx_urb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * USB device callbacks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">irda_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;irda-usb&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">irda_usb_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span>	<span class="o">=</span> <span class="n">irda_usb_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">dongles</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">irda_usb_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">irda_usb_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">irda_driver</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Module parameters</span>
<span class="cm"> */</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">qos_mtt_bits</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">qos_mtt_bits</span><span class="p">,</span> <span class="s">&quot;Minimum Turn Time&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Roman Weissgaerber &lt;weissg@vienna.at&gt;, Dag Brattli &lt;dag@brattli.net&gt;, Jean Tourrilhes &lt;jt@hpl.hp.com&gt; and Nick Fedchik &lt;nick@fedchik.org.ua&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;IrDA-USB Dongle Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
