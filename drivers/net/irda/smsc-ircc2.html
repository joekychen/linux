<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › irda › smsc-ircc2.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>smsc-ircc2.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*********************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Description:   Driver for the SMC Infrared Communications Controller</span>
<span class="cm"> * Author:        Daniele Peri (peri@csai.unipa.it)</span>
<span class="cm"> * Created at:</span>
<span class="cm"> * Modified at:</span>
<span class="cm"> * Modified by:</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 2002      Daniele Peri</span>
<span class="cm"> *     All Rights Reserved.</span>
<span class="cm"> *     Copyright (c) 2002      Jean Tourrilhes</span>
<span class="cm"> *     Copyright (c) 2006      Linus Walleij</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Based on smc-ircc.c:</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 2001      Stefani Seibold</span>
<span class="cm"> *     Copyright (c) 1999-2001 Dag Brattli</span>
<span class="cm"> *     Copyright (c) 1998-1999 Thomas Davis,</span>
<span class="cm"> *</span>
<span class="cm"> *	and irport.c:</span>
<span class="cm"> *</span>
<span class="cm"> *     Copyright (c) 1997, 1998, 1999-2000 Dag Brattli, All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is free software; you can redistribute it and/or</span>
<span class="cm"> *     modify it under the terms of the GNU General Public License as</span>
<span class="cm"> *     published by the Free Software Foundation; either version 2 of</span>
<span class="cm"> *     the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *     This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> *     GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *     You should have received a copy of the GNU General Public License</span>
<span class="cm"> *     along with this program; if not, write to the Free Software</span>
<span class="cm"> *     Foundation, Inc., 59 Temple Place, Suite 330, Boston,</span>
<span class="cm"> *     MA 02111-1307 USA</span>
<span class="cm"> *</span>
<span class="cm"> ********************************************************************/</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/serial_reg.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/pnp.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/pm.h&gt;</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;net/irda/wrapper.h&gt;</span>
<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/irda_device.h&gt;</span>

<span class="cp">#include &quot;smsc-ircc2.h&quot;</span>
<span class="cp">#include &quot;smsc-sio.h&quot;</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Daniele Peri &lt;peri@csai.unipa.it&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SMC IrCC SIR/FIR controller driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">smsc_nopnp</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">nopnp</span><span class="p">,</span> <span class="n">smsc_nopnp</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nopnp</span><span class="p">,</span> <span class="s">&quot;Do not use PNP to detect controller settings, defaults to true&quot;</span><span class="p">);</span>

<span class="cp">#define DMA_INVAL 255</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ircc_dma</span> <span class="o">=</span> <span class="n">DMA_INVAL</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ircc_dma</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ircc_dma</span><span class="p">,</span> <span class="s">&quot;DMA channel&quot;</span><span class="p">);</span>

<span class="cp">#define IRQ_INVAL 255</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ircc_irq</span> <span class="o">=</span> <span class="n">IRQ_INVAL</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ircc_irq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ircc_irq</span><span class="p">,</span> <span class="s">&quot;IRQ line&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ircc_fir</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ircc_fir</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ircc_fir</span><span class="p">,</span> <span class="s">&quot;FIR Base Address&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ircc_sir</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ircc_sir</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ircc_sir</span><span class="p">,</span> <span class="s">&quot;SIR Base Address&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ircc_cfg</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ircc_cfg</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ircc_cfg</span><span class="p">,</span> <span class="s">&quot;Configuration register base address&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">ircc_transceiver</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ircc_transceiver</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ircc_transceiver</span><span class="p">,</span> <span class="s">&quot;Transceiver type&quot;</span><span class="p">);</span>

<span class="cm">/* Types */</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vendor</span><span class="p">;</span> <span class="cm">/* PCI vendor ID */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">device</span><span class="p">;</span> <span class="cm">/* PCI vendor ID */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">subvendor</span><span class="p">;</span> <span class="cm">/* PCI subsystem vendor ID */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">subdevice</span><span class="p">;</span> <span class="cm">/* PCI subsystem device ID */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sir_io</span><span class="p">;</span> <span class="cm">/* I/O port for SIR */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">fir_io</span><span class="p">;</span> <span class="cm">/* I/O port for FIR */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">fir_irq</span><span class="p">;</span> <span class="cm">/* FIR IRQ */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>  <span class="n">fir_dma</span><span class="p">;</span> <span class="cm">/* FIR DMA */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">;</span> <span class="cm">/* I/O port for chip configuration */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">preconfigure</span><span class="p">)(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span> <span class="cm">/* Preconfig function */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>	<span class="cm">/* name shown as info */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">smsc_transceiver</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_for_speed</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">);</span>
	<span class="kt">int</span>  <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smsc_chip</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	u8	type;</span>
<span class="cp">	#endif</span>
	<span class="n">u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">devid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">rev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smsc_chip_address</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfg_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Private data for each instance */</span>
<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>     <span class="cm">/* Yes! we are some kind of netdevice */</span>
	<span class="k">struct</span> <span class="n">irlap_cb</span>    <span class="o">*</span><span class="n">irlap</span><span class="p">;</span> <span class="cm">/* The link layer we are binded to */</span>

	<span class="n">chipio_t</span> <span class="n">io</span><span class="p">;</span>               <span class="cm">/* IrDA controller information */</span>
	<span class="n">iobuff_t</span> <span class="n">tx_buff</span><span class="p">;</span>          <span class="cm">/* Transmit buffer */</span>
	<span class="n">iobuff_t</span> <span class="n">rx_buff</span><span class="p">;</span>          <span class="cm">/* Receive buffer */</span>
	<span class="n">dma_addr_t</span> <span class="n">tx_buff_dma</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">rx_buff_dma</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">qos_info</span> <span class="n">qos</span><span class="p">;</span>       <span class="cm">/* QoS capabilities for this device */</span>

	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>           <span class="cm">/* For serializing operations */</span>

	<span class="n">__u32</span> <span class="n">new_speed</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>               <span class="cm">/* Interface flags */</span>

	<span class="kt">int</span> <span class="n">tx_buff_offsets</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>   <span class="cm">/* Offsets between frames in tx_buff */</span>
	<span class="kt">int</span> <span class="n">tx_len</span><span class="p">;</span>                <span class="cm">/* Number of frames in tx_buff */</span>

	<span class="kt">int</span> <span class="n">transceiver</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pldev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Constants */</span>

<span class="cp">#define SMSC_IRCC2_DRIVER_NAME			&quot;smsc-ircc2&quot;</span>

<span class="cp">#define SMSC_IRCC2_C_IRDA_FALLBACK_SPEED	9600</span>
<span class="cp">#define SMSC_IRCC2_C_DEFAULT_TRANSCEIVER	1</span>
<span class="cp">#define SMSC_IRCC2_C_NET_TIMEOUT		0</span>
<span class="cp">#define SMSC_IRCC2_C_SIR_STOP			0</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_name</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_DRIVER_NAME</span><span class="p">;</span>

<span class="cm">/* Prototypes */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">smsc_ircc_open</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">firbase</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sirbase</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dma</span><span class="p">,</span> <span class="n">u8</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smsc_ircc_present</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sir_base</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_setup_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sir_base</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dma</span><span class="p">,</span> <span class="n">u8</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_setup_qos</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_init_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="n">smsc_ircc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">smsc_ircc_dma_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_dma_receive_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_sir_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span>  <span class="n">smsc_ircc_hard_xmit_sir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span>  <span class="n">smsc_ircc_hard_xmit_fir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_dma_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bofs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_dma_xmit_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_change_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_set_sir_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">smsc_ircc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">smsc_ircc_interrupt_sir</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_sir_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="cp">#if SMSC_IRCC2_C_SIR_STOP</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_sir_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_sir_write_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">smsc_ircc_sir_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fifo_size</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">smsc_ircc_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">smsc_ircc_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">smsc_ircc_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="cp">#if SMSC_IRCC2_C_NET_TIMEOUT</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smsc_ircc_is_receiving</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_probe_transceiver</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_set_transceiver_for_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_sir_wait_hw_transmitter_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">);</span>

<span class="cm">/* Probing */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">smsc_ircc_look_for_chips</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="o">*</span> <span class="n">__init</span> <span class="n">smsc_ircc_probe</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">smsc_superio_flat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="o">*</span><span class="n">chips</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">smsc_superio_paged</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="o">*</span><span class="n">chips</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">smsc_superio_fdc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">smsc_superio_lpc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">preconfigure_smsc_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">preconfigure_through_82801</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="n">preconfigure_ali_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">preconfigure_through_ali</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span> <span class="o">*</span><span class="n">conf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">smsc_ircc_preconfigure_subsystems</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ircc_cfg</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ircc_fir</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ircc_sir</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ircc_dma</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ircc_irq</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Transceivers specific functions */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_set_transceiver_toshiba_sat1800</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">smsc_ircc_probe_transceiver_toshiba_sat1800</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_set_transceiver_smsc_ircc_fast_pin_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">smsc_ircc_probe_transceiver_smsc_ircc_fast_pin_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smsc_ircc_set_transceiver_smsc_ircc_atc</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="n">smsc_ircc_probe_transceiver_smsc_ircc_atc</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">);</span>

<span class="cm">/* Power Management */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">smsc_ircc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">smsc_ircc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">smsc_ircc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">smsc_ircc_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">smsc_ircc_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="n">SMSC_IRCC2_DRIVER_NAME</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* Transceivers for SMSC-ircc */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smsc_transceiver</span> <span class="n">smsc_transceivers</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;Toshiba Satellite 1800 (GP data pin select)&quot;</span><span class="p">,</span> <span class="n">smsc_ircc_set_transceiver_toshiba_sat1800</span><span class="p">,</span> <span class="n">smsc_ircc_probe_transceiver_toshiba_sat1800</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;Fast pin select&quot;</span><span class="p">,</span> <span class="n">smsc_ircc_set_transceiver_smsc_ircc_fast_pin_select</span><span class="p">,</span> <span class="n">smsc_ircc_probe_transceiver_smsc_ircc_fast_pin_select</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;ATC IRMode&quot;</span><span class="p">,</span> <span class="n">smsc_ircc_set_transceiver_smsc_ircc_atc</span><span class="p">,</span> <span class="n">smsc_ircc_probe_transceiver_smsc_ircc_atc</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>
<span class="cp">#define SMSC_IRCC2_C_NUMBER_OF_TRANSCEIVERS (ARRAY_SIZE(smsc_transceivers) - 1)</span>

<span class="cm">/*  SMC SuperIO chipsets definitions */</span>

<span class="cp">#define	KEY55_1	0	</span><span class="cm">/* SuperIO Configuration mode with Key &lt;0x55&gt; */</span><span class="cp"></span>
<span class="cp">#define	KEY55_2	1	</span><span class="cm">/* SuperIO Configuration mode with Key &lt;0x55,0x55&gt; */</span><span class="cp"></span>
<span class="cp">#define	NoIRDA	2	</span><span class="cm">/* SuperIO Chip has no IRDA Port */</span><span class="cp"></span>
<span class="cp">#define	SIR	0	</span><span class="cm">/* SuperIO Chip has only slow IRDA */</span><span class="cp"></span>
<span class="cp">#define	FIR	4	</span><span class="cm">/* SuperIO Chip has fast IRDA */</span><span class="cp"></span>
<span class="cp">#define	SERx4	8	</span><span class="cm">/* SuperIO Chip supports 115,2 KBaud * 4=460,8 KBaud */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="n">__initdata</span> <span class="n">fdc_chips_flat</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="cm">/* Base address 0x3f0 or 0x370 */</span>
	<span class="p">{</span> <span class="s">&quot;37C44&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">NoIRDA</span><span class="p">,</span>		<span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span> <span class="cm">/* This chip cannot be detected */</span>
	<span class="p">{</span> <span class="s">&quot;37C665GT&quot;</span><span class="p">,</span>	<span class="n">KEY55_2</span><span class="o">|</span><span class="n">NoIRDA</span><span class="p">,</span>		<span class="mh">0x65</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37C665GT&quot;</span><span class="p">,</span>	<span class="n">KEY55_2</span><span class="o">|</span><span class="n">NoIRDA</span><span class="p">,</span>		<span class="mh">0x66</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37C669&quot;</span><span class="p">,</span>	<span class="n">KEY55_2</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x02</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37C669&quot;</span><span class="p">,</span>	<span class="n">KEY55_2</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x02</span> <span class="p">},</span> <span class="cm">/* ID? */</span>
	<span class="p">{</span> <span class="s">&quot;37C78&quot;</span><span class="p">,</span>	<span class="n">KEY55_2</span><span class="o">|</span><span class="n">NoIRDA</span><span class="p">,</span>		<span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37N769&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37N869&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x29</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="n">__initdata</span> <span class="n">fdc_chips_paged</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="cm">/* Base address 0x3f0 or 0x370 */</span>
	<span class="p">{</span> <span class="s">&quot;37B72X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x4c</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37B77X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x43</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37B78X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37B80X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37C67X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37C93X&quot;</span><span class="p">,</span>	<span class="n">KEY55_2</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37C93XAPM&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x30</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37C93XFR&quot;</span><span class="p">,</span>	<span class="n">KEY55_2</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37M707&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37M81X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x4d</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37N958FR&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x09</span><span class="p">,</span> <span class="mh">0x04</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37N971&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;37N972&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x0b</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="n">__initdata</span> <span class="n">lpc_chips_flat</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="cm">/* Base address 0x2E or 0x4E */</span>
	<span class="p">{</span> <span class="s">&quot;47N227&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x5a</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47N227&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x7a</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47N267&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x5e</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="n">__initdata</span> <span class="n">lpc_chips_paged</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="cm">/* Base address 0x2E or 0x4E */</span>
	<span class="p">{</span> <span class="s">&quot;47B27X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x51</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47B37X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x52</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47M10X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x59</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47M120&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">NoIRDA</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x5c</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47M13X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x59</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47M14X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x5f</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47N252&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">FIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x0e</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;47S42X&quot;</span><span class="p">,</span>	<span class="n">KEY55_1</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">SERx4</span><span class="p">,</span>	<span class="mh">0x57</span><span class="p">,</span> <span class="mh">0x00</span> <span class="p">},</span>
	<span class="p">{</span> <span class="nb">NULL</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#define SMSCSIO_TYPE_FDC	1</span>
<span class="cp">#define SMSCSIO_TYPE_LPC	2</span>
<span class="cp">#define SMSCSIO_TYPE_FLAT	4</span>
<span class="cp">#define SMSCSIO_TYPE_PAGED	8</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smsc_chip_address</span> <span class="n">__initdata</span> <span class="n">possible_addresses</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">{</span> <span class="mh">0x3f0</span><span class="p">,</span> <span class="n">SMSCSIO_TYPE_FDC</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_FLAT</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_PAGED</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x370</span><span class="p">,</span> <span class="n">SMSCSIO_TYPE_FDC</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_FLAT</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_PAGED</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0xe0</span><span class="p">,</span>  <span class="n">SMSCSIO_TYPE_FDC</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_FLAT</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_PAGED</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x2e</span><span class="p">,</span>  <span class="n">SMSCSIO_TYPE_LPC</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_FLAT</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_PAGED</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mh">0x4e</span><span class="p">,</span>  <span class="n">SMSCSIO_TYPE_LPC</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_FLAT</span><span class="o">|</span><span class="n">SMSCSIO_TYPE_PAGED</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* Globals */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">dev_self</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dev_count</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">register_bank</span><span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bank</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">outb</span><span class="p">(((</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">bank</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)),</span>
               <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* PNP hotplug support */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">smsc_ircc_pnp_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;SMCf010&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="cm">/* and presumably others */</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span> <span class="n">smsc_ircc_pnp_table</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pnp_driver_registered</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PNP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">smsc_ircc_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">firbase</span><span class="p">,</span> <span class="n">sirbase</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dma</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pnp_port_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pnp_port_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="n">pnp_dma_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pnp_irq_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sirbase</span> <span class="o">=</span> <span class="n">pnp_port_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">firbase</span> <span class="o">=</span> <span class="n">pnp_port_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">dma</span> <span class="o">=</span> <span class="n">pnp_dma</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">pnp_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smsc_ircc_open</span><span class="p">(</span><span class="n">firbase</span><span class="p">,</span> <span class="n">sirbase</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">irq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">smsc_ircc_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;smsc-ircc2&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">smsc_ircc_pnp_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">smsc_ircc_pnp_probe</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#else </span><span class="cm">/* CONFIG_PNP */</span><span class="cp"></span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">smsc_ircc_pnp_driver</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * SMSC-ircc stuff</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *******************************************************************************/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_ircc_legacy_probe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PCI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smsc_ircc_preconfigure_subsystems</span><span class="p">(</span><span class="n">ircc_cfg</span><span class="p">,</span> <span class="n">ircc_fir</span><span class="p">,</span> <span class="n">ircc_sir</span><span class="p">,</span> <span class="n">ircc_dma</span><span class="p">,</span> <span class="n">ircc_irq</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Ignore errors from preconfiguration */</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s, Preconfiguration failed !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ircc_fir</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ircc_sir</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot; Overriding FIR address 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ircc_fir</span><span class="p">);</span>
		<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot; Overriding SIR address 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ircc_sir</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">smsc_ircc_open</span><span class="p">(</span><span class="n">ircc_fir</span><span class="p">,</span> <span class="n">ircc_sir</span><span class="p">,</span> <span class="n">ircc_dma</span><span class="p">,</span> <span class="n">ircc_irq</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="cm">/* try user provided configuration register base address */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ircc_cfg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot; Overriding configuration address &quot;</span>
				     <span class="s">&quot;0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ircc_cfg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsc_superio_fdc</span><span class="p">(</span><span class="n">ircc_cfg</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsc_superio_lpc</span><span class="p">(</span><span class="n">ircc_cfg</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">smsc_ircc_look_for_chips</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_init ()</span>
<span class="cm"> *</span>
<span class="cm"> *    Initialize chip. Just try to find out how many chips we are dealing with</span>
<span class="cm"> *    and where they are</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_ircc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smsc_ircc_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s, Can&#39;t register driver!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smsc_nopnp</span> <span class="o">||</span> <span class="o">!</span><span class="n">pnp_platform_devices</span> <span class="o">||</span>
	    <span class="n">ircc_cfg</span> <span class="o">||</span> <span class="n">ircc_fir</span> <span class="o">||</span> <span class="n">ircc_sir</span> <span class="o">||</span>
	    <span class="n">ircc_dma</span> <span class="o">!=</span> <span class="n">DMA_INVAL</span> <span class="o">||</span> <span class="n">ircc_irq</span> <span class="o">!=</span> <span class="n">IRQ_INVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">smsc_ircc_legacy_probe</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smsc_ircc_pnp_driver</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pnp_driver_registered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnp_driver_registered</span><span class="p">)</span>
			<span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smsc_ircc_pnp_driver</span><span class="p">);</span>
		<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smsc_ircc_driver</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">smsc_ircc_net_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">115200</span><span class="p">)</span>
		<span class="k">return</span> 	<span class="n">smsc_ircc_hard_xmit_fir</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> 	<span class="n">smsc_ircc_hard_xmit_sir</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">smsc_ircc_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>       <span class="o">=</span> <span class="n">smsc_ircc_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>       <span class="o">=</span> <span class="n">smsc_ircc_net_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>   <span class="o">=</span> <span class="n">smsc_ircc_net_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">smsc_ircc_net_xmit</span><span class="p">,</span>
<span class="cp">#if SMSC_IRCC2_C_NET_TIMEOUT</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>	<span class="o">=</span> <span class="n">smsc_ircc_timeout</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_open (firbase, sirbase, dma, irq)</span>
<span class="cm"> *</span>
<span class="cm"> *    Try to open driver instance</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">smsc_ircc_open</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sir_base</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dma</span><span class="p">,</span> <span class="n">u8</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">smsc_ircc_present</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">sir_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_count</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dev_self</span><span class="p">))</span> <span class="p">{</span>
	        <span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), too many devices!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate new instance of the driver</span>
<span class="cm">	 */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_irdadev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s() can&#39;t allocate net device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#if SMSC_IRCC2_C_NET_TIMEOUT</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span>  <span class="o">=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="cm">/* Allow enough time for speed change */</span>
<span class="cp">#endif</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smsc_ircc_netdev_ops</span><span class="p">;</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Make ifconfig display some details */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span> <span class="o">=</span> <span class="n">fir_base</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>

	<span class="cm">/* Need to store self somewhere */</span>
	<span class="n">dev_self</span><span class="p">[</span><span class="n">dev_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_RX_BUFF_TRUESIZE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_TX_BUFF_TRUESIZE</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span>
		<span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s, Can&#39;t allocate memory for receive buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">driver_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span>
		<span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s, Can&#39;t allocate memory for transmit buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">driver_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">in_frame</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">OUTSIDE_FRAME</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>

	<span class="n">smsc_ircc_setup_io</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">sir_base</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="n">smsc_ircc_setup_qos</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="n">smsc_ircc_init_chip</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ircc_transceiver</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">&amp;&amp;</span>
	    <span class="n">ircc_transceiver</span> <span class="o">&lt;</span> <span class="n">SMSC_IRCC2_C_NUMBER_OF_TRANSCEIVERS</span><span class="p">)</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">ircc_transceiver</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">smsc_ircc_probe_transceiver</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s, Network device registration failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">driver_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span> <span class="o">=</span> <span class="n">platform_device_register_simple</span><span class="p">(</span><span class="n">SMSC_IRCC2_DRIVER_NAME</span><span class="p">,</span>
						      <span class="n">dev_count</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out5</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">platform_set_drvdata</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;IrDA: Registered device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">dev_count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_out5:</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

 <span class="nl">err_out4:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
			  <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff_dma</span><span class="p">);</span>
 <span class="nl">err_out3:</span>
	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
			  <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff_dma</span><span class="p">);</span>
 <span class="nl">err_out2:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">dev_self</span><span class="p">[</span><span class="n">dev_count</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="nl">err_out1:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">SMSC_IRCC2_FIR_CHIP_IO_EXTENT</span><span class="p">);</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">sir_base</span><span class="p">,</span> <span class="n">SMSC_IRCC2_SIR_CHIP_IO_EXTENT</span><span class="p">);</span>
 <span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_present(fir_base, sir_base)</span>
<span class="cm"> *</span>
<span class="cm"> *    Check the smsc-ircc chip presence</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_present</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sir_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">version</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">SMSC_IRCC2_FIR_CHIP_IO_EXTENT</span><span class="p">,</span>
			    <span class="n">driver_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t get fir_base of 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">fir_base</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">sir_base</span><span class="p">,</span> <span class="n">SMSC_IRCC2_SIR_CHIP_IO_EXTENT</span><span class="p">,</span>
			    <span class="n">driver_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t get sir_base of 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">sir_base</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="n">high</span>    <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_ID_HIGH</span><span class="p">);</span>
	<span class="n">low</span>     <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_ID_LOW</span><span class="p">);</span>
	<span class="n">chip</span>    <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_CHIP_ID</span><span class="p">);</span>
	<span class="n">version</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_VERSION</span><span class="p">);</span>
	<span class="n">config</span>  <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_INTERFACE</span><span class="p">);</span>
	<span class="n">dma</span>     <span class="o">=</span> <span class="n">config</span> <span class="o">&amp;</span> <span class="n">IRCC_INTERFACE_DMA_MASK</span><span class="p">;</span>
	<span class="n">irq</span>     <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">IRCC_INTERFACE_IRQ_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">high</span> <span class="o">!=</span> <span class="mh">0x10</span> <span class="o">||</span> <span class="n">low</span> <span class="o">!=</span> <span class="mh">0xb8</span> <span class="o">||</span> <span class="p">(</span><span class="n">chip</span> <span class="o">!=</span> <span class="mh">0xf1</span> <span class="o">&amp;&amp;</span> <span class="n">chip</span> <span class="o">!=</span> <span class="mh">0xf2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), addr 0x%04x - no device found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">fir_base</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;SMsC IrDA Controller found</span><span class="se">\n</span><span class="s"> IrCC version %d.%d, &quot;</span>
		     <span class="s">&quot;firport 0x%03x, sirport 0x%03x dma=%d, irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">chip</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">sir_base</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out3:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">sir_base</span><span class="p">,</span> <span class="n">SMSC_IRCC2_SIR_CHIP_IO_EXTENT</span><span class="p">);</span>
 <span class="nl">out2:</span>
	<span class="n">release_region</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">SMSC_IRCC2_FIR_CHIP_IO_EXTENT</span><span class="p">);</span>
 <span class="nl">out1:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_setup_io(self, fir_base, sir_base, dma, irq)</span>
<span class="cm"> *</span>
<span class="cm"> *    Setup I/O</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_setup_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sir_base</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="n">dma</span><span class="p">,</span> <span class="n">u8</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">config</span><span class="p">,</span> <span class="n">chip_dma</span><span class="p">,</span> <span class="n">chip_irq</span><span class="p">;</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">config</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_INTERFACE</span><span class="p">);</span>
	<span class="n">chip_dma</span> <span class="o">=</span> <span class="n">config</span> <span class="o">&amp;</span> <span class="n">IRCC_INTERFACE_DMA_MASK</span><span class="p">;</span>
	<span class="n">chip_irq</span> <span class="o">=</span> <span class="p">(</span><span class="n">config</span> <span class="o">&amp;</span> <span class="n">IRCC_INTERFACE_IRQ_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span>  <span class="o">=</span> <span class="n">fir_base</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span>  <span class="o">=</span> <span class="n">sir_base</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_ext</span>   <span class="o">=</span> <span class="n">SMSC_IRCC2_FIR_CHIP_IO_EXTENT</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_ext</span>   <span class="o">=</span> <span class="n">SMSC_IRCC2_SIR_CHIP_IO_EXTENT</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fifo_size</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_FIFO_SIZE</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_C_IRDA_FALLBACK_SPEED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">IRQ_INVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">chip_irq</span><span class="p">)</span>
			<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s, Overriding IRQ - chip says %d, using %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">driver_name</span><span class="p">,</span> <span class="n">chip_irq</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">chip_irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dma</span> <span class="o">!=</span> <span class="n">DMA_INVAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma</span> <span class="o">!=</span> <span class="n">chip_dma</span><span class="p">)</span>
			<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s, Overriding DMA - chip says %d, using %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">driver_name</span><span class="p">,</span> <span class="n">chip_dma</span><span class="p">,</span> <span class="n">dma</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span> <span class="o">=</span> <span class="n">chip_dma</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_setup_qos(self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Setup qos</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_setup_qos</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Initialize QoS for this device */</span>
	<span class="n">irda_init_max_qos_capabilies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">IR_9600</span><span class="o">|</span><span class="n">IR_19200</span><span class="o">|</span><span class="n">IR_38400</span><span class="o">|</span><span class="n">IR_57600</span><span class="o">|</span>
		<span class="n">IR_115200</span><span class="o">|</span><span class="n">IR_576000</span><span class="o">|</span><span class="n">IR_1152000</span><span class="o">|</span><span class="p">(</span><span class="n">IR_4000000</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_MIN_TURN_TIME</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">window_size</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_WINDOW_SIZE</span><span class="p">;</span>
	<span class="n">irda_qos_bits_to_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_init_chip(self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Init chip</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_init_chip</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_MASTER_RESET</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(((</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x87</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_CFGA_IRDA_SIR_A</span><span class="p">),</span>
	     <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGA</span><span class="p">);</span>

<span class="cp">#ifdef smsc_669 </span><span class="cm">/* Uses pin 88/89 for Rx/Tx */</span><span class="cp"></span>
	<span class="n">outb</span><span class="p">(((</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_CFGB_MUX_COM</span><span class="p">),</span>
	     <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">outb</span><span class="p">(((</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_CFGB_MUX_IR</span><span class="p">),</span>
	     <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_FIFO_THRESHOLD</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSC_IRCC2_FIFO_THRESHOLD</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_FIFO_THRESHOLD</span><span class="p">);</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">),</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_CONTROL</span><span class="p">);</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LCR_A</span><span class="p">);</span>

	<span class="n">smsc_ircc_set_sir_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">SMSC_IRCC2_C_IRDA_FALLBACK_SPEED</span><span class="p">);</span>

	<span class="cm">/* Power on device */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_net_ioctl (dev, rq, cmd)</span>
<span class="cm"> *</span>
<span class="cm"> *    Process IOCTL commands for this device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">if_irda_req</span> <span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">if_irda_req</span> <span class="o">*</span><span class="p">)</span> <span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), %s, (cmd=0x%X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCSBANDWIDTH</span>: <span class="cm">/* Set bandwidth */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
                <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Make sure we are the only one touching</span>
<span class="cm">			 * self-&gt;io.speed and the hardware - Jean II */</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">smsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">irq</span><span class="o">-&gt;</span><span class="n">ifr_baudrate</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCSMEDIABUSY</span>: <span class="cm">/* Set media busy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">irda_device_set_media_busy</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCGRECEIVING</span>: <span class="cm">/* Check if we are receiving right now */</span>
		<span class="n">irq</span><span class="o">-&gt;</span><span class="n">ifr_receiving</span> <span class="o">=</span> <span class="n">smsc_ircc_is_receiving</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	case SIOCSDTRRTS:</span>
<span class="c">		if (!capable(CAP_NET_ADMIN)) {</span>
<span class="c">			ret = -EPERM;</span>
<span class="c">			break;</span>
<span class="c">		}</span>
<span class="c">		smsc_ircc_sir_set_dtr_rts(dev, irq-&gt;ifr_dtr, irq-&gt;ifr_rts);</span>
<span class="c">		break;</span>
<span class="cp">	#endif</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if SMSC_IRCC2_C_NET_TIMEOUT</span>
<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_timeout (struct net_device *dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    The networking timeout management.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: transmit timed out, changing speed to: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">smsc_ircc_sir_start</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="n">smsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">trans_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="cm">/* prevent tx timeout */</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_hard_xmit_sir (struct sk_buff *skb, struct net_device *dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    Transmits the current frame until FIFO is full, then</span>
<span class="cm"> *    waits until the next transmit interrupt, and continues until the</span>
<span class="cm"> *    frame is transmitted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">smsc_ircc_hard_xmit_sir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">speed</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;);</span>

	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Make sure test of self-&gt;io.speed &amp; speed change are atomic */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Check if we need to change the speed */</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="n">irda_get_next_speed</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&amp;&amp;</span> <span class="n">speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for empty frame */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We send frames one by one in SIR mode (no</span>
<span class="cm">			 * pipelining), so at this point, if we were sending</span>
<span class="cm">			 * a previous frame, we just received the interrupt</span>
<span class="cm">			 * telling us it is finished (UART_IIR_THRI).</span>
<span class="cm">			 * Therefore, waiting for the transmitter to really</span>
<span class="cm">			 * finish draining the fifo won&#39;t take too long.</span>
<span class="cm">			 * And the interrupt handler is not expected to run.</span>
<span class="cm">			 * - Jean II */</span>
			<span class="n">smsc_ircc_sir_wait_hw_transmitter_finish</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">smsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init tx buffer */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/* Copy skb to tx_buff while wrapping, stuffing and making CRC */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">async_wrap_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
					   <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* Turn on transmit finished interrupt. Will fire immediately!  */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">UART_IER_THRI</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_set_fir_speed (self, baud)</span>
<span class="cm"> *</span>
<span class="cm"> *    Change the speed of the device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_set_fir_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">ir_mode</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">fast</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">fir_base</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">576000</span>:
		<span class="n">ir_mode</span> <span class="o">=</span> <span class="n">IRCC_CFGA_IRDA_HDLC</span><span class="p">;</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">IRCC_CRC</span><span class="p">;</span>
		<span class="n">fast</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), handling baud of 576000</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1152000</span>:
		<span class="n">ir_mode</span> <span class="o">=</span> <span class="n">IRCC_CFGA_IRDA_HDLC</span><span class="p">;</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">IRCC_1152</span> <span class="o">|</span> <span class="n">IRCC_CRC</span><span class="p">;</span>
		<span class="n">fast</span> <span class="o">=</span> <span class="n">IRCC_LCR_A_FAST</span> <span class="o">|</span> <span class="n">IRCC_LCR_A_GP_DATA</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), handling baud of 1152000</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4000000</span>:
		<span class="n">ir_mode</span> <span class="o">=</span> <span class="n">IRCC_CFGA_IRDA_4PPM</span><span class="p">;</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">IRCC_CRC</span><span class="p">;</span>
		<span class="n">fast</span> <span class="o">=</span> <span class="n">IRCC_LCR_A_FAST</span><span class="p">;</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), handling baud of 4000000</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	Now in tranceiver!</span>
<span class="c">	/* This causes an interrupt */</span>
<span class="c">	register_bank(fir_base, 0);</span>
<span class="c">	outb((inb(fir_base + IRCC_LCR_A) &amp;  0xbf) | fast, fir_base + IRCC_LCR_A);</span>
<span class="cp">	#endif</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(((</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRCC_SCE_CFGA_BLOCK_CTRL_BITS_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">ir_mode</span><span class="p">),</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGA</span><span class="p">);</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">|</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_CONTROL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_fir_start(self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Change the speed of the device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_fir_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fir_base</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">fir_base</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="cm">/* Reset everything */</span>

	<span class="cm">/* Clear FIFO */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_LCR_A</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_LCR_A_FIFO_RESET</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_LCR_A</span><span class="p">);</span>

	<span class="cm">/* Enable interrupt */</span>
	<span class="cm">/*outb(IRCC_IER_ACTIVE_FRAME|IRCC_IER_EOM, fir_base + IRCC_IER);*/</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Select the TX/RX interface */</span>
<span class="cp">#ifdef SMSC_669 </span><span class="cm">/* Uses pin 88/89 for Rx/Tx */</span><span class="cp"></span>
	<span class="n">outb</span><span class="p">(((</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_CFGB_MUX_COM</span><span class="p">),</span>
	     <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">outb</span><span class="p">(((</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_CFGB_MUX_IR</span><span class="p">),</span>
	     <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_FIFO_THRESHOLD</span><span class="p">);</span>

	<span class="cm">/* Enable SCE interrupts */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_IER_ACTIVE_FRAME</span> <span class="o">|</span> <span class="n">IRCC_IER_EOM</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_IER</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_MASTER_INT_EN</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_fir_stop(self, baud)</span>
<span class="cm"> *</span>
<span class="cm"> *    Change the speed of the device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_fir_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fir_base</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">fir_base</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*outb(IRCC_MASTER_RESET, fir_base + IRCC_MASTER);*/</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_LCR_B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRCC_LCR_B_SIP_ENABLE</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_LCR_B</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_change_speed(self, baud)</span>
<span class="cm"> *</span>
<span class="cm"> *    Change the speed of the device</span>
<span class="cm"> *</span>
<span class="cm"> * This function *must* be called with spinlock held, because it may</span>
<span class="cm"> * be called from the irq handler. - Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_change_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_speed_was_sir</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s() changing speed to: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">last_speed_was_sir</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&lt;=</span> <span class="n">SMSC_IRCC2_MAX_SIR_SPEED</span><span class="p">;</span>

	<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Temp Hack */</span>
<span class="c">	speed= 1152000;</span>
<span class="c">	self-&gt;io.speed = speed;</span>
<span class="c">	last_speed_was_sir = 0;</span>
<span class="c">	smsc_ircc_fir_start(self);</span>
<span class="cp">	#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">smsc_ircc_sir_start</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	if (!last_speed_was_sir) speed = self-&gt;io.speed;</span>
<span class="cp">	#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">speed</span><span class="p">)</span>
		<span class="n">smsc_ircc_set_transceiver_for_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">&lt;=</span> <span class="n">SMSC_IRCC2_MAX_SIR_SPEED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_speed_was_sir</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smsc_ircc_fir_stop</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">smsc_ircc_sir_start</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">smsc_ircc_set_sir_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_speed_was_sir</span><span class="p">)</span> <span class="p">{</span>
			<span class="cp">#if SMSC_IRCC2_C_SIR_STOP</span>
			<span class="n">smsc_ircc_sir_stop</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="cp">#endif</span>
			<span class="n">smsc_ircc_fir_start</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">smsc_ircc_set_fir_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>

		<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		self-&gt;tx_buff.len = 10;</span>
<span class="c">		self-&gt;tx_buff.data = self-&gt;tx_buff.head;</span>

<span class="c">		smsc_ircc_dma_xmit(self, 4000);</span>
<span class="cp">		#endif</span>
		<span class="cm">/* Be ready for incoming frames */</span>
		<span class="n">smsc_ircc_dma_receive</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_set_sir_speed (self, speed)</span>
<span class="cm"> *</span>
<span class="cm"> *    Set speed of IrDA port to specified baudrate</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_set_sir_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcr</span><span class="p">;</span>    <span class="cm">/* FIFO control reg */</span>
	<span class="kt">int</span> <span class="n">lcr</span><span class="p">;</span>    <span class="cm">/* Line control reg */</span>
	<span class="kt">int</span> <span class="n">divisor</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), Setting speed to: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">;</span>

	<span class="cm">/* Update accounting for new speed */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>

	<span class="cm">/* Turn off interrupts */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>

	<span class="n">divisor</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_MAX_SIR_SPEED</span> <span class="o">/</span> <span class="n">speed</span><span class="p">;</span>

	<span class="n">fcr</span> <span class="o">=</span> <span class="n">UART_FCR_ENABLE_FIFO</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use trigger level 1 to avoid 3 ms. timeout delay at 9600 bps, and</span>
<span class="cm">	 * almost 1,7 ms at 19200 bps. At speeds above that we can just forget</span>
<span class="cm">	 * about this timeout since it will always be fast enough.</span>
<span class="cm">	 */</span>
	<span class="n">fcr</span> <span class="o">|=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mi">38400</span> <span class="o">?</span>
		<span class="n">UART_FCR_TRIGGER_1</span> <span class="o">:</span> <span class="n">UART_FCR_TRIGGER_14</span><span class="p">;</span>

	<span class="cm">/* IrDA ports use 8N1 */</span>
	<span class="n">lcr</span> <span class="o">=</span> <span class="n">UART_LCR_WLEN8</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">UART_LCR_DLAB</span> <span class="o">|</span> <span class="n">lcr</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span> <span class="cm">/* Set DLAB */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">divisor</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span>      <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_DLL</span><span class="p">);</span> <span class="cm">/* Set speed */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">divisor</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span>	  <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_DLM</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">lcr</span><span class="p">,</span>		  <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span> <span class="cm">/* Set 8N1 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">fcr</span><span class="p">,</span>		  <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_FCR</span><span class="p">);</span> <span class="cm">/* Enable FIFO&#39;s */</span>

	<span class="cm">/* Turn on interrups */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">UART_IER_RLSI</span> <span class="o">|</span> <span class="n">UART_IER_RDI</span> <span class="o">|</span> <span class="n">UART_IER_THRI</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s() speed changed to: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_hard_xmit_fir (skb, dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    Transmit the frame!</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">smsc_ircc_hard_xmit_fir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">speed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mtt</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Make sure test of self-&gt;io.speed &amp; speed change are atomic */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Check if we need to change the speed after this frame */</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="n">irda_get_next_speed</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&amp;&amp;</span> <span class="n">speed</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for empty frame */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Note : you should make sure that speed changes</span>
<span class="cm">			 * are not going to corrupt any outgoing frame.</span>
<span class="cm">			 * Look at nsc-ircc for the gory details - Jean II */</span>
			<span class="n">smsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">speed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>

	<span class="n">mtt</span> <span class="o">=</span> <span class="n">irda_get_mtt</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mtt</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">bofs</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Compute how many BOFs (STA or PA&#39;s) we need to waste the</span>
<span class="cm">		 * min turn time given the speed of the link.</span>
<span class="cm">		 */</span>
		<span class="n">bofs</span> <span class="o">=</span> <span class="n">mtt</span> <span class="o">*</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8000</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bofs</span> <span class="o">&gt;</span> <span class="mi">4095</span><span class="p">)</span>
			<span class="n">bofs</span> <span class="o">=</span> <span class="mi">4095</span><span class="p">;</span>

		<span class="n">smsc_ircc_dma_xmit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">bofs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Transmit frame */</span>
		<span class="n">smsc_ircc_dma_xmit</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_dma_xmit (self, bofs)</span>
<span class="cm"> *</span>
<span class="cm"> *    Transmit data using DMA</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_dma_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="cp">#if 1</span>
	<span class="cm">/* Disable Rx */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LCR_B</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IRCC_CFGB_DMA_ENABLE</span><span class="p">,</span>
	     <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">IO_XMIT</span><span class="p">;</span>

	<span class="cm">/* Set BOF additional count for generating the min turn time */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">bofs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_BOF_COUNT_LO</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_CONTROL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">ctrl</span> <span class="o">|</span> <span class="p">((</span><span class="n">bofs</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">),</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_BOF_COUNT_HI</span><span class="p">);</span>

	<span class="cm">/* Set max Tx frame size */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_TX_SIZE_HI</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_TX_SIZE_LO</span><span class="p">);</span>

	<span class="cm">/*outb(UART_MCR_OUT2, self-&gt;io.sir_base + UART_MCR);*/</span>

	<span class="cm">/* Enable burst mode chip Tx DMA */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_CFGB_DMA_ENABLE</span> <span class="o">|</span>
	     <span class="n">IRCC_CFGB_DMA_BURST</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>

	<span class="cm">/* Setup DMA controller (must be done after enabling chip DMA) */</span>
	<span class="n">irda_setup_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff_dma</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
		       <span class="n">DMA_TX_MODE</span><span class="p">);</span>

	<span class="cm">/* Enable interrupt */</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_IER_ACTIVE_FRAME</span> <span class="o">|</span> <span class="n">IRCC_IER_EOM</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_IER</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_MASTER_INT_EN</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>

	<span class="cm">/* Enable transmit */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_LCR_B_SCE_TRANSMIT</span> <span class="o">|</span> <span class="n">IRCC_LCR_B_SIP_ENABLE</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LCR_B</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_dma_xmit_complete (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    The transfer of a frame in finished. This function will only be called</span>
<span class="cm"> *    by the interrupt handler</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_dma_xmit_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Disable Tx */</span>
<span class="c">	register_bank(iobase, 0);</span>
<span class="c">	outb(0x00, iobase + IRCC_LCR_B);</span>
<span class="cp">#endif</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IRCC_CFGB_DMA_ENABLE</span><span class="p">,</span>
	     <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>

	<span class="cm">/* Check for underrun! */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRCC_LSR_UNDERRUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Reset error condition */</span>
		<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_MASTER_ERROR_RESET</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check if it&#39;s time to change the speed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_dma_receive(self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Get ready for receiving a frame. The device will initiate a DMA</span>
<span class="cm"> *    if it starts to receive a frame.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_dma_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Turn off chip DMA */</span>
<span class="c">	register_bank(iobase, 1);</span>
<span class="c">	outb(inb(iobase + IRCC_SCE_CFGB) &amp; ~IRCC_CFGB_DMA_ENABLE,</span>
<span class="c">	     iobase + IRCC_SCE_CFGB);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Disable Tx */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LCR_B</span><span class="p">);</span>

	<span class="cm">/* Turn off chip DMA */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IRCC_CFGB_DMA_ENABLE</span><span class="p">,</span>
	     <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">IO_RECV</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>

	<span class="cm">/* Set max Rx frame size */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">((</span><span class="mi">2050</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_RX_SIZE_HI</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">2050</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_RX_SIZE_LO</span><span class="p">);</span>

	<span class="cm">/* Setup DMA controller */</span>
	<span class="n">irda_setup_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff_dma</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
		       <span class="n">DMA_RX_MODE</span><span class="p">);</span>

	<span class="cm">/* Enable burst mode chip Rx DMA */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_CFGB_DMA_ENABLE</span> <span class="o">|</span>
	     <span class="n">IRCC_CFGB_DMA_BURST</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGB</span><span class="p">);</span>

	<span class="cm">/* Enable interrupt */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_IER_ACTIVE_FRAME</span> <span class="o">|</span> <span class="n">IRCC_IER_EOM</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_IER</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_MASTER_INT_EN</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>

	<span class="cm">/* Enable receiver */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_LCR_B_SCE_RECEIVE</span> <span class="o">|</span> <span class="n">IRCC_LCR_B_SIP_ENABLE</span><span class="p">,</span>
	     <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LCR_B</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_dma_receive_complete(self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Finished with receiving frames</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_dma_receive_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">msgcnt</span><span class="p">,</span> <span class="n">lsr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Disable Rx */</span>
<span class="c">	register_bank(iobase, 0);</span>
<span class="c">	outb(0x00, iobase + IRCC_LCR_B);</span>
<span class="cp">#endif</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LSAR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IRCC_LSAR_ADDRESS_MASK</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LSAR</span><span class="p">);</span>
	<span class="n">lsr</span><span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LSR</span><span class="p">);</span>
	<span class="n">msgcnt</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LCR_B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s: dma count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">get_dma_residue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">));</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span> <span class="o">-</span> <span class="n">get_dma_residue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>

	<span class="cm">/* Look for errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lsr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IRCC_LSR_FRAME_ERROR</span> <span class="o">|</span> <span class="n">IRCC_LSR_CRC_ERROR</span> <span class="o">|</span> <span class="n">IRCC_LSR_SIZE_ERROR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lsr</span> <span class="o">&amp;</span> <span class="n">IRCC_LSR_FRAME_ERROR</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lsr</span> <span class="o">&amp;</span> <span class="n">IRCC_LSR_CRC_ERROR</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lsr</span> <span class="o">&amp;</span> <span class="n">IRCC_LSR_SIZE_ERROR</span><span class="p">)</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lsr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IRCC_LSR_UNDERRUN</span> <span class="o">|</span> <span class="n">IRCC_LSR_OVERRUN</span><span class="p">))</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove CRC */</span>
	<span class="n">len</span> <span class="o">-=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mi">4000000</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2050</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), bogus len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s: msgcnt = %d, len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">msgcnt</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), memory squeeze, dropping frame.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Make sure IP header gets aligned */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IRDA</span><span class="p">);</span>
	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_sir_receive (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Receive one frame from the infrared port</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_sir_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">boguscount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Receive all characters in Rx FIFO, unwrap and unstuff them.</span>
<span class="cm">         * async_unwrap_char will deliver all found frames</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">async_unwrap_char</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">,</span>
				  <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_RX</span><span class="p">));</span>

		<span class="cm">/* Make sure we don&#39;t stay here to long */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boguscount</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), breaking!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_LSR_DR</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_interrupt (irq, dev_id, regs)</span>
<span class="cm"> *</span>
<span class="cm"> *    An interrupt from the chip has arrived. Time to do some work</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">smsc_ircc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">dummy</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="n">iir</span><span class="p">,</span> <span class="n">lcra</span><span class="p">,</span> <span class="n">lsr</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Serialise the interrupt handler in various CPUs, stop Tx path */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Check if we should use the SIR interrupt handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&lt;=</span> <span class="n">SMSC_IRCC2_MAX_SIR_SPEED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">smsc_ircc_interrupt_sir</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">irq_ret_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iir</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_IIR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iir</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">irq_ret_unlock</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="cm">/* Disable interrupts */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_IER</span><span class="p">);</span>
	<span class="n">lcra</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LCR_A</span><span class="p">);</span>
	<span class="n">lsr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_LSR</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), iir = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">iir</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iir</span> <span class="o">&amp;</span> <span class="n">IRCC_IIR_EOM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">IO_RECV</span><span class="p">)</span>
			<span class="n">smsc_ircc_dma_receive_complete</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">smsc_ircc_dma_xmit_complete</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

		<span class="n">smsc_ircc_dma_receive</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iir</span> <span class="o">&amp;</span> <span class="n">IRCC_IIR_ACTIVE_FRAME</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*printk(KERN_WARNING &quot;%s(): Active Frame\n&quot;, __func__);*/</span>
	<span class="p">}</span>

	<span class="cm">/* Enable interrupts again */</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_IER_ACTIVE_FRAME</span> <span class="o">|</span> <span class="n">IRCC_IER_EOM</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_IER</span><span class="p">);</span>

 <span class="nl">irq_ret_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function irport_interrupt_sir (irq, dev_id)</span>
<span class="cm"> *</span>
<span class="cm"> *    Interrupt handler for SIR modes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">smsc_ircc_interrupt_sir</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">boguscount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iir</span><span class="p">,</span> <span class="n">lsr</span><span class="p">;</span>

	<span class="cm">/* Already locked coming here in smsc_ircc_interrupt() */</span>
	<span class="cm">/*spin_lock(&amp;self-&gt;lock);*/</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">;</span>

	<span class="n">iir</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_IIR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_IIR_ID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iir</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">iir</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear interrupt */</span>
		<span class="n">lsr</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_LSR</span><span class="p">);</span>

		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s(), iir=%02x, lsr=%02x, iobase=%#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">__func__</span><span class="p">,</span> <span class="n">iir</span><span class="p">,</span> <span class="n">lsr</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">iir</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">UART_IIR_RLSI</span>:
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;%s(), RLSI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">UART_IIR_RDI</span>:
			<span class="cm">/* Receive interrupt */</span>
			<span class="n">smsc_ircc_sir_receive</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">UART_IIR_THRI</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">lsr</span> <span class="o">&amp;</span> <span class="n">UART_LSR_THRE</span><span class="p">)</span>
				<span class="cm">/* Transmitter ready for data */</span>
				<span class="n">smsc_ircc_sir_write_wakeup</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unhandled IIR=%#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">,</span> <span class="n">iir</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Make sure we don&#39;t stay here to long */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">boguscount</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	        <span class="n">iir</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_IIR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_IIR_ID</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*spin_unlock(&amp;self-&gt;lock);*/</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#if 0</span><span class="c"> /* unused */</span>
<span class="c">/*</span>
<span class="c"> * Function ircc_is_receiving (self)</span>
<span class="c"> *</span>
<span class="c"> *    Return TRUE is we are currently receiving a frame</span>
<span class="c"> *</span>
<span class="c"> */</span>
<span class="c">static int ircc_is_receiving(struct smsc_ircc_cb *self)</span>
<span class="c">{</span>
<span class="c">	int status = FALSE;</span>
<span class="c">	/* int iobase; */</span>

<span class="c">	IRDA_DEBUG(1, &quot;%s\n&quot;, __func__);</span>

<span class="c">	IRDA_ASSERT(self != NULL, return FALSE;);</span>

<span class="c">	IRDA_DEBUG(0, &quot;%s: dma count = %d\n&quot;, __func__,</span>
<span class="c">		   get_dma_residue(self-&gt;io.dma));</span>

<span class="c">	status = (self-&gt;rx_buff.state != OUTSIDE_FRAME);</span>

<span class="c">	return status;</span>
<span class="c">}</span>
<span class="cp">#endif /* unused */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">smsc_ircc_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			    <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unable to allocate irq=%d, err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_start_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">smsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">SMSC_IRCC2_C_IRDA_FALLBACK_SPEED</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_stop_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_IER</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_MASTER_RESET</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_net_open (dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    Start the device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">hwname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), device is suspended</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">smsc_ircc_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), unable to allocate irq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">smsc_ircc_start_interrupts</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Give self a hardware name */</span>
	<span class="cm">/* It would be cool to offer the chip revision here - Jean II */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">hwname</span><span class="p">,</span> <span class="s">&quot;SMSC @ 0x%03x&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Open new IrLAP layer instance, now that everything should be</span>
<span class="cm">	 * initialized properly</span>
<span class="cm">	 */</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="n">irlap_open</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">,</span> <span class="n">hwname</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always allocate the DMA channel after the IRQ,</span>
<span class="cm">	 * and clean up on failure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">smsc_ircc_net_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), unable to allocate DMA=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_net_close (dev)</span>
<span class="cm"> *</span>
<span class="cm"> *    Stop the device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>
	<span class="n">self</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;);</span>

	<span class="cm">/* Stop device */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Stop and remove instance of IrLAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">)</span>
		<span class="n">irlap_close</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
	<span class="n">self</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">smsc_ircc_stop_interrupts</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* if we are called from smsc_ircc_resume we don&#39;t have IRQ reserved */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">disable_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">free_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s, Suspending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>

		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">smsc_ircc_stop_interrupts</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">free_irq</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
			<span class="n">disable_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s, Waking up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">);</span>

		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">smsc_ircc_init_chip</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">smsc_ircc_request_irq</span><span class="p">(</span><span class="n">self</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Don&#39;t fail resume process, just kill this</span>
<span class="cm">				 * network interface</span>
<span class="cm">				 */</span>
				<span class="n">unregister_netdevice</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">enable_dma</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">dma</span><span class="p">);</span>
				<span class="n">smsc_ircc_start_interrupts</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
				<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">suspended</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_close (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Close driver instance</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__exit</span> <span class="nf">smsc_ircc_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;);</span>

	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">pldev</span><span class="p">);</span>

	<span class="cm">/* Remove netdevice */</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">smsc_ircc_stop_interrupts</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

	<span class="cm">/* Release the PORTS that this driver is using */</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), releasing 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">);</span>

	<span class="n">release_region</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_ext</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(), releasing 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		   <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">);</span>

	<span class="n">release_region</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_ext</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
				  <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff_dma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span><span class="p">,</span>
				  <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff_dma</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">smsc_ircc_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">smsc_ircc_close</span><span class="p">(</span><span class="n">dev_self</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnp_driver_registered</span><span class="p">)</span>
		<span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smsc_ircc_pnp_driver</span><span class="p">);</span>

	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smsc_ircc_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Start SIR operations</span>
<span class="cm"> *</span>
<span class="cm"> * This function *must* be called with spinlock held, because it may</span>
<span class="cm"> * be called from the irq handler (via smsc_ircc_change_speed()). - Jean II</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_sir_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">sir_base</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">fir_base</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">;</span>
	<span class="n">sir_base</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">;</span>

	<span class="cm">/* Reset everything */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">IRCC_MASTER_RESET</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>

	<span class="cp">#if SMSC_IRCC2_C_SIR_STOP</span>
	<span class="cm">/*smsc_ircc_sir_stop(self);*/</span>
	<span class="cp">#endif</span>

	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(((</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRCC_SCE_CFGA_BLOCK_CTRL_BITS_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_CFGA_IRDA_SIR_A</span><span class="p">),</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_SCE_CFGA</span><span class="p">);</span>

	<span class="cm">/* Initialize UART */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">UART_LCR_WLEN8</span><span class="p">,</span> <span class="n">sir_base</span> <span class="o">+</span> <span class="n">UART_LCR</span><span class="p">);</span>  <span class="cm">/* Reset DLAB */</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">UART_MCR_DTR</span> <span class="o">|</span> <span class="n">UART_MCR_RTS</span> <span class="o">|</span> <span class="n">UART_MCR_OUT2</span><span class="p">),</span> <span class="n">sir_base</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>

	<span class="cm">/* Turn on interrups */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">UART_IER_RLSI</span> <span class="o">|</span> <span class="n">UART_IER_RDI</span> <span class="o">|</span><span class="n">UART_IER_THRI</span><span class="p">,</span> <span class="n">sir_base</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s() - exit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_MASTER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if SMSC_IRCC2_C_SIR_STOP</span>
<span class="kt">void</span> <span class="nf">smsc_ircc_sir_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">;</span>

	<span class="cm">/* Reset UART */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_MCR</span><span class="p">);</span>

	<span class="cm">/* Turn off interrupts */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_sir_write_wakeup (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Called by the SIR interrupt handler when there&#39;s room for more data.</span>
<span class="cm"> *    If we have more packets to send, we send them here.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_sir_write_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcr</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">;</span>

	<span class="cm">/* Finished with frame?  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
		<span class="cm">/* Write data left in transmit buffer */</span>
		<span class="n">actual</span> <span class="o">=</span> <span class="n">smsc_ircc_sir_write</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fifo_size</span><span class="p">,</span>
				      <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">actual</span><span class="p">;</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">tx_buff</span><span class="p">.</span><span class="n">len</span>  <span class="o">-=</span> <span class="n">actual</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

	<span class="cm">/*if (self-&gt;tx_buff.len ==0)  {*/</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Now serial buffer is almost free &amp; we can start</span>
<span class="cm">		 *  transmission of another packet. But first we must check</span>
<span class="cm">		 *  if we need to change the speed of the hardware</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;%s(), Changing speed to %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">__func__</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">);</span>
			<span class="n">smsc_ircc_sir_wait_hw_transmitter_finish</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
			<span class="n">smsc_ircc_change_speed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Tell network layer that we want more frames */</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">self</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&lt;=</span> <span class="mi">115200</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Reset Rx FIFO to make sure that all reflected transmit data</span>
<span class="cm">			 * is discarded. This is needed for half duplex operation</span>
<span class="cm">			 */</span>
			<span class="n">fcr</span> <span class="o">=</span> <span class="n">UART_FCR_ENABLE_FIFO</span> <span class="o">|</span> <span class="n">UART_FCR_CLEAR_RCVR</span><span class="p">;</span>
			<span class="n">fcr</span> <span class="o">|=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mi">38400</span> <span class="o">?</span>
					<span class="n">UART_FCR_TRIGGER_1</span> <span class="o">:</span> <span class="n">UART_FCR_TRIGGER_14</span><span class="p">;</span>

			<span class="n">outb</span><span class="p">(</span><span class="n">fcr</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_FCR</span><span class="p">);</span>

			<span class="cm">/* Turn on receive interrupts */</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">UART_IER_RDI</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_IER</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_sir_write (iobase, fifo_size, buf, len)</span>
<span class="cm"> *</span>
<span class="cm"> *    Fill Tx FIFO with transmit data</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_sir_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">iobase</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fifo_size</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">actual</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Tx FIFO should be empty! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_LSR_THRE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(), failed, fifo not empty!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill FIFO with current frame */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fifo_size</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">actual</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Transmit next byte */</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">actual</span><span class="p">],</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_TX</span><span class="p">);</span>
		<span class="n">actual</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">actual</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_is_receiving (self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Returns true is we are currently receiving data</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_is_receiving</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">OUTSIDE_FRAME</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_probe_transceiver(self)</span>
<span class="cm"> *</span>
<span class="cm"> *    Tries to find the used Transceiver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_probe_transceiver</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">IRDA_ASSERT</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">return</span><span class="p">;);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">smsc_transceivers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">smsc_transceivers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">probe</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot; %s transceiver found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">smsc_transceivers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
			<span class="n">self</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;No transceiver found. Defaulting to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">smsc_transceivers</span><span class="p">[</span><span class="n">SMSC_IRCC2_C_DEFAULT_TRANSCEIVER</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>

	<span class="n">self</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_C_DEFAULT_TRANSCEIVER</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_set_transceiver_for_speed(self, speed)</span>
<span class="cm"> *</span>
<span class="cm"> *    Set the transceiver according to the speed</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_set_transceiver_for_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">trx</span><span class="p">;</span>

	<span class="n">trx</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">transceiver</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">smsc_transceivers</span><span class="p">[</span><span class="n">trx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">set_for_speed</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">fir_base</span><span class="p">,</span> <span class="n">speed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_wait_hw_transmitter_finish ()</span>
<span class="cm"> *</span>
<span class="cm"> *    Wait for the real end of HW transmission</span>
<span class="cm"> *</span>
<span class="cm"> * The UART is a strict FIFO, and we get called only when we have finished</span>
<span class="cm"> * pushing data to the FIFO, so the maximum amount of time we must wait</span>
<span class="cm"> * is only for the FIFO to drain out.</span>
<span class="cm"> *</span>
<span class="cm"> * We use a simple calibrated loop. We may need to adjust the loop</span>
<span class="cm"> * delay (udelay) to balance I/O traffic and latency. And we also need to</span>
<span class="cm"> * adjust the maximum timeout.</span>
<span class="cm"> * It would probably be better to wait for the proper interrupt,</span>
<span class="cm"> * but it doesn&#39;t seem to be available.</span>
<span class="cm"> *</span>
<span class="cm"> * We can&#39;t use jiffies or kernel timers because :</span>
<span class="cm"> * 1) We are called from the interrupt handler, which disable softirqs,</span>
<span class="cm"> * so jiffies won&#39;t be increased</span>
<span class="cm"> * 2) Jiffies granularity is usually very coarse (10ms), and we don&#39;t</span>
<span class="cm"> * want to wait that long to detect stuck hardware.</span>
<span class="cm"> * Jean II</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_sir_wait_hw_transmitter_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_cb</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">io</span><span class="p">.</span><span class="n">sir_base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">SMSC_IRCC2_HW_TRANSMITTER_TIMEOUT_US</span><span class="p">;</span>

	<span class="cm">/* Calibrated busy loop */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">UART_LSR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">UART_LSR_TEMT</span><span class="p">))</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;%s(): stuck transmitter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* PROBING</span>
<span class="cm"> *</span>
<span class="cm"> * REVISIT we can be told about the device by PNP, and should use that info</span>
<span class="cm"> * instead of probing hardware and creating a platform_device ...</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_ircc_look_for_chips</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smsc_chip_address</span> <span class="o">*</span><span class="n">address</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">address</span> <span class="o">=</span> <span class="n">possible_addresses</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg_base</span> <span class="o">=</span> <span class="n">address</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">;</span>

		<span class="cm">/*printk(KERN_WARNING &quot;%s(): probing: 0x%02x for: 0x%02x\n&quot;, __func__, cfg_base, address-&gt;type);*/</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SMSCSIO_TYPE_FDC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;FDC&quot;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SMSCSIO_TYPE_FLAT</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsc_superio_flat</span><span class="p">(</span><span class="n">fdc_chips_flat</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span>
					<span class="n">found</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SMSCSIO_TYPE_PAGED</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsc_superio_paged</span><span class="p">(</span><span class="n">fdc_chips_paged</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span>
					<span class="n">found</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SMSCSIO_TYPE_LPC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;LPC&quot;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SMSCSIO_TYPE_FLAT</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsc_superio_flat</span><span class="p">(</span><span class="n">lpc_chips_flat</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span>
					<span class="n">found</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">address</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">SMSCSIO_TYPE_PAGED</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsc_superio_paged</span><span class="p">(</span><span class="n">lpc_chips_paged</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="n">type</span><span class="p">))</span>
					<span class="n">found</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">address</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_superio_flat (chip, base, type)</span>
<span class="cm"> *</span>
<span class="cm"> *    Try to get configuration of a smc SuperIO chip with flat register model</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_superio_flat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="o">*</span><span class="n">chips</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfgbase</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">firbase</span><span class="p">,</span> <span class="n">sirbase</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smsc_ircc_probe</span><span class="p">(</span><span class="n">cfgbase</span><span class="p">,</span> <span class="n">SMSCSIOFLAT_DEVICEID_REG</span><span class="p">,</span> <span class="n">chips</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_UARTMODE0C_REG</span><span class="p">,</span> <span class="n">cfgbase</span><span class="p">);</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfgbase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*printk(KERN_WARNING &quot;%s(): mode: 0x%02x\n&quot;, __func__, mode);*/</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">SMSCSIOFLAT_UART2MODE_VAL_IRDA</span><span class="p">))</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(): IrDA not enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_UART2BASEADDR_REG</span><span class="p">,</span> <span class="n">cfgbase</span><span class="p">);</span>
	<span class="n">sirbase</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfgbase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* FIR iobase */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_FIRBASEADDR_REG</span><span class="p">,</span> <span class="n">cfgbase</span><span class="p">);</span>
	<span class="n">firbase</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfgbase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* DMA */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_FIRDMASELECT_REG</span><span class="p">,</span> <span class="n">cfgbase</span><span class="p">);</span>
	<span class="n">dma</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfgbase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SMSCSIOFLAT_FIRDMASELECT_MASK</span><span class="p">;</span>

	<span class="cm">/* IRQ */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_UARTIRQSELECT_REG</span><span class="p">,</span> <span class="n">cfgbase</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfgbase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SMSCSIOFLAT_UART2IRQSELECT_MASK</span><span class="p">;</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;%s(): fir: 0x%02x, sir: 0x%02x, dma: %02d, irq: %d, mode: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">firbase</span><span class="p">,</span> <span class="n">sirbase</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">firbase</span> <span class="o">&amp;&amp;</span> <span class="n">smsc_ircc_open</span><span class="p">(</span><span class="n">firbase</span><span class="p">,</span> <span class="n">sirbase</span><span class="p">,</span> <span class="n">dma</span><span class="p">,</span> <span class="n">irq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Exit configuration */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIO_CFGEXITKEY</span><span class="p">,</span> <span class="n">cfgbase</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_superio_paged (chip, base, type)</span>
<span class="cm"> *</span>
<span class="cm"> *    Try  to get configuration of a smc SuperIO chip with paged register model</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_superio_paged</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="o">*</span><span class="n">chips</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">fir_io</span><span class="p">,</span> <span class="n">sir_io</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smsc_ircc_probe</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">chips</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Select logical device (UART2) */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x07</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x05</span><span class="p">,</span> <span class="n">cfg_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* SIR iobase */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x60</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">sir_io</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x61</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">sir_io</span> <span class="o">|=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Read FIR base */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x62</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">fir_io</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x63</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="n">fir_io</span> <span class="o">|=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x2b</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span> <span class="cm">/* ??? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fir_io</span> <span class="o">&amp;&amp;</span> <span class="n">smsc_ircc_open</span><span class="p">(</span><span class="n">fir_io</span><span class="p">,</span> <span class="n">sir_io</span><span class="p">,</span> <span class="n">ircc_dma</span><span class="p">,</span> <span class="n">ircc_irq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Exit configuration */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIO_CFGEXITKEY</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_access</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reg</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">smsc_ircc_probe</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="n">u8</span> <span class="n">reg</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">smsc_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">devid</span><span class="p">,</span> <span class="n">xdevid</span><span class="p">,</span> <span class="n">rev</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="cm">/* Leave configuration */</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIO_CFGEXITKEY</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">)</span> <span class="o">==</span> <span class="n">SMSCSIO_CFGEXITKEY</span><span class="p">)</span>	<span class="cm">/* not a smc superio chip */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>

	<span class="n">xdevid</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Enter configuration */</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIO_CFGACCESSKEY</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>

	<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	if (smsc_access(cfg_base,0x55))	/* send second key and check */</span>
<span class="c">		return NULL;</span>
<span class="cp">	#endif</span>

	<span class="cm">/* probe device ID */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smsc_access</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">,</span> <span class="n">reg</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">devid</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devid</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">devid</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>	<span class="cm">/* typical values for unused port */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* probe revision ID */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smsc_access</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">,</span> <span class="n">reg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rev</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">cfg_base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rev</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span>			<span class="cm">/* i think this will make no sense */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devid</span> <span class="o">==</span> <span class="n">xdevid</span><span class="p">)</span>		<span class="cm">/* protection against false positives */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Check for expected device ID; are there others? */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">devid</span> <span class="o">!=</span> <span class="n">devid</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">chip</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;found SMC SuperIO Chip (devid=0x%02x rev=%02X base=0x%04x): %s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">devid</span><span class="p">,</span> <span class="n">rev</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">&gt;</span> <span class="n">rev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;Revision higher than expected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NoIRDA</span><span class="p">)</span>
		<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;chipset does not support IRDA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chip</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_superio_fdc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t get cfg_base of 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsc_superio_flat</span><span class="p">(</span><span class="n">fdc_chips_flat</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="s">&quot;FDC&quot;</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">smsc_superio_paged</span><span class="p">(</span><span class="n">fdc_chips_paged</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="s">&quot;FDC&quot;</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>

		<span class="n">release_region</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_superio_lpc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cfg_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">driver_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s: can&#39;t get cfg_base of 0x%03x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">__func__</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smsc_superio_flat</span><span class="p">(</span><span class="n">lpc_chips_flat</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="s">&quot;LPC&quot;</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">smsc_superio_paged</span><span class="p">(</span><span class="n">lpc_chips_paged</span><span class="p">,</span> <span class="n">cfg_base</span><span class="p">,</span> <span class="s">&quot;LPC&quot;</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">release_region</span><span class="p">(</span><span class="n">cfg_base</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Look for some specific subsystem setups that need</span>
<span class="cm"> * pre-configuration not properly done by the BIOS (especially laptops)</span>
<span class="cm"> * This code is based in part on smcinit.c, tosh1800-smcinit.c</span>
<span class="cm"> * and tosh2450-smcinit.c. The table lists the device entries</span>
<span class="cm"> * for ISA bridges with an LPC (Low Pin Count) controller which</span>
<span class="cm"> * handles the communication with the SMSC device. After the LPC</span>
<span class="cm"> * controller is initialized through PCI, the SMSC device is initialized</span>
<span class="cm"> * through a dedicated port in the ISA port-mapped I/O area, this latter</span>
<span class="cm"> * area is used to configure the SMSC device with default</span>
<span class="cm"> * SIR and FIR I/O ports, DMA and IRQ. Different vendors have</span>
<span class="cm"> * used different sets of parameters and different control port</span>
<span class="cm"> * addresses making a subsystem device table necessary.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span> <span class="n">subsystem_configurations</span><span class="p">[]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Subsystems needing entries:</span>
<span class="cm">	 * 0x10b9:0x1533 0x103c:0x0850 HP nx9010 family</span>
<span class="cm">	 * 0x10b9:0x1533 0x0e11:0x005a Compaq nc4000 family</span>
<span class="cm">	 * 0x8086:0x24cc 0x0e11:0x002a HP nx9000 family</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="cm">/* Guessed entry */</span>
		<span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="cm">/* Intel 82801DBM LPC bridge */</span>
		<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="mh">0x24cc</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="mh">0x103c</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mh">0x08bc</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="mh">0x02f8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="mh">0x0130</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="mh">0x004e</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preconfigure</span> <span class="o">=</span> <span class="n">preconfigure_through_82801</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;HP nx5000 family&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="cm">/* Intel 82801DBM LPC bridge */</span>
		<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="mh">0x24cc</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="mh">0x103c</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mh">0x088c</span><span class="p">,</span>
		<span class="cm">/* Quite certain these are the same for nc8000 as for nc6000 */</span>
		<span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="mh">0x02f8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="mh">0x0130</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="mh">0x004e</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preconfigure</span> <span class="o">=</span> <span class="n">preconfigure_through_82801</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;HP nc8000 family&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="cm">/* Intel 82801DBM LPC bridge */</span>
		<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="mh">0x24cc</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="mh">0x103c</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mh">0x0890</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="mh">0x02f8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="mh">0x0130</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="mh">0x05</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="mh">0x004e</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preconfigure</span> <span class="o">=</span> <span class="n">preconfigure_through_82801</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;HP nc6000 family&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="cm">/* Intel 82801DBM LPC bridge */</span>
		<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="mh">0x24cc</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="mh">0x0e11</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mh">0x0860</span><span class="p">,</span>
		<span class="cm">/* I assume these are the same for x1000 as for the others */</span>
		<span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="mh">0x02e8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="mh">0x02f8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="mh">0x002e</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preconfigure</span> <span class="o">=</span> <span class="n">preconfigure_through_82801</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Compaq x1000 family&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="cm">/* Intel 82801DB/DBL (ICH4/ICH4-L) LPC Interface Bridge */</span>
		<span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="mh">0x24c0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="mh">0x1179</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="cm">/* 0xffff is &quot;any&quot; */</span>
		<span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="mh">0x03f8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="mh">0x0130</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="mh">0x002e</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preconfigure</span> <span class="o">=</span> <span class="n">preconfigure_through_82801</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Toshiba laptop with Intel 82801DB/DBL LPC bridge&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="cm">/* Intel 82801CAM ISA bridge */</span>
		<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="mh">0x248c</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="mh">0x1179</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="cm">/* 0xffff is &quot;any&quot; */</span>
		<span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="mh">0x03f8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="mh">0x0130</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="mh">0x002e</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preconfigure</span> <span class="o">=</span> <span class="n">preconfigure_through_82801</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Toshiba laptop with Intel 82801CAM ISA bridge&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="cm">/* 82801DBM (ICH4-M) LPC Interface Bridge */</span>
		<span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="mh">0x24cc</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="mh">0x1179</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="cm">/* 0xffff is &quot;any&quot; */</span>
		<span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="mh">0x03f8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="mh">0x0130</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="mh">0x002e</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preconfigure</span> <span class="o">=</span> <span class="n">preconfigure_through_82801</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Toshiba laptop with Intel 8281DBM LPC bridge&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="cm">/* ALi M1533/M1535 PCI to ISA Bridge [Aladdin IV/V/V+] */</span>
		<span class="p">.</span><span class="n">vendor</span> <span class="o">=</span> <span class="n">PCI_VENDOR_ID_AL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="mh">0x1533</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subvendor</span> <span class="o">=</span> <span class="mh">0x1179</span><span class="p">,</span>
		<span class="p">.</span><span class="n">subdevice</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="cm">/* 0xffff is &quot;any&quot; */</span>
		<span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="mh">0x02e8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="mh">0x02f8</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="mh">0x07</span><span class="p">,</span>
		<span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">,</span>
		<span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="mh">0x002e</span><span class="p">,</span>
		<span class="p">.</span><span class="n">preconfigure</span> <span class="o">=</span> <span class="n">preconfigure_through_ali</span><span class="p">,</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Toshiba laptop with ALi ISA bridge&quot;</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span> <span class="c1">// Terminator</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * This sets up the basic SMSC parameters</span>
<span class="cm"> * (FIR port, SIR port, FIR DMA, FIR IRQ)</span>
<span class="cm"> * through the chip configuration port.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">preconfigure_smsc_chip</span><span class="p">(</span><span class="k">struct</span>
					 <span class="n">smsc_ircc_subsystem_configuration</span>
					 <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">iobase</span> <span class="o">=</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmpbyte</span><span class="p">;</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">LPC47N227_CFGACCESSKEY</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span> <span class="c1">// enter configuration state</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_DEVICEID_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span> <span class="c1">// set for device ID</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Read device ID</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
		   <span class="s">&quot;Detected Chip id: 0x%02x, setting up registers...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">tmpbyte</span><span class="p">);</span>

	<span class="cm">/* Disable UART1 and set up SIR I/O port */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x24</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// select CR24 - UART1 base addr</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// disable UART1</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_UART2BASEADDR_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// select CR25 - UART2 base addr</span>
	<span class="n">outb</span><span class="p">(</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">sir_io</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// bits 2-9 of 0x3f8</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmpbyte</span> <span class="o">!=</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">sir_io</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;ERROR: could not configure SIR ioport.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;Try to supply ircc_cfg argument.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up FIR IRQ channel for UART2 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_UARTIRQSELECT_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span> <span class="c1">// select CR28 - UART1,2 IRQ select</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tmpbyte</span> <span class="o">&amp;=</span> <span class="n">SMSCSIOFLAT_UART1IRQSELECT_MASK</span><span class="p">;</span> <span class="c1">// Do not touch the UART1 portion</span>
	<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_irq</span> <span class="o">&amp;</span> <span class="n">SMSCSIOFLAT_UART2IRQSELECT_MASK</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">tmpbyte</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SMSCSIOFLAT_UART2IRQSELECT_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmpbyte</span> <span class="o">!=</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;ERROR: could not configure FIR IRQ channel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up FIR I/O port */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_FIRBASEADDR_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// CR2B - SCE (FIR) base addr</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_io</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">),</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmpbyte</span> <span class="o">!=</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_io</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;ERROR: could not configure FIR I/O port.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up FIR DMA channel */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_FIRDMASELECT_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// CR2C - SCE (FIR) DMA select</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_dma</span> <span class="o">&amp;</span> <span class="n">LPC47N227_FIRDMASELECT_MASK</span><span class="p">),</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// DMA</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LPC47N227_FIRDMASELECT_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmpbyte</span> <span class="o">!=</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_dma</span> <span class="o">&amp;</span> <span class="n">LPC47N227_FIRDMASELECT_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;ERROR: could not configure FIR DMA channel.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">SMSCSIOFLAT_UARTMODE0C_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// CR0C - UART mode</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tmpbyte</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SMSCSIOFLAT_UART2MODE_MASK</span> <span class="o">|</span>
		<span class="n">SMSCSIOFLAT_UART2MODE_VAL_IRDA</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">tmpbyte</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// enable IrDA (HPSIR) mode, high speed</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">LPC47N227_APMBOOTDRIVE_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// CR07 - Auto Pwr Mgt/boot drive sel</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">tmpbyte</span> <span class="o">|</span> <span class="n">LPC47N227_UART2AUTOPWRDOWN_MASK</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// enable UART2 autopower down</span>

	<span class="cm">/* This one was not part of tosh1800 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mh">0x0a</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// CR0a - ecp fifo / ir mux</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">tmpbyte</span> <span class="o">|</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// send active device to ir port</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">LPC47N227_UART12POWER_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// CR02 - UART 1,2 power</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">tmpbyte</span> <span class="o">|</span> <span class="n">LPC47N227_UART2POWERDOWN_MASK</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// UART2 power up mode, UART1 power down</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">LPC47N227_FDCPOWERVALIDCONF_REG</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// CR00 - FDC Power/valid config cycle</span>
	<span class="n">tmpbyte</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">tmpbyte</span> <span class="o">|</span> <span class="n">LPC47N227_VALID_MASK</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// valid config cycle done</span>

	<span class="n">outb</span><span class="p">(</span><span class="n">LPC47N227_CFGEXITKEY</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>  <span class="c1">// Exit configuration</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 82801CAM generic registers */</span>
<span class="cp">#define VID 0x00</span>
<span class="cp">#define DID 0x02</span>
<span class="cp">#define PIRQ_A_D_ROUT 0x60</span>
<span class="cp">#define SIRQ_CNTL 0x64</span>
<span class="cp">#define PIRQ_E_H_ROUT 0x68</span>
<span class="cp">#define PCI_DMA_C 0x90</span>
<span class="cm">/* LPC-specific registers */</span>
<span class="cp">#define COM_DEC 0xe0</span>
<span class="cp">#define GEN1_DEC 0xe4</span>
<span class="cp">#define LPC_EN 0xe6</span>
<span class="cp">#define GEN2_DEC 0xec</span>
<span class="cm">/*</span>
<span class="cm"> * Sets up the I/O range using the 82801CAM ISA bridge, 82801DBM LPC bridge</span>
<span class="cm"> * or Intel 82801DB/DBL (ICH4/ICH4-L) LPC Interface Bridge.</span>
<span class="cm"> * They all work the same way!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">preconfigure_through_82801</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="k">struct</span>
					     <span class="n">smsc_ircc_subsystem_configuration</span>
					     <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tmpword</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmpbyte</span><span class="p">;</span>

	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;Setting up Intel 82801 controller and SMSC device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Select the range for the COMA COM port (SIR)</span>
<span class="cm">	 * Register COM_DEC:</span>
<span class="cm">	 * Bit 7: reserved</span>
<span class="cm">	 * Bit 6-4, COMB decode range</span>
<span class="cm">	 * Bit 3: reserved</span>
<span class="cm">	 * Bit 2-0, COMA decode range</span>
<span class="cm">	 *</span>
<span class="cm">	 * Decode ranges:</span>
<span class="cm">	 *   000 = 0x3f8-0x3ff (COM1)</span>
<span class="cm">	 *   001 = 0x2f8-0x2ff (COM2)</span>
<span class="cm">	 *   010 = 0x220-0x227</span>
<span class="cm">	 *   011 = 0x228-0x22f</span>
<span class="cm">	 *   100 = 0x238-0x23f</span>
<span class="cm">	 *   101 = 0x2e8-0x2ef (COM4)</span>
<span class="cm">	 *   110 = 0x338-0x33f</span>
<span class="cm">	 *   111 = 0x3e8-0x3ef (COM3)</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COM_DEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpbyte</span><span class="p">);</span>
	<span class="n">tmpbyte</span> <span class="o">&amp;=</span> <span class="mh">0xf8</span><span class="p">;</span> <span class="cm">/* mask COMA bits */</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">sir_io</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x3f8</span>:
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2f8</span>:
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x01</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x220</span>:
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x02</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x228</span>:
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x03</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x238</span>:
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x04</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x2e8</span>:
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x05</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x338</span>:
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x06</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x3e8</span>:
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x07</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="cm">/* COM2 default */</span>
	<span class="p">}</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;COM_DEC (write): 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmpbyte</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">COM_DEC</span><span class="p">,</span> <span class="n">tmpbyte</span><span class="p">);</span>

	<span class="cm">/* Enable Low Pin Count interface */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LPC_EN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpword</span><span class="p">);</span>
	<span class="cm">/* These seem to be set up at all times,</span>
<span class="cm">	 * just make sure it is properly set.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x04e</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x2000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02e</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x1000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x062</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x0800</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x060</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x0400</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;Uncommon I/O base address: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">conf</span><span class="o">-&gt;</span><span class="n">cfg_base</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tmpword</span> <span class="o">&amp;=</span> <span class="mh">0xfffd</span><span class="p">;</span> <span class="cm">/* disable LPC COMB */</span>
	<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x0001</span><span class="p">;</span> <span class="cm">/* set bit 0 : enable LPC COMA addr range (GEN2) */</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;LPC_EN (write): 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmpword</span><span class="p">);</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">LPC_EN</span><span class="p">,</span> <span class="n">tmpword</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Configure LPC DMA channel</span>
<span class="cm">	 * PCI_DMA_C bits:</span>
<span class="cm">	 * Bit 15-14: DMA channel 7 select</span>
<span class="cm">	 * Bit 13-12: DMA channel 6 select</span>
<span class="cm">	 * Bit 11-10: DMA channel 5 select</span>
<span class="cm">	 * Bit 9-8:   Reserved</span>
<span class="cm">	 * Bit 7-6:   DMA channel 3 select</span>
<span class="cm">	 * Bit 5-4:   DMA channel 2 select</span>
<span class="cm">	 * Bit 3-2:   DMA channel 1 select</span>
<span class="cm">	 * Bit 1-0:   DMA channel 0 select</span>
<span class="cm">	 *  00 = Reserved value</span>
<span class="cm">	 *  01 = PC/PCI DMA</span>
<span class="cm">	 *  10 = Reserved value</span>
<span class="cm">	 *  11 = LPC I/F DMA</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_DMA_C</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpword</span><span class="p">);</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_dma</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x07</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0xc000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x06</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x3000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x05</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x0c00</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x03</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x00c0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x0030</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x01</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x000c</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x00</span>:
		<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x0003</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span> <span class="cm">/* do not change settings */</span>
	<span class="p">}</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;PCI_DMA_C (write): 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmpword</span><span class="p">);</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_DMA_C</span><span class="p">,</span> <span class="n">tmpword</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * GEN2_DEC bits:</span>
<span class="cm">	 * Bit 15-4: Generic I/O range</span>
<span class="cm">	 * Bit 3-1: reserved (read as 0)</span>
<span class="cm">	 * Bit 0: enable GEN2 range on LPC I/F</span>
<span class="cm">	 */</span>
	<span class="n">tmpword</span> <span class="o">=</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_io</span> <span class="o">&amp;</span> <span class="mh">0xfff8</span><span class="p">;</span>
	<span class="n">tmpword</span> <span class="o">|=</span> <span class="mh">0x0001</span><span class="p">;</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;GEN2_DEC (write): 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tmpword</span><span class="p">);</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GEN2_DEC</span><span class="p">,</span> <span class="n">tmpword</span><span class="p">);</span>

	<span class="cm">/* Pre-configure chip */</span>
	<span class="k">return</span> <span class="n">preconfigure_smsc_chip</span><span class="p">(</span><span class="n">conf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pre-configure a certain port on the ALi 1533 bridge.</span>
<span class="cm"> * This is based on reverse-engineering since ALi does not</span>
<span class="cm"> * provide any data sheet for the 1533 chip.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">preconfigure_ali_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">reg</span><span class="p">;</span>
	<span class="cm">/* These bits obviously control the different ports */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tmpbyte</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x0130</span>:
	<span class="k">case</span> <span class="mh">0x0178</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="mh">0xb0</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x03f8</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="mh">0xb4</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02f8</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="mh">0xb4</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mh">0x02e8</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="mh">0xb4</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to configure unsupported port on ALi 1533 bridge: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpbyte</span><span class="p">);</span>
	<span class="cm">/* Turn on the right bits */</span>
	<span class="n">tmpbyte</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">tmpbyte</span><span class="p">);</span>
	<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;Activated ALi 1533 ISA bridge port 0x%04x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">preconfigure_through_ali</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="k">struct</span>
					   <span class="n">smsc_ircc_subsystem_configuration</span>
					   <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Configure the two ports on the ALi 1533 */</span>
	<span class="n">preconfigure_ali_port</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">sir_io</span><span class="p">);</span>
	<span class="n">preconfigure_ali_port</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">fir_io</span><span class="p">);</span>

	<span class="cm">/* Pre-configure chip */</span>
	<span class="k">return</span> <span class="n">preconfigure_smsc_chip</span><span class="p">(</span><span class="n">conf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">smsc_ircc_preconfigure_subsystems</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ircc_cfg</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ircc_fir</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ircc_sir</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ircc_dma</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ircc_irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ss_vendor</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ss_device</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span> <span class="o">*</span><span class="n">conf</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Cache the subsystem vendor/device:</span>
<span class="cm">		 * some manufacturers fail to set this for all components,</span>
<span class="cm">		 * so we save it in case there is just 0x0000 0x0000 on the</span>
<span class="cm">		 * device we want to check.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">!=</span> <span class="mh">0x0000U</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ss_vendor</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">;</span>
			<span class="n">ss_device</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">conf</span> <span class="o">=</span> <span class="n">subsystem_configurations</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">subvendor</span><span class="p">;</span> <span class="n">conf</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">&amp;&amp;</span>
			   <span class="n">conf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&amp;&amp;</span>
			   <span class="n">conf</span><span class="o">-&gt;</span><span class="n">subvendor</span> <span class="o">==</span> <span class="n">ss_vendor</span> <span class="o">&amp;&amp;</span>
			   <span class="cm">/* Sometimes these are cached values */</span>
			   <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">subdevice</span> <span class="o">==</span> <span class="n">ss_device</span> <span class="o">||</span>
			    <span class="n">conf</span><span class="o">-&gt;</span><span class="n">subdevice</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span>
					<span class="n">tmpconf</span><span class="p">;</span>

				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmpconf</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smsc_ircc_subsystem_configuration</span><span class="p">));</span>

				<span class="cm">/*</span>
<span class="cm">				 * Override the default values with anything</span>
<span class="cm">				 * passed in as parameter</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ircc_cfg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">tmpconf</span><span class="p">.</span><span class="n">cfg_base</span> <span class="o">=</span> <span class="n">ircc_cfg</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ircc_fir</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">tmpconf</span><span class="p">.</span><span class="n">fir_io</span> <span class="o">=</span> <span class="n">ircc_fir</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ircc_sir</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">tmpconf</span><span class="p">.</span><span class="n">sir_io</span> <span class="o">=</span> <span class="n">ircc_sir</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ircc_dma</span> <span class="o">!=</span> <span class="n">DMA_INVAL</span><span class="p">)</span>
					<span class="n">tmpconf</span><span class="p">.</span><span class="n">fir_dma</span> <span class="o">=</span> <span class="n">ircc_dma</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ircc_irq</span> <span class="o">!=</span> <span class="n">IRQ_INVAL</span><span class="p">)</span>
					<span class="n">tmpconf</span><span class="p">.</span><span class="n">fir_irq</span> <span class="o">=</span> <span class="n">ircc_irq</span><span class="p">;</span>

				<span class="n">IRDA_MESSAGE</span><span class="p">(</span><span class="s">&quot;Detected unconfigured %s SMSC IrDA chip, pre-configuring device.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">conf</span><span class="o">-&gt;</span><span class="n">preconfigure</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">conf</span><span class="o">-&gt;</span><span class="n">preconfigure</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmpconf</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// CONFIG_PCI</span>

<span class="cm">/************************************************</span>
<span class="cm"> *</span>
<span class="cm"> * Transceivers specific functions</span>
<span class="cm"> *</span>
<span class="cm"> ************************************************/</span>


<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_set_transceiver_smsc_ircc_atc(fir_base, speed)</span>
<span class="cm"> *</span>
<span class="cm"> *    Program transceiver through smsc-ircc ATC circuitry</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_set_transceiver_smsc_ircc_atc</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies_now</span><span class="p">,</span> <span class="n">jiffies_timeout</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">jiffies_now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">jiffies_timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SMSC_IRCC2_ATC_PROGRAMMING_TIMEOUT_JIFFIES</span><span class="p">;</span>

	<span class="cm">/* ATC */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_ATC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRCC_ATC_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="n">IRCC_ATC_nPROGREADY</span><span class="o">|</span><span class="n">IRCC_ATC_ENABLE</span><span class="p">,</span>
	     <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_ATC</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_ATC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IRCC_ATC_nPROGREADY</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">jiffies_timeout</span><span class="p">))</span>
		<span class="cm">/* empty */</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;%s(): ATC: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			     <span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_ATC</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_probe_transceiver_smsc_ircc_atc(fir_base)</span>
<span class="cm"> *</span>
<span class="cm"> *    Probe transceiver smsc-ircc ATC circuitry</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_probe_transceiver_smsc_ircc_atc</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_set_transceiver_smsc_ircc_fast_pin_select(self, speed)</span>
<span class="cm"> *</span>
<span class="cm"> *    Set transceiver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_set_transceiver_smsc_ircc_fast_pin_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">fast_mode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">576000</span> :
		<span class="n">fast_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1152000</span> :
	<span class="k">case</span> <span class="mi">4000000</span> :
		<span class="n">fast_mode</span> <span class="o">=</span> <span class="n">IRCC_LCR_A_FAST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_LCR_A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xbf</span><span class="p">)</span> <span class="o">|</span> <span class="n">fast_mode</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_LCR_A</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_probe_transceiver_smsc_ircc_fast_pin_select(fir_base)</span>
<span class="cm"> *</span>
<span class="cm"> *    Probe transceiver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_probe_transceiver_smsc_ircc_fast_pin_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_set_transceiver_toshiba_sat1800(fir_base, speed)</span>
<span class="cm"> *</span>
<span class="cm"> *    Set transceiver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smsc_ircc_set_transceiver_toshiba_sat1800</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">,</span> <span class="n">u32</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">fast_mode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">576000</span> :
		<span class="n">fast_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1152000</span> :
	<span class="k">case</span> <span class="mi">4000000</span> :
		<span class="n">fast_mode</span> <span class="o">=</span> <span class="cm">/*IRCC_LCR_A_FAST |*/</span> <span class="n">IRCC_LCR_A_GP_DATA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="cm">/* This causes an interrupt */</span>
	<span class="n">register_bank</span><span class="p">(</span><span class="n">fir_base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">((</span><span class="n">inb</span><span class="p">(</span><span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_LCR_A</span><span class="p">)</span> <span class="o">&amp;</span>  <span class="mh">0xbf</span><span class="p">)</span> <span class="o">|</span> <span class="n">fast_mode</span><span class="p">,</span> <span class="n">fir_base</span> <span class="o">+</span> <span class="n">IRCC_LCR_A</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function smsc_ircc_probe_transceiver_toshiba_sat1800(fir_base)</span>
<span class="cm"> *</span>
<span class="cm"> *    Probe transceiver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">smsc_ircc_probe_transceiver_toshiba_sat1800</span><span class="p">(</span><span class="kt">int</span> <span class="n">fir_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">module_init</span><span class="p">(</span><span class="n">smsc_ircc_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">smsc_ircc_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
