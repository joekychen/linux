<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › irda › mcs7780.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>mcs7780.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*****************************************************************************</span>
<span class="cm">*</span>
<span class="cm">* Filename:      mcs7780.c</span>
<span class="cm">* Version:       0.4-alpha</span>
<span class="cm">* Description:   Irda MosChip USB Dongle Driver</span>
<span class="cm">* Authors:       Lukasz Stelmach &lt;stlman@poczta.fm&gt;</span>
<span class="cm">* 		 Brian Pugh &lt;bpugh@cs.pdx.edu&gt;</span>
<span class="cm">*		 Judy Fischbach &lt;jfisch@cs.pdx.edu&gt;</span>
<span class="cm">*</span>
<span class="cm">*       Based on stir4200 driver, but some things done differently.</span>
<span class="cm">*       Based on earlier driver by Paul Stewart &lt;stewart@parc.com&gt;</span>
<span class="cm">*</span>
<span class="cm">*       Copyright (C) 2000, Roman Weissgaerber &lt;weissg@vienna.at&gt;</span>
<span class="cm">*       Copyright (C) 2001, Dag Brattli &lt;dag@brattli.net&gt;</span>
<span class="cm">*       Copyright (C) 2001, Jean Tourrilhes &lt;jt@hpl.hp.com&gt;</span>
<span class="cm">*       Copyright (C) 2004, Stephen Hemminger &lt;shemminger@osdl.org&gt;</span>
<span class="cm">*       Copyright (C) 2005, Lukasz Stelmach &lt;stlman@poczta.fm&gt;</span>
<span class="cm">*       Copyright (C) 2005, Brian Pugh &lt;bpugh@cs.pdx.edu&gt;</span>
<span class="cm">*       Copyright (C) 2005, Judy Fischbach &lt;jfisch@cs.pdx.edu&gt;</span>
<span class="cm">*</span>
<span class="cm">*       This program is free software; you can redistribute it and/or modify</span>
<span class="cm">*       it under the terms of the GNU General Public License as published by</span>
<span class="cm">*       the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">*       (at your option) any later version.</span>
<span class="cm">*</span>
<span class="cm">*       This program is distributed in the hope that it will be useful,</span>
<span class="cm">*       but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">*       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">*       GNU General Public License for more details.</span>
<span class="cm">*</span>
<span class="cm">*       You should have received a copy of the GNU General Public License</span>
<span class="cm">*       along with this program; if not, write to the Free Software</span>
<span class="cm">*       Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm">*</span>
<span class="cm">*****************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * MCS7780 is a simple USB to IrDA bridge by MosChip. It is neither</span>
<span class="cm"> * compatibile with irda-usb nor with stir4200. Although it is quite</span>
<span class="cm"> * similar to the later as far as general idea of operation is concerned.</span>
<span class="cm"> * That is it requires the software to do all the framing job at SIR speeds.</span>
<span class="cm"> * The hardware does take care of the framing at MIR and FIR speeds.</span>
<span class="cm"> * It supports all speeds from 2400 through 4Mbps</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>

<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;net/irda/irda.h&gt;</span>
<span class="cp">#include &lt;net/irda/wrapper.h&gt;</span>
<span class="cp">#include &lt;net/irda/crc.h&gt;</span>

<span class="cp">#include &quot;mcs7780.h&quot;</span>

<span class="cp">#define MCS_VENDOR_ID 0x9710</span>
<span class="cp">#define MCS_PRODUCT_ID 0x7780</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">mcs_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* MosChip Corp.,  MCS7780 FIR-USB Adapter */</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="n">MCS_VENDOR_ID</span><span class="p">,</span> <span class="n">MCS_PRODUCT_ID</span><span class="p">)},</span>
	<span class="p">{},</span>
<span class="p">};</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Brian Pugh &lt;bpugh@cs.pdx.edu&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;IrDA-USB Dongle Driver for MosChip MCS7780&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;0.3alpha&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">mcs_table</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">qos_mtt_bits</span> <span class="o">=</span> <span class="mh">0x07</span> <span class="cm">/* &gt; 1ms */</span> <span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">qos_mtt_bits</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">qos_mtt_bits</span><span class="p">,</span> <span class="s">&quot;Minimum Turn Time&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">receive_mode</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">receive_mode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">receive_mode</span><span class="p">,</span>
		 <span class="s">&quot;Receive mode of the device (1:fast, 0:slow, default:1)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sir_tweak</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">sir_tweak</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">sir_tweak</span><span class="p">,</span>
		 <span class="s">&quot;Default pulse width (1:1.6us, 0:3/16 bit, default:1).&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">transceiver_type</span> <span class="o">=</span> <span class="n">MCS_TSC_VISHAY</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">transceiver_type</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">transceiver_type</span><span class="p">,</span> <span class="s">&quot;IR transceiver type, see mcs7780.h.&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">mcs_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mcs7780&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">mcs_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span> <span class="n">mcs_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">mcs_table</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* speed flag selection by direct addressing.</span>
<span class="cm">addr = (speed &gt;&gt; 8) &amp; 0x0f</span>

<span class="cm">0x1   57600	 0x2  115200	 0x4 1152000	 0x5    9600</span>
<span class="cm">0x6   38400	 0x9    2400	 0xa  576000	 0xb   19200</span>

<span class="cm">4Mbps (or 2400) must be checked separately. Since it also has</span>
<span class="cm">to be programmed in a different manner that is not a big problem.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="n">__u16</span> <span class="n">mcs_speed_set</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MCS_SPEED_57600</span><span class="p">,</span>
	<span class="n">MCS_SPEED_115200</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>
	<span class="n">MCS_SPEED_1152000</span><span class="p">,</span>
	<span class="n">MCS_SPEED_9600</span><span class="p">,</span>
	<span class="n">MCS_SPEED_38400</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MCS_SPEED_2400</span><span class="p">,</span>
	<span class="n">MCS_SPEED_576000</span><span class="p">,</span>
	<span class="n">MCS_SPEED_19200</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Set given 16 bit register with a 16 bit value. Send control message</span>
<span class="cm"> * to set dongle register. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcs_set_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">MCS_WRREQ</span><span class="p">,</span>
			       <span class="n">MCS_WR_RTYPE</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			       <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MCS_CTRL_TIMEOUT</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Get 16 bit register value. Send contol message to read dongle register. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcs_get_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">reg</span><span class="p">,</span> <span class="n">__u16</span> <span class="o">*</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">MCS_RDREQ</span><span class="p">,</span>
				  <span class="n">MCS_RD_RTYPE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
				  <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">MCS_CTRL_TIMEOUT</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Setup a communication between mcs7780 and TFDU chips.  It is described</span>
<span class="cm"> * in more detail in the data sheet.  The setup sequence puts the the</span>
<span class="cm"> * vishay tranceiver into high speed mode.  It will also receive SIR speed</span>
<span class="cm"> * packets but at reduced sensitivity.</span>
<span class="cm"> */</span>

<span class="cm">/* 0: OK 1:ERROR */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcs_setup_transceiver_vishay</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">rval</span><span class="p">;</span>

	<span class="cm">/* mcs_get_reg should read exactly two bytes from the dongle */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_get_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_XCVR_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The MCS_XCVR_CONF bit puts the transceiver into configuration</span>
<span class="cm">	 * mode.  The MCS_MODE0 bit must start out high (1) and then</span>
<span class="cm">	 * transition to low and the MCS_STFIR and MCS_MODE1 bits must</span>
<span class="cm">	 * be low.</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MCS_MODE0</span> <span class="o">|</span> <span class="n">MCS_XCVR_CONF</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_STFIR</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_MODE1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_XCVR_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_MODE0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_XCVR_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_XCVR_CONF</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_XCVR_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">error:</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Setup a communication between mcs7780 and agilent chip. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcs_setup_transceiver_agilent</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;This transceiver type is not supported yet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Setup a communication between mcs7780 and sharp chip. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcs_setup_transceiver_sharp</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;This transceiver type is not supported yet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Common setup for all transceivers */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcs_setup_transceiver</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">rval</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Basic transceiver setup error.&quot;</span><span class="p">;</span>

	<span class="cm">/* read value of MODE Register, set the DRIVER and RESET bits</span>
<span class="cm">	* and write value back out to MODE Register</span>
<span class="cm">	*/</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_get_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="n">MCS_DRIVER</span><span class="p">;</span>	<span class="cm">/* put the mcs7780 into configuration mode. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* set min pulse width to 0 initially. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MINRXPW_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_get_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_FIR</span><span class="p">;</span>	<span class="cm">/* turn off fir mode. */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">sir_tweak</span><span class="p">)</span>
		<span class="n">rval</span> <span class="o">|=</span> <span class="n">MCS_SIR16US</span><span class="p">;</span>	<span class="cm">/* 1.6us pulse width */</span>
	<span class="k">else</span>
		<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_SIR16US</span><span class="p">;</span>	<span class="cm">/* 3/16 bit time pulse width */</span>

	<span class="cm">/* make sure ask mode and back to back packets are off. */</span>
	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MCS_BBTG</span> <span class="o">|</span> <span class="n">MCS_ASK</span><span class="p">);</span>

	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_SPEED_MASK</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="n">MCS_SPEED_9600</span><span class="p">;</span>		<span class="cm">/* make sure initial speed is 9600. */</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="mi">9600</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* new_speed is set to 0 */</span>
	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_PLLPWDN</span><span class="p">;</span>		<span class="cm">/* disable power down. */</span>

	<span class="cm">/* make sure device determines direction and that the auto send sip</span>
<span class="cm">	 * pulse are on.</span>
<span class="cm">	 */</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="n">MCS_DTD</span> <span class="o">|</span> <span class="n">MCS_SIPEN</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;transceiver model specific setup error.&quot;</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">transceiver_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MCS_TSC_VISHAY</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_setup_transceiver_vishay</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MCS_TSC_SHARP</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_setup_transceiver_sharp</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MCS_TSC_AGILENT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_setup_transceiver_agilent</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;Unknown transceiver type: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">transceiver_type</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* If transceiver is not SHARP, then if receive mode set</span>
<span class="cm">	* on the RXFAST bit in the XCVR Register otherwise unset it</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">transceiver_type</span> <span class="o">!=</span> <span class="n">MCS_TSC_SHARP</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_get_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_XCVR_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">receive_mode</span><span class="p">)</span>
			<span class="n">rval</span> <span class="o">|=</span> <span class="n">MCS_RXFAST</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_RXFAST</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_XCVR_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;transceiver reset.&quot;</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_get_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/* reset the mcs7780 so all changes take effect. */</span>
	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_RESET</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wraps the data in format for SIR */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcs_wrap_sir_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">wraplen</span><span class="p">;</span>

	<span class="cm">/* 2: full frame length, including &quot;the length&quot; */</span>
	<span class="n">wraplen</span> <span class="o">=</span> <span class="n">async_wrap_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4094</span><span class="p">);</span>

	<span class="n">wraplen</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">wraplen</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wraplen</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">wraplen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wraps the data in format for FIR */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">mcs_wrap_fir_skb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">fcs</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">crc32_le</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>

	<span class="cm">/* add 2 bytes for length value and 4 bytes for fcs. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">6</span><span class="p">;</span>

	<span class="cm">/* The mcs7780 requires that the first two bytes are the packet</span>
<span class="cm">	 * length in little endian order.  Note: the length value includes</span>
<span class="cm">	 * the two bytes for the length value itself.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="cm">/* copy the data into the tx buffer. */</span>
	<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="cm">/* put the fcs in the last four bytes in little endian order. */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcs</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcs</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcs</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Wraps the data in format for MIR */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">mcs_wrap_mir_skb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">fcs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">fcs</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">irda_calc_crc16</span><span class="p">(</span><span class="o">~</span><span class="n">fcs</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">));</span>
	<span class="cm">/* put the total packet length in first.  Note: packet length</span>
<span class="cm">	 * value includes the two bytes that hold the packet length</span>
<span class="cm">	 * itself.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="cm">/* copy the data */</span>
	<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="cm">/* put the fcs in last two bytes in little endian order. */</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcs</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcs</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unwrap received packets at MIR speed.  A 16 bit crc_ccitt checksum is</span>
<span class="cm"> * used for the fcs.  When performed over the entire packet the result</span>
<span class="cm"> * should be GOOD_FCS = 0xf0b8.  Hands the unwrapped data off to the IrDA</span>
<span class="cm"> * layer via a sk_buff.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcs_unwrap_mir</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u16</span> <span class="n">fcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Assume that the frames are going to fill a single packet</span>
<span class="cm">	 * rather than span multiple packets.</span>
<span class="cm">	 */</span>

	<span class="n">new_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">new_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s short frame length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
		<span class="o">++</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="p">;</span>
		<span class="o">++</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fcs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fcs</span> <span class="o">=</span> <span class="n">irda_calc_crc16</span><span class="p">(</span><span class="o">~</span><span class="n">fcs</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">fcs</span> <span class="o">!=</span> <span class="n">GOOD_FCS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;crc error calc 0x%x len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">fcs</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
		<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">new_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IRDA</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">new_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Unwrap received packets at FIR speed.  A 32 bit crc_ccitt checksum is</span>
<span class="cm"> * used for the fcs.  Hands the unwrapped data off to the IrDA</span>
<span class="cm"> * layer via a sk_buff.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcs_unwrap_fir</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">fcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Assume that the frames are going to fill a single packet</span>
<span class="cm">	 * rather than span multiple packets.  This is most likely a false</span>
<span class="cm">	 * assumption.</span>
<span class="cm">	 */</span>

	<span class="n">new_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">new_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;%s short frame length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
		<span class="o">++</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="p">;</span>
		<span class="o">++</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fcs</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">crc32_le</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">new_len</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span><span class="n">fcs</span> <span class="o">!=</span> <span class="n">get_unaligned_le32</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">new_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;crc error calc 0x%x len %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcs</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
		<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">new_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_dropped</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">new_len</span><span class="p">);</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IRDA</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">new_len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Allocates urbs for both receive and transmit.</span>
<span class="cm"> * If alloc fails return error code 0 (fail) otherwise</span>
<span class="cm"> * return error code 1 (success).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcs_setup_urbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">tx_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Sets up state to be initially outside frame, gets receive urb,</span>
<span class="cm"> * sets status to successful and then submits the urb to start</span>
<span class="cm"> * receiving the data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcs_receive_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">in_frame</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">OUTSIDE_FRAME</span><span class="p">;</span>

	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span>
			  <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">),</span>
			  <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">in_buf</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">mcs_receive_irq</span><span class="p">,</span> <span class="n">mcs</span><span class="p">);</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Finds the in and out endpoints for the mcs control block */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mcs_find_endpoints</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">usb_host_endpoint</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="kt">int</span> <span class="n">epnum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If no place to store the endpoints just return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* cycle through all endpoints, find the first two that are DIR_IN */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">epnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span> <span class="o">&amp;</span> <span class="n">USB_DIR_IN</span><span class="p">)</span>
			<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">ep_in</span> <span class="o">=</span> <span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">ep_out</span> <span class="o">=</span> <span class="n">ep</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">desc</span><span class="p">.</span><span class="n">bEndpointAddress</span><span class="p">;</span>

		<span class="cm">/* MosChip says that the chip has only two bulk</span>
<span class="cm">		 * endpoints. Find one for each direction and move on.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">ep_in</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">ep_out</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcs_speed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mcs_cb</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">mcs_speed_change</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function to change the speed of the mcs7780.  Fully supports SIR,</span>
<span class="cm"> * MIR, and FIR speeds.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcs_speed_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">nspeed</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">nspeed</span> <span class="o">=</span> <span class="n">mcs_speed_set</span><span class="p">[(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">];</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">mcs_get_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_RESV_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">cnt</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rval</span> <span class="o">&amp;</span> <span class="n">MCS_IRINTX</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;unable to change speed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mcs_get_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>

	<span class="cm">/* MINRXPW values recommended by MosChip */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">&lt;=</span> <span class="mi">115200</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_FIR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rst</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="mi">115200</span><span class="p">)))</span>
			<span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MINRXPW_REG</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">&lt;=</span> <span class="mi">1152000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_FIR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rst</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">576000</span> <span class="o">||</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">1152000</span><span class="p">)))</span>
			<span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MINRXPW_REG</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rval</span> <span class="o">|=</span> <span class="n">MCS_FIR</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">rst</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">!=</span> <span class="mi">4000000</span><span class="p">)))</span>
			<span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MINRXPW_REG</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_SPEED_MASK</span><span class="p">;</span>
	<span class="n">rval</span> <span class="o">|=</span> <span class="n">nspeed</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rst</span><span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">transceiver_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MCS_TSC_VISHAY</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_setup_transceiver_vishay</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MCS_TSC_SHARP</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_setup_transceiver_sharp</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MCS_TSC_AGILENT</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_setup_transceiver_agilent</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">IRDA_WARNING</span><span class="p">(</span><span class="s">&quot;Unknown transceiver type: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">transceiver_type</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mcs_get_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rval</span><span class="p">);</span>
	<span class="n">rval</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MCS_RESET</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_set_reg</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">MCS_MODE_REG</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">;</span>
	<span class="nl">error:</span>
		<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Ioctl calls not supported at this time.  Can be an area of future work. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcs_net_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* struct if_irda_req *irq = (struct if_irda_req *)rq; */</span>
	<span class="cm">/* struct mcs_cb *mcs = netdev_priv(netdev); */</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Network device is taken down, done by &quot;ifconfig irda0 down&quot; */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcs_net_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Stop transmit processing */</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* kill and free the receive and transmit URBs */</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_urb</span><span class="p">);</span>
	<span class="n">usb_kill_urb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>
	<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">);</span>

	<span class="cm">/* Stop and remove instance of IrLAP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">)</span>
		<span class="n">irlap_close</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Network device is taken up, done by &quot;ifconfig irda0 up&quot; */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcs_net_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">hwname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span>
			     <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">ep_in</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_clear_halt</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span>
			     <span class="n">usb_rcvbulkpipe</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_setup_transceiver</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Initialize for SIR/FIR to copy data directly into skb.  */</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">receiving</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">truesize</span> <span class="o">=</span> <span class="n">IRDA_SKB_MAX_MTU</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">IRDA_SKB_MAX_MTU</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_time</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that everything should be initialized properly,</span>
<span class="cm">	 * Open new IrLAP layer instance to take care of us...</span>
<span class="cm">	 * Note : will send immediately a speed change...</span>
<span class="cm">	 */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">hwname</span><span class="p">,</span> <span class="s">&quot;usb#%d&quot;</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">irlap</span> <span class="o">=</span> <span class="n">irlap_open</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">,</span> <span class="n">hwname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;mcs7780: irlap_open failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcs_setup_urbs</span><span class="p">(</span><span class="n">mcs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error3</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_receive_start</span><span class="p">(</span><span class="n">mcs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error3</span><span class="p">;</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">error3:</span>
		<span class="n">irlap_close</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">irlap</span><span class="p">);</span>
	<span class="nl">error2:</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">.</span><span class="n">skb</span><span class="p">);</span>
	<span class="nl">error1:</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Receive callback function.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcs_receive_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">bytes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">;</span>

		<span class="cm">/* MCS returns frames without BOF and EOF</span>
<span class="cm">		 * I assume it returns whole frames.</span>
<span class="cm">		 */</span>
		<span class="cm">/* SIR speed */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mi">576000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">async_unwrap_char</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">async_unwrap_char</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">,</span> <span class="n">bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="n">async_unwrap_char</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_buff</span><span class="p">,</span> <span class="mh">0xc1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* MIR speed */</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">576000</span> <span class="o">||</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">1152000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mcs_unwrap_mir</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* FIR speed */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">mcs_unwrap_fir</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span>
				<span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">do_gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">rx_time</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Transmit callback function.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcs_send_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span><span class="p">))</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Transmit callback function.  */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">mcs_hard_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wraplen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">mcs</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="n">irda_get_next_speed</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">==</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">))</span>
		<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">new_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* SIR speed */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="mi">576000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wraplen</span> <span class="o">=</span> <span class="n">mcs_wrap_sir_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">out_buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* MIR speed */</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">576000</span> <span class="o">||</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">1152000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wraplen</span> <span class="o">=</span> <span class="n">mcs_wrap_mir_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">out_buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* FIR speed */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">wraplen</span> <span class="o">=</span> <span class="n">mcs_wrap_fir_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">out_buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span>
			  <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span><span class="p">,</span> <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">ep_out</span><span class="p">),</span>
			  <span class="n">mcs</span><span class="o">-&gt;</span><span class="n">out_buf</span><span class="p">,</span> <span class="n">wraplen</span><span class="p">,</span> <span class="n">mcs_send_irq</span><span class="p">,</span> <span class="n">mcs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">tx_urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;failed tx_urb: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="n">ENODEV</span>:
		<span class="k">case</span> <span class="o">-</span><span class="n">EPIPE</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">mcs_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span> <span class="o">=</span> <span class="n">mcs_net_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span> <span class="o">=</span> <span class="n">mcs_net_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span> <span class="o">=</span> <span class="n">mcs_hard_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span> <span class="o">=</span> <span class="n">mcs_net_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called by the USB subsystem for each new device in the</span>
<span class="cm"> * system.  Need to verify the device and if it is, then start handling it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mcs_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
		     <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ndev</span> <span class="o">=</span> <span class="n">alloc_irdadev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mcs</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error1</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;MCS7780 USB-IrDA bridge found at %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">udev</span><span class="o">-&gt;</span><span class="n">devnum</span><span class="p">);</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">ndev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_reset_configuration</span><span class="p">(</span><span class="n">udev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IRDA_ERROR</span><span class="p">(</span><span class="s">&quot;mcs7780: usb reset configuration failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mcs</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">usbdev</span> <span class="o">=</span> <span class="n">udev</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">ndev</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Initialize QoS for this device */</span>
	<span class="n">irda_init_max_qos_capabilies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">);</span>

	<span class="cm">/* That&#39;s the Rx capability. */</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">baud_rate</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span>
	    <span class="n">IR_2400</span> <span class="o">|</span> <span class="n">IR_9600</span> <span class="o">|</span> <span class="n">IR_19200</span> <span class="o">|</span> <span class="n">IR_38400</span> <span class="o">|</span> <span class="n">IR_57600</span> <span class="o">|</span> <span class="n">IR_115200</span>
		<span class="o">|</span> <span class="n">IR_576000</span> <span class="o">|</span> <span class="n">IR_1152000</span> <span class="o">|</span> <span class="p">(</span><span class="n">IR_4000000</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>


	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">min_turn_time</span><span class="p">.</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="n">qos_mtt_bits</span><span class="p">;</span>
	<span class="n">irda_qos_bits_to_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">);</span>

	<span class="cm">/* Speed change work initialisation*/</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">mcs_speed_work</span><span class="p">);</span>

	<span class="n">ndev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mcs_netdev_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mcs_find_endpoints</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">,</span>
				 <span class="n">intf</span><span class="o">-&gt;</span><span class="n">cur_altsetting</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">.</span><span class="n">bNumEndpoints</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error2</span><span class="p">;</span>

	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;IrDA: Registered MosChip MCS7780 device as %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">ndev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">transceiver_type</span> <span class="o">=</span> <span class="n">transceiver_type</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">sir_tweak</span> <span class="o">=</span> <span class="n">sir_tweak</span><span class="p">;</span>
	<span class="n">mcs</span><span class="o">-&gt;</span><span class="n">receive_mode</span> <span class="o">=</span> <span class="n">receive_mode</span><span class="p">;</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">mcs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">error2:</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">ndev</span><span class="p">);</span>

	<span class="nl">error1:</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The current device is removed, the USB layer tells us to shut down. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mcs_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mcs_cb</span> <span class="o">*</span><span class="n">mcs</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcs</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">mcs</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">IRDA_DEBUG</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;MCS7780 now disconnected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">mcs_driver</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
