<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › bonding › bond_main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bond_main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * originally based on the dummy device.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1999, Thomas Davis, tadavis@lbl.gov.</span>
<span class="cm"> * Licensed under the GPL. Based on dummy.c, and eql.c devices.</span>
<span class="cm"> *</span>
<span class="cm"> * bonding.c: an Ethernet Bonding driver</span>
<span class="cm"> *</span>
<span class="cm"> * This is useful to talk to a Cisco EtherChannel compatible equipment:</span>
<span class="cm"> *	Cisco 5500</span>
<span class="cm"> *	Sun Trunking (Solaris)</span>
<span class="cm"> *	Alteon AceDirector Trunks</span>
<span class="cm"> *	Linux Bonding</span>
<span class="cm"> *	and probably many L2 switches ...</span>
<span class="cm"> *</span>
<span class="cm"> * How it works:</span>
<span class="cm"> *    ifconfig bond0 ipaddress netmask up</span>
<span class="cm"> *      will setup a network device, with an ip address.  No mac address</span>
<span class="cm"> *	will be assigned at this time.  The hw mac address will come from</span>
<span class="cm"> *	the first slave bonded to the channel.  All slaves will then use</span>
<span class="cm"> *	this hw mac address.</span>
<span class="cm"> *</span>
<span class="cm"> *    ifconfig bond0 down</span>
<span class="cm"> *         will release all slaves, marking them as down.</span>
<span class="cm"> *</span>
<span class="cm"> *    ifenslave bond0 eth0</span>
<span class="cm"> *	will attach eth0 to bond0 as a slave.  eth0 hw mac address will either</span>
<span class="cm"> *	a: be used as initial mac address</span>
<span class="cm"> *	b: if a hw mac address already is there, eth0&#39;s hw mac address</span>
<span class="cm"> *	   will then be set from bond0.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/udp.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &lt;linux/igmp.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;net/arp.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/if_bonding.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/preempt.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/netns/generic.h&gt;</span>
<span class="cp">#include &lt;net/pkt_sched.h&gt;</span>
<span class="cp">#include &quot;bonding.h&quot;</span>
<span class="cp">#include &quot;bond_3ad.h&quot;</span>
<span class="cp">#include &quot;bond_alb.h&quot;</span>

<span class="cm">/*---------------------------- Module parameters ----------------------------*/</span>

<span class="cm">/* monitor all links that often (in milliseconds). &lt;=0 disables monitoring */</span>
<span class="cp">#define BOND_LINK_MON_INTERV	0</span>
<span class="cp">#define BOND_LINK_ARP_INTERV	0</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">max_bonds</span>	<span class="o">=</span> <span class="n">BOND_DEFAULT_MAX_BONDS</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tx_queues</span>	<span class="o">=</span> <span class="n">BOND_DEFAULT_TX_QUEUES</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">num_peer_notif</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">miimon</span>	<span class="o">=</span> <span class="n">BOND_LINK_MON_INTERV</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">updelay</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">downdelay</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">use_carrier</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">primary</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">primary_reselect</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lacp_rate</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">min_links</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ad_select</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">xmit_hash_policy</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arp_interval</span> <span class="o">=</span> <span class="n">BOND_LINK_ARP_INTERV</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arp_ip_target</span><span class="p">[</span><span class="n">BOND_MAX_ARP_TARGETS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arp_validate</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fail_over_mac</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">all_slaves_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bond_params</span> <span class="n">bonding_defaults</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">resend_igmp</span> <span class="o">=</span> <span class="n">BOND_DEFAULT_RESEND_IGMP</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">max_bonds</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_bonds</span><span class="p">,</span> <span class="s">&quot;Max number of bonded devices&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">tx_queues</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">tx_queues</span><span class="p">,</span> <span class="s">&quot;Max number of transmit queues (default = 16)&quot;</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">num_grat_arp</span><span class="p">,</span> <span class="n">num_peer_notif</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">num_grat_arp</span><span class="p">,</span> <span class="s">&quot;Number of peer notifications to send on &quot;</span>
			       <span class="s">&quot;failover event (alias of num_unsol_na)&quot;</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">num_unsol_na</span><span class="p">,</span> <span class="n">num_peer_notif</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">num_unsol_na</span><span class="p">,</span> <span class="s">&quot;Number of peer notifications to send on &quot;</span>
			       <span class="s">&quot;failover event (alias of num_grat_arp)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">miimon</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">miimon</span><span class="p">,</span> <span class="s">&quot;Link check interval in milliseconds&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">updelay</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">updelay</span><span class="p">,</span> <span class="s">&quot;Delay before considering link up, in milliseconds&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">downdelay</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">downdelay</span><span class="p">,</span> <span class="s">&quot;Delay before considering link down, &quot;</span>
			    <span class="s">&quot;in milliseconds&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">use_carrier</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">use_carrier</span><span class="p">,</span> <span class="s">&quot;Use netif_carrier_ok (vs MII ioctls) in miimon; &quot;</span>
			      <span class="s">&quot;0 for off, 1 for on (default)&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s">&quot;Mode of operation; 0 for balance-rr, &quot;</span>
		       <span class="s">&quot;1 for active-backup, 2 for balance-xor, &quot;</span>
		       <span class="s">&quot;3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, &quot;</span>
		       <span class="s">&quot;6 for balance-alb&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">primary</span><span class="p">,</span> <span class="s">&quot;Primary network device to use&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">primary_reselect</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">primary_reselect</span><span class="p">,</span> <span class="s">&quot;Reselect primary slave &quot;</span>
				   <span class="s">&quot;once it comes up; &quot;</span>
				   <span class="s">&quot;0 for always (default), &quot;</span>
				   <span class="s">&quot;1 for only if speed of primary is &quot;</span>
				   <span class="s">&quot;better, &quot;</span>
				   <span class="s">&quot;2 for only on active slave &quot;</span>
				   <span class="s">&quot;failure&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lacp_rate</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lacp_rate</span><span class="p">,</span> <span class="s">&quot;LACPDU tx rate to request from 802.3ad partner; &quot;</span>
			    <span class="s">&quot;0 for slow, 1 for fast&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">ad_select</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ad_select</span><span class="p">,</span> <span class="s">&quot;803.ad aggregation selection logic; &quot;</span>
			    <span class="s">&quot;0 for stable (default), 1 for bandwidth, &quot;</span>
			    <span class="s">&quot;2 for count&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">min_links</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">min_links</span><span class="p">,</span> <span class="s">&quot;Minimum number of available links before turning on carrier&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">xmit_hash_policy</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">xmit_hash_policy</span><span class="p">,</span> <span class="s">&quot;balance-xor and 802.3ad hashing method; &quot;</span>
				   <span class="s">&quot;0 for layer 2 (default), 1 for layer 3+4, &quot;</span>
				   <span class="s">&quot;2 for layer 2+3&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">arp_interval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">arp_interval</span><span class="p">,</span> <span class="s">&quot;arp interval in milliseconds&quot;</span><span class="p">);</span>
<span class="n">module_param_array</span><span class="p">(</span><span class="n">arp_ip_target</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">arp_ip_target</span><span class="p">,</span> <span class="s">&quot;arp targets in n.n.n.n form&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">arp_validate</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">arp_validate</span><span class="p">,</span> <span class="s">&quot;validate src/dst of ARP probes; &quot;</span>
			       <span class="s">&quot;0 for none (default), 1 for active, &quot;</span>
			       <span class="s">&quot;2 for backup, 3 for all&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">fail_over_mac</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fail_over_mac</span><span class="p">,</span> <span class="s">&quot;For active-backup, do not set all slaves to &quot;</span>
				<span class="s">&quot;the same MAC; 0 for none (default), &quot;</span>
				<span class="s">&quot;1 for active, 2 for follow&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">all_slaves_active</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">all_slaves_active</span><span class="p">,</span> <span class="s">&quot;Keep all frames received on an interface&quot;</span>
				     <span class="s">&quot;by setting active flag for all slaves; &quot;</span>
				     <span class="s">&quot;0 for never (default), 1 for always.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">resend_igmp</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">resend_igmp</span><span class="p">,</span> <span class="s">&quot;Number of IGMP membership reports to send on &quot;</span>
			      <span class="s">&quot;link failure&quot;</span><span class="p">);</span>

<span class="cm">/*----------------------------- Global variables ----------------------------*/</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="n">atomic_t</span> <span class="n">netpoll_block_tx</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="n">bond_net_id</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="n">arp_target</span><span class="p">[</span><span class="n">BOND_MAX_ARP_TARGETS</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">arp_ip_count</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">bond_mode</span>	<span class="o">=</span> <span class="n">BOND_MODE_ROUNDROBIN</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">xmit_hashtype</span> <span class="o">=</span> <span class="n">BOND_XMIT_POLICY_LAYER2</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lacp_fast</span><span class="p">;</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">bond_lacp_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>	<span class="s">&quot;slow&quot;</span><span class="p">,</span>		<span class="n">AD_LACP_SLOW</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;fast&quot;</span><span class="p">,</span>		<span class="n">AD_LACP_FAST</span><span class="p">},</span>
<span class="p">{</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="o">-</span><span class="mi">1</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">bond_mode_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>	<span class="s">&quot;balance-rr&quot;</span><span class="p">,</span>		<span class="n">BOND_MODE_ROUNDROBIN</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;active-backup&quot;</span><span class="p">,</span>	<span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;balance-xor&quot;</span><span class="p">,</span>		<span class="n">BOND_MODE_XOR</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;broadcast&quot;</span><span class="p">,</span>		<span class="n">BOND_MODE_BROADCAST</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;802.3ad&quot;</span><span class="p">,</span>		<span class="n">BOND_MODE_8023AD</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;balance-tlb&quot;</span><span class="p">,</span>		<span class="n">BOND_MODE_TLB</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;balance-alb&quot;</span><span class="p">,</span>		<span class="n">BOND_MODE_ALB</span><span class="p">},</span>
<span class="p">{</span>	<span class="nb">NULL</span><span class="p">,</span>			<span class="o">-</span><span class="mi">1</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">xmit_hashtype_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>	<span class="s">&quot;layer2&quot;</span><span class="p">,</span>		<span class="n">BOND_XMIT_POLICY_LAYER2</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;layer3+4&quot;</span><span class="p">,</span>		<span class="n">BOND_XMIT_POLICY_LAYER34</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;layer2+3&quot;</span><span class="p">,</span>		<span class="n">BOND_XMIT_POLICY_LAYER23</span><span class="p">},</span>
<span class="p">{</span>	<span class="nb">NULL</span><span class="p">,</span>			<span class="o">-</span><span class="mi">1</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">arp_validate_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>	<span class="s">&quot;none&quot;</span><span class="p">,</span>			<span class="n">BOND_ARP_VALIDATE_NONE</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;active&quot;</span><span class="p">,</span>		<span class="n">BOND_ARP_VALIDATE_ACTIVE</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;backup&quot;</span><span class="p">,</span>		<span class="n">BOND_ARP_VALIDATE_BACKUP</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;all&quot;</span><span class="p">,</span>			<span class="n">BOND_ARP_VALIDATE_ALL</span><span class="p">},</span>
<span class="p">{</span>	<span class="nb">NULL</span><span class="p">,</span>			<span class="o">-</span><span class="mi">1</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">fail_over_mac_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>	<span class="s">&quot;none&quot;</span><span class="p">,</span>			<span class="n">BOND_FOM_NONE</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;active&quot;</span><span class="p">,</span>		<span class="n">BOND_FOM_ACTIVE</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;follow&quot;</span><span class="p">,</span>		<span class="n">BOND_FOM_FOLLOW</span><span class="p">},</span>
<span class="p">{</span>	<span class="nb">NULL</span><span class="p">,</span>			<span class="o">-</span><span class="mi">1</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">pri_reselect_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>	<span class="s">&quot;always&quot;</span><span class="p">,</span>		<span class="n">BOND_PRI_RESELECT_ALWAYS</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;better&quot;</span><span class="p">,</span>		<span class="n">BOND_PRI_RESELECT_BETTER</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;failure&quot;</span><span class="p">,</span>		<span class="n">BOND_PRI_RESELECT_FAILURE</span><span class="p">},</span>
<span class="p">{</span>	<span class="nb">NULL</span><span class="p">,</span>			<span class="o">-</span><span class="mi">1</span><span class="p">},</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">ad_select_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">{</span>	<span class="s">&quot;stable&quot;</span><span class="p">,</span>	<span class="n">BOND_AD_STABLE</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;bandwidth&quot;</span><span class="p">,</span>	<span class="n">BOND_AD_BANDWIDTH</span><span class="p">},</span>
<span class="p">{</span>	<span class="s">&quot;count&quot;</span><span class="p">,</span>	<span class="n">BOND_AD_COUNT</span><span class="p">},</span>
<span class="p">{</span>	<span class="nb">NULL</span><span class="p">,</span>		<span class="o">-</span><span class="mi">1</span><span class="p">},</span>
<span class="p">};</span>

<span class="cm">/*-------------------------- Forward declarations ---------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">bond_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">bond_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">);</span>

<span class="cm">/*---------------------------- General routines -----------------------------*/</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">bond_mode_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="n">BOND_MODE_ROUNDROBIN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;load balancing (round-robin)&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;fault-tolerance (active-backup)&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">BOND_MODE_XOR</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;load balancing (xor)&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">BOND_MODE_BROADCAST</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;fault-tolerance (broadcast)&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">BOND_MODE_8023AD</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;IEEE 802.3ad Dynamic link aggregation&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">BOND_MODE_TLB</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;transmit load balancing&quot;</span><span class="p">,</span>
		<span class="p">[</span><span class="n">BOND_MODE_ALB</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;adaptive load balancing&quot;</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">&gt;</span> <span class="n">BOND_MODE_ALB</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">names</span><span class="p">[</span><span class="n">mode</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*---------------------------------- VLAN -----------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * bond_add_vlan - add a new vlan id on bond</span>
<span class="cm"> * @bond: bond that got the notification</span>
<span class="cm"> * @vlan_id: the vlan id to add</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -ENOMEM if allocation failed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_add_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vlan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond: %s, vlan id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">bond</span> <span class="o">?</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">),</span> <span class="n">vlan_id</span><span class="p">);</span>

	<span class="n">vlan</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vlan_entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">);</span>
	<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">=</span> <span class="n">vlan_id</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">);</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;added VLAN ID %d on bond %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bond_del_vlan - delete a vlan id from bond</span>
<span class="cm"> * @bond: bond that got the notification</span>
<span class="cm"> * @vlan_id: the vlan id to delete</span>
<span class="cm"> *</span>
<span class="cm"> * returns -ENODEV if @vlan_id was not found in @bond.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_del_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vlan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond: %s, vlan id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">);</span>

	<span class="n">block_netpoll_tx</span><span class="p">();</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">==</span> <span class="n">vlan_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span>
				<span class="n">bond_alb_clear_vlan</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">);</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;removed VLAN ID %d from bond %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">vlan_id</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

			<span class="n">kfree</span><span class="p">(</span><span class="n">vlan</span><span class="p">);</span>

			<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;couldn&#39;t find VLAN ID %d in bond %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">vlan_id</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">unblock_netpoll_tx</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bond_next_vlan - safely skip to the next item in the vlans list.</span>
<span class="cm"> * @bond: the bond we&#39;re working on</span>
<span class="cm"> * @curr: item we&#39;re advancing from</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %NULL if list is empty, bond-&gt;next_vlan if @curr is %NULL,</span>
<span class="cm"> * or @curr-&gt;next otherwise (even if it is @curr itself again).</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold bond-&gt;lock</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="nf">bond_next_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">vlan_entry</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">vlan_entry</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">==</span> <span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">vlan_entry</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">vlan_entry</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bond_dev_queue_xmit - Prepare skb for xmit.</span>
<span class="cm"> *</span>
<span class="cm"> * @bond: bond device that got this skb for tx.</span>
<span class="cm"> * @skb: hw accel VLAN tagged skb to transmit</span>
<span class="cm"> * @slave_dev: slave that is supposed to xmit this skbuff</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bond_dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">)</span> <span class="o">!=</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="n">qdisc_skb_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bond_queue_mapping</span><span class="p">));</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span> <span class="o">=</span> <span class="n">qdisc_skb_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bond_queue_mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">netpoll_tx_running</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">)))</span>
		<span class="n">bond_netpoll_send_skb</span><span class="p">(</span><span class="n">bond_get_slave_by_dev</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">),</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In the following 2 functions, bond_vlan_rx_add_vid and bond_vlan_rx_kill_vid,</span>
<span class="cm"> * We don&#39;t protect the slave list iteration with a lock because:</span>
<span class="cm"> * a. This operation is performed in IOCTL context,</span>
<span class="cm"> * b. The operation is protected by the RTNL semaphore in the 8021q code,</span>
<span class="cm"> * c. Holding a lock with BH disabled while directly calling a base driver</span>
<span class="cm"> *    entry point is generally a BAD idea.</span>
<span class="cm"> *</span>
<span class="cm"> * The design of synchronization/protection for this operation in the 8021q</span>
<span class="cm"> * module is good for one or more VLAN devices over a single physical device</span>
<span class="cm"> * and cannot be extended for a teaming solution like bonding, so there is a</span>
<span class="cm"> * potential race condition here where a net device from the vlan group might</span>
<span class="cm"> * be referenced (either by a base driver or the 8021q code) while it is being</span>
<span class="cm"> * removed from the system. However, it turns out we&#39;re not making matters</span>
<span class="cm"> * worse, and if it works for regular VLAN usage it will work here too.</span>
<span class="cm">*/</span>

<span class="cm">/**</span>
<span class="cm"> * bond_vlan_rx_add_vid - Propagates adding an id to slaves</span>
<span class="cm"> * @bond_dev: bonding net device that got called</span>
<span class="cm"> * @vid: vlan id being added</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">stop_at</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">vlan_vid_add</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">bond_add_vlan</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: Failed to add vlan id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unwind:</span>
	<span class="cm">/* unwind from head to the slave that failed */</span>
	<span class="n">stop_at</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
	<span class="n">bond_for_each_slave_from_to</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">,</span> <span class="n">stop_at</span><span class="p">)</span>
		<span class="n">vlan_vid_del</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bond_vlan_rx_kill_vid - Propagates deleting an id to slaves</span>
<span class="cm"> * @bond_dev: bonding net device that got called</span>
<span class="cm"> * @vid: vlan id being removed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">vlan_vid_del</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">bond_del_vlan</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: Failed to remove vlan id %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_add_vlans_on_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">vlan_vid_add</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Failed to add vlan id %d to device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">,</span>
				   <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_del_vlans_from_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">vlan_vid_del</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*------------------------------- Link status -------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Set the carrier state for the master according to the state of its</span>
<span class="cm"> * slaves.  If any slaves are up, the master is up.  In 802.3ad mode,</span>
<span class="cm"> * do special 802.3ad magic.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if carrier state does not change, nonzero if it does.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_set_carrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">down</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bond_3ad_set_carrier</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">down:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get link speed and duplex from the slave&#39;s base driver</span>
<span class="cm"> * using ethtool. If for some reason the call fails or the</span>
<span class="cm"> * values are invalid, set speed and duplex to -1,</span>
<span class="cm"> * and return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_update_speed_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="n">ecmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">slave_speed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_UNKNOWN</span><span class="p">;</span>
	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">DUPLEX_UNKNOWN</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">__ethtool_get_settings</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">slave_speed</span> <span class="o">=</span> <span class="n">ethtool_cmd_speed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ecmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_speed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">slave_speed</span> <span class="o">==</span> <span class="p">((</span><span class="n">__u32</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ecmd</span><span class="p">.</span><span class="n">duplex</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DUPLEX_FULL</span>:
	<span class="k">case</span> <span class="n">DUPLEX_HALF</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">=</span> <span class="n">slave_speed</span><span class="p">;</span>
	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">ecmd</span><span class="p">.</span><span class="n">duplex</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * if &lt;dev&gt; supports MII link status reporting, check its link status.</span>
<span class="cm"> *</span>
<span class="cm"> * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),</span>
<span class="cm"> * depending upon the setting of the use_carrier parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * Return either BMSR_LSTATUS, meaning that the link is up (or we</span>
<span class="cm"> * can&#39;t tell and just pretend it is), or 0, meaning that the link is</span>
<span class="cm"> * down.</span>
<span class="cm"> *</span>
<span class="cm"> * If reporting is non-zero, instead of faking link up, return -1 if</span>
<span class="cm"> * both ETHTOOL and MII ioctls fail (meaning the device does not</span>
<span class="cm"> * support them).  If use_carrier is set, return whatever it says.</span>
<span class="cm"> * It&#39;d be nice if there was a good way to tell if a driver supports</span>
<span class="cm"> * netif_carrier, but there really isn&#39;t.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_check_dev_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reporting</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">slave_ops</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">mii</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reporting</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">use_carrier</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">)</span> <span class="o">?</span> <span class="n">BMSR_LSTATUS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Try to get link status using Ethtool first. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span><span class="o">-&gt;</span><span class="n">get_link</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">link</span><span class="p">;</span>

			<span class="n">link</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span><span class="o">-&gt;</span><span class="n">get_link</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">link</span> <span class="o">?</span> <span class="n">BMSR_LSTATUS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Ethtool can&#39;t be used, fallback to MII ioctls. */</span>
	<span class="n">ioctl</span> <span class="o">=</span> <span class="n">slave_ops</span><span class="o">-&gt;</span><span class="n">ndo_do_ioctl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* TODO: set pointer to correct ioctl on a per team member */</span>
		<span class="cm">/*       bases to make this more efficient. that is, once  */</span>
		<span class="cm">/*       we determine the correct ioctl, we will always    */</span>
		<span class="cm">/*       call it and not the others for that team          */</span>
		<span class="cm">/*       member.                                           */</span>

		<span class="cm">/*</span>
<span class="cm">		 * We cannot assume that SIOCGMIIPHY will also read a</span>
<span class="cm">		 * register; not all network drivers (e.g., e100)</span>
<span class="cm">		 * support that.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Yes, the mii is overlaid on the ifreq.ifr_ifru */</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
		<span class="n">mii</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IOCTL</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">SIOCGMIIPHY</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mii</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">=</span> <span class="n">MII_BMSR</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IOCTL</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">SIOCGMIIREG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">mii</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">&amp;</span> <span class="n">BMSR_LSTATUS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If reporting, report that either there&#39;s no dev-&gt;do_ioctl,</span>
<span class="cm">	 * or both SIOCGMIIREG and get_link failed (meaning that we</span>
<span class="cm">	 * cannot report link status).  If not reporting, pretend</span>
<span class="cm">	 * we&#39;re ok.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">reporting</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">BMSR_LSTATUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*----------------------------- Multicast list ------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Push the promiscuity flag down to appropriate slaves</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_set_promiscuity</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* write lock already acquired */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">inc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">inc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Push the allmulti flag down to all slaves</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_set_allmulti</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* write lock already acquired */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dev_set_allmulti</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					       <span class="n">inc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dev_set_allmulti</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">inc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a Multicast address to slaves</span>
<span class="cm"> * according to mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_mc_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* write lock already acquired */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span>
			<span class="n">dev_mc_add</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">dev_mc_add</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a multicast address from slave</span>
<span class="cm"> * according to mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_mc_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* write lock already acquired */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span>
			<span class="n">dev_mc_del</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_mc_del</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">__bond_resend_igmp_join_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">in_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_dev</span><span class="p">)</span>
		<span class="n">ip_mc_rejoin_groups</span><span class="p">(</span><span class="n">in_dev</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve the list of registered multicast addresses for the bonding</span>
<span class="cm"> * device and retransmit an IGMP JOIN request to the current active</span>
<span class="cm"> * slave.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_resend_igmp_join_requests</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="o">*</span><span class="n">vlan_dev</span><span class="p">,</span> <span class="o">*</span><span class="n">master_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">bond_dev</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* rejoin all groups on bond device */</span>
	<span class="n">__bond_resend_igmp_join_requests</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if bond is enslaved to a bridge,</span>
<span class="cm">	 * then rejoin all groups on its master</span>
<span class="cm">	 */</span>
	<span class="n">master_dev</span> <span class="o">=</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master_dev</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">master_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_EBRIDGE</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_BRIDGE_PORT</span><span class="p">))</span>
			<span class="n">__bond_resend_igmp_join_requests</span><span class="p">(</span><span class="n">master_dev</span><span class="p">);</span>

	<span class="cm">/* rejoin all groups on vlan devices */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">vlan_dev</span> <span class="o">=</span> <span class="n">__vlan_find_dev_deep</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span>
						<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_dev</span><span class="p">)</span>
			<span class="n">__bond_resend_igmp_join_requests</span><span class="p">(</span><span class="n">vlan_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">igmp_retrans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mcast_work</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">5</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_resend_igmp_join_requests_delayed</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span><span class="p">,</span>
					    <span class="n">mcast_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">bond_resend_igmp_join_requests</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * flush all members of flush-&gt;mc_list from device dev-&gt;mc_list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_mc_list_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">bond_dev</span><span class="p">)</span>
		<span class="n">dev_mc_del</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* del lacpdu mc addr from mc list */</span>
		<span class="n">u8</span> <span class="n">lacpdu_multicast</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="o">=</span> <span class="n">MULTICAST_LACPDU_ADDR</span><span class="p">;</span>

		<span class="n">dev_mc_del</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">lacpdu_multicast</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*--------------------------- Active slave change ---------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Update the mc list and multicast-related flags for the new and</span>
<span class="cm"> * old active slaves (if any) according to the multicast mode, and</span>
<span class="cm"> * promiscuous flags unconditionally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_mc_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_active</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">old_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span>
		<span class="cm">/* nothing to do -  mc list is already up-to-date on</span>
<span class="cm">		 * all slaves</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
			<span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">old_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
			<span class="n">dev_set_allmulti</span><span class="p">(</span><span class="n">old_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
			<span class="n">dev_mc_del</span><span class="p">(</span><span class="n">old_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: Signal errors upstream. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
			<span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
			<span class="n">dev_set_allmulti</span><span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
			<span class="n">dev_mc_add</span><span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bond_do_fail_over_mac</span>
<span class="cm"> *</span>
<span class="cm"> * Perform special MAC address swapping for fail_over_mac settings</span>
<span class="cm"> *</span>
<span class="cm"> * Called with RTNL, bond-&gt;lock for read, curr_slave_lock for write_bh.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_do_fail_over_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_active</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">old_active</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp_mac</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">saddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BOND_FOM_ACTIVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>  <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
			       <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
			<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_CHANGEADDR</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_FOM_FOLLOW</span>:
		<span class="cm">/*</span>
<span class="cm">		 * if new_active &amp;&amp; old_active, swap them</span>
<span class="cm">		 * if just old_active, do nothing (going to no active slave)</span>
<span class="cm">		 * if just new_active, set new_active to bond&#39;s MAC</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_active</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">old_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_mac</span><span class="p">,</span> <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">saddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">old_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
			       <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">saddr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">saddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">saddr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error %d setting MAC of slave %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">-</span><span class="n">rv</span><span class="p">,</span> <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_active</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">saddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">tmp_mac</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">saddr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">old_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

		<span class="n">rv</span> <span class="o">=</span> <span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">old_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="p">)</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error %d setting MAC of slave %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">-</span><span class="n">rv</span><span class="p">,</span> <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="nl">out:</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: bond_do_fail_over_mac impossible: bad policy %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">bond_should_change_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">prim</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prim</span> <span class="o">||</span> <span class="o">!</span><span class="n">curr</span> <span class="o">||</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">!=</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">force_primary</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">force_primary</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">primary_reselect</span> <span class="o">==</span> <span class="n">BOND_PRI_RESELECT_BETTER</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">prim</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&lt;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">prim</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">==</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&amp;&amp;</span> <span class="n">prim</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">&lt;=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">primary_reselect</span> <span class="o">==</span> <span class="n">BOND_PRI_RESELECT_FAILURE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * find_best_interface - select the best available slave to be the active one</span>
<span class="cm"> * @bond: our bonding struct</span>
<span class="cm"> *</span>
<span class="cm"> * Warning: Caller must hold curr_slave_lock for writing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="nf">bond_find_best_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_active</span><span class="p">,</span> <span class="o">*</span><span class="n">old_active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">bestslave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mintime</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">updelay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">new_active</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_active</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* there were no active slaves left */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>   <span class="cm">/* found one slave */</span>
			<span class="n">new_active</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* still no slave, return NULL */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span> <span class="o">&amp;&amp;</span>
	    <span class="n">bond_should_change_active</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_active</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remember where to stop iterating over the slaves */</span>
	<span class="n">old_active</span> <span class="o">=</span> <span class="n">new_active</span><span class="p">;</span>

	<span class="n">bond_for_each_slave_from</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_active</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">old_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">new_active</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_BACK</span> <span class="o">&amp;&amp;</span>
			   <span class="n">IS_UP</span><span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* link up, but waiting for stabilization */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">&lt;</span> <span class="n">mintime</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mintime</span> <span class="o">=</span> <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">;</span>
				<span class="n">bestslave</span> <span class="o">=</span> <span class="n">new_active</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bestslave</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">bond_should_notify_peers</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond_should_notify_peers: bond %s slave %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span> <span class="o">?</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;NULL&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave</span> <span class="o">||</span> <span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">send_peer_notif</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">__LINK_STATE_LINKWATCH_PENDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">send_peer_notif</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * change_active_interface - change the active slave into the specified one</span>
<span class="cm"> * @bond: our bonding struct</span>
<span class="cm"> * @new: the new slave to make the active one</span>
<span class="cm"> *</span>
<span class="cm"> * Set the new slave to the bond&#39;s settings and unset them on the old</span>
<span class="cm"> * curr_active_slave.</span>
<span class="cm"> * Setting include flags, mc-list, promiscuity, allmulti, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * If @new&#39;s link state is %BOND_LINK_BACK we&#39;ll set it to %BOND_LINK_UP,</span>
<span class="cm"> * because it is apparently the best available slave we have, even though its</span>
<span class="cm"> * updelay hasn&#39;t timed out yet.</span>
<span class="cm"> *</span>
<span class="cm"> * If new_active is not NULL, caller must hold bond-&gt;lock for read and</span>
<span class="cm"> * curr_slave_lock for write_bh.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bond_change_active_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">old_active</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_active</span> <span class="o">==</span> <span class="n">new_active</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_active</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_BACK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: making interface %s the new active one %d ms earlier.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">updelay</span> <span class="o">-</span> <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">)</span> <span class="o">*</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">new_active</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">new_active</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span>
				<span class="n">bond_3ad_handle_link_change</span><span class="p">(</span><span class="n">new_active</span><span class="p">,</span> <span class="n">BOND_LINK_UP</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span>
				<span class="n">bond_alb_handle_link_change</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_active</span><span class="p">,</span> <span class="n">BOND_LINK_UP</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: making interface %s the new active one.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">bond_mc_swap</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_active</span><span class="p">,</span> <span class="n">old_active</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bond_alb_handle_active_change</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_active</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_active</span><span class="p">)</span>
			<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">old_active</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="p">)</span>
			<span class="n">bond_set_slave_active_flags</span><span class="p">(</span><span class="n">new_active</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">=</span> <span class="n">new_active</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_active</span><span class="p">)</span>
			<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">old_active</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">should_notify_peers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

			<span class="n">bond_set_slave_active_flags</span><span class="p">(</span><span class="n">new_active</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span><span class="p">)</span>
				<span class="n">bond_do_fail_over_mac</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_active</span><span class="p">,</span>
						      <span class="n">old_active</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bond</span><span class="o">-&gt;</span><span class="n">send_peer_notif</span> <span class="o">=</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">num_peer_notif</span><span class="p">;</span>
				<span class="n">should_notify_peers</span> <span class="o">=</span>
					<span class="n">bond_should_notify_peers</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="n">netdev_bonding_change</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">NETDEV_BONDING_FAILOVER</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">should_notify_peers</span><span class="p">)</span>
				<span class="n">netdev_bonding_change</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						      <span class="n">NETDEV_NOTIFY_PEERS</span><span class="p">);</span>

			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* resend IGMP joins since active slave has changed or</span>
<span class="cm">	 * all were sent on curr_active_slave.</span>
<span class="cm">	 * resend only if bond is brought up with the affected</span>
<span class="cm">	 * bonding modes and the retransmission is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">resend_igmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">new_active</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ROUNDROBIN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">igmp_retrans</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">resend_igmp</span><span class="p">;</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mcast_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bond_select_active_slave - select a new active slave, if needed</span>
<span class="cm"> * @bond: our bonding struct</span>
<span class="cm"> *</span>
<span class="cm"> * This functions should be called when one of the following occurs:</span>
<span class="cm"> * - The old curr_active_slave has been released or lost its link.</span>
<span class="cm"> * - The primary_slave has got its link back.</span>
<span class="cm"> * - A slave has got its link back and there&#39;s no old curr_active_slave.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold bond-&gt;lock for read and curr_slave_lock for write_bh.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bond_select_active_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">best_slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="n">best_slave</span> <span class="o">=</span> <span class="n">bond_find_best_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">best_slave</span> <span class="o">!=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond_change_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">best_slave</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">bond_set_carrier</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: first active interface up!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: now running without any active interface !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*--------------------------- slave list handling ---------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * This function attaches the slave to the end of list.</span>
<span class="cm"> *</span>
<span class="cm"> * bond-&gt;lock held for writing by caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_attach_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* attaching the first slave */</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_slave</span><span class="p">;</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new_slave</span><span class="p">;</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span> <span class="o">=</span> <span class="n">new_slave</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">;</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new_slave</span><span class="p">;</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_slave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function detaches the slave from the list.</span>
<span class="cm"> * WARNING: no check is made to verify if the slave effectively</span>
<span class="cm"> * belongs to &lt;bond&gt;.</span>
<span class="cm"> * Nothing is freed on return, structures are just unchained.</span>
<span class="cm"> * If any slave pointer in bond was pointing to &lt;slave&gt;,</span>
<span class="cm"> * it should be changed by the calling function.</span>
<span class="cm"> *</span>
<span class="cm"> * bond-&gt;lock held for writing by caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_detach_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">slave</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">slave</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* slave is the first slave */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* there are more slave */</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* slave was the last one */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">slave_enable_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netpoll</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">np</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dev_name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__netpoll_setup</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">slave_disable_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netpoll</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">synchronize_rcu_bh</span><span class="p">();</span>
	<span class="n">__netpoll_cleanup</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">slave_dev_support_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_DISABLE_NETPOLL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_poll_controller</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_poll_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__bond_netpoll_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_UP</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">slave_disable_netpoll</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_netpoll_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__bond_netpoll_cleanup</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_netpoll_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netpoll_info</span> <span class="o">*</span><span class="n">ni</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">slave_enable_netpoll</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__bond_netpoll_cleanup</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">netpoll_info</span> <span class="o">*</span><span class="nf">bond_netpoll_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">npinfo</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">slave_enable_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">slave_disable_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_netpoll_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*---------------------------------- IOCTL ----------------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_sethwaddr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond_dev=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bond_dev</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;slave_dev=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;slave_dev-&gt;addr_len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_features_t</span> <span class="nf">bond_fix_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netdev_features_t</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable adding VLANs to empty bond. But why? --mq */</span>
		<span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_VLAN_CHALLENGED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_ONE_FOR_ALL</span><span class="p">;</span>
	<span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_ALL_FOR_ALL</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">features</span> <span class="o">=</span> <span class="n">netdev_increment_features</span><span class="p">(</span><span class="n">features</span><span class="p">,</span>
						     <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">,</span>
						     <span class="n">mask</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">features</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define BOND_VLAN_FEATURES	(NETIF_F_ALL_CSUM | NETIF_F_SG | \</span>
<span class="cp">				 NETIF_F_FRAGLIST | NETIF_F_ALL_TSO | \</span>
<span class="cp">				 NETIF_F_HIGHDMA | NETIF_F_LRO)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_compute_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">netdev_features_t</span> <span class="n">vlan_features</span> <span class="o">=</span> <span class="n">BOND_VLAN_FEATURES</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_hard_header_len</span> <span class="o">=</span> <span class="n">ETH_HLEN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vlan_features</span> <span class="o">=</span> <span class="n">netdev_increment_features</span><span class="p">(</span><span class="n">vlan_features</span><span class="p">,</span>
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vlan_features</span><span class="p">,</span> <span class="n">BOND_VLAN_FEATURES</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span> <span class="o">&gt;</span> <span class="n">max_hard_header_len</span><span class="p">)</span>
			<span class="n">max_hard_header_len</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">=</span> <span class="n">vlan_features</span><span class="p">;</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span> <span class="o">=</span> <span class="n">max_hard_header_len</span><span class="p">;</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">netdev_change_features</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_setup_by_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">header_ops</span>	    <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">header_ops</span><span class="p">;</span>

	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">type</span>		    <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span>   <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">;</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span>	    <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span>
		<span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">setup_by_slave</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* On bonding slaves other than the currently active slave, suppress</span>
<span class="cm"> * duplicates except for alb non-mcast/bcast.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">bond_should_deliver_exact_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_slave_inactive</span><span class="p">(</span><span class="n">slave</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ALB</span> <span class="o">&amp;&amp;</span>
		    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">!=</span> <span class="n">PACKET_BROADCAST</span> <span class="o">&amp;&amp;</span>
		    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">!=</span> <span class="n">PACKET_MULTICAST</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">rx_handler_result_t</span> <span class="nf">bond_handle_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">pskb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="o">*</span><span class="n">pskb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">recv_probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">RX_HANDLER_ANOTHER</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_share_check</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">RX_HANDLER_CONSUMED</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pskb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">slave</span> <span class="o">=</span> <span class="n">bond_slave_get_rcu</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bond</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">bond</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">)</span>
		<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">recv_probe</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">recv_probe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">recv_probe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nskb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">recv_probe</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">RX_HANDLER_CONSUMED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">consume_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_should_deliver_exact_match</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">RX_HANDLER_EXACT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ALB</span> <span class="o">&amp;&amp;</span>
	    <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_BRIDGE_PORT</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_HOST</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_cow_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">RX_HANDLER_CONSUMED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* enslave device &lt;slave&gt; to bond device &lt;master&gt; */</span>
<span class="kt">int</span> <span class="nf">bond_enslave</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">slave_ops</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">link_reporting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">use_carrier</span> <span class="o">&amp;&amp;</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		<span class="n">slave_ops</span><span class="o">-&gt;</span><span class="n">ndo_do_ioctl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: no link monitoring support for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* already enslaved */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_SLAVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Error, Device was already enslaved</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* vlan challenged mutual exclusion */</span>
	<span class="cm">/* no need to lock since we&#39;re protected by rtnl_lock */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_VLAN_CHALLENGED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: NETIF_F_VLAN_CHALLENGED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_vlan_used</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				   <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: ! NETIF_F_VLAN_CHALLENGED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Old ifenslave binaries are no longer supported.  These can</span>
<span class="cm">	 * be identified with moderate accuracy by the state of the slave:</span>
<span class="cm">	 * the current ifenslave will set the interface down prior to</span>
<span class="cm">	 * enslaving it; the old ifenslave will not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s is up. This may be due to an out of date ifenslave.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_undo_flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set bonding device ether type by slave - bonding netdevices are</span>
<span class="cm">	 * created with ether_setup, so when the slave type is not ARPHRD_ETHER</span>
<span class="cm">	 * there is a need to override some of the type dependent attribs/funcs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * bond ether type mutual exclusion - don&#39;t allow slaves of dissimilar</span>
<span class="cm">	 * ether type (eg ARPHRD_ETHER and ARPHRD_INFINIBAND) share the same bond</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: change device type from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				 <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

			<span class="n">res</span> <span class="o">=</span> <span class="n">netdev_bonding_change</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span>
						    <span class="n">NETDEV_PRE_TYPE_CHANGE</span><span class="p">);</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">notifier_to_errno</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: refused to change device type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err_undo_flags</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Flush unicast and multicast addresses */</span>
			<span class="n">dev_uc_flush</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
			<span class="n">dev_mc_flush</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_ETHER</span><span class="p">)</span>
				<span class="n">bond_setup_by_slave</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">ether_setup</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
				<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFF_TX_SKB_SHARING</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">netdev_bonding_change</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span>
					      <span class="n">NETDEV_POST_TYPE_CHANGE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s ether type (%d) is different from other slaves (%d), can not enslave it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_undo_flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slave_ops</span><span class="o">-&gt;</span><span class="n">ndo_set_mac_address</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.&quot;</span><span class="p">,</span>
				   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span> <span class="o">=</span> <span class="n">BOND_FOM_ACTIVE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span> <span class="o">!=</span> <span class="n">BOND_FOM_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_undo_flags</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_JOIN</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>

	<span class="cm">/* If this is the first slave, then we need to set the master&#39;s hardware</span>
<span class="cm">	 * address to be the same as the slave&#39;s. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
		       <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>


	<span class="n">new_slave</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_undo_flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the new_slave&#39;s queue_id to be zero.  Queue ID mapping</span>
<span class="cm">	 * is set via sysfs or module option if desired.</span>
<span class="cm">	 */</span>
	<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Save slave&#39;s original mtu and then set it to match the bond */</span>
	<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">original_mtu</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">dev_set_mtu</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Error %d calling dev_set_mtu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save slave&#39;s original (&quot;permanent&quot;) mac address for modes</span>
<span class="cm">	 * that need it, and for restoring it upon release, and then</span>
<span class="cm">	 * set it to the master&#39;s address</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Set slave to master&#39;s mac address.  The application already</span>
<span class="cm">		 * set the master&#39;s mac address to that of the first slave</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="n">addr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Error %d calling set_mac_address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_restore_mtu</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">netdev_set_bond_master</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Error %d calling netdev_set_bond_master</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_restore_mac</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* open the slave since the application closed it */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">dev_open</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Opening slave %s failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_unset_master</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">bond</span> <span class="o">=</span> <span class="n">bond</span><span class="p">;</span>
	<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="p">;</span>
	<span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_BONDING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* bond_alb_init_slave() must be called before all other stages since</span>
<span class="cm">		 * it might fail and we do not want to have to undo everything</span>
<span class="cm">		 */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">bond_alb_init_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_slave</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If the mode USES_PRIMARY, then the new slave gets the</span>
<span class="cm">	 * master&#39;s promisc (and mc) settings only if it becomes the</span>
<span class="cm">	 * curr_active_slave, and that is taken care of later when calling</span>
<span class="cm">	 * bond_change_active()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* set promiscuity level to new slave */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_close</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* set allmulti level to new slave */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">dev_set_allmulti</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_close</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">netif_addr_lock_bh</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
		<span class="cm">/* upload master&#39;s mc_list to new slave */</span>
		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">bond_dev</span><span class="p">)</span>
			<span class="n">dev_mc_add</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">netif_addr_unlock_bh</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* add lacpdu mc addr to mc list */</span>
		<span class="n">u8</span> <span class="n">lacpdu_multicast</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="o">=</span> <span class="n">MULTICAST_LACPDU_ADDR</span><span class="p">;</span>

		<span class="n">dev_mc_add</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">lacpdu_multicast</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bond_add_vlans_on_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">bond_attach_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_slave</span><span class="p">);</span>

	<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">bond_compute_features</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">last_arp_rx</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">use_carrier</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">link_reporting</span> <span class="o">=</span> <span class="n">bond_check_dev_link</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">link_reporting</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * miimon is set but a bonded network driver</span>
<span class="cm">			 * does not support ETHTOOL/MII and</span>
<span class="cm">			 * arp_interval is not set.  Note: if</span>
<span class="cm">			 * use_carrier is enabled, we will never go</span>
<span class="cm">			 * here (because netif_carrier is always</span>
<span class="cm">			 * supported); thus, we don&#39;t need to change</span>
<span class="cm">			 * the messages for netif_carrier.</span>
<span class="cm">			 */</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">link_reporting</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* unable get link status using mii/ethtool */</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: can&#39;t get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* check for initial state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_check_dev_link</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">BMSR_LSTATUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">updelay</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_BACK</span><span class="p">;</span>
				<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">updelay</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">BOND_LINK_UP</span> <span class="o">:</span> <span class="n">BOND_LINK_DOWN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">!=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">)</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Initial state of slave_dev is BOND_LINK_%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_DOWN</span> <span class="o">?</span> <span class="s">&quot;DOWN&quot;</span> <span class="o">:</span>
			<span class="p">(</span><span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span> <span class="o">?</span> <span class="s">&quot;UP&quot;</span> <span class="o">:</span> <span class="s">&quot;BACK&quot;</span><span class="p">));</span>

	<span class="n">bond_update_speed_duplex</span><span class="p">(</span><span class="n">new_slave</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">primary</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/* if there is a primary slave, remember it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">primary</span><span class="p">,</span> <span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span> <span class="o">=</span> <span class="n">new_slave</span><span class="p">;</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">force_primary</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span>:
		<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">new_slave</span><span class="p">);</span>
		<span class="n">bond_select_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_MODE_8023AD</span>:
		<span class="cm">/* in 802.3ad mode, the internal mechanism</span>
<span class="cm">		 * will activate the slaves in the selected</span>
<span class="cm">		 * aggregator</span>
<span class="cm">		 */</span>
		<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">new_slave</span><span class="p">);</span>
		<span class="cm">/* if this is the first slave */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SLAVE_AD_INFO</span><span class="p">(</span><span class="n">new_slave</span><span class="p">).</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Initialize AD with the number of times that the AD timer is called in 1 second</span>
<span class="cm">			 * can be called only after the mac address of the bond is set</span>
<span class="cm">			 */</span>
			<span class="n">bond_3ad_initialize</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="mi">1000</span><span class="o">/</span><span class="n">AD_TIMER_INTERVAL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">SLAVE_AD_INFO</span><span class="p">(</span><span class="n">new_slave</span><span class="p">).</span><span class="n">id</span> <span class="o">=</span>
				<span class="n">SLAVE_AD_INFO</span><span class="p">(</span><span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">).</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bond_3ad_bind_slave</span><span class="p">(</span><span class="n">new_slave</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_MODE_TLB</span>:
	<span class="k">case</span> <span class="n">BOND_MODE_ALB</span>:
		<span class="n">bond_set_active_slave</span><span class="p">(</span><span class="n">new_slave</span><span class="p">);</span>
		<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">new_slave</span><span class="p">);</span>
		<span class="n">bond_select_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;This slave is always active in trunk mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* always active in trunk mode */</span>
		<span class="n">bond_set_active_slave</span><span class="p">(</span><span class="n">new_slave</span><span class="p">);</span>

		<span class="cm">/* In trunking mode there is little meaning to curr_active_slave</span>
<span class="cm">		 * anyway (it holds no special properties of the bond device),</span>
<span class="cm">		 * so we can change it without calling change_active_interface()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">=</span> <span class="n">new_slave</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* switch(bond_mode) */</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="n">bond_set_carrier</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">npinfo</span> <span class="o">=</span> <span class="n">bond_netpoll_info</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">npinfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave_enable_netpoll</span><span class="p">(</span><span class="n">new_slave</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Error, %s: master_dev is using netpoll, &quot;</span>
				 <span class="s">&quot;but new slave device does not support netpoll.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_detach</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">bond_create_slave_symlinks</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_detach</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">netdev_rx_handler_register</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">bond_handle_frame</span><span class="p">,</span>
					 <span class="n">new_slave</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Error %d calling netdev_rx_handler_register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_dest_symlinks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: enslaving %s as a%s interface with a%s link.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">new_slave</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;n active&quot;</span> <span class="o">:</span> <span class="s">&quot; backup&quot;</span><span class="p">,</span>
		<span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">!=</span> <span class="n">BOND_LINK_DOWN</span> <span class="o">?</span> <span class="s">&quot;n up&quot;</span> <span class="o">:</span> <span class="s">&quot; down&quot;</span><span class="p">);</span>

	<span class="cm">/* enslave is successful */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Undo stages on error */</span>
<span class="nl">err_dest_symlinks:</span>
	<span class="n">bond_destroy_slave_symlinks</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>

<span class="nl">err_detach:</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bond_detach_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_slave</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="nl">err_close:</span>
	<span class="n">dev_close</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">);</span>

<span class="nl">err_unset_master:</span>
	<span class="n">netdev_set_bond_master</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="nl">err_restore_mac:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX TODO - fom follow mode needs to change master&#39;s</span>
<span class="cm">		 * MAC if this slave&#39;s MAC is in use by the bond, or at</span>
<span class="cm">		 * least print a warning.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">addr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">err_restore_mtu:</span>
	<span class="n">dev_set_mtu</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">new_slave</span><span class="o">-&gt;</span><span class="n">original_mtu</span><span class="p">);</span>

<span class="nl">err_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">new_slave</span><span class="p">);</span>

<span class="nl">err_undo_flags:</span>
	<span class="n">bond_compute_features</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to release the slave device &lt;slave&gt; from the bond device &lt;master&gt;</span>
<span class="cm"> * It is legal to access curr_active_slave without a lock because all the function</span>
<span class="cm"> * is write-locked.</span>
<span class="cm"> *</span>
<span class="cm"> * The rules for slave state should be:</span>
<span class="cm"> *   for Active/Backup:</span>
<span class="cm"> *     Active stays on all backups go down</span>
<span class="cm"> *   for Bonded connections:</span>
<span class="cm"> *     The first up interface should be left on and all others downed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bond_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">oldcurrent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">netdev_features_t</span> <span class="n">old_features</span> <span class="o">=</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>

	<span class="cm">/* slave is not a slave or master is not master of this slave */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_SLAVE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">!=</span> <span class="n">bond_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: cannot release %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block_netpoll_tx</span><span class="p">();</span>
	<span class="n">netdev_bonding_change</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">NETDEV_RELEASE</span><span class="p">);</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">slave</span> <span class="o">=</span> <span class="n">bond_get_slave_by_dev</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not a slave of this bond */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: %s not enslaved</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">unblock_netpoll_tx</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* unregister rx_handler early so bond_handle_frame wouldn&#39;t be called</span>
<span class="cm">	 * for this slave anymore.</span>
<span class="cm">	 */</span>
	<span class="n">netdev_rx_handler_unregister</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">synchronize_net</span><span class="p">();</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				   <span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span>
				   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Inform AD package of unbinding of slave. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* must be called before the slave is</span>
<span class="cm">		 * detached from the list</span>
<span class="cm">		 */</span>
		<span class="n">bond_3ad_unbind_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: releasing %s interface %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;active&quot;</span> <span class="o">:</span> <span class="s">&quot;backup&quot;</span><span class="p">,</span>
		<span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">oldcurrent</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>

	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* release the slave from its bond */</span>
	<span class="n">bond_detach_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oldcurrent</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span>
		<span class="n">bond_change_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Must be called only after the slave has been</span>
<span class="cm">		 * detached from the list and the curr_active_slave</span>
<span class="cm">		 * has been cleared (if our_slave == old_current),</span>
<span class="cm">		 * but before a new active slave is selected.</span>
<span class="cm">		 */</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">bond_alb_deinit_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oldcurrent</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note that we hold RTNL over this sequence, so there</span>
<span class="cm">		 * is no concern that another slave add/remove event</span>
<span class="cm">		 * will interfere.</span>
<span class="cm">		 */</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

		<span class="n">bond_select_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond_set_carrier</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

		<span class="cm">/* if the last slave was removed, zero the mac address</span>
<span class="cm">		 * of the master so it will be set by the application</span>
<span class="cm">		 * to the mac address of the first slave</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond_vlan_used</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: clearing HW address of %s while it still has VLANs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: When re-adding slaves, make sure the bond&#39;s HW address matches its VLANs&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">unblock_netpoll_tx</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_CHANGEADDR</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">bond_compute_features</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_VLAN_CHALLENGED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">old_features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_VLAN_CHALLENGED</span><span class="p">))</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: last VLAN challenged slave %s left bond %s. VLAN blocking is removed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/* must do this from outside any spinlocks */</span>
	<span class="n">bond_destroy_slave_symlinks</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>

	<span class="n">bond_del_vlans_from_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>

	<span class="cm">/* If the mode USES_PRIMARY, then we should only remove its</span>
<span class="cm">	 * promisc and mc settings if it was the curr_active_slave, but that was</span>
<span class="cm">	 * already taken care of above when we detached the slave</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* unset promiscuity level from slave */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
			<span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* unset allmulti level from slave */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
			<span class="n">dev_set_allmulti</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* flush master&#39;s mc_list from slave */</span>
		<span class="n">netif_addr_lock_bh</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
		<span class="n">bond_mc_list_flush</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
		<span class="n">netif_addr_unlock_bh</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netdev_set_bond_master</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">slave_disable_netpoll</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

	<span class="cm">/* close slave before restoring its mac address */</span>
	<span class="n">dev_close</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span> <span class="o">!=</span> <span class="n">BOND_FOM_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* restore original (&quot;permanent&quot;) mac address */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">addr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_set_mtu</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">original_mtu</span><span class="p">);</span>

	<span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFF_BONDING</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* deletion OK */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">* First release a slave and then destroy the bond if no more slaves are left.</span>
<span class="cm">* Must be under rtnl_lock when this function is called.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="nf">bond_release_and_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">bond_release</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_DISABLE_NETPOLL</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: destroying bond %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">unregister_netdevice</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function releases all slaves.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_release_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bond_change_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">slave</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Inform AD package of unbinding of slave</span>
<span class="cm">		 * before slave is detached from the list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span>
			<span class="n">bond_3ad_unbind_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

		<span class="n">slave_dev</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">bond_detach_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>

		<span class="cm">/* now that the slave is detached, unlock and perform</span>
<span class="cm">		 * all the undo steps that should not be called from</span>
<span class="cm">		 * within a lock.</span>
<span class="cm">		 */</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* unregister rx_handler early so bond_handle_frame wouldn&#39;t</span>
<span class="cm">		 * be called for this slave anymore.</span>
<span class="cm">		 */</span>
		<span class="n">netdev_rx_handler_unregister</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">);</span>
		<span class="n">synchronize_net</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* must be called only after the slave</span>
<span class="cm">			 * has been detached from the list</span>
<span class="cm">			 */</span>
			<span class="n">bond_alb_deinit_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">bond_destroy_slave_symlinks</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
		<span class="n">bond_del_vlans_from_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>

		<span class="cm">/* If the mode USES_PRIMARY, then we should only remove its</span>
<span class="cm">		 * promisc and mc settings if it was the curr_active_slave, but that was</span>
<span class="cm">		 * already taken care of above when we detached the slave</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* unset promiscuity level from slave */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
				<span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* unset allmulti level from slave */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
				<span class="n">dev_set_allmulti</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* flush master&#39;s mc_list from slave */</span>
			<span class="n">netif_addr_lock_bh</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
			<span class="n">bond_mc_list_flush</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
			<span class="n">netif_addr_unlock_bh</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">netdev_set_bond_master</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">slave_disable_netpoll</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

		<span class="cm">/* close slave before restoring its mac address */</span>
		<span class="n">dev_close</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* restore original (&quot;permanent&quot;) mac address*/</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="n">addr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
			<span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

		<span class="cm">/* re-acquire the lock before getting the next slave */</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* zero the mac address of the master so it will be</span>
<span class="cm">	 * set by the application to the mac address of the</span>
<span class="cm">	 * first slave</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_vlan_used</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: clearing HW address of %s while it still has VLANs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: When re-adding slaves, make sure the bond&#39;s HW address matches its VLANs&#39;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: released all slaves</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">bond_compute_features</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function changes the active slave to slave &lt;slave_dev&gt;.</span>
<span class="cm"> * It returns -EINVAL in the following cases.</span>
<span class="cm"> *  - &lt;slave_dev&gt; is not found in the list.</span>
<span class="cm"> *  - There is not active slave now.</span>
<span class="cm"> *  - &lt;slave_dev&gt; is already active.</span>
<span class="cm"> *  - The link state of &lt;slave_dev&gt; is not BOND_LINK_UP.</span>
<span class="cm"> *  - &lt;slave_dev&gt; is not running.</span>
<span class="cm"> * In these cases, this function does nothing.</span>
<span class="cm"> * In the other cases, current_slave pointer is changed and 0 is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_ioctl_change_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">old_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Verify that master_dev is indeed the master of slave_dev */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_SLAVE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">!=</span> <span class="n">bond_dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
	<span class="n">old_active</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="n">new_active</span> <span class="o">=</span> <span class="n">bond_get_slave_by_dev</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Changing to the current active: do nothing; return success.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_active</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">new_active</span> <span class="o">==</span> <span class="n">old_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">new_active</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">old_active</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">IS_UP</span><span class="p">(</span><span class="n">new_active</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">block_netpoll_tx</span><span class="p">();</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">bond_change_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_active</span><span class="p">);</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">unblock_netpoll_tx</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_info_query</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifbond</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">bond_mode</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">miimon</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">num_slaves</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_slave_info_query</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifslave</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">slave_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">slave_name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">bond_slave_state</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------------- Monitoring -------------------------------*/</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_miimon_inspect</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">link_state</span><span class="p">,</span> <span class="n">commit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ignore_updelay</span><span class="p">;</span>

	<span class="n">ignore_updelay</span> <span class="o">=</span> <span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span> <span class="o">=</span> <span class="n">BOND_LINK_NOCHANGE</span><span class="p">;</span>

		<span class="n">link_state</span> <span class="o">=</span> <span class="n">bond_check_dev_link</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BOND_LINK_UP</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">link_state</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_FAIL</span><span class="p">;</span>
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">downdelay</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status down for %sinterface %s, disabling it in %d ms.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span>
					 <span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">)</span> <span class="o">?</span>
					<span class="p">(</span><span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">)</span> <span class="o">?</span>
					 <span class="s">&quot;active &quot;</span> <span class="o">:</span> <span class="s">&quot;backup &quot;</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
					<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">downdelay</span> <span class="o">*</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*FALLTHRU*/</span>
		<span class="k">case</span> <span class="n">BOND_LINK_FAIL</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">link_state</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * recovered before downdelay expired</span>
<span class="cm">				 */</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status up again after %d ms for interface %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">downdelay</span> <span class="o">-</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">)</span> <span class="o">*</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">,</span>
					<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span> <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>
				<span class="n">commit</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span><span class="o">--</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BOND_LINK_DOWN</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link_state</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_BACK</span><span class="p">;</span>
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">updelay</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status up for interface %s, enabling it in %d ms.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">ignore_updelay</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">updelay</span> <span class="o">*</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/*FALLTHRU*/</span>
		<span class="k">case</span> <span class="n">BOND_LINK_BACK</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link_state</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status down again after %d ms for interface %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">updelay</span> <span class="o">-</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span><span class="p">)</span> <span class="o">*</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">,</span>
					<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ignore_updelay</span><span class="p">)</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span> <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>
				<span class="n">commit</span><span class="o">++</span><span class="p">;</span>
				<span class="n">ignore_updelay</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">delay</span><span class="o">--</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">commit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_miimon_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BOND_LINK_NOCHANGE</span>:
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BOND_LINK_UP</span>:
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* prevent it from being the active one */</span>
				<span class="n">bond_set_backup_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* make it immediately active */</span>
				<span class="n">bond_set_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">slave</span> <span class="o">!=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* prevent it from being the active one */</span>
				<span class="n">bond_set_backup_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">bond_update_speed_duplex</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status definitely up for interface %s, %u Mbps %s duplex.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">?</span> <span class="s">&quot;full&quot;</span> <span class="o">:</span> <span class="s">&quot;half&quot;</span><span class="p">);</span>

			<span class="cm">/* notify ad that the link status has changed */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span>
				<span class="n">bond_3ad_handle_link_change</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="n">BOND_LINK_UP</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span>
				<span class="n">bond_alb_handle_link_change</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span>
							    <span class="n">BOND_LINK_UP</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">slave</span> <span class="o">==</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">do_failover</span><span class="p">;</span>

			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BOND_LINK_DOWN</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">&lt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span><span class="o">++</span><span class="p">;</span>

			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span> <span class="o">||</span>
			    <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span>
				<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status definitely down for interface %s, disabling it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span>
				<span class="n">bond_3ad_handle_link_change</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span>
							    <span class="n">BOND_LINK_DOWN</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span>
				<span class="n">bond_alb_handle_link_change</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span>
							    <span class="n">BOND_LINK_DOWN</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span> <span class="o">==</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">do_failover</span><span class="p">;</span>

			<span class="k">continue</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: invalid new link %d on slave %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span><span class="p">,</span>
			       <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span> <span class="o">=</span> <span class="n">BOND_LINK_NOCHANGE</span><span class="p">;</span>

			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">do_failover:</span>
		<span class="n">ASSERT_RTNL</span><span class="p">();</span>
		<span class="n">block_netpoll_tx</span><span class="p">();</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">bond_select_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">unblock_netpoll_tx</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">bond_set_carrier</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bond_mii_monitor</span>
<span class="cm"> *</span>
<span class="cm"> * Really a wrapper that splits the mii monitor into two phases: an</span>
<span class="cm"> * inspection, then (if inspection indicates something needs to be done)</span>
<span class="cm"> * an acquisition of appropriate locks followed by a commit phase to</span>
<span class="cm"> * implement whatever link state changes are indicated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bond_mii_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span><span class="p">,</span>
					    <span class="n">mii_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">should_notify_peers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">delay</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">re_arm</span><span class="p">;</span>

	<span class="n">should_notify_peers</span> <span class="o">=</span> <span class="n">bond_should_notify_peers</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_miimon_inspect</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* Race avoidance with bond_close cancel of workqueue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtnl_trylock</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">should_notify_peers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">re_arm</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">bond_miimon_commit</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>	<span class="cm">/* might sleep, hold no other locks */</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">re_arm:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mii_work</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">should_notify_peers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtnl_trylock</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">send_peer_notif</span><span class="o">++</span><span class="p">;</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">netdev_bonding_change</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">NETDEV_NOTIFY_PEERS</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_has_this_ip</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">vlan_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">==</span> <span class="n">bond_confirm_addr</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">vlan_dev</span> <span class="o">=</span> <span class="n">__vlan_find_dev_deep</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_dev</span> <span class="o">&amp;&amp;</span> <span class="n">ip</span> <span class="o">==</span> <span class="n">bond_confirm_addr</span><span class="p">(</span><span class="n">vlan_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ip</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We go to the (large) trouble of VLAN tagging ARP frames because</span>
<span class="cm"> * switches in VLAN mode (especially if ports are configured as</span>
<span class="cm"> * &quot;native&quot; to a VLAN) might not pass non-tagged frames.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_arp_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arp_op</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">dest_ip</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">src_ip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vlan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;arp %d on slave %s: dst %x src %x vid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arp_op</span><span class="p">,</span>
		 <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dest_ip</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">arp_create</span><span class="p">(</span><span class="n">arp_op</span><span class="p">,</span> <span class="n">ETH_P_ARP</span><span class="p">,</span> <span class="n">dest_ip</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">,</span> <span class="n">src_ip</span><span class="p">,</span>
			 <span class="nb">NULL</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ARP packet allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">vlan_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;failed to insert VLAN tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">arp_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_arp_send_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">targets</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_targets</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">vlan_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">BOND_MAX_ARP_TARGETS</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__be32</span> <span class="n">addr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;basa: target %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond_vlan_used</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;basa: empty vlan: arp_send</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">bond_confirm_addr</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bond_arp_send</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ARPOP_REQUEST</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				      <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If VLANs are configured, we do a route lookup to</span>
<span class="cm">		 * determine which VLAN interface would be used, so we</span>
<span class="cm">		 * can tag the ARP with the proper VLAN tag.</span>
<span class="cm">		 */</span>
		<span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">RTO_ONLINK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: no route to arp_ip_target %pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * This target is not on a VLAN</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span> <span class="o">==</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;basa: rtdev == bond-&gt;dev: arp_send</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">bond_confirm_addr</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bond_arp_send</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ARPOP_REQUEST</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				      <span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">vlan_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcu_read_lock</span><span class="p">();</span>
			<span class="n">vlan_dev</span> <span class="o">=</span> <span class="n">__vlan_find_dev_deep</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vlan_dev</span> <span class="o">==</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vlan_id</span> <span class="o">=</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">;</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;basa: vlan match on %s %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">vlan_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_id</span> <span class="o">&amp;&amp;</span> <span class="n">vlan_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">bond_confirm_addr</span><span class="p">(</span><span class="n">vlan_dev</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bond_arp_send</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ARPOP_REQUEST</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				      <span class="n">addr</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: no path to arp_ip_target %pI4 via rt.dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				   <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span> <span class="o">?</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;NULL&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_validate_arp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">sip</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">tip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">targets</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_targets</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">BOND_MAX_ARP_TARGETS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bva: sip %pI4 tip %pI4 t[%d] %pI4 bhti(tip) %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tip</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			 <span class="n">bond_has_this_ip</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">tip</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sip</span> <span class="o">==</span> <span class="n">targets</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond_has_this_ip</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">tip</span><span class="p">))</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">last_arp_rx</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_arp_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arphdr</span> <span class="o">*</span><span class="n">arp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arp_ptr</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">__cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_ARP</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">RX_HANDLER_ANOTHER</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond_arp_rcv: bond %s skb-&gt;dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">arp_hdr_len</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">arp</span> <span class="o">=</span> <span class="n">arp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hln</span> <span class="o">!=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span> <span class="o">||</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_OTHERHOST</span> <span class="o">||</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">==</span> <span class="n">PACKET_LOOPBACK</span> <span class="o">||</span>
	    <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_hrd</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPHRD_ETHER</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pro</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ar_pln</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">arp_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">arp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="n">arp_ptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">arp_ptr</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tip</span><span class="p">,</span> <span class="n">arp_ptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond_arp_rcv: %s %s/%d av %d sv %d sip %pI4 tip %pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond_slave_state</span><span class="p">(</span><span class="n">slave</span><span class="p">),</span>
		 <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_validate</span><span class="p">,</span> <span class="n">slave_do_arp_validate</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">),</span>
		 <span class="o">&amp;</span><span class="n">sip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tip</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Backup slaves won&#39;t see the ARP reply, but do come through</span>
<span class="cm">	 * here for each ARP probe (so we swap the sip/tip to validate</span>
<span class="cm">	 * the probe).  In a &quot;redundant switch, common router&quot; type of</span>
<span class="cm">	 * configuration, the ARP probe will (hopefully) travel from</span>
<span class="cm">	 * the active, through one switch, the router, then the other</span>
<span class="cm">	 * switch before reaching the backup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">))</span>
		<span class="n">bond_validate_arp</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">sip</span><span class="p">,</span> <span class="n">tip</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bond_validate_arp</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">tip</span><span class="p">,</span> <span class="n">sip</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">RX_HANDLER_ANOTHER</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this function is called regularly to monitor each slave&#39;s link</span>
<span class="cm"> * ensuring that traffic is being sent and received when arp monitoring</span>
<span class="cm"> * is used in load-balancing mode. if the adapter has been dormant, then an</span>
<span class="cm"> * arp is transmitted to generate traffic. see activebackup_arp_monitor for</span>
<span class="cm"> * arp monitoring in active backup mode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bond_loadbalance_arp_mon</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span><span class="p">,</span>
					    <span class="n">arp_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">oldcurrent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_failover</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delta_in_ticks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">delta_in_ticks</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">re_arm</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
	<span class="n">oldcurrent</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="cm">/* see if any of the previous devices are up now (i.e. they have</span>
<span class="cm">	 * xmt and rcv traffic). the curr_active_slave does not come into</span>
<span class="cm">	 * the picture unless it is null. also, slave-&gt;jiffies is not needed</span>
<span class="cm">	 * here because we send an arp on each slave and give a slave as</span>
<span class="cm">	 * long as it needs to get the tx/rx within the delta.</span>
<span class="cm">	 * TODO: what about up/down delay in arp mode? it wasn&#39;t here before</span>
<span class="cm">	 *       so it can wait</span>
<span class="cm">	 */</span>
	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trans_start</span> <span class="o">=</span> <span class="n">dev_trans_start</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">!=</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				<span class="n">trans_start</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
				<span class="n">trans_start</span> <span class="o">+</span> <span class="n">delta_in_ticks</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">+</span> <span class="n">delta_in_ticks</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span>  <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>
				<span class="n">bond_set_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

				<span class="cm">/* primary_slave has no meaning in round-robin</span>
<span class="cm">				 * mode. the window of a slave being up and</span>
<span class="cm">				 * curr_active_slave being null after enslaving</span>
<span class="cm">				 * is closed.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oldcurrent</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status definitely up for interface %s, &quot;</span><span class="p">,</span>
						<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="n">do_failover</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: interface %s is now up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
						<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* slave-&gt;link == BOND_LINK_UP */</span>

			<span class="cm">/* not all switches will respond to an arp request</span>
<span class="cm">			 * when the source ip is 0, so don&#39;t take the link down</span>
<span class="cm">			 * if we don&#39;t know our ip yet</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				<span class="n">trans_start</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
				<span class="n">trans_start</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">delta_in_ticks</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_rx</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">delta_in_ticks</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span>  <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>
				<span class="n">bond_set_backup_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">&lt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
					<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span><span class="o">++</span><span class="p">;</span>

				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: interface %s is now down.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					<span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">slave</span> <span class="o">==</span> <span class="n">oldcurrent</span><span class="p">)</span>
					<span class="n">do_failover</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* note: if switch is in round-robin mode, all links</span>
<span class="cm">		 * must tx arp to ensure all links rx an arp - otherwise</span>
<span class="cm">		 * links may oscillate or not come up at all; if switch is</span>
<span class="cm">		 * in something like xor mode, there is nothing we can</span>
<span class="cm">		 * do - all replies will be rx&#39;ed on same link causing slaves</span>
<span class="cm">		 * to be unstable during low/no traffic periods</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_UP</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">bond_arp_send_all</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_failover</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_netpoll_tx</span><span class="p">();</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

		<span class="n">bond_select_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">unblock_netpoll_tx</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">re_arm:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">arp_work</span><span class="p">,</span> <span class="n">delta_in_ticks</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called to inspect slaves for active-backup mode ARP monitor link state</span>
<span class="cm"> * changes.  Sets new_link in slaves to specify what action should take</span>
<span class="cm"> * place for the slave.  Returns 0 if no changes are found, &gt;0 if changes</span>
<span class="cm"> * to link states must be committed.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with bond-&gt;lock held for read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_ab_arp_inspect</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta_in_ticks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">commit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trans_start</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span> <span class="o">=</span> <span class="n">BOND_LINK_NOCHANGE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">!=</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				<span class="n">slave_last_rx</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
				<span class="n">slave_last_rx</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta_in_ticks</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span> <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>
				<span class="n">commit</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Give slaves 2*delta after being enslaved or made</span>
<span class="cm">		 * active.  This avoids bouncing, as the last receive</span>
<span class="cm">		 * times need a full ARP monitor cycle to be updated.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
				  <span class="n">slave</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
				  <span class="n">slave</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">delta_in_ticks</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Backup slave is down if:</span>
<span class="cm">		 * - No current_arp_slave AND</span>
<span class="cm">		 * - more than 3*delta since last receive AND</span>
<span class="cm">		 * - the bond has an IP address</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: a non-null current_arp_slave indicates</span>
<span class="cm">		 * the curr_active_slave went down and we are</span>
<span class="cm">		 * searching for a new one; under this condition</span>
<span class="cm">		 * we only take the curr_active_slave down - this</span>
<span class="cm">		 * gives each slave a chance to tx/rx traffic</span>
<span class="cm">		 * before being taken out</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
			<span class="n">slave_last_rx</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
			<span class="n">slave_last_rx</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">delta_in_ticks</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span> <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>
			<span class="n">commit</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Active slave is down if:</span>
<span class="cm">		 * - more than 2*delta since transmitting OR</span>
<span class="cm">		 * - (more than 2*delta since receive AND</span>
<span class="cm">		 *    the bond has an IP address)</span>
<span class="cm">		 */</span>
		<span class="n">trans_start</span> <span class="o">=</span> <span class="n">dev_trans_start</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
			<span class="n">trans_start</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
			<span class="n">trans_start</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">delta_in_ticks</span><span class="p">)</span> <span class="o">||</span>
		     <span class="o">!</span><span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
			<span class="n">slave_last_rx</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">)</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
			<span class="n">slave_last_rx</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">delta_in_ticks</span><span class="p">)))</span> <span class="p">{</span>

			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span> <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>
			<span class="n">commit</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">commit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called to commit link state changes noted by inspection step of</span>
<span class="cm"> * active-backup mode ARP monitor.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with RTNL and bond-&gt;lock for read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_ab_arp_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta_in_ticks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trans_start</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BOND_LINK_NOCHANGE</span>:
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BOND_LINK_UP</span>:
			<span class="n">trans_start</span> <span class="o">=</span> <span class="n">dev_trans_start</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">&amp;&amp;</span>
			     <span class="n">time_in_range</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					   <span class="n">trans_start</span> <span class="o">-</span> <span class="n">delta_in_ticks</span><span class="p">,</span>
					   <span class="n">trans_start</span> <span class="o">+</span> <span class="n">delta_in_ticks</span><span class="p">))</span> <span class="o">||</span>
			    <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">!=</span> <span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_UP</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span>
						<span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span><span class="p">);</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status definitely up for interface %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">||</span>
				    <span class="p">(</span><span class="n">slave</span> <span class="o">==</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">primary_slave</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">do_failover</span><span class="p">;</span>

			<span class="p">}</span>

			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BOND_LINK_DOWN</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">&lt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span><span class="o">++</span><span class="p">;</span>

			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>
			<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: link status definitely down for interface %s, disabling it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span> <span class="o">==</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">do_failover</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">continue</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: impossible: new_link %d on slave %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">new_link</span><span class="p">,</span>
			       <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">do_failover:</span>
		<span class="n">ASSERT_RTNL</span><span class="p">();</span>
		<span class="n">block_netpoll_tx</span><span class="p">();</span>
		<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">bond_select_active_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">unblock_netpoll_tx</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">bond_set_carrier</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send ARP probes for active-backup mode ARP monitor.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with bond-&gt;lock held for read.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_ab_arp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span> <span class="o">&amp;&amp;</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PROBE: c_arp %s &amp;&amp; cas %s BAD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond_arp_send_all</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="cm">/* if we don&#39;t have a curr_active_slave, search for the next available</span>
<span class="cm">	 * backup slave from the current_arp_slave and make it the candidate</span>
<span class="cm">	 * for becoming the curr_active_slave</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span><span class="p">);</span>

	<span class="cm">/* search for next candidate */</span>
	<span class="n">bond_for_each_slave_from</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_UP</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_BACK</span><span class="p">;</span>
			<span class="n">bond_set_slave_active_flags</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
			<span class="n">bond_arp_send_all</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">current_arp_slave</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if the link state is up at this point, we</span>
<span class="cm">		 * mark it down - this can happen if we have</span>
<span class="cm">		 * simultaneous link failures and</span>
<span class="cm">		 * reselect_active_interface doesn&#39;t make this</span>
<span class="cm">		 * one the current slave so it is still marked</span>
<span class="cm">		 * up when it is actually down</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">BOND_LINK_DOWN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">&lt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
				<span class="n">slave</span><span class="o">-&gt;</span><span class="n">link_failure_count</span><span class="o">++</span><span class="p">;</span>

			<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: backup interface %s is now down.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bond_activebackup_arp_mon</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span><span class="p">,</span>
					    <span class="n">arp_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">should_notify_peers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delta_in_ticks</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">delta_in_ticks</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">re_arm</span><span class="p">;</span>

	<span class="n">should_notify_peers</span> <span class="o">=</span> <span class="n">bond_should_notify_peers</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_ab_arp_inspect</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">delta_in_ticks</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* Race avoidance with bond_close flush of workqueue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtnl_trylock</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">delta_in_ticks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">should_notify_peers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">re_arm</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">bond_ab_arp_commit</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">delta_in_ticks</span><span class="p">);</span>

		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bond_ab_arp_probe</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

<span class="nl">re_arm:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">)</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">arp_work</span><span class="p">,</span> <span class="n">delta_in_ticks</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">should_notify_peers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtnl_trylock</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">send_peer_notif</span><span class="o">++</span><span class="p">;</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">netdev_bonding_change</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">NETDEV_NOTIFY_PEERS</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*-------------------------- netdev event handling --------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Change device name</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_event_changename</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bond_remove_proc_entry</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="n">bond_create_proc_entry</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">bond_debug_reregister</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_master_netdev_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">event_bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_CHANGENAME</span>:
		<span class="k">return</span> <span class="n">bond_event_changename</span><span class="p">(</span><span class="n">event_bond</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_slave_netdev_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span> <span class="o">=</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_UNREGISTER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">setup_by_slave</span><span class="p">)</span>
				<span class="n">bond_release_and_destroy</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">bond_release</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_UP</span>:
	<span class="k">case</span> <span class="n">NETDEV_CHANGE</span>:
		<span class="n">slave</span> <span class="o">=</span> <span class="n">bond_get_slave_by_dev</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">old_speed</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">;</span>
			<span class="n">u8</span>  <span class="n">old_duplex</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">;</span>

			<span class="n">bond_update_speed_duplex</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">old_speed</span> <span class="o">!=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span>
					<span class="n">bond_3ad_adapter_speed_changed</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">old_duplex</span> <span class="o">!=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">duplex</span><span class="p">)</span>
					<span class="n">bond_3ad_adapter_duplex_changed</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_DOWN</span>:
		<span class="cm">/*</span>
<span class="cm">		 * ... Or is it this?</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_CHANGEMTU</span>:
		<span class="cm">/*</span>
<span class="cm">		 * TODO: Should slaves be allowed to</span>
<span class="cm">		 * independently alter their MTU?  For</span>
<span class="cm">		 * an active-backup bond, slaves need</span>
<span class="cm">		 * not be the same type of device, so</span>
<span class="cm">		 * MTUs may vary.  For other modes,</span>
<span class="cm">		 * slaves arguably should have the</span>
<span class="cm">		 * same MTUs. To do this, we&#39;d need to</span>
<span class="cm">		 * take over the slave&#39;s change_mtu</span>
<span class="cm">		 * function for the duration of their</span>
<span class="cm">		 * servitude.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_CHANGENAME</span>:
		<span class="cm">/*</span>
<span class="cm">		 * TODO: handle changing the primary&#39;s name</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_FEAT_CHANGE</span>:
		<span class="n">bond_compute_features</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bond_netdev_event: handle netdev notifier chain events.</span>
<span class="cm"> *</span>
<span class="cm"> * This function receives events for the netdev chain.  The caller (an</span>
<span class="cm"> * ioctl handler calling blocking_notifier_call_chain) holds the necessary</span>
<span class="cm"> * locks for us to safely manipulate the slave devices (RTNL lock,</span>
<span class="cm"> * dev_probe_lock).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_netdev_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">event_dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;event_dev: %s, event: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">event_dev</span> <span class="o">?</span> <span class="n">event_dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">,</span>
		 <span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">event_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_BONDING</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_MASTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;IFF_MASTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">bond_master_netdev_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">event_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_SLAVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;IFF_SLAVE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">bond_slave_netdev_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">event_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">bond_netdev_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">bond_netdev_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*---------------------------- Hashing Policies -----------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Hash for the output device based upon layer 2 and layer 3 data. If</span>
<span class="cm"> * the packet is not IP mimic bond_xmit_hash_policy_l2()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_xmit_hash_policy_l23</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">ntohl</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">^</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">^</span>
			<span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">[</span><span class="mi">5</span><span class="p">]))</span> <span class="o">%</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">%</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hash for the output device based upon layer 3 and layer 4 data. If</span>
<span class="cm"> * the packet is a frag or not TCP or UDP, just use layer 3 data.  If it is</span>
<span class="cm"> * altogether not IP, mimic bond_xmit_hash_policy_l2()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_xmit_hash_policy_l34</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">__be16</span> <span class="o">*</span><span class="n">layer4hdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">iph</span> <span class="o">+</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">layer4_xor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ip_is_fragment</span><span class="p">(</span><span class="n">iph</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span> <span class="o">||</span>
		     <span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">layer4_xor</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">((</span><span class="o">*</span><span class="n">layer4hdr</span> <span class="o">^</span> <span class="o">*</span><span class="p">(</span><span class="n">layer4hdr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">layer4_xor</span> <span class="o">^</span>
			<span class="p">((</span><span class="n">ntohl</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">^</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">))</span> <span class="o">%</span> <span class="n">count</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">%</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hash for the output device based upon layer 2 data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_xmit_hash_policy_l2</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">^</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">%</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*-------------------------- Device entry points ----------------------------*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* reset slave-&gt;backup and slave-&gt;inactive */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">slave</span> <span class="o">!=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">bond_set_slave_active_flags</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mcast_work</span><span class="p">,</span> <span class="n">bond_resend_igmp_join_requests_delayed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* bond_alb_initialize must be called before the timer</span>
<span class="cm">		 * is started.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_alb_initialize</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ALB</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* something went wrong - fail the open operation */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_work</span><span class="p">,</span> <span class="n">bond_alb_monitor</span><span class="p">);</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* link check interval, in milliseconds. */</span>
		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mii_work</span><span class="p">,</span> <span class="n">bond_mii_monitor</span><span class="p">);</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mii_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* arp interval, in milliseconds. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">)</span>
			<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">arp_work</span><span class="p">,</span>
					  <span class="n">bond_activebackup_arp_mon</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">arp_work</span><span class="p">,</span>
					  <span class="n">bond_loadbalance_arp_mon</span><span class="p">);</span>

		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">arp_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_validate</span><span class="p">)</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">recv_probe</span> <span class="o">=</span> <span class="n">bond_arp_rcv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">ad_work</span><span class="p">,</span> <span class="n">bond_3ad_state_machine_handler</span><span class="p">);</span>
		<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">ad_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* register to receive LACPDUs */</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">recv_probe</span> <span class="o">=</span> <span class="n">bond_3ad_lacpdu_recv</span><span class="p">;</span>
		<span class="n">bond_3ad_initiate_agg_selection</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">send_peer_notif</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* link check interval, in milliseconds. */</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mii_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* arp interval, in milliseconds. */</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">arp_work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BOND_MODE_8023AD</span>:
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">ad_work</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_MODE_TLB</span>:
	<span class="k">case</span> <span class="n">BOND_MODE_ALB</span>:
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_work</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delayed_work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mcast_work</span><span class="p">))</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mcast_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Must be called only after all</span>
<span class="cm">		 * slaves have been released</span>
<span class="cm">		 */</span>
		<span class="n">bond_alb_deinitialize</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">recv_probe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="nf">bond_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">));</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">sstats</span> <span class="o">=</span>
			<span class="n">dev_get_stats</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>

		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">;</span>

		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_dropped</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_dropped</span><span class="p">;</span>

		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">multicast</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">collisions</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">collisions</span><span class="p">;</span>

		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_over_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_over_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_fifo_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_fifo_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_missed_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">rx_missed_errors</span><span class="p">;</span>

		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_aborted_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_aborted_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_carrier_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_carrier_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_fifo_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_fifo_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_heartbeat_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_heartbeat_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_window_errors</span> <span class="o">+=</span> <span class="n">sstats</span><span class="o">-&gt;</span><span class="n">tx_window_errors</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_do_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifbond</span> <span class="n">k_binfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifbond</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_binfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifslave</span> <span class="n">k_sinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifslave</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_sinfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">mii</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond_ioctl: master=%s, cmd=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
		<span class="n">mii</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mii</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">mii</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Fall Through */</span>
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
		<span class="cm">/*</span>
<span class="cm">		 * We do this again just in case we were called by SIOCGMIIREG</span>
<span class="cm">		 * instead of SIOCGMIIPHY.</span>
<span class="cm">		 */</span>
		<span class="n">mii</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mii</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>


		<span class="k">if</span> <span class="p">(</span><span class="n">mii</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
			<span class="n">mii</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
				<span class="n">mii</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">BMSR_LSTATUS</span><span class="p">;</span>

			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_INFO_QUERY_OLD</span>:
	<span class="k">case</span> <span class="n">SIOCBONDINFOQUERY</span>:
		<span class="n">u_binfo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ifbond</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k_binfo</span><span class="p">,</span> <span class="n">u_binfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifbond</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">bond_info_query</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k_binfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">copy_to_user</span><span class="p">(</span><span class="n">u_binfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k_binfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifbond</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_SLAVE_INFO_QUERY_OLD</span>:
	<span class="k">case</span> <span class="n">SIOCBONDSLAVEINFOQUERY</span>:
		<span class="n">u_sinfo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ifslave</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k_sinfo</span><span class="p">,</span> <span class="n">u_sinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifslave</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">bond_slave_info_query</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k_sinfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">copy_to_user</span><span class="p">(</span><span class="n">u_sinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k_sinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifslave</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Go on */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">slave_dev</span> <span class="o">=</span> <span class="n">dev_get_by_name</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">),</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_slave</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;slave_dev=%p:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave_dev</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;slave_dev-&gt;name=%s:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BOND_ENSLAVE_OLD</span>:
		<span class="k">case</span> <span class="n">SIOCBONDENSLAVE</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="n">bond_enslave</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BOND_RELEASE_OLD</span>:
		<span class="k">case</span> <span class="n">SIOCBONDRELEASE</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="n">bond_release</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BOND_SETHWADDR_OLD</span>:
		<span class="k">case</span> <span class="n">SIOCBONDSETHWADDR</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="n">bond_sethwaddr</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BOND_CHANGE_ACTIVE_OLD</span>:
		<span class="k">case</span> <span class="n">SIOCBONDCHANGEACTIVE</span>:
			<span class="n">res</span> <span class="o">=</span> <span class="n">bond_ioctl_change_active</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">slave_dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_put</span><span class="p">(</span><span class="n">slave_dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">bond_addr_in_mc_list</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">netdev_hw_addr_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="n">netdev_hw_addr_list_for_each</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_change_rx_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">change</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
		<span class="n">bond_set_promiscuity</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span>
				     <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">change</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
		<span class="n">bond_set_allmulti</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span>
				  <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* looking for addresses to add to slaves&#39; mc list */</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">bond_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">bond_addr_in_mc_list</span><span class="p">(</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mc_list</span><span class="p">,</span>
					     <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
			<span class="n">bond_mc_add</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* looking for addresses to delete from slaves&#39; list */</span>
	<span class="n">netdev_hw_addr_list_for_each</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mc_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">bond_addr_in_mc_list</span><span class="p">(</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">,</span>
					     <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
			<span class="n">bond_mc_del</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* save master&#39;s multicast list */</span>
	<span class="n">__hw_addr_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mc_list</span><span class="p">);</span>
	<span class="n">__hw_addr_add_multiple</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mc_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">,</span>
			       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">,</span> <span class="n">NETDEV_HW_ADDR_T_MULTICAST</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_neigh_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">slave_ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neigh_parms</span> <span class="n">parms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">slave_ops</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave_ops</span><span class="o">-&gt;</span><span class="n">ndo_neigh_setup</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">parms</span><span class="p">.</span><span class="n">neigh_setup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">parms</span><span class="p">.</span><span class="n">neigh_cleanup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">slave_ops</span><span class="o">-&gt;</span><span class="n">ndo_neigh_setup</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parms</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assign slave&#39;s neigh_cleanup to neighbour in case cleanup is called</span>
<span class="cm">	 * after the last slave has been detached.  Assumes that all slaves</span>
<span class="cm">	 * utilize the same neigh_cleanup (true at this writing as only user</span>
<span class="cm">	 * is ipoib).</span>
<span class="cm">	 */</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">parms</span><span class="o">-&gt;</span><span class="n">neigh_cleanup</span> <span class="o">=</span> <span class="n">parms</span><span class="p">.</span><span class="n">neigh_cleanup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parms</span><span class="p">.</span><span class="n">neigh_setup</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">parms</span><span class="p">.</span><span class="n">neigh_setup</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The bonding ndo_neigh_setup is called at init time beofre any</span>
<span class="cm"> * slave exists. So we must declare proxy setup function which will</span>
<span class="cm"> * be used at run time to resolve the actual slave neigh param setup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_neigh_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">neigh_parms</span> <span class="o">*</span><span class="n">parms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">parms</span><span class="o">-&gt;</span><span class="n">neigh_setup</span>   <span class="o">=</span> <span class="n">bond_neigh_init</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change the MTU of all of a master&#39;s slaves to match the master</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">stop_at</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond=%p, name=%s, new_mtu=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bond</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">bond_dev</span> <span class="o">?</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">),</span> <span class="n">new_mtu</span><span class="p">);</span>

	<span class="cm">/* Can&#39;t hold bond-&gt;lock with bh disabled here since</span>
<span class="cm">	 * some base drivers panic. On the other hand we can&#39;t</span>
<span class="cm">	 * hold bond-&gt;lock without bh disabled because we&#39;ll</span>
<span class="cm">	 * deadlock. The only solution is to rely on the fact</span>
<span class="cm">	 * that we&#39;re under rtnl_lock here, and the slaves</span>
<span class="cm">	 * list won&#39;t change. This doesn&#39;t solve the problem</span>
<span class="cm">	 * of setting the slave&#39;s MTU while it is</span>
<span class="cm">	 * transmitting, but the assumption is that the base</span>
<span class="cm">	 * driver can handle that.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: figure out a way to safely iterate the slaves</span>
<span class="cm">	 * list, but without holding a lock around the actual</span>
<span class="cm">	 * call to the base driver.</span>
<span class="cm">	 */</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;s %p s-&gt;p %p c_m %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">slave</span><span class="p">,</span>
			 <span class="n">slave</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span>
			 <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_change_mtu</span><span class="p">);</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">dev_set_mtu</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If we failed to set the slave&#39;s mtu to the new value</span>
<span class="cm">			 * we must abort the operation even in ACTIVE_BACKUP</span>
<span class="cm">			 * mode, because if we allow the backup slaves to have</span>
<span class="cm">			 * different mtu values than the active slave we&#39;ll</span>
<span class="cm">			 * need to change their mtu when doing a failover. That</span>
<span class="cm">			 * means changing their mtu from timer context, which</span>
<span class="cm">			 * is probably not a good idea.</span>
<span class="cm">			 */</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;err %d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unwind:</span>
	<span class="cm">/* unwind from head to the slave that failed */</span>
	<span class="n">stop_at</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
	<span class="n">bond_for_each_slave_from_to</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">,</span> <span class="n">stop_at</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">tmp_res</span><span class="p">;</span>

		<span class="n">tmp_res</span> <span class="o">=</span> <span class="n">dev_set_mtu</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;unwind err %d dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">tmp_res</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Change HW address</span>
<span class="cm"> *</span>
<span class="cm"> * Note that many devices must be down to change the HW address, and</span>
<span class="cm"> * downing the master releases all slaves.  We can make bonds full of</span>
<span class="cm"> * bonding devices to test this, however.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="n">addr</span><span class="p">,</span> <span class="n">tmp_sa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">stop_at</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ALB</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bond_alb_set_mac_address</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>


	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bond=%p, name=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">bond</span><span class="p">,</span> <span class="n">bond_dev</span> <span class="o">?</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If fail_over_mac is set to active, do nothing and return</span>
<span class="cm">	 * success.  Returning an error causes ifenslave to fail.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">fail_over_mac</span> <span class="o">==</span> <span class="n">BOND_FOM_ACTIVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="cm">/* Can&#39;t hold bond-&gt;lock with bh disabled here since</span>
<span class="cm">	 * some base drivers panic. On the other hand we can&#39;t</span>
<span class="cm">	 * hold bond-&gt;lock without bh disabled because we&#39;ll</span>
<span class="cm">	 * deadlock. The only solution is to rely on the fact</span>
<span class="cm">	 * that we&#39;re under rtnl_lock here, and the slaves</span>
<span class="cm">	 * list won&#39;t change. This doesn&#39;t solve the problem</span>
<span class="cm">	 * of setting the slave&#39;s hw address while it is</span>
<span class="cm">	 * transmitting, but the assumption is that the base</span>
<span class="cm">	 * driver can handle that.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: figure out a way to safely iterate the slaves</span>
<span class="cm">	 * list, but without holding a lock around the actual</span>
<span class="cm">	 * call to the base driver.</span>
<span class="cm">	 */</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">slave_ops</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;slave %p %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slave_ops</span><span class="o">-&gt;</span><span class="n">ndo_set_mac_address</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;EOPNOTSUPP %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* TODO: consider downing the slave</span>
<span class="cm">			 * and retry ?</span>
<span class="cm">			 * User should expect communications</span>
<span class="cm">			 * breakage anyway until ARP finish</span>
<span class="cm">			 * updating, so...</span>
<span class="cm">			 */</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;err %d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* success */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unwind:</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_sa</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">tmp_sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="cm">/* unwind from head to the slave that failed */</span>
	<span class="n">stop_at</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
	<span class="n">bond_for_each_slave_from_to</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">,</span> <span class="n">stop_at</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">tmp_res</span><span class="p">;</span>

		<span class="n">tmp_res</span> <span class="o">=</span> <span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_sa</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp_res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;unwind err %d dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">tmp_res</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_xmit_roundrobin</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">start_at</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">slave_no</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start with the curr_active_slave that joined the bond as the</span>
<span class="cm">	 * default for sending IGMP traffic.  For failover purposes one</span>
<span class="cm">	 * needs to maintain some consistency for the interface that will</span>
<span class="cm">	 * send the join/membership reports.  The curr_active_slave found</span>
<span class="cm">	 * will send all of this type of traffic.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_IGMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
		<span class="n">slave</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Concurrent TX may collide on rr_tx_counter; we accept</span>
<span class="cm">		 * that as being rare enough not to justify using an</span>
<span class="cm">		 * atomic op here.</span>
<span class="cm">		 */</span>
		<span class="n">slave_no</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">rr_tx_counter</span><span class="o">++</span> <span class="o">%</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span><span class="p">;</span>

		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">slave_no</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slave_no</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">start_at</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
	<span class="n">bond_for_each_slave_from</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">start_at</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_UP</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">bond_dev_queue_xmit</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no suitable interface, frame not sent */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * in active-backup mode, we know that bond-&gt;curr_active_slave is always valid if</span>
<span class="cm"> * the bond has a usable interface.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_xmit_activebackup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">bond_dev_queue_xmit</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="cm">/* no suitable interface, frame not sent */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * In bond_xmit_xor() , we determine the output device by using a pre-</span>
<span class="cm"> * determined xmit_hash_policy(), If the selected device is not enabled,</span>
<span class="cm"> * find the next active slave.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_xmit_xor</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">start_at</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slave_no</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">slave_no</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">xmit_hash_policy</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span><span class="p">);</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slave_no</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave_no</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">start_at</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>

	<span class="n">bond_for_each_slave_from</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">start_at</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_UP</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">bond_dev_queue_xmit</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no suitable interface, frame not sent */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * in broadcast mode, we send everything to all usable interfaces.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_xmit_broadcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">start_at</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">tx_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
	<span class="n">start_at</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_at</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">bond_for_each_slave_from</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">start_at</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_UP</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">bond_is_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tx_dev</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb2</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: bond_xmit_broadcast(): skb_clone() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">res</span> <span class="o">=</span> <span class="n">bond_dev_queue_xmit</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">skb2</span><span class="p">,</span> <span class="n">tx_dev</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb2</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">tx_dev</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_dev</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">bond_dev_queue_xmit</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tx_dev</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="cm">/* no suitable interface, frame not sent */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* frame sent to all suitable interfaces */</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*------------------------- Device initialization ---------------------------*/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_set_xmit_hash_policy</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">xmit_policy</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BOND_XMIT_POLICY_LAYER23</span>:
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">xmit_hash_policy</span> <span class="o">=</span> <span class="n">bond_xmit_hash_policy_l23</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_XMIT_POLICY_LAYER34</span>:
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">xmit_hash_policy</span> <span class="o">=</span> <span class="n">bond_xmit_hash_policy_l34</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_XMIT_POLICY_LAYER2</span>:
	<span class="nl">default:</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">xmit_hash_policy</span> <span class="o">=</span> <span class="n">bond_xmit_hash_policy_l2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lookup the slave that corresponds to a qid</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bond_slave_override</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">check_slave</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Find out if any slaves have the same mapping as this skb. */</span>
	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">check_slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_slave</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">slave</span> <span class="o">=</span> <span class="n">check_slave</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If the slave isn&#39;t UP, use default transmit policy. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave</span> <span class="o">&amp;&amp;</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">&amp;&amp;</span> <span class="n">IS_UP</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">bond_dev_queue_xmit</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">u16</span> <span class="nf">bond_select_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This helper function exists to help dev_pick_tx get the correct</span>
<span class="cm">	 * destination queue.  Using a helper function skips a call to</span>
<span class="cm">	 * skb_tx_hash and will put the skbs in the queue we expect on their</span>
<span class="cm">	 * way down to the bonding driver.</span>
<span class="cm">	 */</span>
	<span class="n">u16</span> <span class="n">txq</span> <span class="o">=</span> <span class="n">skb_rx_queue_recorded</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">?</span> <span class="n">skb_get_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save the original txq to restore before passing to the driver</span>
<span class="cm">	 */</span>
	<span class="n">qdisc_skb_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bond_queue_mapping</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">queue_mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">txq</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">txq</span> <span class="o">-=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">txq</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">txq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">__bond_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TX_QUEUE_OVERRIDE</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond_slave_override</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BOND_MODE_ROUNDROBIN</span>:
		<span class="k">return</span> <span class="n">bond_xmit_roundrobin</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span>:
		<span class="k">return</span> <span class="n">bond_xmit_activebackup</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BOND_MODE_XOR</span>:
		<span class="k">return</span> <span class="n">bond_xmit_xor</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BOND_MODE_BROADCAST</span>:
		<span class="k">return</span> <span class="n">bond_xmit_broadcast</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BOND_MODE_8023AD</span>:
		<span class="k">return</span> <span class="n">bond_3ad_xmit_xor</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BOND_MODE_ALB</span>:
	<span class="k">case</span> <span class="n">BOND_MODE_TLB</span>:
		<span class="k">return</span> <span class="n">bond_alb_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="cm">/* Should never happen, mode already checked */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: Unknown bonding mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">);</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">bond_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netdev_tx_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we risk deadlock from transmitting this in the</span>
<span class="cm">	 * netpoll path, tell netpoll to queue the frame for later tx</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_netpoll_tx_blocked</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__bond_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set bond mode specific net device operations</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bond_set_mode_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BOND_MODE_ROUNDROBIN</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_MODE_XOR</span>:
		<span class="n">bond_set_xmit_hash_policy</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_MODE_BROADCAST</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_MODE_8023AD</span>:
		<span class="n">bond_set_xmit_hash_policy</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BOND_MODE_ALB</span>:
		<span class="cm">/* FALLTHRU */</span>
	<span class="k">case</span> <span class="n">BOND_MODE_TLB</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Should never happen, mode already checked */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: Unknown bonding mode %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_ethtool_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">drvinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_NAME</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_VERSION</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">drvinfo</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">BOND_ABI_VERSION</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">bond_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>		<span class="o">=</span> <span class="n">bond_ethtool_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>		<span class="o">=</span> <span class="n">ethtool_op_get_link</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">bond_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_init</span>		<span class="o">=</span> <span class="n">bond_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_uninit</span>		<span class="o">=</span> <span class="n">bond_uninit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">bond_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">bond_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">bond_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_select_queue</span>	<span class="o">=</span> <span class="n">bond_select_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats64</span>	<span class="o">=</span> <span class="n">bond_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">bond_do_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_rx_flags</span>	<span class="o">=</span> <span class="n">bond_change_rx_flags</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">bond_set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">bond_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">bond_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_neigh_setup</span>	<span class="o">=</span> <span class="n">bond_neigh_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span>	<span class="o">=</span> <span class="n">bond_vlan_rx_add_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span>	<span class="o">=</span> <span class="n">bond_vlan_rx_kill_vid</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_netpoll_setup</span>	<span class="o">=</span> <span class="n">bond_netpoll_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_netpoll_cleanup</span>	<span class="o">=</span> <span class="n">bond_netpoll_cleanup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">bond_poll_controller</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">ndo_add_slave</span>		<span class="o">=</span> <span class="n">bond_enslave</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_del_slave</span>		<span class="o">=</span> <span class="n">bond_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_fix_features</span>	<span class="o">=</span> <span class="n">bond_fix_features</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="cm">/* initialize rwlocks */</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span> <span class="o">=</span> <span class="n">bonding_defaults</span><span class="p">;</span>

	<span class="cm">/* Initialize pointers */</span>
	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bond_dev</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">);</span>

	<span class="cm">/* Initialize the device entry points */</span>
	<span class="n">ether_setup</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bond_netdev_ops</span><span class="p">;</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bond_ethtool_ops</span><span class="p">;</span>
	<span class="n">bond_set_mode_ops</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span><span class="p">);</span>

	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">bond_destructor</span><span class="p">;</span>

	<span class="cm">/* Initialize the device options */</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_MASTER</span><span class="o">|</span><span class="n">IFF_MULTICAST</span><span class="p">;</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_BONDING</span><span class="p">;</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IFF_XMIT_DST_RELEASE</span> <span class="o">|</span> <span class="n">IFF_TX_SKB_SHARING</span><span class="p">);</span>

	<span class="cm">/* At first, we block adding VLANs. That&#39;s the only way to</span>
<span class="cm">	 * prevent problems that occur when adding VLANs over an</span>
<span class="cm">	 * empty bond. The block will be removed once non-challenged</span>
<span class="cm">	 * slaves are enslaved.</span>
<span class="cm">	 */</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_VLAN_CHALLENGED</span><span class="p">;</span>

	<span class="cm">/* don&#39;t acquire bond device&#39;s netif_tx_lock when</span>
<span class="cm">	 * transmitting */</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_LLTX</span><span class="p">;</span>

	<span class="cm">/* By default, we declare the bond to be fully</span>
<span class="cm">	 * VLAN hardware accelerated capable. Special</span>
<span class="cm">	 * care is taken in the various xmit functions</span>
<span class="cm">	 * when there are slaves that are not hw accel</span>
<span class="cm">	 * capable</span>
<span class="cm">	 */</span>

	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">BOND_VLAN_FEATURES</span> <span class="o">|</span>
				<span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span>
				<span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">|</span>
				<span class="n">NETIF_F_HW_VLAN_FILTER</span><span class="p">;</span>

	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NETIF_F_ALL_CSUM</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NETIF_F_HW_CSUM</span><span class="p">);</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">hw_features</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_work_cancel_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">miimon</span> <span class="o">&amp;&amp;</span> <span class="n">delayed_work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mii_work</span><span class="p">))</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mii_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_interval</span> <span class="o">&amp;&amp;</span> <span class="n">delayed_work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">arp_work</span><span class="p">))</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">arp_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ALB</span> <span class="o">&amp;&amp;</span>
	    <span class="n">delayed_work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_work</span><span class="p">))</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span> <span class="o">&amp;&amp;</span>
	    <span class="n">delayed_work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">ad_work</span><span class="p">))</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">ad_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delayed_work_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mcast_work</span><span class="p">))</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mcast_work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">* Destroy a bonding device.</span>
<span class="cm">* Must be under rtnl_lock when this function is called.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">bond_netpoll_cleanup</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="cm">/* Release the bonded slaves */</span>
	<span class="n">bond_release_all</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">bond_list</span><span class="p">);</span>

	<span class="n">bond_work_cancel_all</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">bond_remove_proc_entry</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">bond_debug_unregister</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">__hw_addr_flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mc_list</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">,</span> <span class="n">vlan_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">vlan</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*------------------------- Module initialization ---------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * Convert string input module parms.  Accept either the</span>
<span class="cm"> * number of the mode or its string name.  A bit complicated because</span>
<span class="cm"> * some mode names are substrings of other names, and calls from sysfs</span>
<span class="cm"> * may have whitespace in the name (trailing newlines, for example).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bond_parse_parm</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="o">*</span><span class="n">tbl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">modeint</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rv</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">modestr</span><span class="p">[</span><span class="n">BOND_MAX_MODENAME_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%20s&quot;</span><span class="p">,</span> <span class="n">modestr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modeint</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">modename</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">modeint</span> <span class="o">==</span> <span class="n">tbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mode</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">modestr</span><span class="p">,</span> <span class="n">tbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">modename</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">tbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_check_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">bond_params</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">arp_validate_value</span><span class="p">,</span> <span class="n">fail_over_mac_value</span><span class="p">,</span> <span class="n">primary_reselect_value</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Convert string parameters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond_mode</span> <span class="o">=</span> <span class="n">bond_parse_parm</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">bond_mode_tbl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_mode</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error: Invalid bonding mode </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">mode</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="s">&quot;NULL&quot;</span> <span class="o">:</span> <span class="n">mode</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xmit_hash_policy</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bond_mode</span> <span class="o">!=</span> <span class="n">BOND_MODE_XOR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">bond_mode</span> <span class="o">!=</span> <span class="n">BOND_MODE_8023AD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;xmit_hash_policy param is irrelevant in mode %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond_mode_name</span><span class="p">(</span><span class="n">bond_mode</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">xmit_hashtype</span> <span class="o">=</span> <span class="n">bond_parse_parm</span><span class="p">(</span><span class="n">xmit_hash_policy</span><span class="p">,</span>
							<span class="n">xmit_hashtype_tbl</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">xmit_hashtype</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error: Invalid xmit_hash_policy </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">xmit_hash_policy</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="s">&quot;NULL&quot;</span> <span class="o">:</span>
				       <span class="n">xmit_hash_policy</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lacp_rate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_mode</span> <span class="o">!=</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;lacp_rate param is irrelevant in mode %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bond_mode_name</span><span class="p">(</span><span class="n">bond_mode</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lacp_fast</span> <span class="o">=</span> <span class="n">bond_parse_parm</span><span class="p">(</span><span class="n">lacp_rate</span><span class="p">,</span> <span class="n">bond_lacp_tbl</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lacp_fast</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error: Invalid lacp rate </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">lacp_rate</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="s">&quot;NULL&quot;</span> <span class="o">:</span> <span class="n">lacp_rate</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ad_select</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">params</span><span class="o">-&gt;</span><span class="n">ad_select</span> <span class="o">=</span> <span class="n">bond_parse_parm</span><span class="p">(</span><span class="n">ad_select</span><span class="p">,</span> <span class="n">ad_select_tbl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">ad_select</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error: Invalid ad_select </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">ad_select</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="s">&quot;NULL&quot;</span> <span class="o">:</span> <span class="n">ad_select</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond_mode</span> <span class="o">!=</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;ad_select param only affects 802.3ad mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">params</span><span class="o">-&gt;</span><span class="n">ad_select</span> <span class="o">=</span> <span class="n">BOND_AD_STABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_bonds</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: max_bonds (%d) not in range %d-%d, so it was reset to BOND_DEFAULT_MAX_BONDS (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">max_bonds</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="n">BOND_DEFAULT_MAX_BONDS</span><span class="p">);</span>
		<span class="n">max_bonds</span> <span class="o">=</span> <span class="n">BOND_DEFAULT_MAX_BONDS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">miimon</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: miimon module parameter (%d), not in range 0-%d, so it was reset to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">miimon</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="n">BOND_LINK_MON_INTERV</span><span class="p">);</span>
		<span class="n">miimon</span> <span class="o">=</span> <span class="n">BOND_LINK_MON_INTERV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">updelay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: updelay module parameter (%d), not in range 0-%d, so it was reset to 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">updelay</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
		<span class="n">updelay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">downdelay</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: downdelay module parameter (%d), not in range 0-%d, so it was reset to 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">downdelay</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
		<span class="n">downdelay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">use_carrier</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">use_carrier</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: use_carrier module parameter (%d), not of valid value (0/1), so it was set to 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">use_carrier</span><span class="p">);</span>
		<span class="n">use_carrier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_peer_notif</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">num_peer_notif</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: num_grat_arp/num_unsol_na (%d) not in range 0-255 so it was reset to 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">num_peer_notif</span><span class="p">);</span>
		<span class="n">num_peer_notif</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reset values for 802.3ad */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond_mode</span> <span class="o">==</span> <span class="n">BOND_MODE_8023AD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">miimon</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: miimon must be specified, otherwise bonding will not detect link failure, speed and duplex which are essential for 802.3ad operation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Forcing miimon to 100msec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">miimon</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_queues</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">tx_queues</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: tx_queues (%d) should be between &quot;</span>
			   <span class="s">&quot;1 and 255, resetting to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">tx_queues</span><span class="p">,</span> <span class="n">BOND_DEFAULT_TX_QUEUES</span><span class="p">);</span>
		<span class="n">tx_queues</span> <span class="o">=</span> <span class="n">BOND_DEFAULT_TX_QUEUES</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">all_slaves_active</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">all_slaves_active</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: all_slaves_active module parameter (%d), &quot;</span>
			   <span class="s">&quot;not of valid value (0/1), so it was set to &quot;</span>
			   <span class="s">&quot;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">all_slaves_active</span><span class="p">);</span>
		<span class="n">all_slaves_active</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resend_igmp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">resend_igmp</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: resend_igmp (%d) should be between &quot;</span>
			   <span class="s">&quot;0 and 255, resetting to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">resend_igmp</span><span class="p">,</span> <span class="n">BOND_DEFAULT_RESEND_IGMP</span><span class="p">);</span>
		<span class="n">resend_igmp</span> <span class="o">=</span> <span class="n">BOND_DEFAULT_RESEND_IGMP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* reset values for TLB/ALB */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bond_mode</span> <span class="o">==</span> <span class="n">BOND_MODE_TLB</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">bond_mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ALB</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">miimon</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: miimon must be specified, otherwise bonding will not detect link failure and link speed which are essential for TLB/ALB load balancing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Forcing miimon to 100msec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">miimon</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ALB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;In ALB mode you might experience client disconnections upon reconnection of a link if the bonding module updelay parameter (%d msec) is incompatible with the forwarding delay time of the switch</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">updelay</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">miimon</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">updelay</span> <span class="o">||</span> <span class="n">downdelay</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* just warn the user the up/down delay will have</span>
<span class="cm">			 * no effect since miimon is zero...</span>
<span class="cm">			 */</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: miimon module parameter not set and updelay (%d) or downdelay (%d) module parameter is set; updelay and downdelay have no effect unless miimon is set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">updelay</span><span class="p">,</span> <span class="n">downdelay</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* don&#39;t allow arp monitoring */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arp_interval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: miimon (%d) and arp_interval (%d) can&#39;t be used simultaneously, disabling ARP monitoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">miimon</span><span class="p">,</span> <span class="n">arp_interval</span><span class="p">);</span>
			<span class="n">arp_interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">updelay</span> <span class="o">%</span> <span class="n">miimon</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: updelay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">updelay</span><span class="p">,</span> <span class="n">miimon</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">updelay</span> <span class="o">/</span> <span class="n">miimon</span><span class="p">)</span> <span class="o">*</span> <span class="n">miimon</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">updelay</span> <span class="o">/=</span> <span class="n">miimon</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">downdelay</span> <span class="o">%</span> <span class="n">miimon</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: downdelay (%d) is not a multiple of miimon (%d), downdelay rounded to %d ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">downdelay</span><span class="p">,</span> <span class="n">miimon</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">downdelay</span> <span class="o">/</span> <span class="n">miimon</span><span class="p">)</span> <span class="o">*</span> <span class="n">miimon</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">downdelay</span> <span class="o">/=</span> <span class="n">miimon</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp_interval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: arp_interval module parameter (%d) , not in range 0-%d, so it was reset to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">arp_interval</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="n">BOND_LINK_ARP_INTERV</span><span class="p">);</span>
		<span class="n">arp_interval</span> <span class="o">=</span> <span class="n">BOND_LINK_ARP_INTERV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">arp_ip_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="p">(</span><span class="n">arp_ip_count</span> <span class="o">&lt;</span> <span class="n">BOND_MAX_ARP_TARGETS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">arp_ip_target</span><span class="p">[</span><span class="n">arp_ip_count</span><span class="p">];</span>
	     <span class="n">arp_ip_count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not complete check, but should be good enough to</span>
<span class="cm">		   catch mistakes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">arp_ip_target</span><span class="p">[</span><span class="n">arp_ip_count</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: bad arp_ip_target module parameter (%s), ARP monitoring will not be performed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">arp_ip_target</span><span class="p">[</span><span class="n">arp_ip_count</span><span class="p">]);</span>
			<span class="n">arp_interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">__be32</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">in_aton</span><span class="p">(</span><span class="n">arp_ip_target</span><span class="p">[</span><span class="n">arp_ip_count</span><span class="p">]);</span>
			<span class="n">arp_target</span><span class="p">[</span><span class="n">arp_ip_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp_interval</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">arp_ip_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* don&#39;t allow arping if no arp_ip_target given... */</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: arp_interval module parameter (%d) specified without providing an arp_ip_target parameter, arp_interval was reset to 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">arp_interval</span><span class="p">);</span>
		<span class="n">arp_interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp_validate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_mode</span> <span class="o">!=</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;arp_validate only supported in active-backup mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arp_interval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;arp_validate requires arp_interval</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">arp_validate_value</span> <span class="o">=</span> <span class="n">bond_parse_parm</span><span class="p">(</span><span class="n">arp_validate</span><span class="p">,</span>
						     <span class="n">arp_validate_tbl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arp_validate_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error: invalid arp_validate </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">arp_validate</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="s">&quot;NULL&quot;</span> <span class="o">:</span> <span class="n">arp_validate</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">arp_validate_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">miimon</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;MII link monitoring set to %d ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">miimon</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">arp_interval</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;ARP monitoring set to %d ms, validate %s, with %d target(s):&quot;</span><span class="p">,</span>
			<span class="n">arp_interval</span><span class="p">,</span>
			<span class="n">arp_validate_tbl</span><span class="p">[</span><span class="n">arp_validate_value</span><span class="p">].</span><span class="n">modename</span><span class="p">,</span>
			<span class="n">arp_ip_count</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arp_ip_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %s&quot;</span><span class="p">,</span> <span class="n">arp_ip_target</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">max_bonds</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* miimon and arp_interval not set, we need one so things</span>
<span class="cm">		 * work as expected, see bonding.txt for details</span>
<span class="cm">		 */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Warning: either miimon or arp_interval and arp_ip_target module parameters must be specified, otherwise bonding will not detect link failures! see bonding.txt for details.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">primary</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">USES_PRIMARY</span><span class="p">(</span><span class="n">bond_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* currently, using a primary only makes sense</span>
<span class="cm">		 * in active backup, TLB or ALB modes</span>
<span class="cm">		 */</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: %s primary device specified but has no effect in %s mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">primary</span><span class="p">,</span> <span class="n">bond_mode_name</span><span class="p">(</span><span class="n">bond_mode</span><span class="p">));</span>
		<span class="n">primary</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">primary</span> <span class="o">&amp;&amp;</span> <span class="n">primary_reselect</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">primary_reselect_value</span> <span class="o">=</span> <span class="n">bond_parse_parm</span><span class="p">(</span><span class="n">primary_reselect</span><span class="p">,</span>
							 <span class="n">pri_reselect_tbl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">primary_reselect_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error: Invalid primary_reselect </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">primary_reselect</span> <span class="o">==</span>
					<span class="nb">NULL</span> <span class="o">?</span> <span class="s">&quot;NULL&quot;</span> <span class="o">:</span> <span class="n">primary_reselect</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">primary_reselect_value</span> <span class="o">=</span> <span class="n">BOND_PRI_RESELECT_ALWAYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fail_over_mac</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fail_over_mac_value</span> <span class="o">=</span> <span class="n">bond_parse_parm</span><span class="p">(</span><span class="n">fail_over_mac</span><span class="p">,</span>
						      <span class="n">fail_over_mac_tbl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fail_over_mac_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error: invalid fail_over_mac </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">arp_validate</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="s">&quot;NULL&quot;</span> <span class="o">:</span> <span class="n">arp_validate</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond_mode</span> <span class="o">!=</span> <span class="n">BOND_MODE_ACTIVEBACKUP</span><span class="p">)</span>
			<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Warning: fail_over_mac only affects active-backup mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fail_over_mac_value</span> <span class="o">=</span> <span class="n">BOND_FOM_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* fill params struct with the proper values */</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">bond_mode</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">xmit_policy</span> <span class="o">=</span> <span class="n">xmit_hashtype</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">miimon</span> <span class="o">=</span> <span class="n">miimon</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">num_peer_notif</span> <span class="o">=</span> <span class="n">num_peer_notif</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">arp_interval</span> <span class="o">=</span> <span class="n">arp_interval</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">arp_validate</span> <span class="o">=</span> <span class="n">arp_validate_value</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">updelay</span> <span class="o">=</span> <span class="n">updelay</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">downdelay</span> <span class="o">=</span> <span class="n">downdelay</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">use_carrier</span> <span class="o">=</span> <span class="n">use_carrier</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">lacp_fast</span> <span class="o">=</span> <span class="n">lacp_fast</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">primary_reselect</span> <span class="o">=</span> <span class="n">primary_reselect_value</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">fail_over_mac</span> <span class="o">=</span> <span class="n">fail_over_mac_value</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">tx_queues</span> <span class="o">=</span> <span class="n">tx_queues</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">all_slaves_active</span> <span class="o">=</span> <span class="n">all_slaves_active</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">resend_igmp</span> <span class="o">=</span> <span class="n">resend_igmp</span><span class="p">;</span>
	<span class="n">params</span><span class="o">-&gt;</span><span class="n">min_links</span> <span class="o">=</span> <span class="n">min_links</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">primary</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">,</span> <span class="n">primary</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
		<span class="n">params</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">[</span><span class="n">IFNAMSIZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">arp_targets</span><span class="p">,</span> <span class="n">arp_target</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arp_target</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">bonding_netdev_xmit_lock_key</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">bonding_netdev_addr_lock_key</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_set_lockdep_class_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="o">*</span><span class="n">_unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">_xmit_lock</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">bonding_netdev_xmit_lock_key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bond_set_lockdep_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_list_lock</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">bonding_netdev_addr_lock_key</span><span class="p">);</span>
	<span class="n">netdev_for_each_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bond_set_lockdep_class_one</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from registration process</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">bn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">),</span> <span class="n">bond_net_id</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Begin bond_init for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize locks that may be required during</span>
<span class="cm">	 * en/deslave operations.  All of the bond_open work</span>
<span class="cm">	 * (of which this is part) should really be moved to</span>
<span class="cm">	 * a phase prior to dev_open</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_hashtbl_lock</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_lock</span><span class="p">));</span>

	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">bond_set_lockdep_class</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="n">bond_create_proc_entry</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">bond_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">);</span>

	<span class="n">bond_prepare_sysfs_group</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">bond_debug_register</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">__hw_addr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">mc_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IFLA_ADDRESS</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nla_len</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IFLA_ADDRESS</span><span class="p">])</span> <span class="o">!=</span> <span class="n">ETH_ALEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">nla_data</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IFLA_ADDRESS</span><span class="p">])))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_get_tx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tx_queues</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_ops</span> <span class="n">bond_link_ops</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kind</span>		<span class="o">=</span> <span class="s">&quot;bond&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priv_size</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span><span class="p">),</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">bond_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">validate</span>	<span class="o">=</span> <span class="n">bond_validate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_tx_queues</span>	<span class="o">=</span> <span class="n">bond_get_tx_queues</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Create a new bond based on the specified name and bonding parameters.</span>
<span class="cm"> * If name is NULL, obtain a suitable &quot;bond%d&quot; name for us.</span>
<span class="cm"> * Caller must NOT hold rtnl_lock; we need to release it here before we</span>
<span class="cm"> * set up our sysfs entries.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bond_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>

	<span class="n">bond_dev</span> <span class="o">=</span> <span class="n">alloc_netdev_mq</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span><span class="p">),</span>
				   <span class="n">name</span> <span class="o">?</span> <span class="n">name</span> <span class="o">:</span> <span class="s">&quot;bond%d&quot;</span><span class="p">,</span>
				   <span class="n">bond_setup</span><span class="p">,</span> <span class="n">tx_queues</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: eek! can&#39;t alloc netdev!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_net_set</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bond_link_ops</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">register_netdevice</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>

	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">bond_destructor</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__net_init</span> <span class="nf">bond_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">bn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">bond_net_id</span><span class="p">);</span>

	<span class="n">bn</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bn</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">);</span>

	<span class="n">bond_create_proc_dir</span><span class="p">(</span><span class="n">bn</span><span class="p">);</span>
	<span class="n">bond_create_sysfs</span><span class="p">(</span><span class="n">bn</span><span class="p">);</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">bond_net_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">bn</span> <span class="o">=</span> <span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">bond_net_id</span><span class="p">);</span>

	<span class="n">bond_destroy_sysfs</span><span class="p">(</span><span class="n">bn</span><span class="p">);</span>
	<span class="n">bond_destroy_proc_dir</span><span class="p">(</span><span class="n">bn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">bond_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">bond_net_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">bond_net_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">bond_net_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bond_net</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">bonding_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">bond_version</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">bond_check_params</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bonding_defaults</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_net_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">rtnl_link_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_link_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_link</span><span class="p">;</span>

	<span class="n">bond_create_debugfs</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_bonds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">bond_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_netdev_notifier</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">rtnl_link_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_link_ops</span><span class="p">);</span>
<span class="nl">err_link:</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_net_ops</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">bonding_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_netdev_notifier</span><span class="p">);</span>

	<span class="n">bond_destroy_debugfs</span><span class="p">();</span>

	<span class="n">rtnl_link_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_link_ops</span><span class="p">);</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_net_ops</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure we don&#39;t have an imbalance on our netpoll blocking</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpoll_block_tx</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">bonding_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">bonding_exit</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">DRV_DESCRIPTION</span> <span class="s">&quot;, v&quot;</span> <span class="n">DRV_VERSION</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Thomas Davis, tadavis@lbl.gov and many others&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_RTNL_LINK</span><span class="p">(</span><span class="s">&quot;bond&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
