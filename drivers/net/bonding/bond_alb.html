<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › bonding › bond_alb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bond_alb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright(c) 1999 - 2004 Intel Corporation. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="cm"> * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span>
<span class="cm"> * for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * The full GNU General Public License is included in this distribution in the</span>
<span class="cm"> * file called LICENSE.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/pkt_sched.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/if_bonding.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;net/ipx.h&gt;</span>
<span class="cp">#include &lt;net/arp.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &quot;bonding.h&quot;</span>
<span class="cp">#include &quot;bond_alb.h&quot;</span>



<span class="cp">#ifndef __long_aligned</span>
<span class="cp">#define __long_aligned __attribute__((aligned((sizeof(long)))))</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">mac_bcast</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="n">__long_aligned</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">mac_v6_allmcast</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">]</span> <span class="n">__long_aligned</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alb_delta_in_ticks</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="n">ALB_TIMER_TICKS_PER_SEC</span><span class="p">;</span>

<span class="cp">#pragma pack(1)</span>
<span class="k">struct</span> <span class="n">learning_pkt</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">mac_dst</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">mac_src</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="n">__be16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">padding</span><span class="p">[</span><span class="n">ETH_ZLEN</span> <span class="o">-</span> <span class="n">ETH_HLEN</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">arp_pkt</span> <span class="p">{</span>
	<span class="n">__be16</span>  <span class="n">hw_addr_space</span><span class="p">;</span>
	<span class="n">__be16</span>  <span class="n">prot_addr_space</span><span class="p">;</span>
	<span class="n">u8</span>      <span class="n">hw_addr_len</span><span class="p">;</span>
	<span class="n">u8</span>      <span class="n">prot_addr_len</span><span class="p">;</span>
	<span class="n">__be16</span>  <span class="n">op_code</span><span class="p">;</span>
	<span class="n">u8</span>      <span class="n">mac_src</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>	<span class="cm">/* sender hardware address */</span>
	<span class="n">__be32</span>  <span class="n">ip_src</span><span class="p">;</span>			<span class="cm">/* sender IP address */</span>
	<span class="n">u8</span>      <span class="n">mac_dst</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>	<span class="cm">/* target hardware address */</span>
	<span class="n">__be32</span>  <span class="n">ip_dst</span><span class="p">;</span>			<span class="cm">/* target IP address */</span>
<span class="p">};</span>
<span class="cp">#pragma pack()</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">arp_pkt</span> <span class="o">*</span><span class="nf">arp_pkt</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">arp_pkt</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Forward declaration */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">alb_send_learning_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mac_addr</span><span class="p">[]);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">_simple_hash</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hash_start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hash_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hash_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash</span> <span class="o">^=</span> <span class="n">hash_start</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*********************** tlb specific functions ***************************/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_lock_tx_hashtbl_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">tx_hashtbl_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_unlock_tx_hashtbl_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">tx_hashtbl_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_lock_tx_hashtbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">tx_hashtbl_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_unlock_tx_hashtbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">tx_hashtbl_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold tx_hashtbl lock */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tlb_init_table_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlb_client_info</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">save_load</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">save_load</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">load_history</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">/</span>
				      <span class="n">BOND_TLB_REBALANCE_INTERVAL</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tx_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">TLB_NULL_INDEX</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">TLB_NULL_INDEX</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tlb_init_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SLAVE_TLB_INFO</span><span class="p">(</span><span class="n">slave</span><span class="p">).</span><span class="n">load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">SLAVE_TLB_INFO</span><span class="p">(</span><span class="n">slave</span><span class="p">).</span><span class="n">head</span> <span class="o">=</span> <span class="n">TLB_NULL_INDEX</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold bond lock for read, BH disabled */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__tlb_clear_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">save_load</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tlb_client_info</span> <span class="o">*</span><span class="n">tx_hash_table</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* clear slave from tx_hashtbl */</span>
	<span class="n">tx_hash_table</span> <span class="o">=</span> <span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">tx_hashtbl</span><span class="p">;</span>

	<span class="cm">/* skip this if we&#39;ve already freed the tx hash table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_hash_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">SLAVE_TLB_INFO</span><span class="p">(</span><span class="n">slave</span><span class="p">).</span><span class="n">head</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">TLB_NULL_INDEX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">next_index</span> <span class="o">=</span> <span class="n">tx_hash_table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
			<span class="n">tlb_init_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tx_hash_table</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">save_load</span><span class="p">);</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tlb_init_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold bond lock for read */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tlb_clear_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">save_load</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">_lock_tx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="n">__tlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">save_load</span><span class="p">);</span>
	<span class="n">_unlock_tx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be called before starting the monitor timer */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tlb_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">TLB_HASH_TABLE_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tlb_client_info</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tlb_client_info</span> <span class="o">*</span><span class="n">new_hashtbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">new_hashtbl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_hashtbl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">_lock_tx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_hashtbl</span> <span class="o">=</span> <span class="n">new_hashtbl</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TLB_HASH_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlb_init_table_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_hashtbl</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">_unlock_tx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be called only after all slaves have been released */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tlb_deinitialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>

	<span class="n">_lock_tx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_hashtbl</span><span class="p">);</span>
	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_hashtbl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">_unlock_tx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">compute_gap</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">-</span> <span class="cm">/* Convert to Megabit per sec */</span>
	       <span class="p">(</span><span class="n">s64</span><span class="p">)</span> <span class="p">(</span><span class="n">SLAVE_TLB_INFO</span><span class="p">(</span><span class="n">slave</span><span class="p">).</span><span class="n">load</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span> <span class="cm">/* Bytes to bits */</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold bond lock for read */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="nf">tlb_get_least_loaded_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">least_loaded</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">max_gap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">least_loaded</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">max_gap</span> <span class="o">=</span> <span class="n">LLONG_MIN</span><span class="p">;</span>

	<span class="cm">/* Find the slave with the largest gap */</span>
	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SLAVE_IS_OK</span><span class="p">(</span><span class="n">slave</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="kt">long</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">compute_gap</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">max_gap</span> <span class="o">&lt;</span> <span class="n">gap</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">least_loaded</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
				<span class="n">max_gap</span> <span class="o">=</span> <span class="n">gap</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">least_loaded</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="nf">__tlb_choose_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash_index</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">skb_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">tlb_client_info</span> <span class="o">*</span><span class="n">hash_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">assigned_slave</span><span class="p">;</span>

	<span class="n">hash_table</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_hashtbl</span><span class="p">;</span>
	<span class="n">assigned_slave</span> <span class="o">=</span> <span class="n">hash_table</span><span class="p">[</span><span class="n">hash_index</span><span class="p">].</span><span class="n">tx_slave</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">assigned_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">assigned_slave</span> <span class="o">=</span> <span class="n">tlb_get_least_loaded_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">assigned_slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tlb_slave_info</span> <span class="o">*</span><span class="n">slave_info</span> <span class="o">=</span>
				<span class="o">&amp;</span><span class="p">(</span><span class="n">SLAVE_TLB_INFO</span><span class="p">(</span><span class="n">assigned_slave</span><span class="p">));</span>
			<span class="n">u32</span> <span class="n">next_index</span> <span class="o">=</span> <span class="n">slave_info</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

			<span class="n">hash_table</span><span class="p">[</span><span class="n">hash_index</span><span class="p">].</span><span class="n">tx_slave</span> <span class="o">=</span> <span class="n">assigned_slave</span><span class="p">;</span>
			<span class="n">hash_table</span><span class="p">[</span><span class="n">hash_index</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">;</span>
			<span class="n">hash_table</span><span class="p">[</span><span class="n">hash_index</span><span class="p">].</span><span class="n">prev</span> <span class="o">=</span> <span class="n">TLB_NULL_INDEX</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">next_index</span> <span class="o">!=</span> <span class="n">TLB_NULL_INDEX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hash_table</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">prev</span> <span class="o">=</span> <span class="n">hash_index</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">slave_info</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">hash_index</span><span class="p">;</span>
			<span class="n">slave_info</span><span class="o">-&gt;</span><span class="n">load</span> <span class="o">+=</span>
				<span class="n">hash_table</span><span class="p">[</span><span class="n">hash_index</span><span class="p">].</span><span class="n">load_history</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">assigned_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash_table</span><span class="p">[</span><span class="n">hash_index</span><span class="p">].</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">assigned_slave</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold bond lock for read */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="nf">tlb_choose_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash_index</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">skb_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">tx_slave</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t need to disable softirq here, becase</span>
<span class="cm">	 * tlb_choose_channel() is only called by bond_alb_xmit()</span>
<span class="cm">	 * which already has softirq disabled.</span>
<span class="cm">	 */</span>
	<span class="n">_lock_tx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="n">tx_slave</span> <span class="o">=</span> <span class="n">__tlb_choose_channel</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">hash_index</span><span class="p">,</span> <span class="n">skb_len</span><span class="p">);</span>
	<span class="n">_unlock_tx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tx_slave</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*********************** rlb specific functions ***************************/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">rx_hashtbl_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">rx_hashtbl_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_lock_rx_hashtbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">rx_hashtbl_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_unlock_rx_hashtbl</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">).</span><span class="n">rx_hashtbl_lock</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* when an ARP REPLY is received from a client update its info</span>
<span class="cm"> * in the rx_hashtbl</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_update_entry_from_arp</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">arp_pkt</span> <span class="o">*</span><span class="n">arp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">client_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_index</span><span class="p">;</span>

	<span class="n">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">hash_index</span> <span class="o">=</span> <span class="n">_simple_hash</span><span class="p">((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_src</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_src</span><span class="p">));</span>
	<span class="n">client_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">hash_index</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">assigned</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_src</span> <span class="o">==</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_dst</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_dst</span> <span class="o">==</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_src</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">mac_src</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* update the clients MAC address */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">mac_src</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rlb_arp_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arp_pkt</span> <span class="o">*</span><span class="n">arp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_ARP</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">arp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">arp_pkt</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Packet has no ARP data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">arp_hdr_len</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">arp_pkt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Packet is too small to be an ARP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">op_code</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* update rx hash table for this ARP */</span>
		<span class="n">rlb_update_entry_from_arp</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">arp</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Server received an ARP Reply from client</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">RX_HANDLER_ANOTHER</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold bond lock for read */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="nf">rlb_next_rx_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">rx_slave</span><span class="p">,</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">start_at</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">next_rx_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_at</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">next_rx_slave</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">start_at</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rx_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bond_for_each_slave_from</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">start_at</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SLAVE_IS_OK</span><span class="p">(</span><span class="n">slave</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_slave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rx_slave</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">speed</span> <span class="o">&gt;</span> <span class="n">rx_slave</span><span class="o">-&gt;</span><span class="n">speed</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rx_slave</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rx_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">next_rx_slave</span> <span class="o">=</span> <span class="n">rx_slave</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rx_slave</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* teach the switch the mac of a disabled slave</span>
<span class="cm"> * on the primary for fault tolerance</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold bond-&gt;curr_slave_lock for write or bond lock for write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_teach_disabled_mac_on_primary</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">primary_is_promisc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">primary_is_promisc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">primary_is_promisc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_promisc_timeout_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">alb_send_learning_packets</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* slave being removed should not be active at this point</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold bond lock for read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_clear_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">rx_hash_table</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">next_index</span><span class="p">;</span>

	<span class="cm">/* clear slave from rx_hashtbl */</span>
	<span class="n">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">rx_hash_table</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span> <span class="n">index</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next_index</span> <span class="o">=</span> <span class="n">rx_hash_table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_hash_table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">slave</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">assigned_slave</span> <span class="o">=</span> <span class="n">rlb_next_rx_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">assigned_slave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rx_hash_table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">slave</span> <span class="o">=</span> <span class="n">assigned_slave</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">rx_hash_table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">mac_dst</span><span class="p">,</span>
							     <span class="n">mac_bcast</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="cm">/* A slave has been removed from the</span>
<span class="cm">					 * table because it is either disabled</span>
<span class="cm">					 * or being released. We must retry the</span>
<span class="cm">					 * update to avoid clients from not</span>
<span class="cm">					 * being updated &amp; disconnecting when</span>
<span class="cm">					 * there is stress</span>
<span class="cm">					 */</span>
					<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_update_retry_counter</span> <span class="o">=</span>
						<span class="n">RLB_UPDATE_RETRY</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="cm">/* there is no active slave */</span>
				<span class="n">rx_hash_table</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slave</span> <span class="o">!=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rlb_teach_disabled_mac_on_primary</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_update_client</span><span class="p">(</span><span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">client_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RLB_ARP_BURST_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">arp_create</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">,</span> <span class="n">ETH_P_ARP</span><span class="p">,</span>
				 <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_dst</span><span class="p">,</span>
				 <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_src</span><span class="p">,</span>
				 <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span>
				 <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
				 <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: failed to create an ARP packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">vlan_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: failed to insert VLAN tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">arp_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* sends ARP REPLIES that update the clients that need updating */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_update_rx_clients</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">client_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_index</span><span class="p">;</span>

	<span class="n">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">hash_index</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">hash_index</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span> <span class="n">hash_index</span> <span class="o">=</span> <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">client_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">hash_index</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ntt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rlb_update_client</span><span class="p">(</span><span class="n">client_info</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_update_retry_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ntt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* do not update the entries again until this counter is zero so that</span>
<span class="cm">	 * not to confuse the clients.</span>
<span class="cm">	 */</span>
	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_update_delay_counter</span> <span class="o">=</span> <span class="n">RLB_UPDATE_DELAY</span><span class="p">;</span>

	<span class="n">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The slave was assigned a new mac address - update the clients */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_req_update_slave_clients</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">client_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ntt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_index</span><span class="p">;</span>

	<span class="n">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">hash_index</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">hash_index</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span> <span class="n">hash_index</span> <span class="o">=</span> <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">client_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">hash_index</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span> <span class="o">==</span> <span class="n">slave</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">mac_bcast</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>update the team's flag only after the whole iteration</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">ntt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>fasten the change</p></td><td class="code"><div class="highlight"><pre>		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_update_retry_counter</span> <span class="o">=</span> <span class="n">RLB_UPDATE_RETRY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* mark all clients using src_ip to be updated */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_req_update_subnet_clients</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">src_ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">client_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_index</span><span class="p">;</span>

	<span class="n">_lock_rx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">hash_index</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">hash_index</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span> <span class="n">hash_index</span> <span class="o">=</span> <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">client_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">hash_index</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: found a client with no channel in the client&#39;s hash table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*update all clients using this src_ip, that are not assigned</span>
<span class="cm">		 * to the team&#39;s address (curr_active_slave) and have a known</span>
<span class="cm">		 * unicast mac address.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_src</span> <span class="o">==</span> <span class="n">src_ip</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
					     <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">mac_bcast</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">_unlock_rx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold both bond and ptr locks for read */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="nf">rlb_choose_channel</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">arp_pkt</span> <span class="o">*</span><span class="n">arp</span> <span class="o">=</span> <span class="n">arp_pkt</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">assigned_slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">client_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">_lock_rx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">hash_index</span> <span class="o">=</span> <span class="n">_simple_hash</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_dst</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_dst</span><span class="p">));</span>
	<span class="n">client_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">hash_index</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">assigned</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_src</span> <span class="o">==</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_src</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_dst</span> <span class="o">==</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_dst</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* the entry is already assigned to this client */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">mac_bcast</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* update mac address from arp */</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">assigned_slave</span> <span class="o">=</span> <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">assigned_slave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">_unlock_rx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">assigned_slave</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* the entry is already assigned to some other client,</span>
<span class="cm">			 * move the old client to primary (curr_active_slave) so</span>
<span class="cm">			 * that the new client can be assigned to this entry.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">&amp;&amp;</span>
			    <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span> <span class="o">!=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>
				<span class="n">rlb_update_client</span><span class="p">(</span><span class="n">client_info</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* assign a new slave */</span>
	<span class="n">assigned_slave</span> <span class="o">=</span> <span class="n">rlb_next_rx_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">assigned_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_src</span> <span class="o">=</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_src</span><span class="p">;</span>
		<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ip_dst</span> <span class="o">=</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_dst</span><span class="p">;</span>
		<span class="cm">/* arp-&gt;mac_dst is broadcast for arp reqeusts.</span>
<span class="cm">		 * will be updated with clients actual unicast mac address</span>
<span class="cm">		 * upon receiving an arp reply.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span> <span class="o">=</span> <span class="n">assigned_slave</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">mac_bcast</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rx_ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ntt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond_vlan_used</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan_get_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">))</span>
				<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">assigned</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">prev_tbl_head</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span><span class="p">;</span>
			<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span> <span class="o">=</span> <span class="n">hash_index</span><span class="p">;</span>
			<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev_tbl_head</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev_tbl_head</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">prev_tbl_head</span><span class="p">].</span><span class="n">prev</span> <span class="o">=</span>
					<span class="n">hash_index</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">assigned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">_unlock_rx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">assigned_slave</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* chooses (and returns) transmit channel for arp reply</span>
<span class="cm"> * does not choose channel for other arp types since they are</span>
<span class="cm"> * sent on the curr_active_slave</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="nf">rlb_arp_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">arp_pkt</span> <span class="o">*</span><span class="n">arp</span> <span class="o">=</span> <span class="n">arp_pkt</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">tx_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">op_code</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REPLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* the arp must be sent on the selected</span>
<span class="cm">		* rx channel</span>
<span class="cm">		*/</span>
		<span class="n">tx_slave</span> <span class="o">=</span> <span class="n">rlb_choose_channel</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bond</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">mac_src</span><span class="p">,</span><span class="n">tx_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Server sent ARP Reply packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">arp</span><span class="o">-&gt;</span><span class="n">op_code</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ARPOP_REQUEST</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Create an entry in the rx_hashtbl for this client as a</span>
<span class="cm">		 * place holder.</span>
<span class="cm">		 * When the arp reply is received the entry will be updated</span>
<span class="cm">		 * with the correct unicast address of the client.</span>
<span class="cm">		 */</span>
		<span class="n">rlb_choose_channel</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bond</span><span class="p">);</span>

		<span class="cm">/* The ARP reply packets must be delayed so that</span>
<span class="cm">		 * they can cancel out the influence of the ARP request.</span>
<span class="cm">		 */</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_update_delay_counter</span> <span class="o">=</span> <span class="n">RLB_UPDATE_DELAY</span><span class="p">;</span>

		<span class="cm">/* arp requests are broadcast and are sent on the primary</span>
<span class="cm">		 * the arp request will collapse all clients on the subnet to</span>
<span class="cm">		 * the primary slave. We must register these clients to be</span>
<span class="cm">		 * updated with their assigned mac.</span>
<span class="cm">		 */</span>
		<span class="n">rlb_req_update_subnet_clients</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">arp</span><span class="o">-&gt;</span><span class="n">ip_src</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Server sent ARP Request packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tx_slave</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold bond lock for read */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_rebalance</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">assigned_slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">client_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ntt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_index</span><span class="p">;</span>

	<span class="n">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">ntt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hash_index</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">hash_index</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span> <span class="n">hash_index</span> <span class="o">=</span> <span class="n">client_info</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">client_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">hash_index</span><span class="p">]);</span>
		<span class="n">assigned_slave</span> <span class="o">=</span> <span class="n">rlb_next_rx_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">assigned_slave</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span> <span class="o">!=</span> <span class="n">assigned_slave</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">slave</span> <span class="o">=</span> <span class="n">assigned_slave</span><span class="p">;</span>
			<span class="n">client_info</span><span class="o">-&gt;</span><span class="n">ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* update the team&#39;s flag only after the whole iteration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ntt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_ntt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold rx_hashtbl lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_init_table_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rlb_client_info</span><span class="p">));</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rlb_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">rlb_client_info</span>	<span class="o">*</span><span class="n">new_hashtbl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">RLB_HASH_TABLE_SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rlb_client_info</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">new_hashtbl</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_hashtbl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span> <span class="o">=</span> <span class="n">new_hashtbl</span><span class="p">;</span>

	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span> <span class="o">=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">RLB_HASH_TABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rlb_init_table_entry</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="cm">/* register to receive ARPs */</span>
	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">recv_probe</span> <span class="o">=</span> <span class="n">rlb_arp_recv</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_deinitialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>

	<span class="n">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">);</span>
	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span> <span class="o">=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">;</span>

	<span class="n">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rlb_clear_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vlan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="n">u32</span> <span class="n">curr_index</span><span class="p">;</span>

	<span class="n">_lock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="n">curr_index</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">curr_index</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rlb_client_info</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">curr_index</span><span class="p">]);</span>
		<span class="n">u32</span> <span class="n">next_index</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">curr_index</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">prev_index</span> <span class="o">=</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">curr_index</span><span class="p">].</span><span class="n">prev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">==</span> <span class="n">vlan_id</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_index</span> <span class="o">==</span> <span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl_head</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev_index</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">prev_index</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next_index</span> <span class="o">!=</span> <span class="n">RLB_NULL_INDEX</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_hashtbl</span><span class="p">[</span><span class="n">next_index</span><span class="p">].</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev_index</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">rlb_init_table_entry</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">curr_index</span> <span class="o">=</span> <span class="n">next_index</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_unlock_rx_hashtbl_bh</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*********************** tlb/rlb shared functions *********************/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alb_send_learning_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="n">u8</span> <span class="n">mac_addr</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">bond_get_bond_by_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">learning_pkt</span> <span class="n">pkt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">learning_pkt</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">mac_dst</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">mac_src</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">pkt</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_LOOP</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_LP_BURST</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

		<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">pkt</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">TC_PRIO_CONTROL</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond_vlan_used</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>

			<span class="n">vlan</span> <span class="o">=</span> <span class="n">bond_next_vlan</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span>
					      <span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">current_alb_vlan</span><span class="p">);</span>

			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">current_alb_vlan</span> <span class="o">=</span> <span class="n">vlan</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">vlan_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: failed to insert VLAN tag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alb_set_slave_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="n">u8</span> <span class="n">addr</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">s_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_TLB</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* for rlb each slave must have a unique hw mac addresses so that */</span>
	<span class="cm">/* each slave will receive packets destined to a different mac */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">s_addr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">s_addr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: dev_set_mac_address of dev %s failed!</span><span class="se">\n</span><span class="s">&quot;</span>
		       <span class="s">&quot;ALB mode requires that the base driver support setting the hw address also when the network device&#39;s interface is open</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Swap MAC addresses between two slaves.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with RTNL held, and no other locks.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">alb_swap_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp_mac_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_mac_addr</span><span class="p">,</span> <span class="n">slave1</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="n">alb_set_slave_mac_addr</span><span class="p">(</span><span class="n">slave1</span><span class="p">,</span> <span class="n">slave2</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="n">alb_set_slave_mac_addr</span><span class="p">(</span><span class="n">slave2</span><span class="p">,</span> <span class="n">tmp_mac_addr</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Send learning packets after MAC address swap.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with RTNL and no other locks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">alb_fasten_mac_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave1</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slaves_state_differ</span> <span class="o">=</span> <span class="p">(</span><span class="n">SLAVE_IS_OK</span><span class="p">(</span><span class="n">slave1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SLAVE_IS_OK</span><span class="p">(</span><span class="n">slave2</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">disabled_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="cm">/* fasten the change in the switch */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SLAVE_IS_OK</span><span class="p">(</span><span class="n">slave1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">alb_send_learning_packets</span><span class="p">(</span><span class="n">slave1</span><span class="p">,</span> <span class="n">slave1</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* inform the clients that the mac address</span>
<span class="cm">			 * has changed</span>
<span class="cm">			 */</span>
			<span class="n">rlb_req_update_slave_clients</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">disabled_slave</span> <span class="o">=</span> <span class="n">slave1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SLAVE_IS_OK</span><span class="p">(</span><span class="n">slave2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">alb_send_learning_packets</span><span class="p">(</span><span class="n">slave2</span><span class="p">,</span> <span class="n">slave2</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* inform the clients that the mac address</span>
<span class="cm">			 * has changed</span>
<span class="cm">			 */</span>
			<span class="n">rlb_req_update_slave_clients</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">disabled_slave</span> <span class="o">=</span> <span class="n">slave2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">slaves_state_differ</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* A disabled slave was assigned an active mac addr */</span>
		<span class="n">rlb_teach_disabled_mac_on_primary</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span>
						  <span class="n">disabled_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alb_change_hw_addr_on_detach</span>
<span class="cm"> * @bond: bonding we&#39;re working on</span>
<span class="cm"> * @slave: the slave that was just detached</span>
<span class="cm"> *</span>
<span class="cm"> * We assume that @slave was already detached from the slave list.</span>
<span class="cm"> *</span>
<span class="cm"> * If @slave&#39;s permanent hw address is different both from its current</span>
<span class="cm"> * address and from @bond&#39;s address, then somewhere in the bond there&#39;s</span>
<span class="cm"> * a slave that has @slave&#39;s permanet address as its current address.</span>
<span class="cm"> * We&#39;ll make sure that that slave no longer uses @slave&#39;s permanent address.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold RTNL and no other locks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">alb_change_hw_addr_on_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">perm_curr_diff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">perm_bond_diff</span><span class="p">;</span>

	<span class="n">perm_curr_diff</span> <span class="o">=</span> <span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span>
						  <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="n">perm_bond_diff</span> <span class="o">=</span> <span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span>
						  <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">perm_curr_diff</span> <span class="o">&amp;&amp;</span> <span class="n">perm_bond_diff</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">tmp_slave</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">tmp_slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span>
						    <span class="n">tmp_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* locking: needs RTNL and nothing else */</span>
			<span class="n">alb_swap_mac_addr</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">tmp_slave</span><span class="p">);</span>
			<span class="n">alb_fasten_mac_swap</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">tmp_slave</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alb_handle_addr_collision_on_attach</span>
<span class="cm"> * @bond: bonding we&#39;re working on</span>
<span class="cm"> * @slave: the slave that was just attached</span>
<span class="cm"> *</span>
<span class="cm"> * checks uniqueness of slave&#39;s mac address and handles the case the</span>
<span class="cm"> * new slave uses the bonds mac address.</span>
<span class="cm"> *</span>
<span class="cm"> * If the permanent hw address of @slave is @bond&#39;s hw address, we need to</span>
<span class="cm"> * find a different hw address to give @slave, that isn&#39;t in use by any other</span>
<span class="cm"> * slave in the bond. This address must be, of course, one of the permanent</span>
<span class="cm"> * addresses of the other slaves.</span>
<span class="cm"> *</span>
<span class="cm"> * We go over the slave list, and for each slave there we compare its</span>
<span class="cm"> * permanent hw address with the current address of all the other slaves.</span>
<span class="cm"> * If no match was found, then we&#39;ve found a slave with a permanent address</span>
<span class="cm"> * that isn&#39;t used by any other slave in the bond, so we can assign it to</span>
<span class="cm"> * @slave.</span>
<span class="cm"> *</span>
<span class="cm"> * assumption: this function is called before @slave is attached to the</span>
<span class="cm"> * 	       bond slave list.</span>
<span class="cm"> *</span>
<span class="cm"> * caller must hold the bond lock for write since the mac addresses are compared</span>
<span class="cm"> * and may be swapped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alb_handle_addr_collision_on_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">tmp_slave1</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_slave2</span><span class="p">,</span> <span class="o">*</span><span class="n">free_mac_slave</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">has_bond_addr</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this is the first slave */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if slave&#39;s mac address differs from bond&#39;s mac address</span>
<span class="cm">	 * check uniqueness of slave&#39;s mac address against the other</span>
<span class="cm">	 * slaves in the bond.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">tmp_slave1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">tmp_slave1</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
						    <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Try setting slave mac to bond address and fall-through</span>
<span class="cm">		   to code handling that situation below... */</span>
		<span class="n">alb_set_slave_mac_addr</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The slave&#39;s address is equal to the address of the bond.</span>
<span class="cm">	 * Search for a spare address in the bond for this slave.</span>
<span class="cm">	 */</span>
	<span class="n">free_mac_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">tmp_slave1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">tmp_slave2</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">tmp_slave1</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">,</span>
						    <span class="n">tmp_slave2</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* no slave has tmp_slave1&#39;s perm addr</span>
<span class="cm">			 * as its curr addr</span>
<span class="cm">			 */</span>
			<span class="n">free_mac_slave</span> <span class="o">=</span> <span class="n">tmp_slave1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_bond_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">tmp_slave1</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
						    <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>

				<span class="n">has_bond_addr</span> <span class="o">=</span> <span class="n">tmp_slave1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free_mac_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alb_set_slave_mac_addr</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="n">free_mac_slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">);</span>

		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s: Warning: the hw address of slave %s is in use by the bond; giving it the hw address of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			   <span class="n">free_mac_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">has_bond_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error: the hw address of slave %s is in use by the bond; couldn&#39;t find a slave with a free hw address to give it (this should not have happened)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * alb_set_mac_address</span>
<span class="cm"> * @bond:</span>
<span class="cm"> * @addr:</span>
<span class="cm"> *</span>
<span class="cm"> * In TLB mode all slaves are configured to the bond&#39;s hw address, but set</span>
<span class="cm"> * their dev_addr field to different addresses (based on their permanent hw</span>
<span class="cm"> * addresses).</span>
<span class="cm"> *</span>
<span class="cm"> * For each slave, this function sets the interface to the new address and then</span>
<span class="cm"> * changes its dev_addr field to its previous value.</span>
<span class="cm"> *</span>
<span class="cm"> * Unwinding assumes bond&#39;s mac address has not yet changed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">alb_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">sa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">stop_at</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmp_addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* save net_device&#39;s current hw address */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_addr</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

		<span class="cm">/* restore net_device&#39;s hw address */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">tmp_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unwind</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unwind:</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">sa</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="cm">/* unwind from head to the slave that failed */</span>
	<span class="n">stop_at</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
	<span class="n">bond_for_each_slave_from_to</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">first_slave</span><span class="p">,</span> <span class="n">stop_at</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp_addr</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">tmp_addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************ exported alb funcions ************************/</span>

<span class="kt">int</span> <span class="nf">bond_alb_initialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rlb_enabled</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">tlb_initialize</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* initialize rlb */</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">rlb_initialize</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tlb_deinitialize</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bond_alb_deinitialize</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>

	<span class="n">tlb_deinitialize</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rlb_deinitialize</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bond_alb_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eth_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">tx_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">__be32</span> <span class="n">ip_bcast</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">hash_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hash_start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">ip6hdr</span><span class="p">;</span>

	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">eth_data</span> <span class="o">=</span> <span class="n">eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* make sure that the curr_active_slave do not change during tx</span>
<span class="cm">	 */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_P_IP</span>: <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">eth_data</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">mac_bcast</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">==</span> <span class="n">ip_bcast</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_IGMP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hash_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
		<span class="n">hash_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
	<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ETH_P_IPV6</span>:
		<span class="cm">/* IPv6 doesn&#39;t really use broadcast mac address, but leave</span>
<span class="cm">		 * that here just in case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">eth_data</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">mac_bcast</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* IPv6 uses all-nodes multicast as an equivalent to</span>
<span class="cm">		 * broadcasts in IPv4.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">eth_data</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">,</span> <span class="n">mac_v6_allmcast</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Additianally, DAD probes should not be tx-balanced as that</span>
<span class="cm">		 * will lead to false positives for duplicate addresses and</span>
<span class="cm">		 * prevent address configuration from working.</span>
<span class="cm">		 */</span>
		<span class="n">ip6hdr</span> <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_addr_any</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip6hdr</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hash_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
		<span class="n">hash_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ETH_P_IPX</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ipx_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipx_checksum</span> <span class="o">!=</span> <span class="n">IPX_NO_CHECKSUM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* something is wrong with this packet */</span>
			<span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ipx_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ipx_type</span> <span class="o">!=</span> <span class="n">IPX_TYPE_NCP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The only protocol worth balancing in</span>
<span class="cm">			 * this family since it has an &quot;ARP&quot; like</span>
<span class="cm">			 * mechanism</span>
<span class="cm">			 */</span>
			<span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hash_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">eth_data</span><span class="o">-&gt;</span><span class="n">h_dest</span><span class="p">;</span>
		<span class="n">hash_size</span> <span class="o">=</span> <span class="n">ETH_ALEN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ETH_P_ARP</span>:
		<span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_slave</span> <span class="o">=</span> <span class="n">rlb_arp_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bond</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">do_tx_balance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_tx_balance</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hash_index</span> <span class="o">=</span> <span class="n">_simple_hash</span><span class="p">(</span><span class="n">hash_start</span><span class="p">,</span> <span class="n">hash_size</span><span class="p">);</span>
		<span class="n">tx_slave</span> <span class="o">=</span> <span class="n">tlb_choose_channel</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">hash_index</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* unbalanced or unassigned, send through primary */</span>
		<span class="n">tx_slave</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>
		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">unbalanced_load</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_slave</span> <span class="o">&amp;&amp;</span> <span class="n">SLAVE_IS_OK</span><span class="p">(</span><span class="n">tx_slave</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_slave</span> <span class="o">!=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">eth_data</span><span class="o">-&gt;</span><span class="n">h_source</span><span class="p">,</span>
			       <span class="n">tx_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
			       <span class="n">ETH_ALEN</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">bond_dev_queue_xmit</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tx_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_slave</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">_lock_tx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
			<span class="n">__tlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">tx_slave</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">_unlock_tx_hashtbl</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no suitable interface, frame not sent */</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bond_alb_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span><span class="p">,</span>
					    <span class="n">alb_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_rebalance_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">lp_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">re_arm</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_rebalance_counter</span><span class="o">++</span><span class="p">;</span>
	<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">lp_counter</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* send learning packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">lp_counter</span> <span class="o">&gt;=</span> <span class="n">BOND_ALB_LP_TICKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* change of curr_active_slave involves swapping of mac addresses.</span>
<span class="cm">		 * in order to avoid this swapping from happening while</span>
<span class="cm">		 * sending the learning packets, the curr_slave_lock must be held for</span>
<span class="cm">		 * read.</span>
<span class="cm">		 */</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alb_send_learning_packets</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">lp_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* rebalance tx traffic */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_rebalance_counter</span> <span class="o">&gt;=</span> <span class="n">BOND_TLB_REBALANCE_TICKS</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slave</span> <span class="o">==</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SLAVE_TLB_INFO</span><span class="p">(</span><span class="n">slave</span><span class="p">).</span><span class="n">load</span> <span class="o">=</span>
					<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">unbalanced_load</span> <span class="o">/</span>
						<span class="n">BOND_TLB_REBALANCE_INTERVAL</span><span class="p">;</span>
				<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">unbalanced_load</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>

		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_rebalance_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* handle rlb stuff */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">primary_is_promisc</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">++</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_promisc_timeout_counter</span> <span class="o">&gt;=</span> <span class="n">RLB_PROMISC_TIMEOUT</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * dev_set_promiscuity requires rtnl and</span>
<span class="cm">			 * nothing else.  Avoid race with bond_close.</span>
<span class="cm">			 */</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtnl_trylock</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">re_arm</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_promisc_timeout_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* If the primary was set to promiscuous mode</span>
<span class="cm">			 * because a slave was disabled then</span>
<span class="cm">			 * it can now leave promiscuous mode.</span>
<span class="cm">			 */</span>
			<span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">primary_is_promisc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">rtnl_unlock</span><span class="p">();</span>
			<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_rebalance</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_rebalance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rlb_rebalance</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* check if clients need updating */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_ntt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_update_delay_counter</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">--</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_update_delay_counter</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">rlb_update_rx_clients</span><span class="p">(</span><span class="n">bond</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_update_retry_counter</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">--</span><span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rlb_update_retry_counter</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">rx_ntt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">re_arm:</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_work</span><span class="p">,</span> <span class="n">alb_delta_in_ticks</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* assumption: called before the slave is attached to the bond</span>
<span class="cm"> * and not locked by the bond lock</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bond_alb_init_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">alb_set_slave_mac_addr</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">perm_hwaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* caller must hold the bond lock for write since the mac addresses</span>
<span class="cm">	 * are compared and may be swapped.</span>
<span class="cm">	 */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">alb_handle_addr_collision_on_attach</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>

	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tlb_init_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>

	<span class="cm">/* order a rebalance ASAP */</span>
	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">tx_rebalance_counter</span> <span class="o">=</span> <span class="n">BOND_TLB_REBALANCE_TICKS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_rebalance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove slave from tlb and rlb hash tables, and fix up MAC addresses</span>
<span class="cm"> * if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold RTNL and no other locks</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bond_alb_deinit_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alb_change_hw_addr_on_detach</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">next_rx_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Caller must hold bond lock for read */</span>
<span class="kt">void</span> <span class="nf">bond_alb_handle_link_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="kt">char</span> <span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alb_bond_info</span> <span class="o">*</span><span class="n">bond_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">BOND_ALB_INFO</span><span class="p">(</span><span class="n">bond</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_DOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">link</span> <span class="o">==</span> <span class="n">BOND_LINK_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* order a rebalance ASAP */</span>
		<span class="n">bond_info</span><span class="o">-&gt;</span><span class="n">tx_rebalance_counter</span> <span class="o">=</span> <span class="n">BOND_TLB_REBALANCE_TICKS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_rebalance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* If the updelay module parameter is smaller than the</span>
<span class="cm">			 * forwarding delay of the switch the rebalance will</span>
<span class="cm">			 * not work because the rebalance arp replies will</span>
<span class="cm">			 * not be forwarded to the clients..</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bond_alb_handle_active_change - assign new curr_active_slave</span>
<span class="cm"> * @bond: our bonding struct</span>
<span class="cm"> * @new_slave: new slave to assign</span>
<span class="cm"> *</span>
<span class="cm"> * Set the bond-&gt;curr_active_slave to @new_slave and handle</span>
<span class="cm"> * mac address swapping and promiscuity changes as needed.</span>
<span class="cm"> *</span>
<span class="cm"> * If new_slave is NULL, caller must hold curr_slave_lock or</span>
<span class="cm"> * bond-&gt;lock for write.</span>
<span class="cm"> *</span>
<span class="cm"> * If new_slave is not NULL, caller must hold RTNL, bond-&gt;lock for</span>
<span class="cm"> * read and curr_slave_lock for write.  Processing here may sleep, so</span>
<span class="cm"> * no other locks may be held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bond_alb_handle_active_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_slave</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">swap_slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">==</span> <span class="n">new_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">&amp;&amp;</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">primary_is_promisc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">primary_is_promisc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_promisc_timeout_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">swap_slave</span> <span class="o">=</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">;</span>
	<span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span> <span class="o">=</span> <span class="n">new_slave</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_slave</span> <span class="o">||</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">slave_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set the new curr_active_slave to the bonds mac address</span>
<span class="cm">	 * i.e. swap mac addresses of old curr_active_slave and new curr_active_slave</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swap_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">tmp_slave</span><span class="p">;</span>
		<span class="cm">/* find slave that is holding the bond&#39;s mac address */</span>
		<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">tmp_slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">tmp_slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
						    <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">swap_slave</span> <span class="o">=</span> <span class="n">tmp_slave</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Arrange for swap_slave and new_slave to temporarily be</span>
<span class="cm">	 * ignored so we can mess with their MAC addresses without</span>
<span class="cm">	 * fear of interference from transmit activity.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">swap_slave</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tlb_clear_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">new_slave</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="cm">/* curr_active_slave must be set before calling alb_swap_mac_addr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* swap mac address */</span>
		<span class="n">alb_swap_mac_addr</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">swap_slave</span><span class="p">,</span> <span class="n">new_slave</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* set the new_slave to the bond mac address */</span>
		<span class="n">alb_set_slave_mac_addr</span><span class="p">(</span><span class="n">new_slave</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">swap_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alb_fasten_mac_swap</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">swap_slave</span><span class="p">,</span> <span class="n">new_slave</span><span class="p">);</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">alb_send_learning_packets</span><span class="p">(</span><span class="n">new_slave</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_slave_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called with RTNL</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bond_alb_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">bond_dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="o">*</span><span class="n">swap_slave</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">alb_set_mac_address</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="cm">/* If there is no curr_active_slave there is nothing else to do.</span>
<span class="cm">	 * Otherwise we&#39;ll need to pass the new address to it and handle</span>
<span class="cm">	 * duplications.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">swap_slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ether_addr_equal_64bits</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
					    <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">swap_slave</span> <span class="o">=</span> <span class="n">slave</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">swap_slave</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alb_swap_mac_addr</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">swap_slave</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">);</span>
		<span class="n">alb_fasten_mac_swap</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">swap_slave</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">alb_set_slave_mac_addr</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">alb_send_learning_packets</span><span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">,</span> <span class="n">bond_dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* inform clients mac address has changed */</span>
			<span class="n">rlb_req_update_slave_clients</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">curr_active_slave</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bond_alb_clear_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vlan_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">current_alb_vlan</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">current_alb_vlan</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">==</span> <span class="n">vlan_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">current_alb_vlan</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">alb_info</span><span class="p">.</span><span class="n">rlb_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rlb_clear_vlan</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">vlan_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
