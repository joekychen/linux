<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › bonding › bonding.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>bonding.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Bond several ethernet interfaces into a Cisco, running &#39;Etherchannel&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * Portions are (c) Copyright 1995 Simon &quot;Guru Aleph-Null&quot; Janes</span>
<span class="cm"> * NCM: Network and Communications Management, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * BUT, I&#39;m the one who modified it for ethernet, so:</span>
<span class="cm"> * (c) Copyright 1999, Thomas Davis, tadavis@lbl.gov</span>
<span class="cm"> *</span>
<span class="cm"> *	This software may be used and distributed according to the terms</span>
<span class="cm"> *	of the GNU Public License, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _LINUX_BONDING_H</span>
<span class="cp">#define _LINUX_BONDING_H</span>

<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/if_bonding.h&gt;</span>
<span class="cp">#include &lt;linux/cpumask.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/netpoll.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &quot;bond_3ad.h&quot;</span>
<span class="cp">#include &quot;bond_alb.h&quot;</span>

<span class="cp">#define DRV_VERSION	&quot;3.7.1&quot;</span>
<span class="cp">#define DRV_RELDATE	&quot;April 27, 2011&quot;</span>
<span class="cp">#define DRV_NAME	&quot;bonding&quot;</span>
<span class="cp">#define DRV_DESCRIPTION	&quot;Ethernet Channel Bonding Driver&quot;</span>

<span class="cp">#define bond_version DRV_DESCRIPTION &quot;: v&quot; DRV_VERSION &quot; (&quot; DRV_RELDATE &quot;)\n&quot;</span>

<span class="cp">#define BOND_MAX_ARP_TARGETS	16</span>

<span class="cp">#define IS_UP(dev)					   \</span>
<span class="cp">	      ((((dev)-&gt;flags &amp; IFF_UP) == IFF_UP)	&amp;&amp; \</span>
<span class="cp">	       netif_running(dev)			&amp;&amp; \</span>
<span class="cp">	       netif_carrier_ok(dev))</span>

<span class="cm">/*</span>
<span class="cm"> * Checks whether slave is ready for transmit.</span>
<span class="cm"> */</span>
<span class="cp">#define SLAVE_IS_OK(slave)			        \</span>
<span class="cp">		    (((slave)-&gt;dev-&gt;flags &amp; IFF_UP)  &amp;&amp; \</span>
<span class="cp">		     netif_running((slave)-&gt;dev)     &amp;&amp; \</span>
<span class="cp">		     ((slave)-&gt;link == BOND_LINK_UP) &amp;&amp; \</span>
<span class="cp">		     bond_is_active_slave(slave))</span>


<span class="cp">#define USES_PRIMARY(mode)				\</span>
<span class="cp">		(((mode) == BOND_MODE_ACTIVEBACKUP) ||	\</span>
<span class="cp">		 ((mode) == BOND_MODE_TLB)          ||	\</span>
<span class="cp">		 ((mode) == BOND_MODE_ALB))</span>

<span class="cp">#define TX_QUEUE_OVERRIDE(mode)				\</span>
<span class="cp">			(((mode) == BOND_MODE_ACTIVEBACKUP) ||	\</span>
<span class="cp">			 ((mode) == BOND_MODE_ROUNDROBIN))</span>
<span class="cm">/*</span>
<span class="cm"> * Less bad way to call ioctl from within the kernel; this needs to be</span>
<span class="cm"> * done some other way to get the call out of interrupt context.</span>
<span class="cm"> * Needs &quot;ioctl&quot; variable to be supplied by calling context.</span>
<span class="cm"> */</span>
<span class="cp">#define IOCTL(dev, arg, cmd) ({		\</span>
<span class="cp">	int res = 0;			\</span>
<span class="cp">	mm_segment_t fs = get_fs();	\</span>
<span class="cp">	set_fs(get_ds());		\</span>
<span class="cp">	res = ioctl(dev, arg, cmd);	\</span>
<span class="cp">	set_fs(fs);			\</span>
<span class="cp">	res; })</span>

<span class="cm">/**</span>
<span class="cm"> * bond_for_each_slave_from - iterate the slaves list from a starting point</span>
<span class="cm"> * @bond:	the bond holding this list.</span>
<span class="cm"> * @pos:	current slave.</span>
<span class="cm"> * @cnt:	counter for max number of moves</span>
<span class="cm"> * @start:	starting point.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold bond-&gt;lock</span>
<span class="cm"> */</span>
<span class="cp">#define bond_for_each_slave_from(bond, pos, cnt, start)	\</span>
<span class="cp">	for (cnt = 0, pos = start;				\</span>
<span class="cp">	     cnt &lt; (bond)-&gt;slave_cnt;				\</span>
<span class="cp">             cnt++, pos = (pos)-&gt;next)</span>

<span class="cm">/**</span>
<span class="cm"> * bond_for_each_slave_from_to - iterate the slaves list from start point to stop point</span>
<span class="cm"> * @bond:	the bond holding this list.</span>
<span class="cm"> * @pos:	current slave.</span>
<span class="cm"> * @cnt:	counter for number max of moves</span>
<span class="cm"> * @start:	start point.</span>
<span class="cm"> * @stop:	stop point.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold bond-&gt;lock</span>
<span class="cm"> */</span>
<span class="cp">#define bond_for_each_slave_from_to(bond, pos, cnt, start, stop)	\</span>
<span class="cp">	for (cnt = 0, pos = start;					\</span>
<span class="cp">	     ((cnt &lt; (bond)-&gt;slave_cnt) &amp;&amp; (pos != (stop)-&gt;next));	\</span>
<span class="cp">             cnt++, pos = (pos)-&gt;next)</span>

<span class="cm">/**</span>
<span class="cm"> * bond_for_each_slave - iterate the slaves list from head</span>
<span class="cm"> * @bond:	the bond holding this list.</span>
<span class="cm"> * @pos:	current slave.</span>
<span class="cm"> * @cnt:	counter for max number of moves</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold bond-&gt;lock</span>
<span class="cm"> */</span>
<span class="cp">#define bond_for_each_slave(bond, pos, cnt)	\</span>
<span class="cp">		bond_for_each_slave_from(bond, pos, cnt, (bond)-&gt;first_slave)</span>


<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">extern</span> <span class="n">atomic_t</span> <span class="n">netpoll_block_tx</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">block_netpoll_tx</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpoll_block_tx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unblock_netpoll_tx</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpoll_block_tx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">is_netpoll_tx_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">netpoll_tx_running</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpoll_block_tx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define block_netpoll_tx()</span>
<span class="cp">#define unblock_netpoll_tx()</span>
<span class="cp">#define is_netpoll_tx_blocked(dev) (0)</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">bond_params</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xmit_policy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">miimon</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_peer_notif</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">arp_interval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">arp_validate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_carrier</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fail_over_mac</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">updelay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">downdelay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lacp_fast</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_links</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ad_select</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">primary</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">primary_reselect</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">arp_targets</span><span class="p">[</span><span class="n">BOND_MAX_ARP_TARGETS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">tx_queues</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">all_slaves_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">resend_igmp</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">modename</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define BOND_MAX_MODENAME_LEN 20</span>

<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">vlan_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">vlan_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">slave</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span> <span class="cm">/* first - useful for panic debug */</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">;</span> <span class="cm">/* our master */</span>
	<span class="kt">int</span>    <span class="n">delay</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_arp_rx</span><span class="p">;</span>
	<span class="n">s8</span>     <span class="n">link</span><span class="p">;</span>    <span class="cm">/* one of BOND_LINK_XXXX */</span>
	<span class="n">s8</span>     <span class="n">new_link</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">backup</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>   <span class="cm">/* indicates backup slave. Value corresponds with</span>
<span class="cm">			      BOND_STATE_ACTIVE and BOND_STATE_BACKUP */</span>
	       <span class="nl">inactive:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* indicates inactive slave */</span>
	<span class="n">u8</span>     <span class="n">duplex</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">original_mtu</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">link_failure_count</span><span class="p">;</span>
	<span class="n">u32</span>    <span class="n">speed</span><span class="p">;</span>
	<span class="n">u16</span>    <span class="n">queue_id</span><span class="p">;</span>
	<span class="n">u8</span>     <span class="n">perm_hwaddr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ad_slave_info</span> <span class="n">ad_info</span><span class="p">;</span> <span class="cm">/* HUGE - better to dynamically alloc */</span>
	<span class="k">struct</span> <span class="n">tlb_slave_info</span> <span class="n">tlb_info</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="k">struct</span> <span class="n">netpoll</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Link pseudo-state only used internally by monitors</span>
<span class="cm"> */</span>
<span class="cp">#define BOND_LINK_NOCHANGE -1</span>

<span class="cm">/*</span>
<span class="cm"> * Here are the locking policies for the two bonding locks:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) Get bond-&gt;lock when reading/writing slave list.</span>
<span class="cm"> * 2) Get bond-&gt;curr_slave_lock when reading/writing bond-&gt;curr_active_slave.</span>
<span class="cm"> *    (It is unnecessary when the write-lock is put with bond-&gt;lock.)</span>
<span class="cm"> * 3) When we lock with bond-&gt;curr_slave_lock, we must lock with bond-&gt;lock</span>
<span class="cm"> *    beforehand.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bonding</span> <span class="p">{</span>
	<span class="k">struct</span>   <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span> <span class="cm">/* first - useful for panic debug */</span>
	<span class="k">struct</span>   <span class="n">slave</span> <span class="o">*</span><span class="n">first_slave</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">slave</span> <span class="o">*</span><span class="n">curr_active_slave</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">slave</span> <span class="o">*</span><span class="n">current_arp_slave</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">slave</span> <span class="o">*</span><span class="n">primary_slave</span><span class="p">;</span>
	<span class="n">bool</span>     <span class="n">force_primary</span><span class="p">;</span>
	<span class="n">s32</span>      <span class="n">slave_cnt</span><span class="p">;</span> <span class="cm">/* never change this value outside the attach/detach wrappers */</span>
	<span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">recv_probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">rwlock_t</span> <span class="n">curr_slave_lock</span><span class="p">;</span>
	<span class="n">u8</span>	 <span class="n">send_peer_notif</span><span class="p">;</span>
	<span class="n">s8</span>	 <span class="n">setup_by_slave</span><span class="p">;</span>
	<span class="n">s8</span>       <span class="n">igmp_retrans</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">struct</span>   <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">proc_entry</span><span class="p">;</span>
	<span class="kt">char</span>     <span class="n">proc_file_name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>
	<span class="k">struct</span>   <span class="n">list_head</span> <span class="n">bond_list</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">netdev_hw_addr_list</span> <span class="n">mc_list</span><span class="p">;</span>
	<span class="kt">int</span>      <span class="p">(</span><span class="o">*</span><span class="n">xmit_hash_policy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">u16</span>      <span class="n">rr_tx_counter</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">ad_bond_info</span> <span class="n">ad_info</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">alb_bond_info</span> <span class="n">alb_info</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">bond_params</span> <span class="n">params</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">list_head</span> <span class="n">vlan_list</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">delayed_work</span> <span class="n">mii_work</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">delayed_work</span> <span class="n">arp_work</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">delayed_work</span> <span class="n">alb_work</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">delayed_work</span> <span class="n">ad_work</span><span class="p">;</span>
	<span class="k">struct</span>   <span class="n">delayed_work</span> <span class="n">mcast_work</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="cm">/* debugging suport via debugfs */</span>
	<span class="k">struct</span>	 <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_dir</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_FS */</span><span class="cp"></span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bond_vlan_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">vlan_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define bond_slave_get_rcu(dev) \</span>
<span class="cp">	((struct slave *) rcu_dereference(dev-&gt;rx_handler_data))</span>

<span class="cm">/**</span>
<span class="cm"> * Returns NULL if the net_device does not belong to any of the bond&#39;s slaves</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold bond lock for read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="nf">bond_get_slave_by_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bond_for_each_slave</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">slave_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">slave</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="nf">bond_get_bond_by_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave</span> <span class="o">||</span> <span class="o">!</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bond_is_lb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_TLB</span> <span class="o">||</span>
		<span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BOND_MODE_ALB</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_set_active_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">backup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_set_backup_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">backup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bond_slave_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">backup</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bond_is_active_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">bond_slave_state</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define BOND_PRI_RESELECT_ALWAYS	0</span>
<span class="cp">#define BOND_PRI_RESELECT_BETTER	1</span>
<span class="cp">#define BOND_PRI_RESELECT_FAILURE	2</span>

<span class="cp">#define BOND_FOM_NONE			0</span>
<span class="cp">#define BOND_FOM_ACTIVE			1</span>
<span class="cp">#define BOND_FOM_FOLLOW			2</span>

<span class="cp">#define BOND_ARP_VALIDATE_NONE		0</span>
<span class="cp">#define BOND_ARP_VALIDATE_ACTIVE	(1 &lt;&lt; BOND_STATE_ACTIVE)</span>
<span class="cp">#define BOND_ARP_VALIDATE_BACKUP	(1 &lt;&lt; BOND_STATE_BACKUP)</span>
<span class="cp">#define BOND_ARP_VALIDATE_ALL		(BOND_ARP_VALIDATE_ACTIVE | \</span>
<span class="cp">					 BOND_ARP_VALIDATE_BACKUP)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">slave_do_arp_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">arp_validate</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bond_slave_state</span><span class="p">(</span><span class="n">slave</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">slave_last_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_do_arp_validate</span><span class="p">(</span><span class="n">bond</span><span class="p">,</span> <span class="n">slave</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">last_arp_rx</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">last_rx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_netpoll_send_skb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netpoll</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="p">)</span>
		<span class="n">netpoll_send_skb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_netpoll_send_skb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_set_slave_inactive_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond_is_lb</span><span class="p">(</span><span class="n">bond</span><span class="p">))</span>
		<span class="n">bond_set_backup_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bond</span><span class="o">-&gt;</span><span class="n">params</span><span class="p">.</span><span class="n">all_slaves_active</span><span class="p">)</span>
		<span class="n">slave</span><span class="o">-&gt;</span><span class="n">inactive</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_set_slave_active_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bond_set_active_slave</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">inactive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">bond_is_slave_inactive</span><span class="p">(</span><span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">slave</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">inactive</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__be32</span> <span class="nf">bond_confirm_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">dst</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">in_dev</span> <span class="o">=</span> <span class="n">__in_dev_get_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_dev</span><span class="p">)</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">inet_confirm_addr</span><span class="p">(</span><span class="n">in_dev</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">local</span><span class="p">,</span> <span class="n">RT_SCOPE_HOST</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">bond_net</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">bond_next_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vlan_entry</span> <span class="o">*</span><span class="n">curr</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bond_dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bond_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bond_create_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_destroy_sysfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">net</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_prepare_sysfs_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bond_create_slave_symlinks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_destroy_slave_symlinks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">master</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bond_enslave</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bond_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">bond_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave_dev</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_mii_monitor</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_loadbalance_arp_mon</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_activebackup_arp_mon</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_set_mode_ops</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">bond_parse_parm</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode_arg</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="o">*</span><span class="n">tbl</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_select_active_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_change_active_slave</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slave</span> <span class="o">*</span><span class="n">new_active</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_create_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_destroy_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_debug_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_debug_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_debug_reregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bond_mode_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">bond_net</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span>		<span class="n">net</span><span class="p">;</span>	<span class="cm">/* Associated network namespace */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">dev_list</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span>	<span class="n">proc_dir</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">class_attribute</span>	<span class="n">class_attr_bonding_masters</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="kt">void</span> <span class="n">bond_create_proc_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_remove_proc_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_create_proc_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">bn</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">bond_destroy_proc_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">bn</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_create_proc_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_remove_proc_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">bonding</span> <span class="o">*</span><span class="n">bond</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_create_proc_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">bn</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bond_destroy_proc_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">bond_net</span> <span class="o">*</span><span class="n">bn</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/* exported from bond_main.c */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">bond_net_id</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">bond_lacp_tbl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">bond_mode_tbl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">xmit_hashtype_tbl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">arp_validate_tbl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">fail_over_mac_tbl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">pri_reselect_tbl</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">bond_parm_tbl</span> <span class="n">ad_select_tbl</span><span class="p">[];</span>

<span class="cp">#endif </span><span class="cm">/* _LINUX_BONDING_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
