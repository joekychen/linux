<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › fddi › defxx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>defxx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * File Name:</span>
<span class="cm"> *   defxx.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright Information:</span>
<span class="cm"> *   Copyright Digital Equipment Corporation 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *   This software may be used and distributed according to the terms of</span>
<span class="cm"> *   the GNU General Public License, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Abstract:</span>
<span class="cm"> *   A Linux device driver supporting the Digital Equipment Corporation</span>
<span class="cm"> *   FDDI TURBOchannel, EISA and PCI controller families.  Supported</span>
<span class="cm"> *   adapters include:</span>
<span class="cm"> *</span>
<span class="cm"> *		DEC FDDIcontroller/TURBOchannel (DEFTA)</span>
<span class="cm"> *		DEC FDDIcontroller/EISA         (DEFEA)</span>
<span class="cm"> *		DEC FDDIcontroller/PCI          (DEFPA)</span>
<span class="cm"> *</span>
<span class="cm"> * The original author:</span>
<span class="cm"> *   LVS	Lawrence V. Stefani &lt;lstefani@yahoo.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Maintainers:</span>
<span class="cm"> *   macro	Maciej W. Rozycki &lt;macro@linux-mips.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Credits:</span>
<span class="cm"> *   I&#39;d like to thank Patricia Cross for helping me get started with</span>
<span class="cm"> *   Linux, David Davies for a lot of help upgrading and configuring</span>
<span class="cm"> *   my development system and for answering many OS and driver</span>
<span class="cm"> *   development questions, and Alan Cox for recommendations and</span>
<span class="cm"> *   integration help on getting FDDI support into Linux.  LVS</span>
<span class="cm"> *</span>
<span class="cm"> * Driver Architecture:</span>
<span class="cm"> *   The driver architecture is largely based on previous driver work</span>
<span class="cm"> *   for other operating systems.  The upper edge interface and</span>
<span class="cm"> *   functions were largely taken from existing Linux device drivers</span>
<span class="cm"> *   such as David Davies&#39; DE4X5.C driver and Donald Becker&#39;s TULIP.C</span>
<span class="cm"> *   driver.</span>
<span class="cm"> *</span>
<span class="cm"> *   Adapter Probe -</span>
<span class="cm"> *		The driver scans for supported EISA adapters by reading the</span>
<span class="cm"> *		SLOT ID register for each EISA slot and making a match</span>
<span class="cm"> *		against the expected value.</span>
<span class="cm"> *</span>
<span class="cm"> *   Bus-Specific Initialization -</span>
<span class="cm"> *		This driver currently supports both EISA and PCI controller</span>
<span class="cm"> *		families.  While the custom DMA chip and FDDI logic is similar</span>
<span class="cm"> *		or identical, the bus logic is very different.  After</span>
<span class="cm"> *		initialization, the	only bus-specific differences is in how the</span>
<span class="cm"> *		driver enables and disables interrupts.  Other than that, the</span>
<span class="cm"> *		run-time critical code behaves the same on both families.</span>
<span class="cm"> *		It&#39;s important to note that both adapter families are configured</span>
<span class="cm"> *		to I/O map, rather than memory map, the adapter registers.</span>
<span class="cm"> *</span>
<span class="cm"> *   Driver Open/Close -</span>
<span class="cm"> *		In the driver open routine, the driver ISR (interrupt service</span>
<span class="cm"> *		routine) is registered and the adapter is brought to an</span>
<span class="cm"> *		operational state.  In the driver close routine, the opposite</span>
<span class="cm"> *		occurs; the driver ISR is deregistered and the adapter is</span>
<span class="cm"> *		brought to a safe, but closed state.  Users may use consecutive</span>
<span class="cm"> *		commands to bring the adapter up and down as in the following</span>
<span class="cm"> *		example:</span>
<span class="cm"> *					ifconfig fddi0 up</span>
<span class="cm"> *					ifconfig fddi0 down</span>
<span class="cm"> *					ifconfig fddi0 up</span>
<span class="cm"> *</span>
<span class="cm"> *   Driver Shutdown -</span>
<span class="cm"> *		Apparently, there is no shutdown or halt routine support under</span>
<span class="cm"> *		Linux.  This routine would be called during &quot;reboot&quot; or</span>
<span class="cm"> *		&quot;shutdown&quot; to allow the driver to place the adapter in a safe</span>
<span class="cm"> *		state before a warm reboot occurs.  To be really safe, the user</span>
<span class="cm"> *		should close the adapter before shutdown (eg. ifconfig fddi0 down)</span>
<span class="cm"> *		to ensure that the adapter DMA engine is taken off-line.  However,</span>
<span class="cm"> *		the current driver code anticipates this problem and always issues</span>
<span class="cm"> *		a soft reset of the adapter	at the beginning of driver initialization.</span>
<span class="cm"> *		A future driver enhancement in this area may occur in 2.1.X where</span>
<span class="cm"> *		Alan indicated that a shutdown handler may be implemented.</span>
<span class="cm"> *</span>
<span class="cm"> *   Interrupt Service Routine -</span>
<span class="cm"> *		The driver supports shared interrupts, so the ISR is registered for</span>
<span class="cm"> *		each board with the appropriate flag and the pointer to that board&#39;s</span>
<span class="cm"> *		device structure.  This provides the context during interrupt</span>
<span class="cm"> *		processing to support shared interrupts and multiple boards.</span>
<span class="cm"> *</span>
<span class="cm"> *		Interrupt enabling/disabling can occur at many levels.  At the host</span>
<span class="cm"> *		end, you can disable system interrupts, or disable interrupts at the</span>
<span class="cm"> *		PIC (on Intel systems).  Across the bus, both EISA and PCI adapters</span>
<span class="cm"> *		have a bus-logic chip interrupt enable/disable as well as a DMA</span>
<span class="cm"> *		controller interrupt enable/disable.</span>
<span class="cm"> *</span>
<span class="cm"> *		The driver currently enables and disables adapter interrupts at the</span>
<span class="cm"> *		bus-logic chip and assumes that Linux will take care of clearing or</span>
<span class="cm"> *		acknowledging any host-based interrupt chips.</span>
<span class="cm"> *</span>
<span class="cm"> *   Control Functions -</span>
<span class="cm"> *		Control functions are those used to support functions such as adding</span>
<span class="cm"> *		or deleting multicast addresses, enabling or disabling packet</span>
<span class="cm"> *		reception filters, or other custom/proprietary commands.  Presently,</span>
<span class="cm"> *		the driver supports the &quot;get statistics&quot;, &quot;set multicast list&quot;, and</span>
<span class="cm"> *		&quot;set mac address&quot; functions defined by Linux.  A list of possible</span>
<span class="cm"> *		enhancements include:</span>
<span class="cm"> *</span>
<span class="cm"> *				- Custom ioctl interface for executing port interface commands</span>
<span class="cm"> *				- Custom ioctl interface for adding unicast addresses to</span>
<span class="cm"> *				  adapter CAM (to support bridge functions).</span>
<span class="cm"> *				- Custom ioctl interface for supporting firmware upgrades.</span>
<span class="cm"> *</span>
<span class="cm"> *   Hardware (port interface) Support Routines -</span>
<span class="cm"> *		The driver function names that start with &quot;dfx_hw_&quot; represent</span>
<span class="cm"> *		low-level port interface routines that are called frequently.  They</span>
<span class="cm"> *		include issuing a DMA or port control command to the adapter,</span>
<span class="cm"> *		resetting the adapter, or reading the adapter state.  Since the</span>
<span class="cm"> *		driver initialization and run-time code must make calls into the</span>
<span class="cm"> *		port interface, these routines were written to be as generic and</span>
<span class="cm"> *		usable as possible.</span>
<span class="cm"> *</span>
<span class="cm"> *   Receive Path -</span>
<span class="cm"> *		The adapter DMA engine supports a 256 entry receive descriptor block</span>
<span class="cm"> *		of which up to 255 entries can be used at any given time.  The</span>
<span class="cm"> *		architecture is a standard producer, consumer, completion model in</span>
<span class="cm"> *		which the driver &quot;produces&quot; receive buffers to the adapter, the</span>
<span class="cm"> *		adapter &quot;consumes&quot; the receive buffers by DMAing incoming packet data,</span>
<span class="cm"> *		and the driver &quot;completes&quot; the receive buffers by servicing the</span>
<span class="cm"> *		incoming packet, then &quot;produces&quot; a new buffer and starts the cycle</span>
<span class="cm"> *		again.  Receive buffers can be fragmented in up to 16 fragments</span>
<span class="cm"> *		(descriptor	entries).  For simplicity, this driver posts</span>
<span class="cm"> *		single-fragment receive buffers of 4608 bytes, then allocates a</span>
<span class="cm"> *		sk_buff, copies the data, then reposts the buffer.  To reduce CPU</span>
<span class="cm"> *		utilization, a better approach would be to pass up the receive</span>
<span class="cm"> *		buffer (no extra copy) then allocate and post a replacement buffer.</span>
<span class="cm"> *		This is a performance enhancement that should be looked into at</span>
<span class="cm"> *		some point.</span>
<span class="cm"> *</span>
<span class="cm"> *   Transmit Path -</span>
<span class="cm"> *		Like the receive path, the adapter DMA engine supports a 256 entry</span>
<span class="cm"> *		transmit descriptor block of which up to 255 entries can be used at</span>
<span class="cm"> *		any	given time.  Transmit buffers can be fragmented	in up to 255</span>
<span class="cm"> *		fragments (descriptor entries).  This driver always posts one</span>
<span class="cm"> *		fragment per transmit packet request.</span>
<span class="cm"> *</span>
<span class="cm"> *		The fragment contains the entire packet from FC to end of data.</span>
<span class="cm"> *		Before posting the buffer to the adapter, the driver sets a three-byte</span>
<span class="cm"> *		packet request header (PRH) which is required by the Motorola MAC chip</span>
<span class="cm"> *		used on the adapters.  The PRH tells the MAC the type of token to</span>
<span class="cm"> *		receive/send, whether or not to generate and append the CRC, whether</span>
<span class="cm"> *		synchronous or asynchronous framing is used, etc.  Since the PRH</span>
<span class="cm"> *		definition is not necessarily consistent across all FDDI chipsets,</span>
<span class="cm"> *		the driver, rather than the common FDDI packet handler routines,</span>
<span class="cm"> *		sets these bytes.</span>
<span class="cm"> *</span>
<span class="cm"> *		To reduce the amount of descriptor fetches needed per transmit request,</span>
<span class="cm"> *		the driver takes advantage of the fact that there are at least three</span>
<span class="cm"> *		bytes available before the skb-&gt;data field on the outgoing transmit</span>
<span class="cm"> *		request.  This is guaranteed by having fddi_setup() in net_init.c set</span>
<span class="cm"> *		dev-&gt;hard_header_len to 24 bytes.  21 bytes accounts for the largest</span>
<span class="cm"> *		header in an 802.2 SNAP frame.  The other 3 bytes are the extra &quot;pad&quot;</span>
<span class="cm"> *		bytes which we&#39;ll use to store the PRH.</span>
<span class="cm"> *</span>
<span class="cm"> *		There&#39;s a subtle advantage to adding these pad bytes to the</span>
<span class="cm"> *		hard_header_len, it ensures that the data portion of the packet for</span>
<span class="cm"> *		an 802.2 SNAP frame is longword aligned.  Other FDDI driver</span>
<span class="cm"> *		implementations may not need the extra padding and can start copying</span>
<span class="cm"> *		or DMAing directly from the FC byte which starts at skb-&gt;data.  Should</span>
<span class="cm"> *		another driver implementation need ADDITIONAL padding, the net_init.c</span>
<span class="cm"> *		module should be updated and dev-&gt;hard_header_len should be increased.</span>
<span class="cm"> *		NOTE: To maintain the alignment on the data portion of the packet,</span>
<span class="cm"> *		dev-&gt;hard_header_len should always be evenly divisible by 4 and at</span>
<span class="cm"> *		least 24 bytes in size.</span>
<span class="cm"> *</span>
<span class="cm"> * Modification History:</span>
<span class="cm"> *		Date		Name	Description</span>
<span class="cm"> *		16-Aug-96	LVS		Created.</span>
<span class="cm"> *		20-Aug-96	LVS		Updated dfx_probe so that version information</span>
<span class="cm"> *							string is only displayed if 1 or more cards are</span>
<span class="cm"> *							found.  Changed dfx_rcv_queue_process to copy</span>
<span class="cm"> *							3 NULL bytes before FC to ensure that data is</span>
<span class="cm"> *							longword aligned in receive buffer.</span>
<span class="cm"> *		09-Sep-96	LVS		Updated dfx_ctl_set_multicast_list to enable</span>
<span class="cm"> *							LLC group promiscuous mode if multicast list</span>
<span class="cm"> *							is too large.  LLC individual/group promiscuous</span>
<span class="cm"> *							mode is now disabled if IFF_PROMISC flag not set.</span>
<span class="cm"> *							dfx_xmt_queue_pkt no longer checks for NULL skb</span>
<span class="cm"> *							on Alan Cox recommendation.  Added node address</span>
<span class="cm"> *							override support.</span>
<span class="cm"> *		12-Sep-96	LVS		Reset current address to factory address during</span>
<span class="cm"> *							device open.  Updated transmit path to post a</span>
<span class="cm"> *							single fragment which includes PRH-&gt;end of data.</span>
<span class="cm"> *		Mar 2000	AC		Did various cleanups for 2.3.x</span>
<span class="cm"> *		Jun 2000	jgarzik		PCI and resource alloc cleanups</span>
<span class="cm"> *		Jul 2000	tjeerd		Much cleanup and some bug fixes</span>
<span class="cm"> *		Sep 2000	tjeerd		Fix leak on unload, cosmetic code cleanup</span>
<span class="cm"> *		Feb 2001			Skb allocation fixes</span>
<span class="cm"> *		Feb 2001	davej		PCI enable cleanups.</span>
<span class="cm"> *		04 Aug 2003	macro		Converted to the DMA API.</span>
<span class="cm"> *		14 Aug 2004	macro		Fix device names reported.</span>
<span class="cm"> *		14 Jun 2005	macro		Use irqreturn_t.</span>
<span class="cm"> *		23 Oct 2006	macro		Big-endian host support.</span>
<span class="cm"> *		14 Dec 2006	macro		TURBOchannel support.</span>
<span class="cm"> */</span>

<span class="cm">/* Include files */</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/eisa.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/fddidevice.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/tc.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#include &quot;defxx.h&quot;</span>

<span class="cm">/* Version information string should be updated prior to each new release!  */</span>
<span class="cp">#define DRV_NAME &quot;defxx&quot;</span>
<span class="cp">#define DRV_VERSION &quot;v1.10&quot;</span>
<span class="cp">#define DRV_RELDATE &quot;2006/12/14&quot;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span>
	<span class="n">DRV_NAME</span> <span class="s">&quot;: &quot;</span> <span class="n">DRV_VERSION</span> <span class="s">&quot; &quot;</span> <span class="n">DRV_RELDATE</span>
	<span class="s">&quot;  Lawrence V. Stefani and others</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#define DYNAMIC_BUFFERS 1</span>

<span class="cp">#define SKBUFF_RX_COPYBREAK 200</span>
<span class="cm">/*</span>
<span class="cm"> * NEW_SKB_SIZE = PI_RCV_DATA_K_SIZE_MAX+128 to allow 128 byte</span>
<span class="cm"> * alignment for compatibility with old EISA boards.</span>
<span class="cm"> */</span>
<span class="cp">#define NEW_SKB_SIZE (PI_RCV_DATA_K_SIZE_MAX+128)</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cp">#define DFX_BUS_PCI(dev) (dev-&gt;bus == &amp;pci_bus_type)</span>
<span class="cp">#else</span>
<span class="cp">#define DFX_BUS_PCI(dev) 0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_EISA</span>
<span class="cp">#define DFX_BUS_EISA(dev) (dev-&gt;bus == &amp;eisa_bus_type)</span>
<span class="cp">#else</span>
<span class="cp">#define DFX_BUS_EISA(dev) 0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_TC</span>
<span class="cp">#define DFX_BUS_TC(dev) (dev-&gt;bus == &amp;tc_bus_type)</span>
<span class="cp">#else</span>
<span class="cp">#define DFX_BUS_TC(dev) 0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_DEFXX_MMIO</span>
<span class="cp">#define DFX_MMIO 1</span>
<span class="cp">#else</span>
<span class="cp">#define DFX_MMIO 0</span>
<span class="cp">#endif</span>

<span class="cm">/* Define module-wide (static) routines */</span>

<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_bus_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_bus_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_bus_config_check</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_driver_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">print_name</span><span class="p">,</span>
					<span class="n">resource_size_t</span> <span class="n">bar_start</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_adap_init</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get_buffers</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_int_pr_halt_id</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_int_type_0_process</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_int_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>	<span class="n">dfx_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span>		<span class="n">net_device_stats</span> <span class="o">*</span><span class="n">dfx_ctl_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_ctl_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_ctl_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_ctl_update_cam</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_ctl_update_filters</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_hw_port_ctrl_req</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_UINT32</span>	<span class="n">command</span><span class="p">,</span> <span class="n">PI_UINT32</span> <span class="n">data_a</span><span class="p">,</span> <span class="n">PI_UINT32</span> <span class="n">data_b</span><span class="p">,</span> <span class="n">PI_UINT32</span> <span class="o">*</span><span class="n">host_data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_hw_adap_reset</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_UINT32</span> <span class="n">type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_hw_adap_state_rd</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_hw_dma_uninit</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_UINT32</span> <span class="n">type</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_rcv_init</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get_buffers</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_rcv_queue_process</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_rcv_flush</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">dfx_xmt_queue_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>		<span class="n">dfx_xmt_done</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>		<span class="n">dfx_xmt_flush</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>

<span class="cm">/* Define module-wide (static) variables */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">dfx_pci_driver</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">eisa_driver</span> <span class="n">dfx_eisa_driver</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tc_driver</span> <span class="n">dfx_tc_driver</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * =======================</span>
<span class="cm"> * = dfx_port_write_long =</span>
<span class="cm"> * = dfx_port_read_long  =</span>
<span class="cm"> * =======================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Routines for reading and writing values from/to adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp		- pointer to board information</span>
<span class="cm"> *   offset	- register offset from base I/O address</span>
<span class="cm"> *   data	- for dfx_port_write_long, this is a value to write;</span>
<span class="cm"> *		  for dfx_port_read_long, this is a pointer to store</span>
<span class="cm"> *		  the read value</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   These routines perform the correct operation to read or write</span>
<span class="cm"> *   the adapter register.</span>
<span class="cm"> *</span>
<span class="cm"> *   EISA port block base addresses are based on the slot number in which the</span>
<span class="cm"> *   controller is installed.  For example, if the EISA controller is installed</span>
<span class="cm"> *   in slot 4, the port block base address is 0x4000.  If the controller is</span>
<span class="cm"> *   installed in slot 2, the port block base address is 0x2000, and so on.</span>
<span class="cm"> *   This port block can be used to access PDQ, ESIC, and DEFEA on-board</span>
<span class="cm"> *   registers using the register offsets defined in DEFXX.H.</span>
<span class="cm"> *</span>
<span class="cm"> *   PCI port block base addresses are assigned by the PCI BIOS or system</span>
<span class="cm"> *   firmware.  There is one 128 byte port block which can be accessed.  It</span>
<span class="cm"> *   allows for I/O mapping of both PDQ and PFI registers using the register</span>
<span class="cm"> *   offsets defined in DEFXX.H.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   bp-&gt;base is a valid base I/O address for this adapter.</span>
<span class="cm"> *   offset is a valid register offset for this adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Rather than produce macros for these functions, these routines</span>
<span class="cm"> *   are defined using &quot;inline&quot; to ensure that the compiler will</span>
<span class="cm"> *   generate inline code and not waste a procedure call and return.</span>
<span class="cm"> *   This provides all the benefits of macros, but with the</span>
<span class="cm"> *   advantage of strict data type checking.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dfx_writel</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">mem</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">mb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dfx_outl</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">port</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_port_write_long</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">__maybe_unused</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfx_bus_tc</span> <span class="o">=</span> <span class="n">DFX_BUS_TC</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_use_mmio</span> <span class="o">=</span> <span class="n">DFX_MMIO</span> <span class="o">||</span> <span class="n">dfx_bus_tc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span>
		<span class="n">dfx_writel</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dfx_outl</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dfx_readl</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mb</span><span class="p">();</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">mem</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dfx_inl</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">inl</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">port</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_port_read_long</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">__maybe_unused</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfx_bus_tc</span> <span class="o">=</span> <span class="n">DFX_BUS_TC</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_use_mmio</span> <span class="o">=</span> <span class="n">DFX_MMIO</span> <span class="o">||</span> <span class="n">dfx_bus_tc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span>
		<span class="n">dfx_readl</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dfx_inl</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ================</span>
<span class="cm"> * = dfx_get_bars =</span>
<span class="cm"> * ================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Retrieves the address range used to access control and status</span>
<span class="cm"> *   registers.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bdev	- pointer to device information</span>
<span class="cm"> *   bar_start	- pointer to store the start address</span>
<span class="cm"> *   bar_len	- pointer to store the length of the area</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   I am sure there are some.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_get_bars</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			 <span class="n">resource_size_t</span> <span class="o">*</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">resource_size_t</span> <span class="o">*</span><span class="n">bar_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dfx_bus_pci</span> <span class="o">=</span> <span class="n">DFX_BUS_PCI</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_eisa</span> <span class="o">=</span> <span class="n">DFX_BUS_EISA</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_tc</span> <span class="o">=</span> <span class="n">DFX_BUS_TC</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_use_mmio</span> <span class="o">=</span> <span class="n">DFX_MMIO</span> <span class="o">||</span> <span class="n">dfx_bus_tc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">dfx_use_mmio</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

		<span class="o">*</span><span class="n">bar_start</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">),</span> <span class="n">num</span><span class="p">);</span>
		<span class="o">*</span><span class="n">bar_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">),</span> <span class="n">num</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_eisa</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_addr</span> <span class="o">=</span> <span class="n">to_eisa_device</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
		<span class="n">resource_size_t</span> <span class="n">bar</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bar</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_MEM_ADD_CMP_2</span><span class="p">);</span>
			<span class="n">bar</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">bar</span> <span class="o">|=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_MEM_ADD_CMP_1</span><span class="p">);</span>
			<span class="n">bar</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">bar</span> <span class="o">|=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_MEM_ADD_CMP_0</span><span class="p">);</span>
			<span class="n">bar</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="o">*</span><span class="n">bar_start</span> <span class="o">=</span> <span class="n">bar</span><span class="p">;</span>
			<span class="n">bar</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_MEM_ADD_MASK_2</span><span class="p">);</span>
			<span class="n">bar</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">bar</span> <span class="o">|=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_MEM_ADD_MASK_1</span><span class="p">);</span>
			<span class="n">bar</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">bar</span> <span class="o">|=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_MEM_ADD_MASK_0</span><span class="p">);</span>
			<span class="n">bar</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="o">*</span><span class="n">bar_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">bar</span> <span class="o">|</span> <span class="n">PI_MEM_ADD_MASK_M</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">bar_start</span> <span class="o">=</span> <span class="n">base_addr</span><span class="p">;</span>
			<span class="o">*</span><span class="n">bar_len</span> <span class="o">=</span> <span class="n">PI_ESIC_K_CSR_IO_LEN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_tc</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">bar_start</span> <span class="o">=</span> <span class="n">to_tc_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">.</span><span class="n">start</span> <span class="o">+</span>
			     <span class="n">PI_TC_K_CSR_OFFSET</span><span class="p">;</span>
		<span class="o">*</span><span class="n">bar_len</span> <span class="o">=</span> <span class="n">PI_TC_K_CSR_LEN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">dfx_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">dfx_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">dfx_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">dfx_xmt_queue_pkt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">dfx_ctl_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">dfx_ctl_set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">dfx_ctl_set_mac_address</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * ================</span>
<span class="cm"> * = dfx_register =</span>
<span class="cm"> * ================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Initializes a supported FDDI controller</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bdev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   0		 - This device (fddi0, fddi1, etc) configured successfully</span>
<span class="cm"> *   -EBUSY      - Failed to get resources, or dfx_driver_init failed.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   It compiles so it should work :-( (PCI cards do :-)</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Device structures for FDDI adapters (fddi0, fddi1, etc) are</span>
<span class="cm"> *   initialized and the board resources are read and stored in</span>
<span class="cm"> *   the device structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">dfx_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">version_disp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfx_bus_pci</span> <span class="o">=</span> <span class="n">DFX_BUS_PCI</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_tc</span> <span class="o">=</span> <span class="n">DFX_BUS_TC</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_use_mmio</span> <span class="o">=</span> <span class="n">DFX_MMIO</span> <span class="o">||</span> <span class="n">dfx_bus_tc</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">print_name</span> <span class="o">=</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">DFX_board_t</span>	  <span class="o">*</span><span class="n">bp</span><span class="p">;</span>			<span class="cm">/* board pointer */</span>
	<span class="n">resource_size_t</span> <span class="n">bar_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* pointer to port */</span>
	<span class="n">resource_size_t</span> <span class="n">bar_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* resource length */</span>
	<span class="kt">int</span> <span class="n">alloc_size</span><span class="p">;</span>				<span class="cm">/* total buffer size used */</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">region</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">version_disp</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* display version info if adapter is found */</span>
		<span class="n">version_disp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* set display flag to TRUE so that */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>	<span class="cm">/* we only display this string ONCE */</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_fddidev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Unable to allocate fddidev, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">print_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable PCI device. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span> <span class="o">&amp;&amp;</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Cannot enable PCI device, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">print_name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">bdev</span><span class="p">);</span>

	<span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">dfx_get_bars</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bar_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bar_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span>
		<span class="n">region</span> <span class="o">=</span> <span class="n">request_mem_region</span><span class="p">(</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">bar_len</span><span class="p">,</span> <span class="n">print_name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">region</span> <span class="o">=</span> <span class="n">request_region</span><span class="p">(</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">bar_len</span><span class="p">,</span> <span class="n">print_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">region</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Cannot reserve I/O resource &quot;</span>
		       <span class="s">&quot;0x%lx @ 0x%lx, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">print_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bar_len</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bar_start</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_disable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set up I/O base address. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">mem</span> <span class="o">=</span> <span class="n">ioremap_nocache</span><span class="p">(</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">bar_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Cannot map MMIO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">print_name</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out_region</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">bar_start</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">bar_start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize new device structure */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">dfx_netdev_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span><span class="p">)</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_driver_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">print_name</span><span class="p">,</span> <span class="n">bar_start</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_unmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out_kfree</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: registered as %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">print_name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_kfree:</span>
	<span class="n">alloc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_DESCR_BLOCK</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">PI_CMD_REQ_K_SIZE_MAX</span> <span class="o">+</span> <span class="n">PI_CMD_RSP_K_SIZE_MAX</span> <span class="o">+</span>
<span class="cp">#ifndef DYNAMIC_BUFFERS</span>
		     <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span> <span class="o">*</span> <span class="n">PI_RCV_DATA_K_SIZE_MAX</span><span class="p">)</span> <span class="o">+</span>
<span class="cp">#endif</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_CONSUMER_BLOCK</span><span class="p">)</span> <span class="o">+</span>
		     <span class="p">(</span><span class="n">PI_ALIGN_K_DESC_BLK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">,</span>
				  <span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced_dma</span><span class="p">);</span>

<span class="nl">err_out_unmap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">mem</span><span class="p">);</span>

<span class="nl">err_out_region:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">bar_len</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">bar_len</span><span class="p">);</span>

<span class="nl">err_out_disable:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span><span class="p">)</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>

<span class="nl">err_out:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ================</span>
<span class="cm"> * = dfx_bus_init =</span>
<span class="cm"> * ================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Initializes the bus-specific controller logic.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Determine and save adapter IRQ in device table,</span>
<span class="cm"> *   then perform bus-specific logic initialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   bp-&gt;base has already been set with the proper</span>
<span class="cm"> *	 base I/O address for this device.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Interrupts are enabled at the adapter bus-specific logic.</span>
<span class="cm"> *   Note:  Interrupts at the DMA engine (PDQ chip) are not</span>
<span class="cm"> *   enabled yet.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">dfx_bus_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfx_bus_pci</span> <span class="o">=</span> <span class="n">DFX_BUS_PCI</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_eisa</span> <span class="o">=</span> <span class="n">DFX_BUS_EISA</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_tc</span> <span class="o">=</span> <span class="n">DFX_BUS_TC</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_use_mmio</span> <span class="o">=</span> <span class="n">DFX_MMIO</span> <span class="o">||</span> <span class="n">dfx_bus_tc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;In dfx_bus_init...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Initialize a pointer back to the net_device struct */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Initialize adapter based on bus type */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_tc</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">to_tc_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_eisa</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_addr</span> <span class="o">=</span> <span class="n">to_eisa_device</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

		<span class="cm">/* Get the interrupt level from the ESIC chip.  */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="n">PI_CONFIG_STAT_0_M_IRQ</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">&gt;&gt;=</span> <span class="n">PI_CONFIG_STAT_0_V_IRQ</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">PI_CONFIG_STAT_0_IRQ_K_9</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_CONFIG_STAT_0_IRQ_K_10</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_CONFIG_STAT_0_IRQ_K_11</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_CONFIG_STAT_0_IRQ_K_15</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Enable memory decoding (MEMCS0) and/or port decoding</span>
<span class="cm">		 * (IOCS1/IOCS0) as appropriate in Function Control</span>
<span class="cm">		 * Register.  One of the port chip selects seems to be</span>
<span class="cm">		 * used for the Burst Holdoff register, but this bit of</span>
<span class="cm">		 * documentation is missing and as yet it has not been</span>
<span class="cm">		 * determined which of the two.  This is also the reason</span>
<span class="cm">		 * the size of the decoded port range is twice as large</span>
<span class="cm">		 * as one required by the PDQ.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Set the decode range of the board.  */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">port</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PI_IO_CMP_V_SLOT</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_ADD_CMP_0_1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_ADD_CMP_0_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_ADD_CMP_1_1</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_ADD_CMP_1_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">PI_ESIC_K_CSR_IO_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_ADD_MASK_0_1</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_ADD_MASK_0_0</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_ADD_MASK_1_1</span><span class="p">,</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_ADD_MASK_1_0</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

		<span class="cm">/* Enable the decoders.  */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">PI_FUNCTION_CNTRL_M_IOCS1</span> <span class="o">|</span> <span class="n">PI_FUNCTION_CNTRL_M_IOCS0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">PI_FUNCTION_CNTRL_M_MEMCS0</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_FUNCTION_CNTRL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Enable access to the rest of the module</span>
<span class="cm">		 * (including PDQ and packet memory).</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">PI_SLOT_CNTRL_M_ENB</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_SLOT_CNTRL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Map PDQ registers into memory or port space.  This is</span>
<span class="cm">		 * done with a bit in the Burst Holdoff register.</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_DEFEA_K_BURST_HOLDOFF</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">PI_BURST_HOLDOFF_V_MEM_MAP</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PI_BURST_HOLDOFF_V_MEM_MAP</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_DEFEA_K_BURST_HOLDOFF</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="cm">/* Enable interrupts at EISA bus interface chip (ESIC) */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">PI_CONFIG_STAT_0_M_INT_ENB</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

		<span class="cm">/* Get the interrupt level from the PCI Configuration Table */</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

		<span class="cm">/* Check Latency Timer and set if less than minimal */</span>

		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">PFI_K_LAT_TIMER_MIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">PFI_K_LAT_TIMER_DEF</span><span class="p">;</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Enable interrupts at PCI bus interface chip (PFI) */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">PFI_MODE_M_PDQ_INT_ENB</span> <span class="o">|</span> <span class="n">PFI_MODE_M_DMA_ENB</span><span class="p">;</span>
		<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PFI_K_REG_MODE_CTRL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ==================</span>
<span class="cm"> * = dfx_bus_uninit =</span>
<span class="cm"> * ==================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Uninitializes the bus-specific controller logic.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Perform bus-specific logic uninitialization.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   bp-&gt;base has already been set with the proper</span>
<span class="cm"> *	 base I/O address for this device.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Interrupts are disabled at the adapter bus-specific logic.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">dfx_bus_uninit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfx_bus_pci</span> <span class="o">=</span> <span class="n">DFX_BUS_PCI</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_eisa</span> <span class="o">=</span> <span class="n">DFX_BUS_EISA</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;In dfx_bus_uninit...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Uninitialize adapter based on bus type */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_eisa</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_addr</span> <span class="o">=</span> <span class="n">to_eisa_device</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

		<span class="cm">/* Disable interrupts at EISA bus interface chip (ESIC) */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PI_CONFIG_STAT_0_M_INT_ENB</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Disable interrupts at PCI bus interface chip (PFI) */</span>
		<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PFI_K_REG_MODE_CTRL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ========================</span>
<span class="cm"> * = dfx_bus_config_check =</span>
<span class="cm"> * ========================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Checks the configuration (burst size, full-duplex, etc.)  If any parameters</span>
<span class="cm"> *   are illegal, then this routine will set new defaults.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   For Revision 1 FDDI EISA, Revision 2 or later FDDI EISA with rev E or later</span>
<span class="cm"> *   PDQ, and all FDDI PCI controllers, all values are legal.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   dfx_adap_init has NOT been called yet so burst size and other items have</span>
<span class="cm"> *   not been set.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">dfx_bus_config_check</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="n">__maybe_unused</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfx_bus_eisa</span> <span class="o">=</span> <span class="n">DFX_BUS_EISA</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>				<span class="cm">/* return code from adapter port control call */</span>
	<span class="n">u32</span>	<span class="n">host_data</span><span class="p">;</span>			<span class="cm">/* LW data returned from port control call */</span>

	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;In dfx_bus_config_check...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Configuration check only valid for EISA adapter */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_eisa</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First check if revision 2 EISA controller.  Rev. 1 cards used</span>
<span class="cm">		 * PDQ revision B, so no workaround needed in this case.  Rev. 3</span>
<span class="cm">		 * cards used PDQ revision E, so no workaround needed in this</span>
<span class="cm">		 * case, either.  Only Rev. 2 cards used either Rev. D or E</span>
<span class="cm">		 * chips, so we must verify the chip revision on Rev. 2 cards.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">to_eisa_device</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">driver_data</span> <span class="o">==</span> <span class="n">DEFEA_PROD_ID_2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Revision 2 FDDI EISA controller found,</span>
<span class="cm">			 * so let&#39;s check PDQ revision of adapter.</span>
<span class="cm">			 */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">dfx_hw_port_ctrl_req</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
											<span class="n">PI_PCTRL_M_SUB_CMD</span><span class="p">,</span>
											<span class="n">PI_SUB_CMD_K_PDQ_REV_GET</span><span class="p">,</span>
											<span class="mi">0</span><span class="p">,</span>
											<span class="o">&amp;</span><span class="n">host_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">host_data</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>
				<span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Either we couldn&#39;t determine the PDQ revision, or</span>
<span class="cm">				 * we determined that it is at revision D.  In either case,</span>
<span class="cm">				 * we need to implement the workaround.</span>
<span class="cm">				 */</span>

				<span class="cm">/* Ensure that the burst size is set to 8 longwords or less */</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">burst_size</span><span class="p">)</span>
					<span class="p">{</span>
					<span class="k">case</span> <span class="n">PI_PDATA_B_DMA_BURST_SIZE_32</span>:
					<span class="k">case</span> <span class="n">PI_PDATA_B_DMA_BURST_SIZE_16</span>:
						<span class="n">bp</span><span class="o">-&gt;</span><span class="n">burst_size</span> <span class="o">=</span> <span class="n">PI_PDATA_B_DMA_BURST_SIZE_8</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>

					<span class="nl">default:</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>

				<span class="cm">/* Ensure that full-duplex mode is not enabled */</span>

				<span class="n">bp</span><span class="o">-&gt;</span><span class="n">full_duplex_enb</span> <span class="o">=</span> <span class="n">PI_SNMP_K_FALSE</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ===================</span>
<span class="cm"> * = dfx_driver_init =</span>
<span class="cm"> * ===================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Initializes remaining adapter board structure information</span>
<span class="cm"> *   and makes sure adapter is in a safe state prior to dfx_open().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *   print_name - printable device name</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This function allocates additional resources such as the host memory</span>
<span class="cm"> *   blocks needed by the adapter (eg. descriptor and consumer blocks).</span>
<span class="cm"> *	 Remaining bus initialization steps are also completed.  The adapter</span>
<span class="cm"> *   is also reset so that it is in the DMA_UNAVAILABLE state.  The OS</span>
<span class="cm"> *   must call dfx_open() to open the adapter and bring it on-line.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   DFX_K_SUCCESS	- initialization succeeded</span>
<span class="cm"> *   DFX_K_FAILURE	- initialization failed - could not allocate memory</span>
<span class="cm"> *						or read adapter MAC address</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   Memory allocated from pci_alloc_consistent() call is physically</span>
<span class="cm"> *   contiguous, locked memory.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Adapter is reset and should be in DMA_UNAVAILABLE state before</span>
<span class="cm"> *   returning from this routine.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">dfx_driver_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">print_name</span><span class="p">,</span>
				     <span class="n">resource_size_t</span> <span class="n">bar_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfx_bus_pci</span> <span class="o">=</span> <span class="n">DFX_BUS_PCI</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_eisa</span> <span class="o">=</span> <span class="n">DFX_BUS_EISA</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_tc</span> <span class="o">=</span> <span class="n">DFX_BUS_TC</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_use_mmio</span> <span class="o">=</span> <span class="n">DFX_MMIO</span> <span class="o">||</span> <span class="n">dfx_bus_tc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc_size</span><span class="p">;</span>			<span class="cm">/* total buffer size needed */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">top_v</span><span class="p">,</span> <span class="o">*</span><span class="n">curr_v</span><span class="p">;</span>		<span class="cm">/* virtual addrs into memory block */</span>
	<span class="n">dma_addr_t</span> <span class="n">top_p</span><span class="p">,</span> <span class="n">curr_p</span><span class="p">;</span>	<span class="cm">/* physical addrs into memory block */</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>			<span class="cm">/* host data register value */</span>
	<span class="n">__le32</span> <span class="n">le32</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">board_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;In dfx_driver_init...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Initialize bus-specific hardware registers */</span>

	<span class="n">dfx_bus_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize default values for configurable parameters</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: All of these parameters are ones that a user may</span>
<span class="cm">	 *       want to customize.  It&#39;d be nice to break these</span>
<span class="cm">	 *		 out into Space.c or someplace else that&#39;s more</span>
<span class="cm">	 *		 accessible/understandable than this file.</span>
<span class="cm">	 */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">full_duplex_enb</span>		<span class="o">=</span> <span class="n">PI_SNMP_K_FALSE</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">req_ttrt</span>			<span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">12500</span><span class="p">;</span>		<span class="cm">/* 8ms in 80 nanosec units */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">burst_size</span>			<span class="o">=</span> <span class="n">PI_PDATA_B_DMA_BURST_SIZE_DEF</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span>	<span class="o">=</span> <span class="n">RCV_BUFS_DEF</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that HW configuration is OK</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Depending on the hardware revision, we may need to modify</span>
<span class="cm">	 *       some of the configurable parameters to workaround hardware</span>
<span class="cm">	 *       limitations.  We&#39;ll perform this configuration check AFTER</span>
<span class="cm">	 *       setting the parameters to their default values.</span>
<span class="cm">	 */</span>

	<span class="n">dfx_bus_config_check</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Disable PDQ interrupts first */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_HOST_INT_ENB</span><span class="p">,</span> <span class="n">PI_HOST_INT_K_DISABLE_ALL_INTS</span><span class="p">);</span>

	<span class="cm">/* Place adapter in DMA_UNAVAILABLE state by resetting adapter */</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">dfx_hw_dma_uninit</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDATA_A_RESET_M_SKIP_ST</span><span class="p">);</span>

	<span class="cm">/*  Read the factory MAC address from the adapter then save it */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_port_ctrl_req</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PCTRL_M_MLA</span><span class="p">,</span> <span class="n">PI_PDATA_A_MLA_K_LO</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Could not read adapter factory MAC address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">print_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">le32</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">factory_mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">le32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_port_ctrl_req</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PCTRL_M_MLA</span><span class="p">,</span> <span class="n">PI_PDATA_A_MLA_K_HI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Could not read adapter factory MAC address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">print_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">le32</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">factory_mac_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">le32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set current address to factory address</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Node address override support is handled through</span>
<span class="cm">	 *       dfx_ctl_set_mac_address.</span>
<span class="cm">	 */</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">factory_mac_addr</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_tc</span><span class="p">)</span>
		<span class="n">board_name</span> <span class="o">=</span> <span class="s">&quot;DEFTA&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_eisa</span><span class="p">)</span>
		<span class="n">board_name</span> <span class="o">=</span> <span class="s">&quot;DEFEA&quot;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span><span class="p">)</span>
		<span class="n">board_name</span> <span class="o">=</span> <span class="s">&quot;DEFPA&quot;</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: %s at %saddr = 0x%llx, IRQ = %d, Hardware addr = %pMF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">print_name</span><span class="p">,</span> <span class="n">board_name</span><span class="p">,</span> <span class="n">dfx_use_mmio</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;I/O &quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get memory for descriptor block, consumer block, and other buffers</span>
<span class="cm">	 * that need to be DMA read or written to by the adapter.</span>
<span class="cm">	 */</span>

	<span class="n">alloc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_DESCR_BLOCK</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">PI_CMD_REQ_K_SIZE_MAX</span> <span class="o">+</span>
					<span class="n">PI_CMD_RSP_K_SIZE_MAX</span> <span class="o">+</span>
<span class="cp">#ifndef DYNAMIC_BUFFERS</span>
					<span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span> <span class="o">*</span> <span class="n">PI_RCV_DATA_K_SIZE_MAX</span><span class="p">)</span> <span class="o">+</span>
<span class="cp">#endif</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">PI_CONSUMER_BLOCK</span><span class="p">)</span> <span class="o">+</span>
					<span class="p">(</span><span class="n">PI_ALIGN_K_DESC_BLK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced</span> <span class="o">=</span> <span class="n">top_v</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced_dma</span><span class="p">,</span>
						   <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">top_v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Could not allocate memory for host buffers &quot;</span>
		       <span class="s">&quot;and structures!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">print_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">top_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">);</span>	<span class="cm">/* zero out memory before continuing */</span>
	<span class="n">top_p</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced_dma</span><span class="p">;</span>	<span class="cm">/* get physical address of buffer */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  To guarantee the 8K alignment required for the descriptor block, 8K - 1</span>
<span class="cm">	 *  plus the amount of memory needed was allocated.  The physical address</span>
<span class="cm">	 *	is now 8K aligned.  By carving up the memory in a specific order,</span>
<span class="cm">	 *  we&#39;ll guarantee the alignment requirements for all other structures.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Note: If the assumptions change regarding the non-paged, non-cached,</span>
<span class="cm">	 *		  physically contiguous nature of the memory block or the address</span>
<span class="cm">	 *		  alignments, then we&#39;ll need to implement a different algorithm</span>
<span class="cm">	 *		  for allocating the needed memory.</span>
<span class="cm">	 */</span>

	<span class="n">curr_p</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">top_p</span><span class="p">,</span> <span class="n">PI_ALIGN_K_DESC_BLK</span><span class="p">);</span>
	<span class="n">curr_v</span> <span class="o">=</span> <span class="n">top_v</span> <span class="o">+</span> <span class="p">(</span><span class="n">curr_p</span> <span class="o">-</span> <span class="n">top_p</span><span class="p">);</span>

	<span class="cm">/* Reserve space for descriptor block */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span> <span class="o">=</span> <span class="p">(</span><span class="n">PI_DESCR_BLOCK</span> <span class="o">*</span><span class="p">)</span> <span class="n">curr_v</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_phys</span> <span class="o">=</span> <span class="n">curr_p</span><span class="p">;</span>
	<span class="n">curr_v</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_DESCR_BLOCK</span><span class="p">);</span>
	<span class="n">curr_p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_DESCR_BLOCK</span><span class="p">);</span>

	<span class="cm">/* Reserve space for command request buffer */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span> <span class="o">=</span> <span class="p">(</span><span class="n">PI_DMA_CMD_REQ</span> <span class="o">*</span><span class="p">)</span> <span class="n">curr_v</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_phys</span> <span class="o">=</span> <span class="n">curr_p</span><span class="p">;</span>
	<span class="n">curr_v</span> <span class="o">+=</span> <span class="n">PI_CMD_REQ_K_SIZE_MAX</span><span class="p">;</span>
	<span class="n">curr_p</span> <span class="o">+=</span> <span class="n">PI_CMD_REQ_K_SIZE_MAX</span><span class="p">;</span>

	<span class="cm">/* Reserve space for command response buffer */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span> <span class="o">=</span> <span class="p">(</span><span class="n">PI_DMA_CMD_RSP</span> <span class="o">*</span><span class="p">)</span> <span class="n">curr_v</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_phys</span> <span class="o">=</span> <span class="n">curr_p</span><span class="p">;</span>
	<span class="n">curr_v</span> <span class="o">+=</span> <span class="n">PI_CMD_RSP_K_SIZE_MAX</span><span class="p">;</span>
	<span class="n">curr_p</span> <span class="o">+=</span> <span class="n">PI_CMD_RSP_K_SIZE_MAX</span><span class="p">;</span>

	<span class="cm">/* Reserve space for the LLC host receive queue buffers */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_block_virt</span> <span class="o">=</span> <span class="n">curr_v</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_block_phys</span> <span class="o">=</span> <span class="n">curr_p</span><span class="p">;</span>

<span class="cp">#ifndef DYNAMIC_BUFFERS</span>
	<span class="n">curr_v</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span> <span class="o">*</span> <span class="n">PI_RCV_DATA_K_SIZE_MAX</span><span class="p">);</span>
	<span class="n">curr_p</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span> <span class="o">*</span> <span class="n">PI_RCV_DATA_K_SIZE_MAX</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Reserve space for the consumer block */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span> <span class="o">=</span> <span class="p">(</span><span class="n">PI_CONSUMER_BLOCK</span> <span class="o">*</span><span class="p">)</span> <span class="n">curr_v</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_phys</span> <span class="o">=</span> <span class="n">curr_p</span><span class="p">;</span>

	<span class="cm">/* Display virtual and physical addresses if debug driver */</span>

	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Descriptor block virt = %0lX, phys = %0X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">print_name</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_phys</span><span class="p">);</span>
	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Command Request buffer virt = %0lX, phys = %0X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">print_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_phys</span><span class="p">);</span>
	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Command Response buffer virt = %0lX, phys = %0X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">print_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_phys</span><span class="p">);</span>
	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Receive buffer block virt = %0lX, phys = %0X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">print_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_block_virt</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_block_phys</span><span class="p">);</span>
	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Consumer block virt = %0lX, phys = %0X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">print_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_phys</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">DFX_K_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =================</span>
<span class="cm"> * = dfx_adap_init =</span>
<span class="cm"> * =================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Brings the adapter to the link avail/link unavailable state.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *   get_buffers - non-zero if buffers to be allocated</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Issues the low-level firmware/hardware calls necessary to bring</span>
<span class="cm"> *   the adapter up, or to properly reset and restore adapter during</span>
<span class="cm"> *   run-time.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   DFX_K_SUCCESS - Adapter brought up successfully</span>
<span class="cm"> *   DFX_K_FAILURE - Adapter initialization failed</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   bp-&gt;reset_type should be set to a valid reset type value before</span>
<span class="cm"> *   calling this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Adapter should be in LINK_AVAILABLE or LINK_UNAVAILABLE state</span>
<span class="cm"> *   upon a successful return of this routine.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_adap_init</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get_buffers</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;In dfx_adap_init...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Disable PDQ interrupts first */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_HOST_INT_ENB</span><span class="p">,</span> <span class="n">PI_HOST_INT_K_DISABLE_ALL_INTS</span><span class="p">);</span>

	<span class="cm">/* Place adapter in DMA_UNAVAILABLE state by resetting adapter */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_dma_uninit</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">reset_type</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Could not uninitialize/reset adapter!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When the PDQ is reset, some false Type 0 interrupts may be pending,</span>
<span class="cm">	 * so we&#39;ll acknowledge all Type 0 interrupts now before continuing.</span>
<span class="cm">	 */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_TYPE_0_STATUS</span><span class="p">,</span> <span class="n">PI_HOST_INT_K_ACK_ALL_TYPE_0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear Type 1 and Type 2 registers before going to DMA_AVAILABLE state</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We only need to clear host copies of these registers.  The PDQ reset</span>
<span class="cm">	 *       takes care of the on-board register values.</span>
<span class="cm">	 */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">lword</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">lword</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">lword</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear consumer block before going to DMA_AVAILABLE state */</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_CONSUMER_BLOCK</span><span class="p">));</span>

	<span class="cm">/* Initialize the DMA Burst Size */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_port_ctrl_req</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
							<span class="n">PI_PCTRL_M_SUB_CMD</span><span class="p">,</span>
							<span class="n">PI_SUB_CMD_K_BURST_SIZE_SET</span><span class="p">,</span>
							<span class="n">bp</span><span class="o">-&gt;</span><span class="n">burst_size</span><span class="p">,</span>
							<span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Could not set adapter burst size!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set base address of Consumer Block</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assumption: 32-bit physical address of consumer block is 64 byte</span>
<span class="cm">	 *			   aligned.  That is, bits 0-5 of the address must be zero.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_port_ctrl_req</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
							<span class="n">PI_PCTRL_M_CONS_BLOCK</span><span class="p">,</span>
							<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_phys</span><span class="p">,</span>
							<span class="mi">0</span><span class="p">,</span>
							<span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Could not set consumer block address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the base address of Descriptor Block and bring adapter</span>
<span class="cm">	 * to DMA_AVAILABLE state.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We also set the literal and data swapping requirements</span>
<span class="cm">	 *       in this command.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assumption: 32-bit physical address of descriptor block</span>
<span class="cm">	 *       is 8Kbyte aligned.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_port_ctrl_req</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PCTRL_M_INIT</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_phys</span> <span class="o">|</span>
				       <span class="n">PI_PDATA_A_INIT_M_BSWAP_INIT</span><span class="p">),</span>
				 <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Could not set descriptor block address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set transmit flush timeout value */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">PI_CMD_K_CHARS_SET</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">char_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_FLUSH_TIME</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">char_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span>		<span class="o">=</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* 3 seconds */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">char_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">item_index</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">char_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_EOL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: DMA command request failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Set the initial values for eFDXEnable and MACTReq MIB objects */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">PI_CMD_K_SNMP_SET</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">snmp_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_FDX_ENB_DIS</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">snmp_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">full_duplex_enb</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">snmp_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">item_index</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">snmp_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_MAC_T_REQ</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">snmp_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">req_ttrt</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">snmp_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">item_index</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">snmp_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_EOL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: DMA command request failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Initialize adapter CAM */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_ctl_update_cam</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter CAM update failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Initialize adapter filters */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_ctl_update_filters</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter filters update failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove any existing dynamic buffers (i.e. if the adapter is being</span>
<span class="cm">	 * reinitialized)</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_buffers</span><span class="p">)</span>
		<span class="n">dfx_rcv_flush</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Initialize receive descriptor block and produce buffers */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_rcv_init</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">get_buffers</span><span class="p">))</span>
	        <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Receive buffer allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_buffers</span><span class="p">)</span>
			<span class="n">dfx_rcv_flush</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Issue START command and bring adapter to LINK_(UN)AVAILABLE state */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">PI_CMD_K_START</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Start command failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_buffers</span><span class="p">)</span>
			<span class="n">dfx_rcv_flush</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Initialization succeeded, reenable PDQ interrupts */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_HOST_INT_ENB</span><span class="p">,</span> <span class="n">PI_HOST_INT_K_ENABLE_DEF_INTS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">DFX_K_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ============</span>
<span class="cm"> * = dfx_open =</span>
<span class="cm"> * ============</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Opens the adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This function brings the adapter to an operational state.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   0		 - Adapter was successfully opened</span>
<span class="cm"> *   -EAGAIN - Could not register IRQ or adapter initialization failed</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   This routine should only be called for a device that was</span>
<span class="cm"> *   initialized successfully.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Adapter should be in LINK_AVAILABLE or LINK_UNAVAILABLE state</span>
<span class="cm"> *   if the open is successful.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;In dfx_open...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Register IRQ - support shared interrupts by passing device ptr */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dfx_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			  <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Requested IRQ %d is busy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set current address to factory MAC address</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We&#39;ve already done this step in dfx_driver_init.</span>
<span class="cm">	 *       However, it&#39;s possible that a user has set a node</span>
<span class="cm">	 *		 address override, then closed and reopened the</span>
<span class="cm">	 *		 adapter.  Unless we reset the device address field</span>
<span class="cm">	 *		 now, we&#39;ll continue to use the existing modified</span>
<span class="cm">	 *		 address.</span>
<span class="cm">	 */</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">factory_mac_addr</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>

	<span class="cm">/* Clear local unicast/multicast address tables and counts */</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_table</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_table</span><span class="p">));</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Disable promiscuous filter settings */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">ind_group_prom</span>	<span class="o">=</span> <span class="n">PI_FSTATE_K_BLOCK</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">group_prom</span>		<span class="o">=</span> <span class="n">PI_FSTATE_K_BLOCK</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Reset and initialize adapter */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">reset_type</span> <span class="o">=</span> <span class="n">PI_PDATA_A_RESET_M_SKIP_ST</span><span class="p">;</span>	<span class="cm">/* skip self-test */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_adap_init</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Adapter open failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set device structure info */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =============</span>
<span class="cm"> * = dfx_close =</span>
<span class="cm"> * =============</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Closes the device/module.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This routine closes the adapter and brings it to a safe state.</span>
<span class="cm"> *   The interrupt service routine is deregistered with the OS.</span>
<span class="cm"> *   The adapter can be opened again with another call to dfx_open().</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   Always return 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   No further requests for this adapter are made after this routine is</span>
<span class="cm"> *   called.  dfx_open() can be called to reset and reinitialize the</span>
<span class="cm"> *   adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Adapter should be in DMA_UNAVAILABLE state upon completion of this</span>
<span class="cm"> *   routine.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;In dfx_close...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Disable PDQ interrupts first */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_HOST_INT_ENB</span><span class="p">,</span> <span class="n">PI_HOST_INT_K_DISABLE_ALL_INTS</span><span class="p">);</span>

	<span class="cm">/* Place adapter in DMA_UNAVAILABLE state by resetting adapter */</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">dfx_hw_dma_uninit</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDATA_A_RESET_M_SKIP_ST</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Flush any pending transmit buffers</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: It&#39;s important that we flush the transmit buffers</span>
<span class="cm">	 *		 BEFORE we clear our copy of the Type 2 register.</span>
<span class="cm">	 *		 Otherwise, we&#39;ll have no idea how many buffers</span>
<span class="cm">	 *		 we need to free.</span>
<span class="cm">	 */</span>

	<span class="n">dfx_xmt_flush</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear Type 1 and Type 2 registers after adapter reset</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Even though we&#39;re closing the adapter, it&#39;s</span>
<span class="cm">	 *       possible that an interrupt will occur after</span>
<span class="cm">	 *		 dfx_close is called.  Without some assurance to</span>
<span class="cm">	 *		 the contrary we want to make sure that we don&#39;t</span>
<span class="cm">	 *		 process receive and transmit LLC frames and update</span>
<span class="cm">	 *		 the Type 2 register with bad information.</span>
<span class="cm">	 */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">lword</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">lword</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">lword</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear consumer block for the same reason given above */</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_CONSUMER_BLOCK</span><span class="p">));</span>

	<span class="cm">/* Release all dynamically allocate skb in the receive ring. */</span>

	<span class="n">dfx_rcv_flush</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

	<span class="cm">/* Clear device structure flags */</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Deregister (free) IRQ */</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ======================</span>
<span class="cm"> * = dfx_int_pr_halt_id =</span>
<span class="cm"> * ======================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Displays halt id&#39;s in string form.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Determine current halt id and display appropriate string.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_int_pr_halt_id</span><span class="p">(</span><span class="n">DFX_board_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="n">PI_UINT32</span>	<span class="n">port_status</span><span class="p">;</span>			<span class="cm">/* PDQ port status register value */</span>
	<span class="n">PI_UINT32</span>	<span class="n">halt_id</span><span class="p">;</span>				<span class="cm">/* PDQ port status halt ID */</span>

	<span class="cm">/* Read the latest port status */</span>

	<span class="n">dfx_port_read_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_status</span><span class="p">);</span>

	<span class="cm">/* Display halt state transition information */</span>

	<span class="n">halt_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">PI_PSTATUS_M_HALT_ID</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PI_PSTATUS_V_HALT_ID</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">halt_id</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">case</span> <span class="n">PI_HALT_ID_K_SELFTEST_TIMEOUT</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: Selftest Timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_HALT_ID_K_PARITY_ERROR</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: Host Bus Parity Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_HALT_ID_K_HOST_DIR_HALT</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: Host-Directed Halt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_HALT_ID_K_SW_FAULT</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: Adapter Software Fault</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_HALT_ID_K_HW_FAULT</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: Adapter Hardware Fault</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_HALT_ID_K_PC_TRACE</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: FDDI Network PC Trace Path Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_HALT_ID_K_DMA_ERROR</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: Adapter DMA Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_HALT_ID_K_IMAGE_CRC_ERROR</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: Firmware Image CRC Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PI_HALT_ID_K_BUS_EXCEPTION</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: 68000 Bus Exception</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Halt ID: Unknown (code = %X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">halt_id</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ==========================</span>
<span class="cm"> * = dfx_int_type_0_process =</span>
<span class="cm"> * ==========================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Processes Type 0 interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Processes all enabled Type 0 interrupts.  If the reason for the interrupt</span>
<span class="cm"> *   is a serious fault on the adapter, then an error message is displayed</span>
<span class="cm"> *   and the adapter is reset.</span>
<span class="cm"> *</span>
<span class="cm"> *   One tricky potential timing window is the rapid succession of &quot;link avail&quot;</span>
<span class="cm"> *   &quot;link unavail&quot; state change interrupts.  The acknowledgement of the Type 0</span>
<span class="cm"> *   interrupt must be done before reading the state from the Port Status</span>
<span class="cm"> *   register.  This is true because a state change could occur after reading</span>
<span class="cm"> *   the data, but before acknowledging the interrupt.  If this state change</span>
<span class="cm"> *   does happen, it would be lost because the driver is using the old state,</span>
<span class="cm"> *   and it will never know about the new state because it subsequently</span>
<span class="cm"> *   acknowledges the state change interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> *          INCORRECT                                      CORRECT</span>
<span class="cm"> *      read type 0 int reasons                   read type 0 int reasons</span>
<span class="cm"> *      read adapter state                        ack type 0 interrupts</span>
<span class="cm"> *      ack type 0 interrupts                     read adapter state</span>
<span class="cm"> *      ... process interrupt ...                 ... process interrupt ...</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   An adapter reset may occur if the adapter has any Type 0 error interrupts</span>
<span class="cm"> *   or if the port status indicates that the adapter is halted.  The driver</span>
<span class="cm"> *   is responsible for reinitializing the adapter with the current CAM</span>
<span class="cm"> *   contents and adapter filter settings.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_int_type_0_process</span><span class="p">(</span><span class="n">DFX_board_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">)</span>

	<span class="p">{</span>
	<span class="n">PI_UINT32</span>	<span class="n">type_0_status</span><span class="p">;</span>		<span class="cm">/* Host Interrupt Type 0 register */</span>
	<span class="n">PI_UINT32</span>	<span class="n">state</span><span class="p">;</span>				<span class="cm">/* current adap state (from port status) */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read host interrupt Type 0 register to determine which Type 0</span>
<span class="cm">	 * interrupts are pending.  Immediately write it back out to clear</span>
<span class="cm">	 * those interrupts.</span>
<span class="cm">	 */</span>

	<span class="n">dfx_port_read_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_TYPE_0_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type_0_status</span><span class="p">);</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_TYPE_0_STATUS</span><span class="p">,</span> <span class="n">type_0_status</span><span class="p">);</span>

	<span class="cm">/* Check for Type 0 error interrupts */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type_0_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PI_TYPE_0_STAT_M_NXM</span> <span class="o">|</span>
							<span class="n">PI_TYPE_0_STAT_M_PM_PAR_ERR</span> <span class="o">|</span>
							<span class="n">PI_TYPE_0_STAT_M_BUS_PAR_ERR</span><span class="p">))</span>
		<span class="p">{</span>
		<span class="cm">/* Check for Non-Existent Memory error */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type_0_status</span> <span class="o">&amp;</span> <span class="n">PI_TYPE_0_STAT_M_NXM</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Non-Existent Memory Access Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/* Check for Packet Memory Parity error */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type_0_status</span> <span class="o">&amp;</span> <span class="n">PI_TYPE_0_STAT_M_PM_PAR_ERR</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Packet Memory Parity Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/* Check for Host Bus Parity error */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type_0_status</span> <span class="o">&amp;</span> <span class="n">PI_TYPE_0_STAT_M_BUS_PAR_ERR</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Host Bus Parity Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/* Reset adapter and bring it back on-line */</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_available</span> <span class="o">=</span> <span class="n">PI_K_FALSE</span><span class="p">;</span>	<span class="cm">/* link is no longer available */</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">reset_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/* rerun on-board diagnostics */</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Resetting adapter...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dfx_adap_init</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter reset failed!  Disabling adapter interrupts.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_HOST_INT_ENB</span><span class="p">,</span> <span class="n">PI_HOST_INT_K_DISABLE_ALL_INTS</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter reset successful!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Check for transmit flush interrupt */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type_0_status</span> <span class="o">&amp;</span> <span class="n">PI_TYPE_0_STAT_M_XMT_FLUSH</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="cm">/* Flush any pending xmt&#39;s and acknowledge the flush interrupt */</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_available</span> <span class="o">=</span> <span class="n">PI_K_FALSE</span><span class="p">;</span>		<span class="cm">/* link is no longer available */</span>
		<span class="n">dfx_xmt_flush</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>						<span class="cm">/* flush any outstanding packets */</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">dfx_hw_port_ctrl_req</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span>
									<span class="n">PI_PCTRL_M_XMT_DATA_FLUSH_DONE</span><span class="p">,</span>
									<span class="mi">0</span><span class="p">,</span>
									<span class="mi">0</span><span class="p">,</span>
									<span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/* Check for adapter state change */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type_0_status</span> <span class="o">&amp;</span> <span class="n">PI_TYPE_0_STAT_M_STATE_CHANGE</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="cm">/* Get latest adapter state */</span>

		<span class="n">state</span> <span class="o">=</span> <span class="n">dfx_hw_adap_state_rd</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>	<span class="cm">/* get adapter state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PI_STATE_K_HALTED</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Adapter has transitioned to HALTED state, try to reset</span>
<span class="cm">			 * adapter to bring it back on-line.  If reset fails,</span>
<span class="cm">			 * leave the adapter in the broken state.</span>
<span class="cm">			 */</span>

			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Controller has transitioned to HALTED state!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">dfx_int_pr_halt_id</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>			<span class="cm">/* display halt id as string */</span>

			<span class="cm">/* Reset adapter and bring it back on-line */</span>

			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_available</span> <span class="o">=</span> <span class="n">PI_K_FALSE</span><span class="p">;</span>	<span class="cm">/* link is no longer available */</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">reset_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/* rerun on-board diagnostics */</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Resetting adapter...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dfx_adap_init</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
				<span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter reset failed!  Disabling adapter interrupts.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_HOST_INT_ENB</span><span class="p">,</span> <span class="n">PI_HOST_INT_K_DISABLE_ALL_INTS</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter reset successful!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">PI_STATE_K_LINK_AVAIL</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_available</span> <span class="o">=</span> <span class="n">PI_K_TRUE</span><span class="p">;</span>		<span class="cm">/* set link available flag */</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ==================</span>
<span class="cm"> * = dfx_int_common =</span>
<span class="cm"> * ==================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Interrupt service routine (ISR)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This is the ISR which processes incoming adapter interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   This routine assumes PDQ interrupts have not been disabled.</span>
<span class="cm"> *   When interrupts are disabled at the PDQ, the Port Status register</span>
<span class="cm"> *   is automatically cleared.  This routine uses the Port Status</span>
<span class="cm"> *   register value to determine whether a Type 0 interrupt occurred,</span>
<span class="cm"> *   so it&#39;s important that adapter interrupts are not normally</span>
<span class="cm"> *   enabled/disabled at the PDQ.</span>
<span class="cm"> *</span>
<span class="cm"> *   It&#39;s vital that this routine is NOT reentered for the</span>
<span class="cm"> *   same board and that the OS is not in another section of</span>
<span class="cm"> *   code (eg. dfx_xmt_queue_pkt) for the same board on a</span>
<span class="cm"> *   different thread.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Pending interrupts are serviced.  Depending on the type of</span>
<span class="cm"> *   interrupt, acknowledging and clearing the interrupt at the</span>
<span class="cm"> *   PDQ involves writing a register to clear the interrupt bit</span>
<span class="cm"> *   or updating completion indices.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_int_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">PI_UINT32</span>	<span class="n">port_status</span><span class="p">;</span>		<span class="cm">/* Port Status register */</span>

	<span class="cm">/* Process xmt interrupts - frequent case, so always call this routine */</span>

	<span class="k">if</span><span class="p">(</span><span class="n">dfx_xmt_done</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>				<span class="cm">/* free consumed xmt packets */</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Process rcv interrupts - frequent case, so always call this routine */</span>

	<span class="n">dfx_rcv_queue_process</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>		<span class="cm">/* service received LLC frames */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Transmit and receive producer and completion indices are updated on the</span>
<span class="cm">	 * adapter by writing to the Type 2 Producer register.  Since the frequent</span>
<span class="cm">	 * case is that we&#39;ll be processing either LLC transmit or receive buffers,</span>
<span class="cm">	 * we&#39;ll optimize I/O writes by doing a single register write here.</span>
<span class="cm">	 */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_TYPE_2_PROD</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">lword</span><span class="p">);</span>

	<span class="cm">/* Read PDQ Port Status register to find out which interrupts need processing */</span>

	<span class="n">dfx_port_read_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_status</span><span class="p">);</span>

	<span class="cm">/* Process Type 0 interrupts (if any) - infrequent, so only call when needed */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">PI_PSTATUS_M_TYPE_0_PENDING</span><span class="p">)</span>
		<span class="n">dfx_int_type_0_process</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>	<span class="cm">/* process Type 0 interrupts */</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =================</span>
<span class="cm"> * = dfx_interrupt =</span>
<span class="cm"> * =================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Interrupt processing routine</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Whether a valid interrupt was seen.</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   irq	- interrupt vector</span>
<span class="cm"> *   dev_id	- pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This routine calls the interrupt processing routine for this adapter.  It</span>
<span class="cm"> *   disables and reenables adapter interrupts, as appropriate.  We can support</span>
<span class="cm"> *   shared interrupts since the incoming dev_id pointer provides our device</span>
<span class="cm"> *   structure context.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   IRQ_HANDLED - an IRQ was handled.</span>
<span class="cm"> *   IRQ_NONE    - no IRQ was handled.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   The interrupt acknowledgement at the hardware level (eg. ACKing the PIC</span>
<span class="cm"> *   on Intel-based systems) is done by the operating system outside this</span>
<span class="cm"> *   routine.</span>
<span class="cm"> *</span>
<span class="cm"> *	 System interrupts are enabled through this call.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Interrupts are disabled, then reenabled at the adapter.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dfx_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfx_bus_pci</span> <span class="o">=</span> <span class="n">DFX_BUS_PCI</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_eisa</span> <span class="o">=</span> <span class="n">DFX_BUS_EISA</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_tc</span> <span class="o">=</span> <span class="n">DFX_BUS_TC</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="cm">/* Service adapter interrupts */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">dfx_port_read_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PFI_K_REG_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PFI_STATUS_M_PDQ_INT</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* Disable PDQ-PFI interrupts at PFI */</span>
		<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PFI_K_REG_MODE_CTRL</span><span class="p">,</span>
				    <span class="n">PFI_MODE_M_DMA_ENB</span><span class="p">);</span>

		<span class="cm">/* Call interrupt service routine for this adapter */</span>
		<span class="n">dfx_int_common</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* Clear PDQ interrupt status bit and reenable interrupts */</span>
		<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PFI_K_REG_STATUS</span><span class="p">,</span>
				    <span class="n">PFI_STATUS_M_PDQ_INT</span><span class="p">);</span>
		<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PFI_K_REG_MODE_CTRL</span><span class="p">,</span>
				    <span class="p">(</span><span class="n">PFI_MODE_M_PDQ_INT_ENB</span> <span class="o">|</span>
				     <span class="n">PFI_MODE_M_DMA_ENB</span><span class="p">));</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_eisa</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base_addr</span> <span class="o">=</span> <span class="n">to_eisa_device</span><span class="p">(</span><span class="n">bdev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">PI_CONFIG_STAT_0_M_PEND</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* Disable interrupts at the ESIC */</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PI_CONFIG_STAT_0_M_INT_ENB</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="cm">/* Call interrupt service routine for this adapter */</span>
		<span class="n">dfx_int_common</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* Reenable interrupts at the ESIC */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="n">PI_CONFIG_STAT_0_M_INT_ENB</span><span class="p">;</span>
		<span class="n">outb</span><span class="p">(</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">PI_ESIC_K_IO_CONFIG_STAT_0</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_tc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">dfx_port_read_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PI_PSTATUS_M_RCV_DATA_PENDING</span> <span class="o">|</span>
				<span class="n">PI_PSTATUS_M_XMT_DATA_PENDING</span> <span class="o">|</span>
				<span class="n">PI_PSTATUS_M_SMT_HOST_PENDING</span> <span class="o">|</span>
				<span class="n">PI_PSTATUS_M_UNSOL_PENDING</span> <span class="o">|</span>
				<span class="n">PI_PSTATUS_M_CMD_RSP_PENDING</span> <span class="o">|</span>
				<span class="n">PI_PSTATUS_M_CMD_REQ_PENDING</span> <span class="o">|</span>
				<span class="n">PI_PSTATUS_M_TYPE_0_PENDING</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* Call interrupt service routine for this adapter */</span>
		<span class="n">dfx_int_common</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =====================</span>
<span class="cm"> * = dfx_ctl_get_stats =</span>
<span class="cm"> * =====================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Get statistics for FDDI adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Pointer to FDDI statistics structure</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Gets current MIB objects from adapter, then</span>
<span class="cm"> *   returns FDDI statistics structure as defined</span>
<span class="cm"> *   in if_fddi.h.</span>
<span class="cm"> *</span>
<span class="cm"> *   Note: Since the FDDI statistics structure is</span>
<span class="cm"> *   still new and the device structure doesn&#39;t</span>
<span class="cm"> *   have an FDDI-specific get statistics handler,</span>
<span class="cm"> *   we&#39;ll return the FDDI statistics structure as</span>
<span class="cm"> *   a pointer to an Ethernet statistics structure.</span>
<span class="cm"> *   That way, at least the first part of the statistics</span>
<span class="cm"> *   structure can be decoded properly, and it allows</span>
<span class="cm"> *   &quot;smart&quot; applications to perform a second cast to</span>
<span class="cm"> *   decode the FDDI-specific statistics.</span>
<span class="cm"> *</span>
<span class="cm"> *   We&#39;ll have to pay attention to this routine as the</span>
<span class="cm"> *   device structure becomes more mature and LAN media</span>
<span class="cm"> *   independent.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">dfx_ctl_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Fill the bp-&gt;stats structure with driver-maintained counters */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_packets</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_total_frames</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">tx_packets</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_total_frames</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_bytes</span>   <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_total_bytes</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">tx_bytes</span>   <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_total_bytes</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_errors</span>  <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_crc_errors</span> <span class="o">+</span>
				   <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_frame_status_errors</span> <span class="o">+</span>
				   <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_length_errors</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">tx_errors</span>  <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_length_errors</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_dropped</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_discards</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">tx_dropped</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_discards</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">multicast</span>  <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_multicast_frames</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">collisions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* always zero (0) for FDDI */</span>

	<span class="cm">/* Get FDDI SMT MIB objects */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">PI_CMD_K_SMT_MIB_GET</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="cm">/* Fill the bp-&gt;stats structure with the SMT MIB object values */</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_station_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_station_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_station_id</span><span class="p">));</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_op_version_id</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_op_version_id</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_hi_version_id</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_hi_version_id</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_lo_version_id</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_lo_version_id</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_user_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_user_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_user_data</span><span class="p">));</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_mib_version_id</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_mib_version_id</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_mac_cts</span>						<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_mac_ct</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_non_master_cts</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_non_master_ct</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_master_cts</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_master_ct</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_available_paths</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_available_paths</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_config_capabilities</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_config_capabilities</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_config_policy</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_config_policy</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_connection_policy</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_connection_policy</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_t_notify</span>						<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_t_notify</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_stat_rpt_policy</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_stat_rpt_policy</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_trace_max_expiration</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_trace_max_expiration</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_bypass_present</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_bypass_present</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_ecm_state</span>						<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_ecm_state</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_cf_state</span>						<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_cf_state</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_remote_disconnect_flag</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_remote_disconnect_flag</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_station_status</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_station_status</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_peer_wrap_flag</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_peer_wrap_flag</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_time_stamp</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_msg_time_stamp</span><span class="p">.</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">smt_transition_time_stamp</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">smt_transition_time_stamp</span><span class="p">.</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_frame_status_functions</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_frame_status_functions</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_t_max_capability</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_t_max_capability</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_tvx_capability</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_tvx_capability</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_available_paths</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_available_paths</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_current_path</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_current_path</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_upstream_nbr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_upstream_nbr</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_downstream_nbr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_downstream_nbr</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_old_upstream_nbr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_old_upstream_nbr</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_old_downstream_nbr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_old_downstream_nbr</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_dup_address_test</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_dup_address_test</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_requested_paths</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_requested_paths</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_downstream_port_type</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_downstream_port_type</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_smt_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_smt_address</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_t_req</span>							<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_t_req</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_t_neg</span>							<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_t_neg</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_t_max</span>							<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_t_max</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_tvx_value</span>						<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_tvx_value</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_frame_error_threshold</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_frame_error_threshold</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_frame_error_ratio</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_frame_error_ratio</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_rmt_state</span>						<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_rmt_state</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_da_flag</span>						<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_da_flag</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_una_da_flag</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_unda_flag</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_frame_error_flag</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_frame_error_flag</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_ma_unitdata_available</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_ma_unitdata_available</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_hardware_present</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_hardware_present</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_ma_unitdata_enable</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">mac_ma_unitdata_enable</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">path_tvx_lower_bound</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">path_tvx_lower_bound</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">path_t_max_lower_bound</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">path_t_max_lower_bound</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">path_max_t_req</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">path_max_t_req</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">path_configuration</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">path_configuration</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">path_configuration</span><span class="p">));</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_my_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_my_type</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_my_type</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_my_type</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_neighbor_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_neighbor_type</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_neighbor_type</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_neighbor_type</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_connection_policies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_connection_policies</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_connection_policies</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_connection_policies</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_mac_indicated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_mac_indicated</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_mac_indicated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_mac_indicated</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_current_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_current_path</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_current_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_current_path</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_requested_paths</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_requested_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_requested_paths</span><span class="p">[</span><span class="mi">1</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_requested_paths</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_mac_placement</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_mac_placement</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_mac_placement</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_mac_placement</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_available_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_available_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_available_paths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_available_paths</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_pmd_class</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_pmd_class</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_pmd_class</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_pmd_class</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_connection_capabilities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_connection_capabilities</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_connection_capabilities</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_connection_capabilities</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_bs_flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_bs_flag</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_bs_flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_bs_flag</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_ler_estimate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_ler_estimate</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_ler_estimate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_ler_estimate</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_ler_cutoff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_ler_cutoff</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_ler_cutoff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_ler_cutoff</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_ler_alarm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_ler_alarm</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_ler_alarm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_ler_alarm</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_connect_state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_connect_state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_connect_state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_connect_state</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_pcm_state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_pcm_state</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_pcm_state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_pcm_state</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_pc_withhold</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_pc_withhold</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_pc_withhold</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_pc_withhold</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_ler_flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_ler_flag</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_ler_flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>					<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_ler_flag</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_hardware_present</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_hardware_present</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_hardware_present</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">smt_mib_get</span><span class="p">.</span><span class="n">port_hardware_present</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Get FDDI counters */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">PI_CMD_K_CNTRS_GET</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>

	<span class="cm">/* Fill the bp-&gt;stats structure with the FDDI counter values */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_frame_cts</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">frame_cnt</span><span class="p">.</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_copied_cts</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">copied_cnt</span><span class="p">.</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_transmit_cts</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">transmit_cnt</span><span class="p">.</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_error_cts</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">error_cnt</span><span class="p">.</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mac_lost_cts</span>				<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">lost_cnt</span><span class="p">.</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_lct_fail_cts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">lct_rejects</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_lct_fail_cts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">lct_rejects</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_lem_reject_cts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">lem_rejects</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_lem_reject_cts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">lem_rejects</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_lem_cts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">link_errors</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ls</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">port_lem_cts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>			<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_virt</span><span class="o">-&gt;</span><span class="n">cntrs_get</span><span class="p">.</span><span class="n">cntrs</span><span class="p">.</span><span class="n">link_errors</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ls</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ==============================</span>
<span class="cm"> * = dfx_ctl_set_multicast_list =</span>
<span class="cm"> * ==============================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Enable/Disable LLC frame promiscuous mode reception</span>
<span class="cm"> *   on the adapter and/or update multicast address table.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This routine follows a fairly simple algorithm for setting the</span>
<span class="cm"> *   adapter filters and CAM:</span>
<span class="cm"> *</span>
<span class="cm"> *		if IFF_PROMISC flag is set</span>
<span class="cm"> *			enable LLC individual/group promiscuous mode</span>
<span class="cm"> *		else</span>
<span class="cm"> *			disable LLC individual/group promiscuous mode</span>
<span class="cm"> *			if number of incoming multicast addresses &gt;</span>
<span class="cm"> *					(CAM max size - number of unicast addresses in CAM)</span>
<span class="cm"> *				enable LLC group promiscuous mode</span>
<span class="cm"> *				set driver-maintained multicast address count to zero</span>
<span class="cm"> *			else</span>
<span class="cm"> *				disable LLC group promiscuous mode</span>
<span class="cm"> *				set driver-maintained multicast address count to incoming count</span>
<span class="cm"> *			update adapter CAM</span>
<span class="cm"> *		update adapter filters</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   Multicast addresses are presented in canonical (LSB) format.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   On-board adapter CAM and filters are updated.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_ctl_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span>					<span class="n">i</span><span class="p">;</span>			<span class="cm">/* used as index in for loop */</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="cm">/* Enable LLC frame promiscuous mode, if necessary */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">ind_group_prom</span> <span class="o">=</span> <span class="n">PI_FSTATE_K_PASS</span><span class="p">;</span>		<span class="cm">/* Enable LLC ind/group prom mode */</span>

	<span class="cm">/* Else, update multicast address table */</span>

	<span class="k">else</span>
		<span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">ind_group_prom</span> <span class="o">=</span> <span class="n">PI_FSTATE_K_BLOCK</span><span class="p">;</span>		<span class="cm">/* Disable LLC ind/group prom mode */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check whether incoming multicast address count exceeds table size</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: The adapters utilize an on-board 64 entry CAM for</span>
<span class="cm">		 *       supporting perfect filtering of multicast packets</span>
<span class="cm">		 *		 and bridge functions when adding unicast addresses.</span>
<span class="cm">		 *		 There is no hash function available.  To support</span>
<span class="cm">		 *		 additional multicast addresses, the all multicast</span>
<span class="cm">		 *		 filter (LLC group promiscuous mode) must be enabled.</span>
<span class="cm">		 *</span>
<span class="cm">		 *		 The firmware reserves two CAM entries for SMT-related</span>
<span class="cm">		 *		 multicast addresses, which leaves 62 entries available.</span>
<span class="cm">		 *		 The following code ensures that we&#39;re not being asked</span>
<span class="cm">		 *		 to add more than 62 addresses to the CAM.  If we are,</span>
<span class="cm">		 *		 the driver will enable the all multicast filter.</span>
<span class="cm">		 *		 Should the number of multicast addresses drop below</span>
<span class="cm">		 *		 the high water mark, the filter will be disabled and</span>
<span class="cm">		 *		 perfect filtering will be used.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PI_CMD_ADDR_FILTER_K_SIZE</span> <span class="o">-</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_count</span><span class="p">))</span>
			<span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">group_prom</span>	<span class="o">=</span> <span class="n">PI_FSTATE_K_PASS</span><span class="p">;</span>		<span class="cm">/* Enable LLC group prom mode */</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_count</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/* Don&#39;t add mc addrs to CAM */</span>
			<span class="p">}</span>
		<span class="k">else</span>
			<span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">group_prom</span>	<span class="o">=</span> <span class="n">PI_FSTATE_K_BLOCK</span><span class="p">;</span>	<span class="cm">/* Disable LLC group prom mode */</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_count</span>	<span class="o">=</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>		<span class="cm">/* Add mc addrs to CAM */</span>
			<span class="p">}</span>

		<span class="cm">/* Copy addresses to multicast address table, then update adapter CAM */</span>

		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_table</span><span class="p">[</span><span class="n">i</span><span class="o">++</span> <span class="o">*</span> <span class="n">FDDI_K_ALEN</span><span class="p">],</span>
			       <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dfx_ctl_update_cam</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Could not update multicast address table!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="k">else</span>
			<span class="p">{</span>
			<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Multicast address table updated!  Added %d addresses.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_count</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="cm">/* Update adapter filters */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_ctl_update_filters</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Could not update adapter filters!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">else</span>
		<span class="p">{</span>
		<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter filters updated!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ===========================</span>
<span class="cm"> * = dfx_ctl_set_mac_address =</span>
<span class="cm"> * ===========================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Add node address override (unicast address) to adapter</span>
<span class="cm"> *   CAM and update dev_addr field in device table.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev  - pointer to device information</span>
<span class="cm"> *   addr - pointer to sockaddr structure containing unicast address to add</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   The adapter supports node address overrides by adding one or more</span>
<span class="cm"> *   unicast addresses to the adapter CAM.  This is similar to adding</span>
<span class="cm"> *   multicast addresses.  In this routine we&#39;ll update the driver and</span>
<span class="cm"> *   device structures with the new address, then update the adapter CAM</span>
<span class="cm"> *   to ensure that the adapter will copy and strip frames destined and</span>
<span class="cm"> *   sourced by that address.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   Always returns zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   The address pointed to by addr-&gt;sa_data is a valid unicast</span>
<span class="cm"> *   address and is presented in canonical (LSB) format.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   On-board adapter CAM is updated.  On-board adapter filters</span>
<span class="cm"> *   may be updated.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_ctl_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr</span>	<span class="o">*</span><span class="n">p_sockaddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Copy unicast address to driver-maintained structs and update count */</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">p_sockaddr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>	<span class="cm">/* update device struct */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_table</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_sockaddr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>	<span class="cm">/* update driver struct */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify we&#39;re not exceeding the CAM size by adding unicast address</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: It&#39;s possible that before entering this routine we&#39;ve</span>
<span class="cm">	 *       already filled the CAM with 62 multicast addresses.</span>
<span class="cm">	 *		 Since we need to place the node address override into</span>
<span class="cm">	 *		 the CAM, we have to check to see that we&#39;re not</span>
<span class="cm">	 *		 exceeding the CAM size.  If we are, we have to enable</span>
<span class="cm">	 *		 the LLC group (multicast) promiscuous mode filter as</span>
<span class="cm">	 *		 in dfx_ctl_set_multicast_list.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_count</span> <span class="o">+</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">PI_CMD_ADDR_FILTER_K_SIZE</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">group_prom</span>	<span class="o">=</span> <span class="n">PI_FSTATE_K_PASS</span><span class="p">;</span>		<span class="cm">/* Enable LLC group prom mode */</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_count</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/* Don&#39;t add mc addrs to CAM */</span>

		<span class="cm">/* Update adapter filters */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dfx_ctl_update_filters</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Could not update adapter filters!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="k">else</span>
			<span class="p">{</span>
			<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter filters updated!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="cm">/* Update adapter CAM with new unicast address */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_ctl_update_cam</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Could not set new MAC address!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">else</span>
		<span class="p">{</span>
		<span class="n">DBG_printk</span><span class="p">(</span><span class="s">&quot;%s: Adapter CAM updated with new MAC address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* always return zero */</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ======================</span>
<span class="cm"> * = dfx_ctl_update_cam =</span>
<span class="cm"> * ======================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Procedure to update adapter CAM (Content Addressable Memory)</span>
<span class="cm"> *   with desired unicast and multicast address entries.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Updates adapter CAM with current contents of board structure</span>
<span class="cm"> *   unicast and multicast address tables.  Since there are only 62</span>
<span class="cm"> *   free entries in CAM, this routine ensures that the command</span>
<span class="cm"> *   request buffer is not overrun.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   DFX_K_SUCCESS - Request succeeded</span>
<span class="cm"> *   DFX_K_FAILURE - Request failed</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   All addresses being added (unicast and multicast) are in canonical</span>
<span class="cm"> *   order.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   On-board adapter CAM is updated.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_ctl_update_cam</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>				<span class="cm">/* used as index */</span>
	<span class="n">PI_LAN_ADDR</span>	<span class="o">*</span><span class="n">p_addr</span><span class="p">;</span>		<span class="cm">/* pointer to CAM entry */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in command request information</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Even though both the unicast and multicast address</span>
<span class="cm">	 *       table entries are stored as contiguous 6 byte entries,</span>
<span class="cm">	 *		 the firmware address filter set command expects each</span>
<span class="cm">	 *		 entry to be two longwords (8 bytes total).  We must be</span>
<span class="cm">	 *		 careful to only copy the six bytes of each unicast and</span>
<span class="cm">	 *		 multicast table entry into each command entry.  This</span>
<span class="cm">	 *		 is also why we must first clear the entire command</span>
<span class="cm">	 *		 request buffer.</span>
<span class="cm">	 */</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PI_CMD_REQ_K_SIZE_MAX</span><span class="p">);</span>	<span class="cm">/* first clear buffer */</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">PI_CMD_K_ADDR_FILTER_SET</span><span class="p">;</span>
	<span class="n">p_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">addr_filter_set</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Now add unicast addresses to command request buffer, if any */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">PI_CMD_ADDR_FILTER_K_SIZE</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_table</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">FDDI_K_ALEN</span><span class="p">],</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
			<span class="n">p_addr</span><span class="o">++</span><span class="p">;</span>			<span class="cm">/* point to next command entry */</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="cm">/* Now add multicast addresses to command request buffer, if any */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">uc_count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PI_CMD_ADDR_FILTER_K_SIZE</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">p_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">mc_table</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">FDDI_K_ALEN</span><span class="p">],</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
			<span class="n">p_addr</span><span class="o">++</span><span class="p">;</span>			<span class="cm">/* point to next command entry */</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="cm">/* Issue command to update adapter CAM, then return */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">DFX_K_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ==========================</span>
<span class="cm"> * = dfx_ctl_update_filters =</span>
<span class="cm"> * ==========================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Procedure to update adapter filters with desired</span>
<span class="cm"> *   filter settings.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Enables or disables filter using current filter settings.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   DFX_K_SUCCESS - Request succeeded.</span>
<span class="cm"> *   DFX_K_FAILURE - Request failed.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   We must always pass up packets destined to the broadcast</span>
<span class="cm"> *   address (FF-FF-FF-FF-FF-FF), so we&#39;ll always keep the</span>
<span class="cm"> *   broadcast filter enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   On-board adapter filters are updated.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_ctl_update_filters</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/* used as index */</span>

	<span class="cm">/* Fill in command request information */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">PI_CMD_K_FILTERS_SET</span><span class="p">;</span>

	<span class="cm">/* Initialize Broadcast filter - * ALWAYS ENABLED * */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">filter_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_BROADCAST</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">filter_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">].</span><span class="n">value</span>	<span class="o">=</span> <span class="n">PI_FSTATE_K_PASS</span><span class="p">;</span>

	<span class="cm">/* Initialize LLC Individual/Group Promiscuous filter */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">filter_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_IND_GROUP_PROM</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">filter_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">].</span><span class="n">value</span>	<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">ind_group_prom</span><span class="p">;</span>

	<span class="cm">/* Initialize LLC Group Promiscuous filter */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">filter_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_GROUP_PROM</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">filter_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">].</span><span class="n">value</span>	<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">group_prom</span><span class="p">;</span>

	<span class="cm">/* Terminate the item code list */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_virt</span><span class="o">-&gt;</span><span class="n">filter_set</span><span class="p">.</span><span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">item_code</span>	<span class="o">=</span> <span class="n">PI_ITEM_K_EOL</span><span class="p">;</span>

	<span class="cm">/* Issue command to update adapter filters, then return */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DFX_K_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DFX_K_FAILURE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">DFX_K_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ======================</span>
<span class="cm"> * = dfx_hw_dma_cmd_req =</span>
<span class="cm"> * ======================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Sends PDQ DMA command to adapter firmware</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   The command request and response buffers are posted to the adapter in the manner</span>
<span class="cm"> *   described in the PDQ Port Specification:</span>
<span class="cm"> *</span>
<span class="cm"> *		1. Command Response Buffer is posted to adapter.</span>
<span class="cm"> *		2. Command Request Buffer is posted to adapter.</span>
<span class="cm"> *		3. Command Request consumer index is polled until it indicates that request</span>
<span class="cm"> *         buffer has been DMA&#39;d to adapter.</span>
<span class="cm"> *		4. Command Response consumer index is polled until it indicates that response</span>
<span class="cm"> *         buffer has been DMA&#39;d from adapter.</span>
<span class="cm"> *</span>
<span class="cm"> *   This ordering ensures that a response buffer is already available for the firmware</span>
<span class="cm"> *   to use once it&#39;s done processing the request buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   DFX_K_SUCCESS	  - DMA command succeeded</span>
<span class="cm"> * 	 DFX_K_OUTSTATE   - Adapter is NOT in proper state</span>
<span class="cm"> *   DFX_K_HW_TIMEOUT - DMA command timed out</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   Command request buffer has already been filled with desired DMA command.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_hw_dma_cmd_req</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>			<span class="cm">/* adapter status */</span>
	<span class="kt">int</span> <span class="n">timeout_cnt</span><span class="p">;</span>	<span class="cm">/* used in for loops */</span>

	<span class="cm">/* Make sure the adapter is in a state that we can issue the DMA command in */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dfx_hw_adap_state_rd</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">==</span> <span class="n">PI_STATE_K_RESET</span><span class="p">)</span>		<span class="o">||</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PI_STATE_K_HALTED</span><span class="p">)</span>		<span class="o">||</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PI_STATE_K_DMA_UNAVAIL</span><span class="p">)</span>	<span class="o">||</span>
		<span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">PI_STATE_K_UPGRADE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">DFX_K_OUTSTATE</span><span class="p">;</span>

	<span class="cm">/* Put response buffer on the command response queue */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">cmd_rsp</span><span class="p">[</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span><span class="p">].</span><span class="n">long_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">PI_RCV_DESCR_M_SOP</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">PI_CMD_RSP_K_SIZE_MAX</span> <span class="o">/</span> <span class="n">PI_ALIGN_K_CMD_RSP_BUFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PI_RCV_DESCR_V_SEG_LEN</span><span class="p">));</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">cmd_rsp</span><span class="p">[</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span><span class="p">].</span><span class="n">long_1</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_phys</span><span class="p">;</span>

	<span class="cm">/* Bump (and wrap) the producer index and write out to register */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span> <span class="o">&amp;=</span> <span class="n">PI_CMD_RSP_K_NUM_ENTRIES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_CMD_RSP_PROD</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">lword</span><span class="p">);</span>

	<span class="cm">/* Put request buffer on the command request queue */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">cmd_req</span><span class="p">[</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span><span class="p">].</span><span class="n">long_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">PI_XMT_DESCR_M_SOP</span> <span class="o">|</span>
			<span class="n">PI_XMT_DESCR_M_EOP</span> <span class="o">|</span> <span class="p">(</span><span class="n">PI_CMD_REQ_K_SIZE_MAX</span> <span class="o">&lt;&lt;</span> <span class="n">PI_XMT_DESCR_V_SEG_LEN</span><span class="p">));</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">cmd_req</span><span class="p">[</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span><span class="p">].</span><span class="n">long_1</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_phys</span><span class="p">;</span>

	<span class="cm">/* Bump (and wrap) the producer index and write out to register */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span> <span class="o">&amp;=</span> <span class="n">PI_CMD_REQ_K_NUM_ENTRIES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_CMD_REQ_PROD</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">lword</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here we wait for the command request consumer index to be equal</span>
<span class="cm">	 * to the producer, indicating that the adapter has DMAed the request.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span> <span class="n">timeout_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout_cnt</span><span class="o">--</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span> <span class="o">==</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="o">-&gt;</span><span class="n">cmd_req</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>			<span class="cm">/* wait for 100 microseconds */</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DFX_K_HW_TIMEOUT</span><span class="p">;</span>

	<span class="cm">/* Bump (and wrap) the completion index and write out to register */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">comp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">comp</span> <span class="o">&amp;=</span> <span class="n">PI_CMD_REQ_K_NUM_ENTRIES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_CMD_REQ_PROD</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_req_reg</span><span class="p">.</span><span class="n">lword</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here we wait for the command response consumer index to be equal</span>
<span class="cm">	 * to the producer, indicating that the adapter has DMAed the response.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span> <span class="n">timeout_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout_cnt</span><span class="o">--</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">prod</span> <span class="o">==</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="o">-&gt;</span><span class="n">cmd_rsp</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>			<span class="cm">/* wait for 100 microseconds */</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DFX_K_HW_TIMEOUT</span><span class="p">;</span>

	<span class="cm">/* Bump (and wrap) the completion index and write out to register */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">comp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">comp</span> <span class="o">&amp;=</span> <span class="n">PI_CMD_RSP_K_NUM_ENTRIES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_CMD_RSP_PROD</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">cmd_rsp_reg</span><span class="p">.</span><span class="n">lword</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">DFX_K_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ========================</span>
<span class="cm"> * = dfx_hw_port_ctrl_req =</span>
<span class="cm"> * ========================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Sends PDQ port control command to adapter firmware</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Host data register value in host_data if ptr is not NULL</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp			- pointer to board information</span>
<span class="cm"> *	 command	- port control command</span>
<span class="cm"> *	 data_a		- port data A register value</span>
<span class="cm"> *	 data_b		- port data B register value</span>
<span class="cm"> *	 host_data	- ptr to host data register value</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Send generic port control command to adapter by writing</span>
<span class="cm"> *   to various PDQ port registers, then polling for completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   DFX_K_SUCCESS	  - port control command succeeded</span>
<span class="cm"> *   DFX_K_HW_TIMEOUT - port control command timed out</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_hw_port_ctrl_req</span><span class="p">(</span>
	<span class="n">DFX_board_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">PI_UINT32</span>	<span class="n">command</span><span class="p">,</span>
	<span class="n">PI_UINT32</span>	<span class="n">data_a</span><span class="p">,</span>
	<span class="n">PI_UINT32</span>	<span class="n">data_b</span><span class="p">,</span>
	<span class="n">PI_UINT32</span>	<span class="o">*</span><span class="n">host_data</span>
	<span class="p">)</span>

	<span class="p">{</span>
	<span class="n">PI_UINT32</span>	<span class="n">port_cmd</span><span class="p">;</span>		<span class="cm">/* Port Control command register value */</span>
	<span class="kt">int</span>			<span class="n">timeout_cnt</span><span class="p">;</span>	<span class="cm">/* used in for loops */</span>

	<span class="cm">/* Set Command Error bit in command longword */</span>

	<span class="n">port_cmd</span> <span class="o">=</span> <span class="p">(</span><span class="n">PI_UINT32</span><span class="p">)</span> <span class="p">(</span><span class="n">command</span> <span class="o">|</span> <span class="n">PI_PCTRL_M_CMD_ERROR</span><span class="p">);</span>

	<span class="cm">/* Issue port command to the adapter */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_DATA_A</span><span class="p">,</span> <span class="n">data_a</span><span class="p">);</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_DATA_B</span><span class="p">,</span> <span class="n">data_b</span><span class="p">);</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_CTRL</span><span class="p">,</span> <span class="n">port_cmd</span><span class="p">);</span>

	<span class="cm">/* Now wait for command to complete */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">command</span> <span class="o">==</span> <span class="n">PI_PCTRL_M_BLAST_FLASH</span><span class="p">)</span>
		<span class="n">timeout_cnt</span> <span class="o">=</span> <span class="mi">600000</span><span class="p">;</span>	<span class="cm">/* set command timeout count to 60 seconds */</span>
	<span class="k">else</span>
		<span class="n">timeout_cnt</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>	<span class="cm">/* set command timeout count to 2 seconds */</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">timeout_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout_cnt</span><span class="o">--</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">dfx_port_read_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">port_cmd</span> <span class="o">&amp;</span> <span class="n">PI_PCTRL_M_CMD_ERROR</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>			<span class="cm">/* wait for 100 microseconds */</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DFX_K_HW_TIMEOUT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the address of host_data is non-zero, assume caller has supplied a</span>
<span class="cm">	 * non NULL pointer, and return the contents of the HOST_DATA register in</span>
<span class="cm">	 * it.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">dfx_port_read_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_HOST_DATA</span><span class="p">,</span> <span class="n">host_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">DFX_K_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =====================</span>
<span class="cm"> * = dfx_hw_adap_reset =</span>
<span class="cm"> * =====================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Resets adapter</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp   - pointer to board information</span>
<span class="cm"> *   type - type of reset to perform</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Issue soft reset to adapter by writing to PDQ Port Reset</span>
<span class="cm"> *   register.  Use incoming reset type to tell adapter what</span>
<span class="cm"> *   kind of reset operation to perform.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   This routine merely issues a soft reset to the adapter.</span>
<span class="cm"> *   It is expected that after this routine returns, the caller</span>
<span class="cm"> *   will appropriately poll the Port Status register for the</span>
<span class="cm"> *   adapter to enter the proper state.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Internal adapter registers are cleared.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_hw_adap_reset</span><span class="p">(</span>
	<span class="n">DFX_board_t</span>	<span class="o">*</span><span class="n">bp</span><span class="p">,</span>
	<span class="n">PI_UINT32</span>	<span class="n">type</span>
	<span class="p">)</span>

	<span class="p">{</span>
	<span class="cm">/* Set Reset type and assert reset */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_DATA_A</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>	<span class="cm">/* tell adapter type of reset */</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_RESET</span><span class="p">,</span> <span class="n">PI_RESET_M_ASSERT_RESET</span><span class="p">);</span>

	<span class="cm">/* Wait for at least 1 Microsecond according to the spec. We wait 20 just to be safe */</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

	<span class="cm">/* Deassert reset */</span>

	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_RESET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ========================</span>
<span class="cm"> * = dfx_hw_adap_state_rd =</span>
<span class="cm"> * ========================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Returns current adapter state</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Adapter state per PDQ Port Specification</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Reads PDQ Port Status register and returns adapter state.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_hw_adap_state_rd</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="n">PI_UINT32</span> <span class="n">port_status</span><span class="p">;</span>		<span class="cm">/* Port Status register value */</span>

	<span class="n">dfx_port_read_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_PORT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_status</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">port_status</span> <span class="o">&amp;</span> <span class="n">PI_PSTATUS_M_STATE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PI_PSTATUS_V_STATE</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =====================</span>
<span class="cm"> * = dfx_hw_dma_uninit =</span>
<span class="cm"> * =====================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Brings adapter to DMA_UNAVAILABLE state</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp   - pointer to board information</span>
<span class="cm"> *   type - type of reset to perform</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Bring adapter to DMA_UNAVAILABLE state by performing the following:</span>
<span class="cm"> *		1. Set reset type bit in Port Data A Register then reset adapter.</span>
<span class="cm"> *		2. Check that adapter is in DMA_UNAVAILABLE state.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   DFX_K_SUCCESS	  - adapter is in DMA_UNAVAILABLE state</span>
<span class="cm"> *   DFX_K_HW_TIMEOUT - adapter did not reset properly</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Internal adapter registers are cleared.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_hw_dma_uninit</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_UINT32</span> <span class="n">type</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="kt">int</span> <span class="n">timeout_cnt</span><span class="p">;</span>	<span class="cm">/* used in for loops */</span>

	<span class="cm">/* Set reset type bit and reset adapter */</span>

	<span class="n">dfx_hw_adap_reset</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="cm">/* Now wait for adapter to enter DMA_UNAVAILABLE state */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span> <span class="n">timeout_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">timeout_cnt</span><span class="o">--</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_adap_state_rd</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">==</span> <span class="n">PI_STATE_K_DMA_UNAVAIL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>					<span class="cm">/* wait for 100 microseconds */</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">DFX_K_HW_TIMEOUT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">DFX_K_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Align an sk_buff to a boundary power of 2</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_skb_align</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>	<span class="cm">/* Where we want to be */</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ================</span>
<span class="cm"> * = dfx_rcv_init =</span>
<span class="cm"> * ================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Produces buffers to adapter LLC Host receive descriptor block</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *   get_buffers - non-zero if buffers to be allocated</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This routine can be called during dfx_adap_init() or during an adapter</span>
<span class="cm"> *	 reset.  It initializes the descriptor block and produces all allocated</span>
<span class="cm"> *   LLC Host queue receive buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   Return 0 on success or -ENOMEM if buffer allocation failed (when using</span>
<span class="cm"> *   dynamic buffer allocation). If the buffer allocation failed, the</span>
<span class="cm"> *   already allocated buffers will not be released and the caller should do</span>
<span class="cm"> *   this.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   The PDQ has been reset and the adapter and driver maintained Type 2</span>
<span class="cm"> *   register indices are cleared.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Receive buffers are posted to the adapter LLC queue and the adapter</span>
<span class="cm"> *   is notified.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_rcv_init</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">get_buffers</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>					<span class="cm">/* used in for loop */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Since each receive buffer is a single fragment of same length, initialize</span>
<span class="cm">	 *  first longword in each receive descriptor for entire LLC Host descriptor</span>
<span class="cm">	 *  block.  Also initialize second longword in each receive descriptor with</span>
<span class="cm">	 *  physical address of receive buffer.  We&#39;ll always allocate receive</span>
<span class="cm">	 *  buffers in powers of 2 so that we can easily fill the 256 entry descriptor</span>
<span class="cm">	 *  block and produce new receive buffers by simply updating the receive</span>
<span class="cm">	 *  producer index.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 	Assumptions:</span>
<span class="cm">	 *		To support all shipping versions of PDQ, the receive buffer size</span>
<span class="cm">	 *		must be mod 128 in length and the physical address must be 128 byte</span>
<span class="cm">	 *		aligned.  In other words, bits 0-6 of the length and address must</span>
<span class="cm">	 *		be zero for the following descriptor field entries to be correct on</span>
<span class="cm">	 *		all PDQ-based boards.  We guaranteed both requirements during</span>
<span class="cm">	 *		driver initialization when we allocated memory for the receive buffers.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_buffers</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef DYNAMIC_BUFFERS</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">PI_RCV_DATA_K_NUM_ENTRIES</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newskb</span> <span class="o">=</span> <span class="n">__netdev_alloc_skb</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">NEW_SKB_SIZE</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newskb</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">rcv_data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">].</span><span class="n">long_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">PI_RCV_DESCR_M_SOP</span> <span class="o">|</span>
				<span class="p">((</span><span class="n">PI_RCV_DATA_K_SIZE_MAX</span> <span class="o">/</span> <span class="n">PI_ALIGN_K_RCV_DATA_BUFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PI_RCV_DESCR_V_SEG_LEN</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * align to 128 bytes for compatibility with</span>
<span class="cm">			 * the old EISA boards.</span>
<span class="cm">			 */</span>

			<span class="n">my_skb_align</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">rcv_data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">].</span><span class="n">long_1</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dma_map_single</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">,</span> <span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						    <span class="n">NEW_SKB_SIZE</span><span class="p">,</span>
						    <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * p_rcv_buff_va is only used inside the</span>
<span class="cm">			 * kernel so we put the skb pointer here.</span>
<span class="cm">			 */</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">p_rcv_buff_va</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">newskb</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#else</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">PI_RCV_DATA_K_NUM_ENTRIES</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">rcv_data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">].</span><span class="n">long_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">PI_RCV_DESCR_M_SOP</span> <span class="o">|</span>
				<span class="p">((</span><span class="n">PI_RCV_DATA_K_SIZE_MAX</span> <span class="o">/</span> <span class="n">PI_ALIGN_K_RCV_DATA_BUFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PI_RCV_DESCR_V_SEG_LEN</span><span class="p">));</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">rcv_data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">].</span><span class="n">long_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_block_phys</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">PI_RCV_DATA_K_SIZE_MAX</span><span class="p">));</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">p_rcv_buff_va</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_block_virt</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">PI_RCV_DATA_K_SIZE_MAX</span><span class="p">));</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/* Update receive producer and Type 2 register */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">rcv_prod</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span><span class="p">;</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_TYPE_2_PROD</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">lword</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =========================</span>
<span class="cm"> * = dfx_rcv_queue_process =</span>
<span class="cm"> * =========================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Process received LLC frames.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Received LLC frames are processed until there are no more consumed frames.</span>
<span class="cm"> *   Once all frames are processed, the receive buffers are returned to the</span>
<span class="cm"> *   adapter.  Note that this algorithm fixes the length of time that can be spent</span>
<span class="cm"> *   in this routine, because there are a fixed number of receive buffers to</span>
<span class="cm"> *   process and buffers are not produced until this routine exits and returns</span>
<span class="cm"> *   to the ISR.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_rcv_queue_process</span><span class="p">(</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span>
	<span class="p">)</span>

	<span class="p">{</span>
	<span class="n">PI_TYPE_2_CONSUMER</span>	<span class="o">*</span><span class="n">p_type_2_cons</span><span class="p">;</span>		<span class="cm">/* ptr to rcv/xmt consumer block register */</span>
	<span class="kt">char</span>				<span class="o">*</span><span class="n">p_buff</span><span class="p">;</span>			<span class="cm">/* ptr to start of packet receive buffer (FMC descriptor) */</span>
	<span class="n">u32</span>					<span class="n">descr</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">;</span>		<span class="cm">/* FMC descriptor field and packet length */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span><span class="p">;</span>				<span class="cm">/* pointer to a sk_buff to hold incoming packet data */</span>

	<span class="cm">/* Service all consumed LLC receive frames */</span>

	<span class="n">p_type_2_cons</span> <span class="o">=</span> <span class="p">(</span><span class="n">PI_TYPE_2_CONSUMER</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="o">-&gt;</span><span class="n">xmt_rcv_data</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">rcv_comp</span> <span class="o">!=</span> <span class="n">p_type_2_cons</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">rcv_cons</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="cm">/* Process any errors */</span>

		<span class="kt">int</span> <span class="n">entry</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">rcv_comp</span><span class="p">;</span>
<span class="cp">#ifdef DYNAMIC_BUFFERS</span>
		<span class="n">p_buff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">p_rcv_buff_va</span><span class="p">[</span><span class="n">entry</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">p_buff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">p_rcv_buff_va</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
<span class="cp">#endif</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descr</span><span class="p">,</span> <span class="n">p_buff</span> <span class="o">+</span> <span class="n">RCV_BUFF_K_DESCR</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">descr</span> <span class="o">&amp;</span> <span class="n">PI_FMC_DESCR_M_RCC_FLUSH</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">descr</span> <span class="o">&amp;</span> <span class="n">PI_FMC_DESCR_M_RCC_CRC</span><span class="p">)</span>
				<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_frame_status_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">rx_in_place</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* The frame was received without errors - verify packet length */</span>

			<span class="n">pkt_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)((</span><span class="n">descr</span> <span class="o">&amp;</span> <span class="n">PI_FMC_DESCR_M_LEN</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PI_FMC_DESCR_V_LEN</span><span class="p">);</span>
			<span class="n">pkt_len</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>				<span class="cm">/* subtract 4 byte CRC */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IN_RANGE</span><span class="p">(</span><span class="n">pkt_len</span><span class="p">,</span> <span class="n">FDDI_K_LLC_ZLEN</span><span class="p">,</span> <span class="n">FDDI_K_LLC_LEN</span><span class="p">))</span>
				<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_length_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span><span class="p">{</span>
<span class="cp">#ifdef DYNAMIC_BUFFERS</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&gt;</span> <span class="n">SKBUFF_RX_COPYBREAK</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newskb</span><span class="p">;</span>

					<span class="n">newskb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">NEW_SKB_SIZE</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">newskb</span><span class="p">){</span>
						<span class="n">rx_in_place</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

						<span class="n">my_skb_align</span><span class="p">(</span><span class="n">newskb</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
						<span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">p_rcv_buff_va</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
						<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">,</span>
							<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">rcv_data</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">long_1</span><span class="p">,</span>
							<span class="n">NEW_SKB_SIZE</span><span class="p">,</span>
							<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
						<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">RCV_BUFF_K_PADDING</span><span class="p">);</span>
						<span class="n">bp</span><span class="o">-&gt;</span><span class="n">p_rcv_buff_va</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">newskb</span><span class="p">;</span>
						<span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">rcv_data</span><span class="p">[</span><span class="n">entry</span><span class="p">].</span><span class="n">long_1</span> <span class="o">=</span>
							<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dma_map_single</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">,</span>
								<span class="n">newskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
								<span class="n">NEW_SKB_SIZE</span><span class="p">,</span>
								<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
					<span class="n">skb</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">pkt_len</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>	<span class="cm">/* alloc new buffer to pass up, add room for PRH */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Could not allocate receive buffer.  Dropping packet.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
					<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_discards</span><span class="o">++</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifndef DYNAMIC_BUFFERS</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">rx_in_place</span><span class="p">)</span>
<span class="cp">#endif</span>
					<span class="p">{</span>
						<span class="cm">/* Receive buffer allocated, pass receive packet up */</span>

						<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
							       <span class="n">p_buff</span> <span class="o">+</span> <span class="n">RCV_BUFF_K_PADDING</span><span class="p">,</span>
							       <span class="n">pkt_len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>		<span class="cm">/* adjust data field so that it points to FC byte */</span>
					<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">);</span>		<span class="cm">/* pass up packet length, NOT including CRC */</span>
					<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">fddi_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
					<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_total_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
					<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

					<span class="cm">/* Update the rcv counters */</span>
					<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_total_frames</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p_buff</span> <span class="o">+</span> <span class="n">RCV_BUFF_K_DA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
						<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_multicast_frames</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Advance the producer (for recycling) and advance the completion</span>
<span class="cm">		 * (for servicing received frames).  Note that it is okay to</span>
<span class="cm">		 * advance the producer without checking that it passes the</span>
<span class="cm">		 * completion index because they are both advanced at the same</span>
<span class="cm">		 * rate.</span>
<span class="cm">		 */</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">rcv_prod</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">rcv_comp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =====================</span>
<span class="cm"> * = dfx_xmt_queue_pkt =</span>
<span class="cm"> * =====================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Queues packets for transmission</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   skb - pointer to sk_buff to queue for transmission</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Here we assume that an incoming skb transmit request</span>
<span class="cm"> *   is contained in a single physically contiguous buffer</span>
<span class="cm"> *   in which the virtual address of the start of packet</span>
<span class="cm"> *   (skb-&gt;data) can be converted to a physical address</span>
<span class="cm"> *   by using pci_map_single().</span>
<span class="cm"> *</span>
<span class="cm"> *   Since the adapter architecture requires a three byte</span>
<span class="cm"> *   packet request header to prepend the start of packet,</span>
<span class="cm"> *   we&#39;ll write the three byte field immediately prior to</span>
<span class="cm"> *   the FC byte.  This assumption is valid because we&#39;ve</span>
<span class="cm"> *   ensured that dev-&gt;hard_header_len includes three pad</span>
<span class="cm"> *   bytes.  By posting a single fragment to the adapter,</span>
<span class="cm"> *   we&#39;ll reduce the number of descriptor fetches and</span>
<span class="cm"> *   bus traffic needed to send the request.</span>
<span class="cm"> *</span>
<span class="cm"> *   Also, we can&#39;t free the skb until after it&#39;s been DMA&#39;d</span>
<span class="cm"> *   out by the adapter, so we&#39;ll queue it in the driver and</span>
<span class="cm"> *   return it in dfx_xmt_done.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   0 - driver queued packet, link is unavailable, or skbuff was bad</span>
<span class="cm"> *	 1 - caller should requeue the sk_buff for later transmission</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *	 First and foremost, we assume the incoming skb pointer</span>
<span class="cm"> *   is NOT NULL and is pointing to a valid sk_buff structure.</span>
<span class="cm"> *</span>
<span class="cm"> *   The outgoing packet is complete, starting with the</span>
<span class="cm"> *   frame control byte including the last byte of data,</span>
<span class="cm"> *   but NOT including the 4 byte CRC.  We&#39;ll let the</span>
<span class="cm"> *   adapter hardware generate and append the CRC.</span>
<span class="cm"> *</span>
<span class="cm"> *   The entire packet is stored in one physically</span>
<span class="cm"> *   contiguous buffer which is not cached and whose</span>
<span class="cm"> *   32-bit physical address can be determined.</span>
<span class="cm"> *</span>
<span class="cm"> *   It&#39;s vital that this routine is NOT reentered for the</span>
<span class="cm"> *   same board and that the OS is not in another section of</span>
<span class="cm"> *   code (eg. dfx_int_common) for the same board on a</span>
<span class="cm"> *   different thread.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">dfx_xmt_queue_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="n">DFX_board_t</span>		<span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u8</span>			<span class="n">prod</span><span class="p">;</span>				<span class="cm">/* local transmit producer index */</span>
	<span class="n">PI_XMT_DESCR</span>		<span class="o">*</span><span class="n">p_xmt_descr</span><span class="p">;</span>		<span class="cm">/* ptr to transmit descriptor block entry */</span>
	<span class="n">XMT_DRIVER_DESCR</span>	<span class="o">*</span><span class="n">p_xmt_drv_descr</span><span class="p">;</span>	<span class="cm">/* ptr to transmit driver descriptor */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify that incoming transmit request is OK</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: The packet size check is consistent with other</span>
<span class="cm">	 *		 Linux device drivers, although the correct packet</span>
<span class="cm">	 *		 size should be verified before calling the</span>
<span class="cm">	 *		 transmit routine.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IN_RANGE</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">FDDI_K_LLC_ZLEN</span><span class="p">,</span> <span class="n">FDDI_K_LLC_LEN</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: Invalid packet length - %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_length_errors</span><span class="o">++</span><span class="p">;</span>		<span class="cm">/* bump error counter */</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>			<span class="cm">/* return &quot;success&quot; */</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * See if adapter link is available, if not, free buffer</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: If the link isn&#39;t available, free buffer and return 0</span>
<span class="cm">	 *		 rather than tell the upper layer to requeue the packet.</span>
<span class="cm">	 *		 The methodology here is that by the time the link</span>
<span class="cm">	 *		 becomes available, the packet to be sent will be</span>
<span class="cm">	 *		 fairly stale.  By simply dropping the packet, the</span>
<span class="cm">	 *		 higher layer protocols will eventually time out</span>
<span class="cm">	 *		 waiting for response packets which it won&#39;t receive.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_available</span> <span class="o">==</span> <span class="n">PI_K_FALSE</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dfx_hw_adap_state_rd</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">==</span> <span class="n">PI_STATE_K_LINK_AVAIL</span><span class="p">)</span>	<span class="cm">/* is link really available? */</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">link_available</span> <span class="o">=</span> <span class="n">PI_K_TRUE</span><span class="p">;</span>		<span class="cm">/* if so, set flag and continue */</span>
		<span class="k">else</span>
			<span class="p">{</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_discards</span><span class="o">++</span><span class="p">;</span>					<span class="cm">/* bump error counter */</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>		<span class="cm">/* free sk_buff now */</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>		<span class="cm">/* return &quot;success&quot; */</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Get the current producer and the next free xmt data descriptor */</span>

	<span class="n">prod</span>		<span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_prod</span><span class="p">;</span>
	<span class="n">p_xmt_descr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">xmt_data</span><span class="p">[</span><span class="n">prod</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get pointer to auxiliary queue entry to contain information</span>
<span class="cm">	 * for this packet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: The current xmt producer index will become the</span>
<span class="cm">	 *	 current xmt completion index when we complete this</span>
<span class="cm">	 *	 packet later on.  So, we&#39;ll get the pointer to the</span>
<span class="cm">	 *	 next auxiliary queue entry now before we bump the</span>
<span class="cm">	 *	 producer index.</span>
<span class="cm">	 */</span>

	<span class="n">p_xmt_drv_descr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_drv_descr_blk</span><span class="p">[</span><span class="n">prod</span><span class="o">++</span><span class="p">]);</span>	<span class="cm">/* also bump producer index */</span>

	<span class="cm">/* Write the three PRH bytes immediately before the FC byte */</span>

	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFX_PRH0_BYTE</span><span class="p">;</span>	<span class="cm">/* these byte values are defined */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFX_PRH1_BYTE</span><span class="p">;</span>	<span class="cm">/* in the Motorola FDDI MAC chip */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">DFX_PRH2_BYTE</span><span class="p">;</span>	<span class="cm">/* specification */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write the descriptor with buffer info and bump producer</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: Since we need to start DMA from the packet request</span>
<span class="cm">	 *		 header, we&#39;ll add 3 bytes to the DMA buffer length,</span>
<span class="cm">	 *		 and we&#39;ll determine the physical address of the</span>
<span class="cm">	 *		 buffer from the PRH, not skb-&gt;data.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Assumptions:</span>
<span class="cm">	 *		 1. Packet starts with the frame control (FC) byte</span>
<span class="cm">	 *		    at skb-&gt;data.</span>
<span class="cm">	 *		 2. The 4-byte CRC is not appended to the buffer or</span>
<span class="cm">	 *			included in the length.</span>
<span class="cm">	 *		 3. Packet length (skb-&gt;len) is from FC to end of</span>
<span class="cm">	 *			data, inclusive.</span>
<span class="cm">	 *		 4. The packet length does not exceed the maximum</span>
<span class="cm">	 *			FDDI LLC frame length of 4491 bytes.</span>
<span class="cm">	 *		 5. The entire packet is contained in a physically</span>
<span class="cm">	 *			contiguous, non-cached, locked memory space</span>
<span class="cm">	 *			comprised of a single buffer pointed to by</span>
<span class="cm">	 *			skb-&gt;data.</span>
<span class="cm">	 *		 6. The physical address of the start of packet</span>
<span class="cm">	 *			can be determined from the virtual address</span>
<span class="cm">	 *			by using pci_map_single() and is only 32-bits</span>
<span class="cm">	 *			wide.</span>
<span class="cm">	 */</span>

	<span class="n">p_xmt_descr</span><span class="o">-&gt;</span><span class="n">long_0</span>	<span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">PI_XMT_DESCR_M_SOP</span> <span class="o">|</span> <span class="n">PI_XMT_DESCR_M_EOP</span> <span class="o">|</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PI_XMT_DESCR_V_SEG_LEN</span><span class="p">));</span>
	<span class="n">p_xmt_descr</span><span class="o">-&gt;</span><span class="n">long_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dma_map_single</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify that descriptor is actually available</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: If descriptor isn&#39;t available, return 1 which tells</span>
<span class="cm">	 *	 the upper layer to requeue the packet for later</span>
<span class="cm">	 *	 transmission.</span>
<span class="cm">	 *</span>
<span class="cm">	 *       We need to ensure that the producer never reaches the</span>
<span class="cm">	 *	 completion, except to indicate that the queue is empty.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prod</span> <span class="o">==</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>	<span class="cm">/* requeue packet for later */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Save info for this packet for xmt done indication routine</span>
<span class="cm">	 *</span>
<span class="cm">	 * Normally, we&#39;d save the producer index in the p_xmt_drv_descr</span>
<span class="cm">	 * structure so that we&#39;d have it handy when we complete this</span>
<span class="cm">	 * packet later (in dfx_xmt_done).  However, since the current</span>
<span class="cm">	 * transmit architecture guarantees a single fragment for the</span>
<span class="cm">	 * entire packet, we can simply bump the completion index by</span>
<span class="cm">	 * one (1) for each completed packet.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: If this assumption changes and we&#39;re presented with</span>
<span class="cm">	 *	 an inconsistent number of transmit fragments for packet</span>
<span class="cm">	 *	 data, we&#39;ll need to modify this code to save the current</span>
<span class="cm">	 *	 transmit producer index.</span>
<span class="cm">	 */</span>

	<span class="n">p_xmt_drv_descr</span><span class="o">-&gt;</span><span class="n">p_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Update Type 2 register */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_prod</span> <span class="o">=</span> <span class="n">prod</span><span class="p">;</span>
	<span class="n">dfx_port_write_long</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">PI_PDQ_K_REG_TYPE_2_PROD</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">lword</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>	<span class="cm">/* packet queued to adapter */</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * ================</span>
<span class="cm"> * = dfx_xmt_done =</span>
<span class="cm"> * ================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Processes all frames that have been transmitted.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   For all consumed transmit descriptors that have not</span>
<span class="cm"> *   yet been completed, we&#39;ll free the skb we were holding</span>
<span class="cm"> *   onto using dev_kfree_skb and bump the appropriate</span>
<span class="cm"> *   counters.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   The Type 2 register is not updated in this routine.  It is</span>
<span class="cm"> *   assumed that it will be updated in the ISR when dfx_xmt_done</span>
<span class="cm"> *   returns.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfx_xmt_done</span><span class="p">(</span><span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="n">XMT_DRIVER_DESCR</span>	<span class="o">*</span><span class="n">p_xmt_drv_descr</span><span class="p">;</span>	<span class="cm">/* ptr to transmit driver descriptor */</span>
	<span class="n">PI_TYPE_2_CONSUMER</span>	<span class="o">*</span><span class="n">p_type_2_cons</span><span class="p">;</span>		<span class="cm">/* ptr to rcv/xmt consumer block register */</span>
	<span class="n">u8</span>			<span class="n">comp</span><span class="p">;</span>			<span class="cm">/* local transmit completion index */</span>
	<span class="kt">int</span> 			<span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* buffers freed */</span>

	<span class="cm">/* Service all consumed transmit frames */</span>

	<span class="n">p_type_2_cons</span> <span class="o">=</span> <span class="p">(</span><span class="n">PI_TYPE_2_CONSUMER</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="o">-&gt;</span><span class="n">xmt_rcv_data</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span> <span class="o">!=</span> <span class="n">p_type_2_cons</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_cons</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="cm">/* Get pointer to the transmit driver descriptor block information */</span>

		<span class="n">p_xmt_drv_descr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_drv_descr_blk</span><span class="p">[</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span><span class="p">]);</span>

		<span class="cm">/* Increment transmit counters */</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_total_frames</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_total_bytes</span> <span class="o">+=</span> <span class="n">p_xmt_drv_descr</span><span class="o">-&gt;</span><span class="n">p_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Return skb to operating system */</span>
		<span class="n">comp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span><span class="p">;</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">,</span>
				 <span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">xmt_data</span><span class="p">[</span><span class="n">comp</span><span class="p">].</span><span class="n">long_1</span><span class="p">,</span>
				 <span class="n">p_xmt_drv_descr</span><span class="o">-&gt;</span><span class="n">p_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">p_xmt_drv_descr</span><span class="o">-&gt;</span><span class="n">p_skb</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Move to start of next packet by updating completion index</span>
<span class="cm">		 *</span>
<span class="cm">		 * Here we assume that a transmit packet request is always</span>
<span class="cm">		 * serviced by posting one fragment.  We can therefore</span>
<span class="cm">		 * simplify the completion code by incrementing the</span>
<span class="cm">		 * completion index by one.  This code will need to be</span>
<span class="cm">		 * modified if this assumption changes.  See comments</span>
<span class="cm">		 * in dfx_xmt_queue_pkt for more details.</span>
<span class="cm">		 */</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">freed</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
	<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * =================</span>
<span class="cm"> * = dfx_rcv_flush =</span>
<span class="cm"> * =================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Remove all skb&#39;s in the receive ring.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Free&#39;s all the dynamically allocated skb&#39;s that are</span>
<span class="cm"> *   currently attached to the device receive ring. This</span>
<span class="cm"> *   function is typically only used when the device is</span>
<span class="cm"> *   initialized or reinitialized.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>
<span class="cp">#ifdef DYNAMIC_BUFFERS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_rcv_flush</span><span class="p">(</span> <span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="p">)</span>
	<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">PI_RCV_DATA_K_NUM_ENTRIES</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">p_rcv_buff_va</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">bp</span><span class="o">-&gt;</span><span class="n">p_rcv_buff_va</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dfx_rcv_flush</span><span class="p">(</span> <span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* DYNAMIC_BUFFERS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * =================</span>
<span class="cm"> * = dfx_xmt_flush =</span>
<span class="cm"> * =================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Processes all frames whether they&#39;ve been transmitted</span>
<span class="cm"> *   or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bp - pointer to board information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   For all produced transmit descriptors that have not</span>
<span class="cm"> *   yet been completed, we&#39;ll free the skb we were holding</span>
<span class="cm"> *   onto using dev_kfree_skb and bump the appropriate</span>
<span class="cm"> *   counters.  Of course, it&#39;s possible that some of</span>
<span class="cm"> *   these transmit requests actually did go out, but we</span>
<span class="cm"> *   won&#39;t make that distinction here.  Finally, we&#39;ll</span>
<span class="cm"> *   update the consumer index to match the producer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   This routine does NOT update the Type 2 register.  It</span>
<span class="cm"> *   is assumed that this routine is being called during a</span>
<span class="cm"> *   transmit flush interrupt, or a shutdown or close routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dfx_xmt_flush</span><span class="p">(</span> <span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="p">)</span>
	<span class="p">{</span>
	<span class="n">u32</span>			<span class="n">prod_cons</span><span class="p">;</span>		<span class="cm">/* rcv/xmt consumer block longword */</span>
	<span class="n">XMT_DRIVER_DESCR</span>	<span class="o">*</span><span class="n">p_xmt_drv_descr</span><span class="p">;</span>	<span class="cm">/* ptr to transmit driver descriptor */</span>
	<span class="n">u8</span>			<span class="n">comp</span><span class="p">;</span>			<span class="cm">/* local transmit completion index */</span>

	<span class="cm">/* Flush all outstanding transmit frames */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span> <span class="o">!=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_prod</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="cm">/* Get pointer to the transmit driver descriptor block information */</span>

		<span class="n">p_xmt_drv_descr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_drv_descr_blk</span><span class="p">[</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span><span class="p">]);</span>

		<span class="cm">/* Return skb to operating system */</span>
		<span class="n">comp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span><span class="p">;</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bus_dev</span><span class="p">,</span>
				 <span class="n">bp</span><span class="o">-&gt;</span><span class="n">descr_block_virt</span><span class="o">-&gt;</span><span class="n">xmt_data</span><span class="p">[</span><span class="n">comp</span><span class="p">].</span><span class="n">long_1</span><span class="p">,</span>
				 <span class="n">p_xmt_drv_descr</span><span class="o">-&gt;</span><span class="n">p_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">p_xmt_drv_descr</span><span class="o">-&gt;</span><span class="n">p_skb</span><span class="p">);</span>

		<span class="cm">/* Increment transmit error counter */</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">xmt_discards</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Move to start of next packet by updating completion index</span>
<span class="cm">		 *</span>
<span class="cm">		 * Here we assume that a transmit packet request is always</span>
<span class="cm">		 * serviced by posting one fragment.  We can therefore</span>
<span class="cm">		 * simplify the completion code by incrementing the</span>
<span class="cm">		 * completion index by one.  This code will need to be</span>
<span class="cm">		 * modified if this assumption changes.  See comments</span>
<span class="cm">		 * in dfx_xmt_queue_pkt for more details.</span>
<span class="cm">		 */</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_comp</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Update the transmit consumer index in the consumer block */</span>

	<span class="n">prod_cons</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="o">-&gt;</span><span class="n">xmt_rcv_data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PI_CONS_M_XMT_INDEX</span><span class="p">);</span>
	<span class="n">prod_cons</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_xmt_reg</span><span class="p">.</span><span class="n">index</span><span class="p">.</span><span class="n">xmt_prod</span> <span class="o">&lt;&lt;</span> <span class="n">PI_CONS_V_XMT_INDEX</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">cons_block_virt</span><span class="o">-&gt;</span><span class="n">xmt_rcv_data</span> <span class="o">=</span> <span class="n">prod_cons</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ==================</span>
<span class="cm"> * = dfx_unregister =</span>
<span class="cm"> * ==================</span>
<span class="cm"> *</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Shuts down an FDDI controller</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *</span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   bdev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   It compiles so it should work :-( (PCI cards do :-)</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Device structures for FDDI adapters (fddi0, fddi1, etc) are</span>
<span class="cm"> *   freed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">dfx_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">DFX_board_t</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_pci</span> <span class="o">=</span> <span class="n">DFX_BUS_PCI</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_bus_tc</span> <span class="o">=</span> <span class="n">DFX_BUS_TC</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dfx_use_mmio</span> <span class="o">=</span> <span class="n">DFX_MMIO</span> <span class="o">||</span> <span class="n">dfx_bus_tc</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">bar_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* pointer to port */</span>
	<span class="n">resource_size_t</span> <span class="n">bar_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* resource length */</span>
	<span class="kt">int</span>		<span class="n">alloc_size</span><span class="p">;</span>		<span class="cm">/* total buffer size used */</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">alloc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_DESCR_BLOCK</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">PI_CMD_REQ_K_SIZE_MAX</span> <span class="o">+</span> <span class="n">PI_CMD_RSP_K_SIZE_MAX</span> <span class="o">+</span>
<span class="cp">#ifndef DYNAMIC_BUFFERS</span>
		     <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">rcv_bufs_to_post</span> <span class="o">*</span> <span class="n">PI_RCV_DATA_K_SIZE_MAX</span><span class="p">)</span> <span class="o">+</span>
<span class="cp">#endif</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="n">PI_CONSUMER_BLOCK</span><span class="p">)</span> <span class="o">+</span>
		     <span class="p">(</span><span class="n">PI_ALIGN_K_DESC_BLK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced</span><span class="p">)</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">,</span>
				  <span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">kmalloced_dma</span><span class="p">);</span>

	<span class="n">dfx_bus_uninit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dfx_get_bars</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bar_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bar_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_use_mmio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">.</span><span class="n">mem</span><span class="p">);</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">bar_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">bar_start</span><span class="p">,</span> <span class="n">bar_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfx_bus_pci</span><span class="p">)</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">to_pci_dev</span><span class="p">(</span><span class="n">bdev</span><span class="p">));</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">__maybe_unused</span> <span class="n">dfx_dev_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="n">__maybe_unused</span> <span class="n">dfx_dev_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">dfx_pci_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="n">dfx_pci_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">dfx_pci_table</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_DEVICE</span><span class="p">(</span><span class="n">PCI_VENDOR_ID_DEC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_DEC_FDDI</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">dfx_pci_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">dfx_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;defxx&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">dfx_pci_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">dfx_pci_register</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">dfx_pci_unregister</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__devinit</span> <span class="kt">int</span> <span class="nf">dfx_pci_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dfx_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">dfx_pci_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dfx_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_EISA</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">eisa_device_id</span> <span class="n">dfx_eisa_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;DEC3001&quot;</span><span class="p">,</span> <span class="n">DEFEA_PROD_ID_1</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s">&quot;DEC3002&quot;</span><span class="p">,</span> <span class="n">DEFEA_PROD_ID_2</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s">&quot;DEC3003&quot;</span><span class="p">,</span> <span class="n">DEFEA_PROD_ID_3</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s">&quot;DEC3004&quot;</span><span class="p">,</span> <span class="n">DEFEA_PROD_ID_4</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">eisa</span><span class="p">,</span> <span class="n">dfx_eisa_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">eisa_driver</span> <span class="n">dfx_eisa_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">dfx_eisa_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;defxx&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bus</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">eisa_bus_type</span><span class="p">,</span>
		<span class="p">.</span><span class="n">probe</span>	<span class="o">=</span> <span class="n">dfx_dev_register</span><span class="p">,</span>
		<span class="p">.</span><span class="n">remove</span>	<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">dfx_dev_unregister</span><span class="p">),</span>
	<span class="p">},</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_EISA */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_TC</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tc_device_id</span> <span class="k">const</span> <span class="n">dfx_tc_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;DEC     &quot;</span><span class="p">,</span> <span class="s">&quot;PMAF-FA &quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;DEC     &quot;</span><span class="p">,</span> <span class="s">&quot;PMAF-FD &quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;DEC     &quot;</span><span class="p">,</span> <span class="s">&quot;PMAF-FS &quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;DEC     &quot;</span><span class="p">,</span> <span class="s">&quot;PMAF-FU &quot;</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">dfx_tc_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tc_driver</span> <span class="n">dfx_tc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">dfx_tc_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span>		<span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;defxx&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">bus</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">tc_bus_type</span><span class="p">,</span>
		<span class="p">.</span><span class="n">probe</span>	<span class="o">=</span> <span class="n">dfx_dev_register</span><span class="p">,</span>
		<span class="p">.</span><span class="n">remove</span>	<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">dfx_dev_unregister</span><span class="p">),</span>
	<span class="p">},</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TC */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="n">__maybe_unused</span> <span class="nf">dfx_dev_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">dfx_register</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">get_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="n">__maybe_unused</span> <span class="nf">dfx_dev_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dfx_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">dfx_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dfx_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">eisa_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dfx_eisa_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">tc_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dfx_tc_driver</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">dfx_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tc_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dfx_tc_driver</span><span class="p">);</span>
	<span class="n">eisa_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dfx_eisa_driver</span><span class="p">);</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dfx_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dfx_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dfx_cleanup</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Lawrence V. Stefani&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;DEC FDDIcontroller TC/EISA/PCI (DEFTA/DEFEA/DEFPA) driver &quot;</span>
		   <span class="n">DRV_VERSION</span> <span class="s">&quot; &quot;</span> <span class="n">DRV_RELDATE</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
