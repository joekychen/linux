<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › fddi › skfp › skfddi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>skfddi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * File Name:</span>
<span class="cm"> *   skfddi.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright Information:</span>
<span class="cm"> *   Copyright SysKonnect 1998,1999.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * The information in this file is provided &quot;AS IS&quot; without warranty.</span>
<span class="cm"> *</span>
<span class="cm"> * Abstract:</span>
<span class="cm"> *   A Linux device driver supporting the SysKonnect FDDI PCI controller</span>
<span class="cm"> *   familie.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintainers:</span>
<span class="cm"> *   CG    Christoph Goos (cgoos@syskonnect.de)</span>
<span class="cm"> *</span>
<span class="cm"> * Contributors:</span>
<span class="cm"> *   DM    David S. Miller</span>
<span class="cm"> *</span>
<span class="cm"> * Address all question to:</span>
<span class="cm"> *   linux@syskonnect.de</span>
<span class="cm"> *</span>
<span class="cm"> * The technical manual for the adapters is available from SysKonnect&#39;s</span>
<span class="cm"> * web pages: www.syskonnect.com</span>
<span class="cm"> * Goto &quot;Support&quot; and search Knowledge Base for &quot;manual&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver Architecture:</span>
<span class="cm"> *   The driver architecture is based on the DEC FDDI driver by</span>
<span class="cm"> *   Lawrence V. Stefani and several ethernet drivers.</span>
<span class="cm"> *   I also used an existing Windows NT miniport driver.</span>
<span class="cm"> *   All hardware dependent functions are handled by the SysKonnect</span>
<span class="cm"> *   Hardware Module.</span>
<span class="cm"> *   The only headerfiles that are directly related to this source</span>
<span class="cm"> *   are skfddi.c, h/types.h, h/osdef1st.h, h/targetos.h.</span>
<span class="cm"> *   The others belong to the SysKonnect FDDI Hardware Module and</span>
<span class="cm"> *   should better not be changed.</span>
<span class="cm"> *</span>
<span class="cm"> * Modification History:</span>
<span class="cm"> *              Date            Name    Description</span>
<span class="cm"> *              02-Mar-98       CG	Created.</span>
<span class="cm"> *</span>
<span class="cm"> *		10-Mar-99	CG	Support for 2.2.x added.</span>
<span class="cm"> *		25-Mar-99	CG	Corrected IRQ routing for SMP (APIC)</span>
<span class="cm"> *		26-Oct-99	CG	Fixed compilation error on 2.2.13</span>
<span class="cm"> *		12-Nov-99	CG	Source code release</span>
<span class="cm"> *		22-Nov-99	CG	Included in kernel source.</span>
<span class="cm"> *		07-May-00	DM	64 bit fixes, new dma interface</span>
<span class="cm"> *		31-Jul-03	DB	Audit copy_*_user in skfp_ioctl</span>
<span class="cm"> *					  Daniele Bellucci &lt;bellucda@tiscali.it&gt;</span>
<span class="cm"> *		03-Dec-03	SH	Convert to PCI device model</span>
<span class="cm"> *</span>
<span class="cm"> * Compilation options (-Dxxx):</span>
<span class="cm"> *              DRIVERDEBUG     print lots of messages to log file</span>
<span class="cm"> *              DUMPPACKETS     print received/transmitted packets to logfile</span>
<span class="cm"> * </span>
<span class="cm"> * Tested cpu architectures:</span>
<span class="cm"> *	- i386</span>
<span class="cm"> *	- sparc64</span>
<span class="cm"> */</span>

<span class="cm">/* Version information string - should be updated prior to */</span>
<span class="cm">/* each new release!!! */</span>
<span class="cp">#define VERSION		&quot;2.07&quot;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">boot_msg</span> <span class="o">=</span> 
	<span class="s">&quot;SysKonnect FDDI PCI Adapter driver v&quot;</span> <span class="n">VERSION</span> <span class="s">&quot; for</span><span class="se">\n</span><span class="s">&quot;</span>
	<span class="s">&quot;  SK-55xx/SK-58xx adapters (SK-NET FDDI-FP/UP/LP)&quot;</span><span class="p">;</span>

<span class="cm">/* Include files */</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/fddidevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>

<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include	&quot;h/types.h&quot;</span>
<span class="cp">#undef ADDR			</span><span class="c1">// undo Linux definition</span>
<span class="cp">#include	&quot;h/skfbi.h&quot;</span>
<span class="cp">#include	&quot;h/fddi.h&quot;</span>
<span class="cp">#include	&quot;h/smc.h&quot;</span>
<span class="cp">#include	&quot;h/smtstate.h&quot;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Define module-wide (static) routines</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="n">skfp_driver_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">skfp_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">skfp_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">skfp_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">skfp_ctl_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">skfp_ctl_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">skfp_ctl_set_multicast_list_wo_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">skfp_ctl_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">skfp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">skfp_send_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">send_queued_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">CheckSourceAddress</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ResetAdapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Functions needed by the hardware module</p></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">mac_drv_get_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">mac_drv_get_desc_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_int</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mac_drv_virt2phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dma_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dma_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">union</span> <span class="n">s_fp_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_drv_tx_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="o">*</span><span class="n">txd</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">llc_restart_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_drv_rx_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">rxd</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">frag_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_drv_requeue_rxd</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">rxd</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">frag_count</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_drv_fill_rxd</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_drv_clear_rxd</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">rxd</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">frag_count</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mac_drv_rx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">look_ahead</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">la_len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dump_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>External functions from the hardware module</p></td><td class="code"><div class="highlight"><pre><span class="k">extern</span> <span class="n">u_int</span> <span class="n">mac_drv_check_space</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">mac_drv_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hwm_tx_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">far</span> <span class="o">*</span> <span class="n">virt</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">phys</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame_status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">hwm_tx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">fc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frag_count</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">frame_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame_status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">fddi_isr</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">hwm_rx_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">far</span> <span class="o">*</span> <span class="n">virt</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">phys</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame_status</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mac_drv_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">mac_drv_clear_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="n">enable_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_short</span> <span class="n">queue</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">skfddi_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_SK</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SK_FP</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>			<span class="cm">/* Terminating entry */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">skfddi_pci_tbl</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mirko Lindner &lt;mlindner@syskonnect.de&gt;&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Define module-wide (static) variables</p></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="n">num_boards</span><span class="p">;</span>	<span class="cm">/* total number of adapters configured */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">skfp_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">skfp_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">skfp_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">skfp_send_pkt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">skfp_ctl_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">fddi_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">skfp_ctl_set_multicast_list</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">skfp_ctl_set_mac_address</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">skfp_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * =================</span>
<span class="cm"> * = skfp_init_one =</span>
<span class="cm"> * =================</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Probes for supported FDDI PCI controllers</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   pdev - pointer to PCI device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This is now called by PCI driver registration process</span>
<span class="cm"> *   for each board found.</span>
<span class="cm"> *   </span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   0           - This device (fddi0, fddi1, etc) configured successfully</span>
<span class="cm"> *   -ENODEV - No devices present, or no SysKonnect FDDI PCI device</span>
<span class="cm"> *                         present for this device name</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Device structures for FDDI adapters (fddi0, fddi1, etc) are</span>
<span class="cm"> *   initialized and the board resources are read and stored in</span>
<span class="cm"> *   the device structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">skfp_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">;</span>	<span class="cm">/* board pointer */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering skfp_init_one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_boards</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> 
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boot_msg</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;skfddi&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out1</span><span class="p">;</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="cp">#ifdef MEM_MAPPED_IO</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;skfp: region is not an MMIO resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mem</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mh">0x4000</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IO_RESOURCE_IO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;skfp: region is not PIO resource</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mem</span> <span class="o">=</span> <span class="n">ioport_map</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">FP_IO_LEN</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;skfp:  Unable to map register, &quot;</span>
				<span class="s">&quot;FDDI adapter will be disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_fddidev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;skfp: Unable to allocate fddi device, &quot;</span>
				<span class="s">&quot;FDDI adapter will be disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skfp_netdev_ops</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Initialize board structure with bus-specific info */</span>
	<span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">bus_type</span> <span class="o">=</span> <span class="n">SK_BUS_TYPE_PCI</span><span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">pdev</span> <span class="o">=</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">QueueSkb</span> <span class="o">=</span> <span class="n">MAX_TX_QUEUE_LEN</span><span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MaxFrameSize</span> <span class="o">=</span> <span class="n">MAX_FRAME_SIZE</span><span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">slot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">iop</span> <span class="o">=</span> <span class="n">mem</span><span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">ResetRequested</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SendSkbQueue</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mem</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">skfp_driver_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out4</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out5</span><span class="p">;</span>

	<span class="o">++</span><span class="n">num_boards</span><span class="p">;</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x5500</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x5800</span><span class="p">)</span> 
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: SysKonnect FDDI PCI adapter&quot;</span>
		       <span class="s">&quot; found (SK-%04X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>	
		       <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: FDDI PCI adapter found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err_out5:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span><span class="p">)</span> 
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemSize</span><span class="p">,</span>
				    <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span><span class="p">,</span> 
				    <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemDMA</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MAX_FRAME_SIZE</span><span class="p">,</span>
			    <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBuffer</span><span class="p">,</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBufferDMA</span><span class="p">);</span>
<span class="nl">err_out4:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">err_out3:</span>
<span class="cp">#ifdef MEM_MAPPED_IO</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">ioport_unmap</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="nl">err_out2:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">err_out1:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called for each adapter board from pci_unregister_driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">skfp_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemSize</span><span class="p">,</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span><span class="p">,</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemDMA</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">MAX_FRAME_SIZE</span><span class="p">,</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBuffer</span><span class="p">,</span>
				    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBufferDMA</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef MEM_MAPPED_IO</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">iop</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">ioport_unmap</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">iop</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ====================</span>
<span class="cm"> * = skfp_driver_init =</span>
<span class="cm"> * ====================</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Initializes remaining adapter board structure information</span>
<span class="cm"> *   and makes sure adapter is in a safe state prior to skfp_open().</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This function allocates additional resources such as the host memory</span>
<span class="cm"> *   blocks needed by the adapter.</span>
<span class="cm"> *   The adapter is also reset. The OS must call skfp_open() to open </span>
<span class="cm"> *   the adapter and bring it on-line.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *    0 - initialization succeeded</span>
<span class="cm"> *   -1 - initialization failed</span>
<span class="cm"> */</span>
<span class="k">static</span>  <span class="kt">int</span> <span class="nf">skfp_driver_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering skfp_driver_init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>set the io address in private structures</p></td><td class="code"><div class="highlight"><pre>	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Get the interrupt level from the PCI Configuration Table</p></td><td class="code"><div class="highlight"><pre>	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">);</span>
	</pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Allocate invalid frame</p></td><td class="code"><div class="highlight"><pre>	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">LocalRxBuffer</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MAX_FRAME_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">LocalRxBufferDMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">LocalRxBuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;could not allocate mem for &quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;LocalRxBuffer: %d byte</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MAX_FRAME_SIZE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Determine the required size of the 'shared' memory area.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemSize</span> <span class="o">=</span> <span class="n">mac_drv_check_space</span><span class="p">();</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Memory for HWM: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemSize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemSize</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>	<span class="c1">// for descriptor alignment</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemAddr</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
							 <span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemSize</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemDMA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemAddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;could not allocate mem for &quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;hardware module: %ld byte</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemSize</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemHeap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// Nothing used yet.</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemAddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemHeap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>			<span class="c1">// SharedMemSize &gt; 0</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemAddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemSize</span><span class="p">);</span>

	<span class="n">card_stop</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>		<span class="c1">// Reset adapter.</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;mac_drv_init()..</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_drv_init</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;mac_drv_init() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_address</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;HW-Addr: %pMF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_canon_addr</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_canon_addr</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="n">smt_reset_defaults</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemAddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
				    <span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemSize</span><span class="p">,</span>
				    <span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemAddr</span><span class="p">,</span>
				    <span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemDMA</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">SharedMemAddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">LocalRxBuffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">MAX_FRAME_SIZE</span><span class="p">,</span>
				    <span class="n">bp</span><span class="o">-&gt;</span><span class="n">LocalRxBuffer</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">LocalRxBufferDMA</span><span class="p">);</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">LocalRxBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// skfp_driver_init</span>


<span class="cm">/*</span>
<span class="cm"> * =============</span>
<span class="cm"> * = skfp_open =</span>
<span class="cm"> * =============</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Opens the adapter</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This function brings the adapter to an operational state.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   0           - Adapter was successfully opened</span>
<span class="cm"> *   -EAGAIN - Could not register IRQ</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">skfp_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering skfp_open</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Register IRQ - support shared interrupts by passing device ptr */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">skfp_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set current address to factory MAC address</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: We&#39;ve already done this step in skfp_driver_init.</span>
<span class="cm">	 *       However, it&#39;s possible that a user has set a node</span>
<span class="cm">	 *               address override, then closed and reopened the</span>
<span class="cm">	 *               adapter.  Unless we reset the device address field</span>
<span class="cm">	 *               now, we&#39;ll continue to use the existing modified</span>
<span class="cm">	 *               address.</span>
<span class="cm">	 */</span>
	<span class="n">read_address</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_canon_addr</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

	<span class="n">init_smt</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">smt_online</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">STI_FBI</span><span class="p">();</span>

	<span class="cm">/* Clear local multicast address tables */</span>
	<span class="n">mac_clear_multicast</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>

	<span class="cm">/* Disable promiscuous filter settings */</span>
	<span class="n">mac_drv_rx_mode</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">RX_DISABLE_PROMISC</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// skfp_open</span>


<span class="cm">/*</span>
<span class="cm"> * ==============</span>
<span class="cm"> * = skfp_close =</span>
<span class="cm"> * ==============</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Closes the device/module.</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This routine closes the adapter and brings it to a safe state.</span>
<span class="cm"> *   The interrupt service routine is deregistered with the OS.</span>
<span class="cm"> *   The adapter can be opened again with another call to skfp_open().</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   Always return 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   No further requests for this adapter are made after this routine is</span>
<span class="cm"> *   called.  skfp_open() can be called to reset and reinitialize the</span>
<span class="cm"> *   adapter.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">skfp_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>

	<span class="n">CLI_FBI</span><span class="p">();</span>
	<span class="n">smt_reset_defaults</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">card_stop</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
	<span class="n">mac_drv_clear_tx_queue</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
	<span class="n">mac_drv_clear_rx_queue</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* Deregister (free) IRQ */</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SendSkbQueue</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">QueueSkb</span> <span class="o">=</span> <span class="n">MAX_TX_QUEUE_LEN</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// skfp_close</span>


<span class="cm">/*</span>
<span class="cm"> * ==================</span>
<span class="cm"> * = skfp_interrupt =</span>
<span class="cm"> * ==================</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Interrupt processing routine</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   irq        - interrupt vector</span>
<span class="cm"> *   dev_id     - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This routine calls the interrupt processing routine for this adapter.  It</span>
<span class="cm"> *   disables and reenables adapter interrupts, as appropriate.  We can support</span>
<span class="cm"> *   shared interrupts since the incoming dev_id pointer provides our device</span>
<span class="cm"> *   structure context. All the real work is done in the hardware module.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   None</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   The interrupt acknowledgement at the hardware level (eg. ACKing the PIC</span>
<span class="cm"> *   on Intel-based systems) is done by the operating system outside this</span>
<span class="cm"> *   routine.</span>
<span class="cm"> *</span>
<span class="cm"> *       System interrupts are enabled through this call.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   Interrupts are disabled, then reenabled at the adapter.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">skfp_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">;</span>	<span class="cm">/* private board structure pointer */</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

	<span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>IRQs enabled or disabled ?</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">inpd</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_IMSK</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>IRQs are disabled: must be shared interrupt</p></td><td class="code"><div class="highlight"><pre>		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Note: At this point, IRQs are enabled.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">((</span><span class="n">inpd</span><span class="p">(</span><span class="n">ISR_A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">is_imask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// IRQ?</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>Adapter did not issue an IRQ: must be shared interrupt</p></td><td class="code"><div class="highlight"><pre>		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">CLI_FBI</span><span class="p">();</span>		<span class="c1">// Disable IRQs from our adapter.</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>Call interrupt handler in hardware module (HWM).</p></td><td class="code"><div class="highlight"><pre>	<span class="n">fddi_isr</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">ResetRequested</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ResetAdapter</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">ResetRequested</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">);</span>
	<span class="n">STI_FBI</span><span class="p">();</span>		<span class="c1">// Enable IRQs from our adapter.</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// skfp_interrupt</span>


<span class="cm">/*</span>
<span class="cm"> * ======================</span>
<span class="cm"> * = skfp_ctl_get_stats =</span>
<span class="cm"> * ======================</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Get statistics for FDDI adapter</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Pointer to FDDI statistics structure</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Gets current MIB objects from adapter, then</span>
<span class="cm"> *   returns FDDI statistics structure as defined</span>
<span class="cm"> *   in if_fddi.h.</span>
<span class="cm"> *</span>
<span class="cm"> *   Note: Since the FDDI statistics structure is</span>
<span class="cm"> *   still new and the device structure doesn&#39;t</span>
<span class="cm"> *   have an FDDI-specific get statistics handler,</span>
<span class="cm"> *   we&#39;ll return the FDDI statistics structure as</span>
<span class="cm"> *   a pointer to an Ethernet statistics structure.</span>
<span class="cm"> *   That way, at least the first part of the statistics</span>
<span class="cm"> *   structure can be decoded properly.</span>
<span class="cm"> *   We&#39;ll have to pay attention to this routine as the</span>
<span class="cm"> *   device structure becomes more mature and LAN media</span>
<span class="cm"> *   independent.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">skfp_ctl_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Fill the bp-&gt;stats structure with driver-maintained counters */</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">port_bs_flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">port_bs_flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x5678</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>goos: need to fill out fddi statistic</p></td><td class="code"><div class="highlight"><pre><span class="cp">#if 0</span><span class="c"></span>
<span class="c">	/* Get FDDI SMT MIB objects */</span>

<span class="c">/* Fill the bp-&gt;stats structure with the SMT MIB object values */</span>

<span class="c">	memcpy(bp-&gt;stats.smt_station_id, &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_id, sizeof(bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_id));</span>
<span class="c">	bp-&gt;stats.smt_op_version_id = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_op_version_id;</span>
<span class="c">	bp-&gt;stats.smt_hi_version_id = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_hi_version_id;</span>
<span class="c">	bp-&gt;stats.smt_lo_version_id = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_lo_version_id;</span>
<span class="c">	memcpy(bp-&gt;stats.smt_user_data, &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_user_data, sizeof(bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_user_data));</span>
<span class="c">	bp-&gt;stats.smt_mib_version_id = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_mib_version_id;</span>
<span class="c">	bp-&gt;stats.smt_mac_cts = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_mac_ct;</span>
<span class="c">	bp-&gt;stats.smt_non_master_cts = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_non_master_ct;</span>
<span class="c">	bp-&gt;stats.smt_master_cts = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_master_ct;</span>
<span class="c">	bp-&gt;stats.smt_available_paths = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_available_paths;</span>
<span class="c">	bp-&gt;stats.smt_config_capabilities = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_config_capabilities;</span>
<span class="c">	bp-&gt;stats.smt_config_policy = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_config_policy;</span>
<span class="c">	bp-&gt;stats.smt_connection_policy = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_connection_policy;</span>
<span class="c">	bp-&gt;stats.smt_t_notify = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_t_notify;</span>
<span class="c">	bp-&gt;stats.smt_stat_rpt_policy = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_stat_rpt_policy;</span>
<span class="c">	bp-&gt;stats.smt_trace_max_expiration = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_trace_max_expiration;</span>
<span class="c">	bp-&gt;stats.smt_bypass_present = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_bypass_present;</span>
<span class="c">	bp-&gt;stats.smt_ecm_state = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_ecm_state;</span>
<span class="c">	bp-&gt;stats.smt_cf_state = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_cf_state;</span>
<span class="c">	bp-&gt;stats.smt_remote_disconnect_flag = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_remote_disconnect_flag;</span>
<span class="c">	bp-&gt;stats.smt_station_status = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_station_status;</span>
<span class="c">	bp-&gt;stats.smt_peer_wrap_flag = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_peer_wrap_flag;</span>
<span class="c">	bp-&gt;stats.smt_time_stamp = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_msg_time_stamp.ls;</span>
<span class="c">	bp-&gt;stats.smt_transition_time_stamp = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.smt_transition_time_stamp.ls;</span>
<span class="c">	bp-&gt;stats.mac_frame_status_functions = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_status_functions;</span>
<span class="c">	bp-&gt;stats.mac_t_max_capability = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_max_capability;</span>
<span class="c">	bp-&gt;stats.mac_tvx_capability = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_tvx_capability;</span>
<span class="c">	bp-&gt;stats.mac_available_paths = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_available_paths;</span>
<span class="c">	bp-&gt;stats.mac_current_path = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_current_path;</span>
<span class="c">	memcpy(bp-&gt;stats.mac_upstream_nbr, &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_upstream_nbr, FDDI_K_ALEN);</span>
<span class="c">	memcpy(bp-&gt;stats.mac_downstream_nbr, &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_downstream_nbr, FDDI_K_ALEN);</span>
<span class="c">	memcpy(bp-&gt;stats.mac_old_upstream_nbr, &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_old_upstream_nbr, FDDI_K_ALEN);</span>
<span class="c">	memcpy(bp-&gt;stats.mac_old_downstream_nbr, &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_old_downstream_nbr, FDDI_K_ALEN);</span>
<span class="c">	bp-&gt;stats.mac_dup_address_test = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_dup_address_test;</span>
<span class="c">	bp-&gt;stats.mac_requested_paths = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_requested_paths;</span>
<span class="c">	bp-&gt;stats.mac_downstream_port_type = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_downstream_port_type;</span>
<span class="c">	memcpy(bp-&gt;stats.mac_smt_address, &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_smt_address, FDDI_K_ALEN);</span>
<span class="c">	bp-&gt;stats.mac_t_req = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_req;</span>
<span class="c">	bp-&gt;stats.mac_t_neg = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_neg;</span>
<span class="c">	bp-&gt;stats.mac_t_max = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_t_max;</span>
<span class="c">	bp-&gt;stats.mac_tvx_value = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_tvx_value;</span>
<span class="c">	bp-&gt;stats.mac_frame_error_threshold = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_threshold;</span>
<span class="c">	bp-&gt;stats.mac_frame_error_ratio = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_ratio;</span>
<span class="c">	bp-&gt;stats.mac_rmt_state = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_rmt_state;</span>
<span class="c">	bp-&gt;stats.mac_da_flag = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_da_flag;</span>
<span class="c">	bp-&gt;stats.mac_una_da_flag = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_unda_flag;</span>
<span class="c">	bp-&gt;stats.mac_frame_error_flag = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_frame_error_flag;</span>
<span class="c">	bp-&gt;stats.mac_ma_unitdata_available = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_ma_unitdata_available;</span>
<span class="c">	bp-&gt;stats.mac_hardware_present = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_hardware_present;</span>
<span class="c">	bp-&gt;stats.mac_ma_unitdata_enable = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.mac_ma_unitdata_enable;</span>
<span class="c">	bp-&gt;stats.path_tvx_lower_bound = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_tvx_lower_bound;</span>
<span class="c">	bp-&gt;stats.path_t_max_lower_bound = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_t_max_lower_bound;</span>
<span class="c">	bp-&gt;stats.path_max_t_req = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_max_t_req;</span>
<span class="c">	memcpy(bp-&gt;stats.path_configuration, &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_configuration, sizeof(bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.path_configuration));</span>
<span class="c">	bp-&gt;stats.port_my_type[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_my_type[0];</span>
<span class="c">	bp-&gt;stats.port_my_type[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_my_type[1];</span>
<span class="c">	bp-&gt;stats.port_neighbor_type[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_neighbor_type[0];</span>
<span class="c">	bp-&gt;stats.port_neighbor_type[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_neighbor_type[1];</span>
<span class="c">	bp-&gt;stats.port_connection_policies[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_policies[0];</span>
<span class="c">	bp-&gt;stats.port_connection_policies[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_policies[1];</span>
<span class="c">	bp-&gt;stats.port_mac_indicated[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_indicated[0];</span>
<span class="c">	bp-&gt;stats.port_mac_indicated[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_indicated[1];</span>
<span class="c">	bp-&gt;stats.port_current_path[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_current_path[0];</span>
<span class="c">	bp-&gt;stats.port_current_path[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_current_path[1];</span>
<span class="c">	memcpy(&amp;bp-&gt;stats.port_requested_paths[0 * 3], &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_requested_paths[0], 3);</span>
<span class="c">	memcpy(&amp;bp-&gt;stats.port_requested_paths[1 * 3], &amp;bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_requested_paths[1], 3);</span>
<span class="c">	bp-&gt;stats.port_mac_placement[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_placement[0];</span>
<span class="c">	bp-&gt;stats.port_mac_placement[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_mac_placement[1];</span>
<span class="c">	bp-&gt;stats.port_available_paths[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_available_paths[0];</span>
<span class="c">	bp-&gt;stats.port_available_paths[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_available_paths[1];</span>
<span class="c">	bp-&gt;stats.port_pmd_class[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pmd_class[0];</span>
<span class="c">	bp-&gt;stats.port_pmd_class[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pmd_class[1];</span>
<span class="c">	bp-&gt;stats.port_connection_capabilities[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_capabilities[0];</span>
<span class="c">	bp-&gt;stats.port_connection_capabilities[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connection_capabilities[1];</span>
<span class="c">	bp-&gt;stats.port_bs_flag[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_bs_flag[0];</span>
<span class="c">	bp-&gt;stats.port_bs_flag[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_bs_flag[1];</span>
<span class="c">	bp-&gt;stats.port_ler_estimate[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_estimate[0];</span>
<span class="c">	bp-&gt;stats.port_ler_estimate[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_estimate[1];</span>
<span class="c">	bp-&gt;stats.port_ler_cutoff[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_cutoff[0];</span>
<span class="c">	bp-&gt;stats.port_ler_cutoff[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_cutoff[1];</span>
<span class="c">	bp-&gt;stats.port_ler_alarm[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_alarm[0];</span>
<span class="c">	bp-&gt;stats.port_ler_alarm[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_alarm[1];</span>
<span class="c">	bp-&gt;stats.port_connect_state[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connect_state[0];</span>
<span class="c">	bp-&gt;stats.port_connect_state[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_connect_state[1];</span>
<span class="c">	bp-&gt;stats.port_pcm_state[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pcm_state[0];</span>
<span class="c">	bp-&gt;stats.port_pcm_state[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pcm_state[1];</span>
<span class="c">	bp-&gt;stats.port_pc_withhold[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pc_withhold[0];</span>
<span class="c">	bp-&gt;stats.port_pc_withhold[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_pc_withhold[1];</span>
<span class="c">	bp-&gt;stats.port_ler_flag[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_flag[0];</span>
<span class="c">	bp-&gt;stats.port_ler_flag[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_ler_flag[1];</span>
<span class="c">	bp-&gt;stats.port_hardware_present[0] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_hardware_present[0];</span>
<span class="c">	bp-&gt;stats.port_hardware_present[1] = bp-&gt;cmd_rsp_virt-&gt;smt_mib_get.port_hardware_present[1];</span>


<span class="c">	/* Fill the bp-&gt;stats structure with the FDDI counter values */</span>

<span class="c">	bp-&gt;stats.mac_frame_cts = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.frame_cnt.ls;</span>
<span class="c">	bp-&gt;stats.mac_copied_cts = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.copied_cnt.ls;</span>
<span class="c">	bp-&gt;stats.mac_transmit_cts = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.transmit_cnt.ls;</span>
<span class="c">	bp-&gt;stats.mac_error_cts = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.error_cnt.ls;</span>
<span class="c">	bp-&gt;stats.mac_lost_cts = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lost_cnt.ls;</span>
<span class="c">	bp-&gt;stats.port_lct_fail_cts[0] = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lct_rejects[0].ls;</span>
<span class="c">	bp-&gt;stats.port_lct_fail_cts[1] = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lct_rejects[1].ls;</span>
<span class="c">	bp-&gt;stats.port_lem_reject_cts[0] = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lem_rejects[0].ls;</span>
<span class="c">	bp-&gt;stats.port_lem_reject_cts[1] = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.lem_rejects[1].ls;</span>
<span class="c">	bp-&gt;stats.port_lem_cts[0] = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.link_errors[0].ls;</span>
<span class="c">	bp-&gt;stats.port_lem_cts[1] = bp-&gt;cmd_rsp_virt-&gt;cntrs_get.cntrs.link_errors[1].ls;</span>

<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// ctl_get_stat</span>


<span class="cm">/*</span>
<span class="cm"> * ==============================</span>
<span class="cm"> * = skfp_ctl_set_multicast_list =</span>
<span class="cm"> * ==============================</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Enable/Disable LLC frame promiscuous mode reception</span>
<span class="cm"> *   on the adapter and/or update multicast address table.</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   This function acquires the driver lock and only calls</span>
<span class="cm"> *   skfp_ctl_set_multicast_list_wo_lock then.</span>
<span class="cm"> *   This routine follows a fairly simple algorithm for setting the</span>
<span class="cm"> *   adapter filters and CAM:</span>
<span class="cm"> *</span>
<span class="cm"> *      if IFF_PROMISC flag is set</span>
<span class="cm"> *              enable promiscuous mode</span>
<span class="cm"> *      else</span>
<span class="cm"> *              disable promiscuous mode</span>
<span class="cm"> *              if number of multicast addresses &lt;= max. multicast number</span>
<span class="cm"> *                      add mc addresses to adapter table</span>
<span class="cm"> *              else</span>
<span class="cm"> *                      enable promiscuous mode</span>
<span class="cm"> *              update adapter filters</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   Multicast addresses are presented in canonical (LSB) format.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   On-board adapter filters are updated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">skfp_ctl_set_multicast_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">,</span> <span class="n">Flags</span><span class="p">);</span>
	<span class="n">skfp_ctl_set_multicast_list_wo_lock</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">,</span> <span class="n">Flags</span><span class="p">);</span>
<span class="p">}</span>				<span class="c1">// skfp_ctl_set_multicast_list</span>



<span class="k">static</span> <span class="kt">void</span> <span class="nf">skfp_ctl_set_multicast_list_wo_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

	<span class="cm">/* Enable promiscuous mode, if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mac_drv_rx_mode</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">RX_ENABLE_PROMISC</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PROMISCUOUS MODE ENABLED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Else, update multicast address table */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mac_drv_rx_mode</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">RX_DISABLE_PROMISC</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;PROMISCUOUS MODE DISABLED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Reset all MC addresses</p></td><td class="code"><div class="highlight"><pre>		<span class="n">mac_clear_multicast</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
		<span class="n">mac_drv_rx_mode</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">RX_DISABLE_ALLMULTI</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mac_drv_rx_mode</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">RX_ENABLE_ALLMULTI</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ENABLE ALL MC ADDRESSES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">FPMAX_MULTICAST</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* use exact filtering */</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>point to first multicast addr</p></td><td class="code"><div class="highlight"><pre>				<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mac_add_multicast</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span>
						<span class="p">(</span><span class="k">struct</span> <span class="n">fddi_addr</span> <span class="o">*</span><span class="p">)</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span>
						<span class="mi">1</span><span class="p">);</span>

					<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ENABLE MC ADDRESS: %pMF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
				<span class="p">}</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="c1">// more MC addresses than HW supports</span>

				<span class="n">mac_drv_rx_mode</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">RX_ENABLE_ALLMULTI</span><span class="p">);</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ENABLE ALL MC ADDRESSES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="c1">// no MC addresses</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;DISABLE ALL MC ADDRESSES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Update adapter filters */</span>
		<span class="n">mac_update_multicast</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>				<span class="c1">// skfp_ctl_set_multicast_list_wo_lock</span>


<span class="cm">/*</span>
<span class="cm"> * ===========================</span>
<span class="cm"> * = skfp_ctl_set_mac_address =</span>
<span class="cm"> * ===========================</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   set new mac address on adapter and update dev_addr field in device table.</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev  - pointer to device information</span>
<span class="cm"> *   addr - pointer to sockaddr structure containing unicast address to set</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   The address pointed to by addr-&gt;sa_data is a valid unicast</span>
<span class="cm"> *   address and is presented in canonical (LSB) format.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">skfp_ctl_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">p_sockaddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Flags</span><span class="p">;</span>


	<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">p_sockaddr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">FDDI_K_ALEN</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">,</span> <span class="n">Flags</span><span class="p">);</span>
	<span class="n">ResetAdapter</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">,</span> <span class="n">Flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* always return zero */</span>
<span class="p">}</span>				<span class="c1">// skfp_ctl_set_mac_address</span>


<span class="cm">/*</span>
<span class="cm"> * ==============</span>
<span class="cm"> * = skfp_ioctl =</span>
<span class="cm"> * ==============</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *</span>
<span class="cm"> * Perform IOCTL call functions here. Some are privileged operations and the</span>
<span class="cm"> * effective uid is checked in those cases.</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   status value</span>
<span class="cm"> *   0 - success</span>
<span class="cm"> *   other - failure</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   dev  - pointer to device information</span>
<span class="cm"> *   rq - pointer to ioctl request structure</span>
<span class="cm"> *   cmd - ?</span>
<span class="cm"> *</span>
<span class="cm"> */</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">skfp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_skfp_ioctl</span> <span class="n">ioc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ioc</span><span class="p">,</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_skfp_ioctl</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ioc</span><span class="p">.</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SKFP_GET_STATS</span>:	<span class="cm">/* Get the driver statistics */</span>
		<span class="n">ioc</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">MacStat</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ioc</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">skfp_ctl_get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">ioc</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
				<span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SKFP_CLR_STATS</span>:	<span class="cm">/* Zero out the driver statistics */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">MacStat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">MacStat</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;ioctl for %s: unknown cmd: %04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ioc</span><span class="p">.</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="p">}</span>			<span class="c1">// switch</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// skfp_ioctl</span>


<span class="cm">/*</span>
<span class="cm"> * =====================</span>
<span class="cm"> * = skfp_send_pkt     =</span>
<span class="cm"> * =====================</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Queues a packet for transmission and try to transmit it.</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   Condition code</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   skb - pointer to sk_buff to queue for transmission</span>
<span class="cm"> *   dev - pointer to device information</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Here we assume that an incoming skb transmit request</span>
<span class="cm"> *   is contained in a single physically contiguous buffer</span>
<span class="cm"> *   in which the virtual address of the start of packet</span>
<span class="cm"> *   (skb-&gt;data) can be converted to a physical address</span>
<span class="cm"> *   by using pci_map_single().</span>
<span class="cm"> *</span>
<span class="cm"> *   We have an internal queue for packets we can not send </span>
<span class="cm"> *   immediately. Packets in this queue can be given to the </span>
<span class="cm"> *   adapter if transmit buffers are freed.</span>
<span class="cm"> *</span>
<span class="cm"> *   We can&#39;t free the skb until after it&#39;s been DMA&#39;d</span>
<span class="cm"> *   out by the adapter, so we&#39;ll keep it in the driver and</span>
<span class="cm"> *   return it in mac_drv_tx_complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Codes:</span>
<span class="cm"> *   0 - driver has queued and/or sent packet</span>
<span class="cm"> *       1 - caller should requeue the sk_buff for later transmission</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *   The entire packet is stored in one physically</span>
<span class="cm"> *   contiguous buffer which is not cached and whose</span>
<span class="cm"> *   32-bit physical address can be determined.</span>
<span class="cm"> *</span>
<span class="cm"> *   It&#39;s vital that this routine is NOT reentered for the</span>
<span class="cm"> *   same board and that the OS is not in another section of</span>
<span class="cm"> *   code (eg. skfp_interrupt) for the same board on a</span>
<span class="cm"> *   different thread.</span>
<span class="cm"> *</span>
<span class="cm"> * Side Effects:</span>
<span class="cm"> *   None</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">skfp_send_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;skfp_send_pkt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Verify that incoming transmit request is OK</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: The packet size check is consistent with other</span>
<span class="cm">	 *               Linux device drivers, although the correct packet</span>
<span class="cm">	 *               size should be verified before calling the</span>
<span class="cm">	 *               transmit routine.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">FDDI_K_LLC_ZLEN</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">FDDI_K_LLC_LEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* bump error counter */</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>dequeue packets from xmt queue and send them</p></td><td class="code"><div class="highlight"><pre>		<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>	<span class="cm">/* return &quot;success&quot; */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">QueueSkb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// return with tbusy set: queue full</span>

		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">QueueSkb</span><span class="o">--</span><span class="p">;</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SendSkbQueue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">send_queued_packets</span><span class="p">(</span><span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">QueueSkb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

<span class="p">}</span>				<span class="c1">// skfp_send_pkt</span>


<span class="cm">/*</span>
<span class="cm"> * =======================</span>
<span class="cm"> * = send_queued_packets =</span>
<span class="cm"> * =======================</span>
<span class="cm"> *   </span>
<span class="cm"> * Overview:</span>
<span class="cm"> *   Send packets from the driver queue as long as there are some and</span>
<span class="cm"> *   transmit resources are available.</span>
<span class="cm"> *  </span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   None</span>
<span class="cm"> *       </span>
<span class="cm"> * Arguments:</span>
<span class="cm"> *   smc - pointer to smc (adapter) structure</span>
<span class="cm"> *</span>
<span class="cm"> * Functional Description:</span>
<span class="cm"> *   Take a packet from queue if there is any. If not, then we are done.</span>
<span class="cm"> *   Check if there are resources to send the packet. If not, requeue it</span>
<span class="cm"> *   and exit. </span>
<span class="cm"> *   Set packet descriptor flags and give packet to adapter.</span>
<span class="cm"> *   Check if any send resources can be freed (we do not use the</span>
<span class="cm"> *   transmit complete interrupt).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">send_queued_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="o">*</span><span class="n">txd</span><span class="p">;</span>	<span class="c1">// Current TxD.</span>
	<span class="n">dma_addr_t</span> <span class="n">dma_address</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">Flags</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">frame_status</span><span class="p">;</span>	<span class="c1">// HWM tx frame status.</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;send queued packets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>send first buffer from queue</p></td><td class="code"><div class="highlight"><pre>		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SendSkbQueue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;queue empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>		<span class="c1">// queue empty !</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">,</span> <span class="n">Flags</span><span class="p">);</span>
		<span class="n">fc</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">queue</span> <span class="o">=</span> <span class="p">(</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">FC_SYNC_BIT</span><span class="p">)</span> <span class="o">?</span> <span class="n">QUEUE_S</span> <span class="o">:</span> <span class="n">QUEUE_A0</span><span class="p">;</span>
<span class="cp">#ifdef ESS</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>Check if the frame may/must be sent as a synchronous frame.</p></td><td class="code"><div class="highlight"><pre>		<span class="k">if</span> <span class="p">((</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_SYNC_BIT</span> <span class="o">|</span> <span class="n">FC_LLC_PRIOR</span><span class="p">))</span> <span class="o">==</span> <span class="n">FC_ASYNC_LLC</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>It's an LLC frame.</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">ess</span><span class="p">.</span><span class="n">sync_bw_available</span><span class="p">)</span>
				<span class="n">fc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_SYNC_BIT</span><span class="p">;</span> <span class="c1">// No bandwidth available.</span>

			<span class="k">else</span> <span class="p">{</span>	<span class="c1">// Bandwidth is available.</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">mib</span><span class="p">.</span><span class="n">fddiESSSynchTxMode</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>Send as sync. frame.</p></td><td class="code"><div class="highlight"><pre>					<span class="n">fc</span> <span class="o">|=</span> <span class="n">FC_SYNC_BIT</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="cp">#endif				</span><span class="c1">// ESS</span>
		<span class="n">frame_status</span> <span class="o">=</span> <span class="n">hwm_tx_init</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LOC_TX</span> <span class="o">|</span> <span class="n">LAN_TX</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>Unable to send the frame.</p></td><td class="code"><div class="highlight"><pre>			<span class="k">if</span> <span class="p">((</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="n">RING_DOWN</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Ring is down.</p></td><td class="code"><div class="highlight"><pre>				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Tx attempt while ring down.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="n">OUT_OF_TXD</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: out of TXDs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: out of transmit resources&quot;</span><span class="p">,</span>
					<span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="p">}</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>Note: We will retry the operation as soon as
transmit resources become available.</p></td><td class="code"><div class="highlight"><pre>			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">SendSkbQueue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">,</span> <span class="n">Flags</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>	<span class="c1">// Packet has been queued.</span>

		<span class="p">}</span>		<span class="c1">// if (unable to send frame)</span>

		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">QueueSkb</span><span class="o">++</span><span class="p">;</span>	<span class="c1">// one packet less in local queue</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>source address in packet ?</p></td><td class="code"><div class="highlight"><pre>		<span class="n">CheckSourceAddress</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_canon_addr</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>

		<span class="n">txd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="o">*</span><span class="p">)</span> <span class="n">HWM_GET_CURR_TXD</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>

		<span class="n">dma_address</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
					     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="n">LAN_TX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">txd</span><span class="o">-&gt;</span><span class="n">txd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>			<span class="c1">// save skb</span>
			<span class="n">txd</span><span class="o">-&gt;</span><span class="n">txd_os</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">dma_address</span><span class="p">;</span>	<span class="c1">// save dma mapping</span>
		<span class="p">}</span>
		<span class="n">hwm_tx_frag</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dma_address</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
                      <span class="n">frame_status</span> <span class="o">|</span> <span class="n">FIRST_FRAG</span> <span class="o">|</span> <span class="n">LAST_FRAG</span> <span class="o">|</span> <span class="n">EN_IRQ_EOF</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">frame_status</span> <span class="o">&amp;</span> <span class="n">LAN_TX</span><span class="p">))</span> <span class="p">{</span>		<span class="c1">// local only frame</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_address</span><span class="p">,</span>
					 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">,</span> <span class="n">Flags</span><span class="p">);</span>
	<span class="p">}</span>			<span class="c1">// for</span>

	<span class="k">return</span><span class="p">;</span>			<span class="c1">// never reached</span>

<span class="p">}</span>				<span class="c1">// send_queued_packets</span>


<span class="cm">/************************</span>
<span class="cm"> * </span>
<span class="cm"> * CheckSourceAddress</span>
<span class="cm"> *</span>
<span class="cm"> * Verify if the source address is set. Insert it if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">CheckSourceAddress</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hw_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">SRBit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">frame</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span><span class="p">])</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x01</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// source routing bit</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span> <span class="n">frame</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">SRBit</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span><span class="p">],</span> <span class="n">hw_addr</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">frame</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="n">SRBit</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// CheckSourceAddress</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	ResetAdapter</span>
<span class="cm"> *</span>
<span class="cm"> *	Reset the adapter and bring it back to operational mode.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ResetAdapter</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;[fddi: ResetAdapter]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>Stop the adapter.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">card_stop</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>		<span class="c1">// Stop all activity.</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>Clear the transmit and receive descriptor queues.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">mac_drv_clear_tx_queue</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
	<span class="n">mac_drv_clear_rx_queue</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>Restart the adapter.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">smt_reset_defaults</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="c1">// Initialize the SMT module.</span>

	<span class="n">init_smt</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>	<span class="c1">// Initialize the hardware.</span>

	<span class="n">smt_online</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="c1">// Insert into the ring again.</span>
	<span class="n">STI_FBI</span><span class="p">();</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>Restore original receive mode (multicasts, promiscuous, etc.).</p></td><td class="code"><div class="highlight"><pre>	<span class="n">skfp_ctl_set_multicast_list_wo_lock</span><span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>				<span class="c1">// ResetAdapter</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>--------------- functions called by hardware module ----------------</p></td><td class="code"><div class="highlight"><pre><span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	llc_restart_tx</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware driver calls this routine when the transmit complete</span>
<span class="cm"> *	interrupt bits (end of frame) for the synchronous or asynchronous</span>
<span class="cm"> *	queue is set.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE The hardware driver calls this function also if no packets are queued.</span>
<span class="cm"> *	The routine must be able to handle this case.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">llc_restart_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;[llc_restart_tx]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>Try to send queued packets</p></td><td class="code"><div class="highlight"><pre>	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">);</span>
	<span class="n">send_queued_packets</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">DriverLock</span><span class="p">);</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span><span class="c1">// system may send again if it was blocked</span>

<span class="p">}</span>				<span class="c1">// llc_restart_tx</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_get_space</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware module calls this function to allocate the memory</span>
<span class="cm"> *	for the SMT MBufs if the define MB_OUTSIDE_SMC is specified.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	size - Size of memory in bytes to allocate.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	!= 0	A pointer to the virtual address of the allocated memory.</span>
<span class="cm"> *	== 0	Allocation error.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mac_drv_get_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;mac_drv_get_space (%d bytes), &quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">virt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span> <span class="o">+</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemHeap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemHeap</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Unexpected SMT memory size requested: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemHeap</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>	<span class="c1">// Move heap pointer.</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;mac_drv_get_space end</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;virt addr: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span> <span class="n">virt</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;bus  addr: %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span>
	       <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemDMA</span> <span class="o">+</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">virt</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span><span class="p">)));</span>
	<span class="k">return</span> <span class="n">virt</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// mac_drv_get_space</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_get_desc_mem</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called by the hardware dependent module.</span>
<span class="cm"> *	It allocates the memory for the RxD and TxD descriptors.</span>
<span class="cm"> *</span>
<span class="cm"> *	This memory must be non-cached, non-movable and non-swappable.</span>
<span class="cm"> *	This memory should start at a physical page boundary.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	size - Size of memory in bytes to allocate.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	!= 0	A pointer to the virtual address of the allocated memory.</span>
<span class="cm"> *	== 0	Allocation error.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mac_drv_get_desc_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">char</span> <span class="o">*</span><span class="n">virt</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;mac_drv_get_desc_mem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Descriptor memory must be aligned on 16-byte boundary.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">virt</span> <span class="o">=</span> <span class="n">mac_drv_get_space</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span> <span class="p">(</span><span class="mi">16</span> <span class="o">-</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">virt</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">15UL</span><span class="p">));</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Allocate %u bytes alignment gap &quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;for descriptor memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mac_drv_get_space</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;fddi: Unable to align descriptor memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">virt</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// mac_drv_get_desc_mem</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_virt2phys</span>
<span class="cm"> *</span>
<span class="cm"> *	Get the physical address of a given virtual address.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	virt - A (virtual) pointer into our &#39;shared&#39; memory area.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Physical address of the given virtual address.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mac_drv_virt2phys</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemDMA</span> <span class="o">+</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">virt</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span><span class="p">);</span>
<span class="p">}</span>				<span class="c1">// mac_drv_virt2phys</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	dma_master</span>
<span class="cm"> *</span>
<span class="cm"> *	The HWM calls this function, when the driver leads through a DMA</span>
<span class="cm"> *	transfer. If the OS-specific module must prepare the system hardware</span>
<span class="cm"> *	for the DMA transfer, it should do it in this function.</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware module calls this dma_master if it wants to send an SMT</span>
<span class="cm"> *	frame.  This means that the virt address passed in here is part of</span>
<span class="cm"> *      the &#39;shared&#39; memory area.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	virt - The virtual address of the data.</span>
<span class="cm"> *</span>
<span class="cm"> *	len - The length in bytes of the data.</span>
<span class="cm"> *</span>
<span class="cm"> *	flag - Indicates the transmit direction and the buffer type:</span>
<span class="cm"> *		DMA_RD	(0x01)	system RAM ==&gt; adapter buffer memory</span>
<span class="cm"> *		DMA_WR	(0x02)	adapter buffer memory ==&gt; system RAM</span>
<span class="cm"> *		SMT_BUF (0x80)	SMT buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	&gt;&gt; NOTE: SMT_BUF and DMA_RD are always set for PCI. &lt;&lt;</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Returns the pyhsical address for the DMA transfer.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="n">u_long</span> <span class="nf">dma_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span> <span class="n">smc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemDMA</span> <span class="o">+</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">virt</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">SharedMemAddr</span><span class="p">);</span>
<span class="p">}</span>				<span class="c1">// dma_master</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	dma_complete</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware module calls this routine when it has completed a DMA</span>
<span class="cm"> *	transfer. If the operating system dependent module has set up the DMA</span>
<span class="cm"> *	channel via dma_master() (e.g. Windows NT or AIX) it should clean up</span>
<span class="cm"> *	the DMA channel.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	descr - A pointer to a TxD or RxD, respectively.</span>
<span class="cm"> *</span>
<span class="cm"> *	flag - Indicates the DMA transfer direction / SMT buffer:</span>
<span class="cm"> *		DMA_RD	(0x01)	system RAM ==&gt; adapter buffer memory</span>
<span class="cm"> *		DMA_WR	(0x02)	adapter buffer memory ==&gt; system RAM</span>
<span class="cm"> *		SMT_BUF (0x80)	SMT buffer (managed by HWM)</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">dma_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">union</span> <span class="n">s_fp_descr</span> <span class="o">*</span><span class="n">descr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* For TX buffers, there are two cases.  If it is an SMT transmit</span>
<span class="cm">	 * buffer, there is nothing to do since we use consistent memory</span>
<span class="cm">	 * for the &#39;shared&#39; memory area.  The other case is for normal</span>
<span class="cm">	 * transmit packets given to us by the networking stack, and in</span>
<span class="cm">	 * that case we cleanup the PCI DMA mapping in mac_drv_tx_complete</span>
<span class="cm">	 * below.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For RX buffers, we have to unmap dynamic PCI DMA mappings here</span>
<span class="cm">	 * because the hardware module is about to potentially look at</span>
<span class="cm">	 * the contents of the buffer.  If we did not call the PCI DMA</span>
<span class="cm">	 * unmap first, the hardware module could read inconsistent data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">DMA_WR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>
		<span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">descr</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">;</span>

		<span class="cm">/* If SKB is NULL, we used the local buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">MaxFrameSize</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">MaxFrameSize</span><span class="p">;</span>

			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
					 <span class="n">MaxFrameSize</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">r</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>				<span class="c1">// dma_complete</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_tx_complete</span>
<span class="cm"> *</span>
<span class="cm"> *	Transmit of a packet is complete. Release the tx staging buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	txd - A pointer to the last TxD which is used by the frame.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Returns nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">mac_drv_tx_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="o">*</span><span class="n">txd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering mac_drv_tx_complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>Check if this TxD points to a skb</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">txd</span><span class="o">-&gt;</span><span class="n">txd_os</span><span class="p">.</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;TXD with no skb assigned.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">txd</span><span class="o">-&gt;</span><span class="n">txd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>release the DMA mapping</p></td><td class="code"><div class="highlight"><pre>	<span class="n">pci_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">pdev</span><span class="p">,</span> <span class="n">txd</span><span class="o">-&gt;</span><span class="n">txd_os</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
			 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
	<span class="n">txd</span><span class="o">-&gt;</span><span class="n">txd_os</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>	<span class="c1">// Count transmitted packets.</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">tx_bytes</span><span class="o">+=</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>	<span class="c1">// Count bytes</span></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>free the skb</p></td><td class="code"><div class="highlight"><pre>	<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;leaving mac_drv_tx_complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>				<span class="c1">// mac_drv_tx_complete</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> * dump packets to logfile</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="cp">#ifdef DUMPPACKETS</span>
<span class="kt">void</span> <span class="nf">dump_data</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">255</span><span class="p">],</span> <span class="n">sh</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">length</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;---Packet start---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%02x %02x %02x %02x %02x %02x %02x %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span> <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span>
		       <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">4</span><span class="p">],</span> <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">5</span><span class="p">],</span> <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">6</span><span class="p">],</span> <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">7</span><span class="p">]);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="n">Data</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">]);</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>				<span class="c1">// dump_data</span>
<span class="cp">#else</span>
<span class="cp">#define dump_data(data,len)</span>
<span class="cp">#endif				</span><span class="c1">// DUMPPACKETS</span>

<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_rx_complete</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware module calls this function if an LLC frame is received</span>
<span class="cm"> *	in a receive buffer. Also the SMT, NSA, and directed beacon frames</span>
<span class="cm"> *	from the network will be passed to the LLC layer by this function</span>
<span class="cm"> *	if passing is enabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_rx_complete forwards the frame to the LLC layer if it should</span>
<span class="cm"> *	be received. It also fills the RxD ring with new receive buffers if</span>
<span class="cm"> *	some can be queued.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	rxd - A pointer to the first RxD which is used by the receive frame.</span>
<span class="cm"> *</span>
<span class="cm"> *	frag_count - Count of RxDs used by the received frame.</span>
<span class="cm"> *</span>
<span class="cm"> *	len - Frame length.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">mac_drv_rx_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">rxd</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">frag_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">virt</span><span class="p">,</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ri</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">RifLength</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering mac_drv_rx_complete (len=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frag_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// This is not allowed to happen.</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;fddi: Multi-fragment receive!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">RequeueRxd</span><span class="p">;</span>	<span class="c1">// Re-use the given RXD(s).</span>

	<span class="p">}</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;No skb in rxd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">RequeueRxd</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">virt</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>The DMA mapping was released in dma_complete above.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">dump_data</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * FDDI Frame format:</span>
<span class="cm">	 * +-------+-------+-------+------------+--------+------------+</span>
<span class="cm">	 * | FC[1] | DA[6] | SA[6] | RIF[0..18] | LLC[3] | Data[0..n] |</span>
<span class="cm">	 * +-------+-------+-------+------------+--------+------------+</span>
<span class="cm">	 *</span>
<span class="cm">	 * FC = Frame Control</span>
<span class="cm">	 * DA = Destination Address</span>
<span class="cm">	 * SA = Source Address</span>
<span class="cm">	 * RIF = Routing Information Field</span>
<span class="cm">	 * LLC = Logical Link Control</span>
<span class="cm">	 */</span></pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><p>Remove Routing Information Field (RIF), if present.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">((</span><span class="n">virt</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">FDDI_RII</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">RifLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>goos: RIF removal has still to be tested</p></td><td class="code"><div class="highlight"><pre>		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RIF found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-40"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-40">&#182;</a></div><p>Get RIF length from Routing Control (RC) field.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">cp</span> <span class="o">=</span> <span class="n">virt</span> <span class="o">+</span> <span class="n">FDDI_MAC_HDR_LEN</span><span class="p">;</span>	<span class="c1">// Point behind MAC header.</span>

		<span class="n">ri</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span> <span class="n">cp</span><span class="p">));</span>
		<span class="n">RifLength</span> <span class="o">=</span> <span class="n">ri</span> <span class="o">&amp;</span> <span class="n">FDDI_RCF_LEN_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">FDDI_MAC_HDR_LEN</span> <span class="o">+</span> <span class="n">RifLength</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;fddi: Invalid RIF.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">RequeueRxd</span><span class="p">;</span>	<span class="c1">// Discard the frame.</span>

		<span class="p">}</span>
		<span class="n">virt</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FDDI_RII</span><span class="p">;</span>	<span class="c1">// Clear RII bit.</span></pre></div></td></tr>


<tr id="section-41"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-41">&#182;</a></div><p>regions overlap</p></td><td class="code"><div class="highlight"><pre>		<span class="n">virt</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">+</span> <span class="n">RifLength</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">FDDI_MAC_HDR_LEN</span><span class="p">;</span> <span class="n">n</span><span class="p">;</span> <span class="n">n</span><span class="o">--</span><span class="p">)</span>
			<span class="o">*--</span><span class="n">virt</span> <span class="o">=</span> <span class="o">*--</span><span class="n">cp</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-42"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-42">&#182;</a></div><p>adjust sbd->data pointer</p></td><td class="code"><div class="highlight"><pre>		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">RifLength</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">RifLength</span><span class="p">;</span>
		<span class="n">RifLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-43"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-43">&#182;</a></div><p>Count statistics.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>	<span class="c1">// Count indicated receive</span></pre></div></td></tr>


<tr id="section-44"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-44">&#182;</a></div><p>packets.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_bytes</span><span class="o">+=</span><span class="n">len</span><span class="p">;</span>	<span class="c1">// Count bytes.</span></pre></div></td></tr>


<tr id="section-45"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-45">&#182;</a></div><p>virt points to header again</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">virt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// Check group (multicast) bit.</span>

		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">multicast</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span></pre></div></td></tr>


<tr id="section-46"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-46">&#182;</a></div><p>deliver frame to system</p></td><td class="code"><div class="highlight"><pre>	<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">fddi_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">HWM_RX_CHECK</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">RX_LOW_WATERMARK</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

      <span class="nl">RequeueRxd:</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Rx: re-queue RXD.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mac_drv_requeue_rxd</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">rxd</span><span class="p">,</span> <span class="n">frag_count</span><span class="p">);</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>	<span class="c1">// Count receive packets</span></pre></div></td></tr>


<tr id="section-47"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-47">&#182;</a></div><p>not indicated.</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>				<span class="c1">// mac_drv_rx_complete</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_requeue_rxd</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware module calls this function to request the OS-specific</span>
<span class="cm"> *	module to queue the receive buffer(s) represented by the pointer</span>
<span class="cm"> *	to the RxD and the frag_count into the receive queue again. This</span>
<span class="cm"> *	buffer was filled with an invalid frame or an SMT frame.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	rxd - A pointer to the first RxD which is used by the receive frame.</span>
<span class="cm"> *</span>
<span class="cm"> *	frag_count - Count of RxDs used by the received frame.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">mac_drv_requeue_rxd</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">rxd</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">frag_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">next_rxd</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">src_rxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">MaxFrameSize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">v_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">b_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frag_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>	<span class="c1">// This is not allowed to happen.</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;fddi: Multi-fragment requeue!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">MaxFrameSize</span> <span class="o">=</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MaxFrameSize</span><span class="p">;</span>
	<span class="n">src_rxd</span> <span class="o">=</span> <span class="n">rxd</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">frag_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">frag_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next_rxd</span> <span class="o">=</span> <span class="n">src_rxd</span><span class="o">-&gt;</span><span class="n">rxd_next</span><span class="p">;</span>
		<span class="n">rxd</span> <span class="o">=</span> <span class="n">HWM_GET_CURR_RXD</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">src_rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// this should not happen</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Requeue with no skb in rxd!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">MaxFrameSize</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-48"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-48">&#182;</a></div><p>we got a skb</p></td><td class="code"><div class="highlight"><pre>				<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">MaxFrameSize</span><span class="p">);</span>
				<span class="n">v_addr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="n">b_addr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">pdev</span><span class="p">,</span>
							<span class="n">v_addr</span><span class="p">,</span>
							<span class="n">MaxFrameSize</span><span class="p">,</span>
							<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
				<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">b_addr</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-49"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-49">&#182;</a></div><p>no skb available, use local buffer</p></td><td class="code"><div class="highlight"><pre>				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Queueing invalid buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">v_addr</span> <span class="o">=</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBuffer</span><span class="p">;</span>
				<span class="n">b_addr</span> <span class="o">=</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBufferDMA</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-50"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-50">&#182;</a></div><p>we use skb from old rxd</p></td><td class="code"><div class="highlight"><pre>			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">v_addr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">b_addr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">v_addr</span><span class="p">,</span>
						<span class="n">MaxFrameSize</span><span class="p">,</span>
						<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">b_addr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hwm_rx_frag</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">v_addr</span><span class="p">,</span> <span class="n">b_addr</span><span class="p">,</span> <span class="n">MaxFrameSize</span><span class="p">,</span>
			    <span class="n">FIRST_FRAG</span> <span class="o">|</span> <span class="n">LAST_FRAG</span><span class="p">);</span>

		<span class="n">src_rxd</span> <span class="o">=</span> <span class="n">next_rxd</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>				<span class="c1">// mac_drv_requeue_rxd</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_fill_rxd</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware module calls this function at initialization time</span>
<span class="cm"> *	to fill the RxD ring with receive buffers. It is also called by</span>
<span class="cm"> *	mac_drv_rx_complete if rx_free is large enough to queue some new</span>
<span class="cm"> *	receive buffers into the RxD ring. mac_drv_fill_rxd queues new</span>
<span class="cm"> *	receive buffers as long as enough RxDs and receive buffers are</span>
<span class="cm"> *	available.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">mac_drv_fill_rxd</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">MaxFrameSize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">v_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">rxd</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering mac_drv_fill_rxd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-51"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-51">&#182;</a></div><p>Walk through the list of free receive buffers, passing receive
buffers to the HWM as long as RXDs are available.</p></td><td class="code"><div class="highlight"><pre>	<span class="n">MaxFrameSize</span> <span class="o">=</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MaxFrameSize</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-52"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-52">&#182;</a></div><p>Check if there is any RXD left.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">while</span> <span class="p">(</span><span class="n">HWM_GET_RX_FREE</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">rxd</span> <span class="o">=</span> <span class="n">HWM_GET_CURR_RXD</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">MaxFrameSize</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-53"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-53">&#182;</a></div><p>we got a skb</p></td><td class="code"><div class="highlight"><pre>			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">MaxFrameSize</span><span class="p">);</span>
			<span class="n">v_addr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">b_addr</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">v_addr</span><span class="p">,</span>
						<span class="n">MaxFrameSize</span><span class="p">,</span>
						<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">b_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-54"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-54">&#182;</a></div><p>no skb available, use local buffer
System has run out of buffer memory, but we want to
keep the receiver running in hope of better times.
Multiple descriptors may point to this local buffer,
so data in it must be considered invalid.</p></td><td class="code"><div class="highlight"><pre>			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Queueing invalid buffer!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">v_addr</span> <span class="o">=</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBuffer</span><span class="p">;</span>
			<span class="n">b_addr</span> <span class="o">=</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">LocalRxBufferDMA</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-55"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-55">&#182;</a></div><p>Pass receive buffer to HWM.</p></td><td class="code"><div class="highlight"><pre>		<span class="n">hwm_rx_frag</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">v_addr</span><span class="p">,</span> <span class="n">b_addr</span><span class="p">,</span> <span class="n">MaxFrameSize</span><span class="p">,</span>
			    <span class="n">FIRST_FRAG</span> <span class="o">|</span> <span class="n">LAST_FRAG</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;leaving mac_drv_fill_rxd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>				<span class="c1">// mac_drv_fill_rxd</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_clear_rxd</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware module calls this function to release unused</span>
<span class="cm"> *	receive buffers.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	rxd - A pointer to the first RxD which is used by the receive buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *	frag_count - Count of RxDs used by the receive buffer.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">mac_drv_clear_rxd</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="o">*</span><span class="n">rxd</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">frag_count</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering mac_drv_clear_rxd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frag_count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>	<span class="c1">// This is not allowed to happen.</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;fddi: Multi-fragment clear!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">frag_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">frag_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skfddi_priv</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">MaxFrameSize</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">MaxFrameSize</span><span class="p">;</span>

			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">dma_addr</span><span class="p">,</span>
					 <span class="n">MaxFrameSize</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_os</span><span class="p">.</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rxd</span> <span class="o">=</span> <span class="n">rxd</span><span class="o">-&gt;</span><span class="n">rxd_next</span><span class="p">;</span>	<span class="c1">// Next RXD.</span>

	<span class="p">}</span>
<span class="p">}</span>				<span class="c1">// mac_drv_clear_rxd</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_rx_init</span>
<span class="cm"> *</span>
<span class="cm"> *	The hardware module calls this routine when an SMT or NSA frame of the</span>
<span class="cm"> *	local SMT should be delivered to the LLC layer.</span>
<span class="cm"> *</span>
<span class="cm"> *	It is necessary to have this function, because there is no other way to</span>
<span class="cm"> *	copy the contents of SMT MBufs into receive buffers.</span>
<span class="cm"> *</span>
<span class="cm"> *	mac_drv_rx_init allocates the required target memory for this frame,</span>
<span class="cm"> *	and receives the frame fragment by fragment by calling mac_drv_rx_frag.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	len - The length (in bytes) of the received frame (FC, DA, SA, Data).</span>
<span class="cm"> *</span>
<span class="cm"> *	fc - The Frame Control field of the received frame.</span>
<span class="cm"> *</span>
<span class="cm"> *	look_ahead - A pointer to the lookahead data buffer (may be NULL).</span>
<span class="cm"> *</span>
<span class="cm"> *	la_len - The length of the lookahead data stored in the lookahead</span>
<span class="cm"> *	buffer (may be zero).</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Always returns zero (0).</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">int</span> <span class="nf">mac_drv_rx_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fc</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">look_ahead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">la_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering mac_drv_rx_init(len=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-56"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-56">&#182;</a></div><p>"Received" a SMT or NSA frame of the local SMT.</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">la_len</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">FDDI_MAC_HDR_LEN</span> <span class="o">||</span> <span class="o">!</span><span class="n">look_ahead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fddi: Discard invalid local SMT frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;  len=%d, la_len=%d, (ULONG) look_ahead=%08lXh.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">len</span><span class="p">,</span> <span class="n">la_len</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">look_ahead</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fddi: Local SMT: skb memory exhausted.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">look_ahead</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-57"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-57">&#182;</a></div><p>deliver frame to system</p></td><td class="code"><div class="highlight"><pre>	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">fddi_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// mac_drv_rx_init</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	smt_timer_poll</span>
<span class="cm"> *</span>
<span class="cm"> *	This routine is called periodically by the SMT module to clean up the</span>
<span class="cm"> *	driver.</span>
<span class="cm"> *</span>
<span class="cm"> *	Return any queued frames back to the upper protocol layers if the ring</span>
<span class="cm"> *	is down.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">smt_timer_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>				<span class="c1">// smt_timer_poll</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	ring_status_indication</span>
<span class="cm"> *</span>
<span class="cm"> *	This function indicates a change of the ring state.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	status - The current ring status.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">ring_status_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ring_status_indication( &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_RES15</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_RES15 &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_HARDERROR</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_HARDERROR &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_SOFTERROR</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_SOFTERROR &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_BEACON</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_BEACON &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_PATHTEST</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_PATHTEST &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_SELFTEST</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_SELFTEST &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_RES9</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_RES9 &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_DISCONNECT</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_DISCONNECT &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_RES7</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_RES7 &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_DUPADDR</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_DUPADDR &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_NORINGOP</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_NORINGOP &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_VERSION</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_VERSION &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_STUCKBYPASSS</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_STUCKBYPASSS &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_EVENT</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_EVENT &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_RINGOPCHANGE</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_RINGOPCHANGE &quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RS_RES0</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;RS_RES0 &quot;</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>				<span class="c1">// ring_status_indication</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	smt_get_time</span>
<span class="cm"> *</span>
<span class="cm"> *	Gets the current time from the system.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	None.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	The current time in TICKS_PER_SECOND.</span>
<span class="cm"> *</span>
<span class="cm"> *	TICKS_PER_SECOND has the unit &#39;count of timer ticks per second&#39;. It is</span>
<span class="cm"> *	defined in &quot;targetos.h&quot;. The definition of TICKS_PER_SECOND must comply</span>
<span class="cm"> *	to the time returned by smt_get_time().</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">smt_get_time</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>				<span class="c1">// smt_get_time</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	smt_stat_counter</span>
<span class="cm"> *</span>
<span class="cm"> *	Status counter update (ring_op, fifo full).</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	stat -	= 0: A ring operational change occurred.</span>
<span class="cm"> *		= 1: The FORMAC FIFO buffer is full / FIFO overflow.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">smt_stat_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stat</span><span class="p">)</span>
<span class="p">{</span></pre></div></td></tr>


<tr id="section-58"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-58">&#182;</a></div><pre><code> BOOLEAN RingIsUp ;
</code></pre></td><td class="code"><div class="highlight"><pre>	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;smt_stat_counter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">stat</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Ring operational change.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Receive fifo overflow.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">MacStat</span><span class="p">.</span><span class="n">gen</span><span class="p">.</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Unknown status (%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>				<span class="c1">// smt_stat_counter</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	cfm_state_change</span>
<span class="cm"> *</span>
<span class="cm"> *	Sets CFM state in custom statistics.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	c_state - Possible values are:</span>
<span class="cm"> *</span>
<span class="cm"> *		EC0_OUT, EC1_IN, EC2_TRACE, EC3_LEAVE, EC4_PATH_TEST,</span>
<span class="cm"> *		EC5_INSERT, EC6_CHECK, EC7_DEINSERT</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">cfm_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_state</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DRIVERDEBUG</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">c_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SC0_ISOLATED</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC0_ISOLATED&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SC1_WRAP_A</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC1_WRAP_A&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SC2_WRAP_B</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC2_WRAP_B&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SC4_THRU_A</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC4_THRU_A&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SC5_THRU_B</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC5_THRU_B&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SC7_WRAP_S</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC7_WRAP_S&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SC9_C_WRAP_A</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC9_C_WRAP_A&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SC10_C_WRAP_B</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC10_C_WRAP_B&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SC11_C_WRAP_S</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;SC11_C_WRAP_S&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cfm_state_change: unknown %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c_state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;cfm_state_change: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="c1">// DRIVERDEBUG</span>
<span class="p">}</span>				<span class="c1">// cfm_state_change</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	ecm_state_change</span>
<span class="cm"> *</span>
<span class="cm"> *	Sets ECM state in custom statistics.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	e_state - Possible values are:</span>
<span class="cm"> *</span>
<span class="cm"> *		SC0_ISOLATED, SC1_WRAP_A (5), SC2_WRAP_B (6), SC4_THRU_A (12),</span>
<span class="cm"> *		SC5_THRU_B (7), SC7_WRAP_S (8)</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">ecm_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e_state</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DRIVERDEBUG</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">e_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">EC0_OUT</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;EC0_OUT&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EC1_IN</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;EC1_IN&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EC2_TRACE</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;EC2_TRACE&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EC3_LEAVE</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;EC3_LEAVE&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EC4_PATH_TEST</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;EC4_PATH_TEST&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EC5_INSERT</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;EC5_INSERT&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EC6_CHECK</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;EC6_CHECK&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">EC7_DEINSERT</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;EC7_DEINSERT&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ecm_state_change: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="c1">//DRIVERDEBUG</span>
<span class="p">}</span>				<span class="c1">// ecm_state_change</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	rmt_state_change</span>
<span class="cm"> *</span>
<span class="cm"> *	Sets RMT state in custom statistics.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> *</span>
<span class="cm"> *	r_state - Possible values are:</span>
<span class="cm"> *</span>
<span class="cm"> *		RM0_ISOLATED, RM1_NON_OP, RM2_RING_OP, RM3_DETECT,</span>
<span class="cm"> *		RM4_NON_OP_DUP, RM5_RING_OP_DUP, RM6_DIRECTED, RM7_TRACE</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">rmt_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r_state</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DRIVERDEBUG</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">r_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RM0_ISOLATED</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;RM0_ISOLATED&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RM1_NON_OP</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;RM1_NON_OP - not operational&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RM2_RING_OP</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;RM2_RING_OP - ring operational&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RM3_DETECT</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;RM3_DETECT - detect dupl addresses&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RM4_NON_OP_DUP</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;RM4_NON_OP_DUP - dupl. addr detected&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RM5_RING_OP_DUP</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;RM5_RING_OP_DUP - ring oper. with dupl. addr&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RM6_DIRECTED</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;RM6_DIRECTED - sending directed beacons&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RM7_TRACE</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;RM7_TRACE - trace initiated&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;[rmt_state_change: %s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="cp">#endif				</span><span class="c1">// DRIVERDEBUG</span>
<span class="p">}</span>				<span class="c1">// rmt_state_change</span>


<span class="cm">/************************</span>
<span class="cm"> *</span>
<span class="cm"> *	drv_reset_indication</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called by the SMT when it has detected a severe</span>
<span class="cm"> *	hardware problem. The driver should perform a reset on the adapter</span>
<span class="cm"> *	as soon as possible, but not from within this function.</span>
<span class="cm"> * Args</span>
<span class="cm"> *	smc - A pointer to the SMT context struct.</span>
<span class="cm"> * Out</span>
<span class="cm"> *	Nothing.</span>
<span class="cm"> *</span>
<span class="cm"> ************************/</span>
<span class="kt">void</span> <span class="nf">drv_reset_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering drv_reset_indication</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">os</span><span class="p">.</span><span class="n">ResetRequested</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>	<span class="c1">// Set flag.</span>

<span class="p">}</span>				<span class="c1">// drv_reset_indication</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">skfddi_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;skfddi&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">skfddi_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">skfp_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">skfp_remove_one</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">skfd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skfddi_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">skfd_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skfddi_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">skfd_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">skfd_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
