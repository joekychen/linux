<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › fddi › skfp › h › hwmtm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>hwmtm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *	(C)Copyright 1998,1999 SysKonnect,</span>
<span class="cm"> *	a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	The information in this file is provided &quot;AS IS&quot; without warranty.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cp">#ifndef	_HWM_</span>
<span class="cp">#define	_HWM_</span>

<span class="cp">#include &quot;mbuf.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * MACRO for DMA synchronization:</span>
<span class="cm"> *	The descriptor &#39;desc&#39; is flushed for the device &#39;flag&#39;.</span>
<span class="cm"> *	Devices are the CPU (DDI_DMA_SYNC_FORCPU) and the</span>
<span class="cm"> *	adapter (DDI_DMA_SYNC_FORDEV).</span>
<span class="cm"> *</span>
<span class="cm"> *	&#39;desc&#39;	Pointer to a Rx or Tx descriptor.</span>
<span class="cm"> *	&#39;flag&#39;	Flag for direction (view for CPU or DEVICE) that</span>
<span class="cm"> *		should be synchronized.</span>
<span class="cm"> *</span>
<span class="cm"> *	Empty macros and defines are specified here. The real macro</span>
<span class="cm"> *	is os-specific and should be defined in osdef1st.h.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef DRV_BUF_FLUSH</span>
<span class="cp">#define DRV_BUF_FLUSH(desc,flag)</span>
<span class="cp">#define DDI_DMA_SYNC_FORCPU</span>
<span class="cp">#define DDI_DMA_SYNC_FORDEV</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * hardware modul dependent receive modes</span>
<span class="cm">	 */</span>
<span class="cp">#define	RX_ENABLE_PASS_SMT	21</span>
<span class="cp">#define	RX_DISABLE_PASS_SMT	22</span>
<span class="cp">#define	RX_ENABLE_PASS_NSA	23</span>
<span class="cp">#define	RX_DISABLE_PASS_NSA	24</span>
<span class="cp">#define	RX_ENABLE_PASS_DB	25</span>
<span class="cp">#define	RX_DISABLE_PASS_DB	26</span>
<span class="cp">#define	RX_DISABLE_PASS_ALL	27</span>
<span class="cp">#define	RX_DISABLE_LLC_PROMISC	28</span>
<span class="cp">#define	RX_ENABLE_LLC_PROMISC	29</span>


<span class="cp">#ifndef	DMA_RD</span>
<span class="cp">#define DMA_RD		1	</span><span class="cm">/* memory -&gt; hw */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#ifndef DMA_WR</span>
<span class="cp">#define DMA_WR		2	</span><span class="cm">/* hw -&gt; memory */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#define SMT_BUF		0x80</span>

	<span class="cm">/*</span>
<span class="cm">	 * bits of the frame status byte</span>
<span class="cm">	 */</span>
<span class="cp">#define EN_IRQ_EOF	0x02	</span><span class="cm">/* get IRQ after end of frame transmission */</span><span class="cp"></span>
<span class="cp">#define	LOC_TX		0x04	</span><span class="cm">/* send frame to the local SMT */</span><span class="cp"></span>
<span class="cp">#define LAST_FRAG	0x08	</span><span class="cm">/* last TxD of the frame */</span><span class="cp"></span>
<span class="cp">#define	FIRST_FRAG	0x10	</span><span class="cm">/* first TxD of the frame */</span><span class="cp"></span>
<span class="cp">#define	LAN_TX		0x20	</span><span class="cm">/* send frame to network if set */</span><span class="cp"></span>
<span class="cp">#define RING_DOWN	0x40	</span><span class="cm">/* error: unable to send, ring down */</span><span class="cp"></span>
<span class="cp">#define OUT_OF_TXD	0x80	</span><span class="cm">/* error: not enough TxDs available */</span><span class="cp"></span>


<span class="cp">#ifndef NULL</span>
<span class="cp">#define NULL 		0</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	LITTLE_ENDIAN</span>
<span class="cp">#define HWM_REVERSE(x)	(x)</span>
<span class="cp">#else</span>
<span class="cp">#define	HWM_REVERSE(x)		((((x)&lt;&lt;24L)&amp;0xff000000L)	+	\</span>
<span class="cp">				 (((x)&lt;&lt; 8L)&amp;0x00ff0000L)	+	\</span>
<span class="cp">				 (((x)&gt;&gt; 8L)&amp;0x0000ff00L)	+	\</span>
<span class="cp">				 (((x)&gt;&gt;24L)&amp;0x000000ffL))</span>
<span class="cp">#endif</span>

<span class="cp">#define C_INDIC		(1L&lt;&lt;25)</span>
<span class="cp">#define A_INDIC		(1L&lt;&lt;26)</span>
<span class="cp">#define	RD_FS_LOCAL	0x80</span>

	<span class="cm">/*</span>
<span class="cm">	 * DEBUG FLAGS</span>
<span class="cm">	 */</span>
<span class="cp">#define	DEBUG_SMTF	1</span>
<span class="cp">#define	DEBUG_SMT	2</span>
<span class="cp">#define	DEBUG_ECM	3</span>
<span class="cp">#define	DEBUG_RMT	4</span>
<span class="cp">#define	DEBUG_CFM	5</span>
<span class="cp">#define	DEBUG_PCM	6</span>
<span class="cp">#define	DEBUG_SBA	7</span>
<span class="cp">#define	DEBUG_ESS	8</span>

<span class="cp">#define	DB_HWM_RX	10</span>
<span class="cp">#define	DB_HWM_TX	11</span>
<span class="cp">#define DB_HWM_GEN	12</span>

<span class="k">struct</span> <span class="n">s_mbuf_pool</span> <span class="p">{</span>
<span class="cp">#ifndef	MB_OUTSIDE_SMC</span>
	<span class="n">SMbuf</span>		<span class="n">mb</span><span class="p">[</span><span class="n">MAX_MBUF</span><span class="p">]</span> <span class="p">;</span>		<span class="cm">/* mbuf pool */</span>
<span class="cp">#endif</span>
	<span class="n">SMbuf</span>		<span class="o">*</span><span class="n">mb_start</span> <span class="p">;</span>		<span class="cm">/* points to the first mb */</span>
	<span class="n">SMbuf</span>		<span class="o">*</span><span class="n">mb_free</span> <span class="p">;</span>		<span class="cm">/* free queue */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">hwm_r</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * hardware modul specific receive variables</span>
<span class="cm">	 */</span>
	<span class="n">u_int</span>			<span class="n">len</span> <span class="p">;</span>		<span class="cm">/* length of the whole frame */</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">mb_pos</span> <span class="p">;</span>	<span class="cm">/* SMbuf receive position */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">hw_modul</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * All hardware modul specific variables</span>
<span class="cm">	 */</span>
	<span class="k">struct</span>	<span class="n">s_mbuf_pool</span>	<span class="n">mbuf_pool</span> <span class="p">;</span>
	<span class="k">struct</span>	<span class="n">hwm_r</span>	<span class="n">r</span> <span class="p">;</span>

	<span class="k">union</span> <span class="n">s_fp_descr</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">descr_p</span> <span class="p">;</span> <span class="cm">/* points to the desriptor area */</span>

	<span class="n">u_short</span> <span class="n">pass_SMT</span> <span class="p">;</span>		<span class="cm">/* pass SMT frames */</span>
	<span class="n">u_short</span> <span class="n">pass_NSA</span> <span class="p">;</span>		<span class="cm">/* pass all NSA frames */</span>
	<span class="n">u_short</span> <span class="n">pass_DB</span> <span class="p">;</span>		<span class="cm">/* pass Direct Beacon Frames */</span>
	<span class="n">u_short</span> <span class="n">pass_llc_promisc</span> <span class="p">;</span>	<span class="cm">/* pass all llc frames (default ON) */</span>

	<span class="n">SMbuf</span>	<span class="o">*</span><span class="n">llc_rx_pipe</span> <span class="p">;</span>		<span class="cm">/* points to the first queued llc fr */</span>
	<span class="n">SMbuf</span>	<span class="o">*</span><span class="n">llc_rx_tail</span> <span class="p">;</span>		<span class="cm">/* points to the last queued llc fr */</span>
	<span class="kt">int</span>	<span class="n">queued_rx_frames</span> <span class="p">;</span>	<span class="cm">/* number of queued frames */</span>

	<span class="n">SMbuf</span>	<span class="o">*</span><span class="n">txd_tx_pipe</span> <span class="p">;</span>		<span class="cm">/* points to first mb in the txd ring */</span>
	<span class="n">SMbuf</span>	<span class="o">*</span><span class="n">txd_tx_tail</span> <span class="p">;</span>		<span class="cm">/* points to last mb in the txd ring */</span>
	<span class="kt">int</span>	<span class="n">queued_txd_mb</span> <span class="p">;</span>		<span class="cm">/* number of SMT MBufs in txd ring */</span>

	<span class="kt">int</span>	<span class="n">rx_break</span> <span class="p">;</span>		<span class="cm">/* rev. was breaked because ind. off */</span>
	<span class="kt">int</span>	<span class="n">leave_isr</span> <span class="p">;</span>		<span class="cm">/* leave fddi_isr immedeately if set */</span>
	<span class="kt">int</span>	<span class="n">isr_flag</span> <span class="p">;</span>		<span class="cm">/* set, when HWM is entered from isr */</span>
	<span class="cm">/*</span>
<span class="cm">	 * variables for the current transmit frame</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">s_smt_tx_queue</span> <span class="o">*</span><span class="n">tx_p</span> <span class="p">;</span>	<span class="cm">/* pointer to the transmit queue */</span>
	<span class="n">u_long</span>	<span class="n">tx_descr</span> <span class="p">;</span>		<span class="cm">/* tx descriptor for FORMAC+ */</span>
	<span class="kt">int</span>	<span class="n">tx_len</span> <span class="p">;</span>		<span class="cm">/* tx frame length */</span>
	<span class="n">SMbuf</span>	<span class="o">*</span><span class="n">tx_mb</span> <span class="p">;</span>		<span class="cm">/* SMT tx MBuf pointer */</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">tx_data</span> <span class="p">;</span>		<span class="cm">/* data pointer to the SMT tx Mbuf */</span>

	<span class="kt">int</span>	<span class="n">detec_count</span> <span class="p">;</span>		<span class="cm">/* counter for out of RxD condition */</span>
	<span class="n">u_long</span>	<span class="n">rx_len_error</span> <span class="p">;</span>		<span class="cm">/* rx len FORMAC != sum of fragments */</span>
<span class="p">}</span> <span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * DEBUG structs and macros</span>
<span class="cm"> */</span>

<span class="cp">#ifdef	DEBUG</span>
<span class="k">struct</span> <span class="n">os_debug</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">hwm_rx</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">hwm_tx</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">hwm_gen</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	DEBUG</span>
<span class="cp">#ifdef	DEBUG_BRD</span>
<span class="cp">#define	DB_P	smc-&gt;debug</span>
<span class="cp">#else</span>
<span class="cp">#define DB_P	debug</span>
<span class="cp">#endif</span>

<span class="cp">#define DB_RX(a,b,c,lev) if (DB_P.d_os.hwm_rx &gt;= (lev))	printf(a,b,c)</span>
<span class="cp">#define DB_TX(a,b,c,lev) if (DB_P.d_os.hwm_tx &gt;= (lev))	printf(a,b,c)</span>
<span class="cp">#define DB_GEN(a,b,c,lev) if (DB_P.d_os.hwm_gen &gt;= (lev)) printf(a,b,c)</span>
<span class="cp">#else	</span><span class="cm">/* DEBUG */</span><span class="cp"></span>
<span class="cp">#define DB_RX(a,b,c,lev)</span>
<span class="cp">#define DB_TX(a,b,c,lev)</span>
<span class="cp">#define DB_GEN(a,b,c,lev)</span>
<span class="cp">#endif	</span><span class="cm">/* DEBUG */</span><span class="cp"></span>

<span class="cp">#ifndef	SK_BREAK</span>
<span class="cp">#define	SK_BREAK()</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * HWM Macros</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_TX_PHYS)</span>
<span class="cm"> *	u_long HWM_GET_TX_PHYS(txd)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to read</span>
<span class="cm"> *		the physical address of the specified TxD.</span>
<span class="cm"> *</span>
<span class="cm"> * para	txd	pointer to the TxD</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_TX_PHYS(txd)		(u_long)AIX_REVERSE((txd)-&gt;txd_tbadr)</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_TX_LEN)</span>
<span class="cm"> *	int HWM_GET_TX_LEN(txd)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to read</span>
<span class="cm"> *		the fragment length of the specified TxD</span>
<span class="cm"> *</span>
<span class="cm"> * para	rxd	pointer to the TxD</span>
<span class="cm"> *</span>
<span class="cm"> * return	the length of the fragment in bytes</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_TX_LEN(txd)	((int)AIX_REVERSE((txd)-&gt;txd_tbctrl)&amp; RD_LENGTH)</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_TX_USED)</span>
<span class="cm"> *	txd *HWM_GET_TX_USED(smc,queue)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to get the</span>
<span class="cm"> *		number of used TxDs for the queue, specified by the index.</span>
<span class="cm"> *</span>
<span class="cm"> * para	queue	the number of the send queue: Can be specified by</span>
<span class="cm"> *		QUEUE_A0, QUEUE_S or (frame_status &amp; QUEUE_A0)</span>
<span class="cm"> *</span>
<span class="cm"> * return	number of used TxDs for this send queue</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_TX_USED(smc,queue)	(int) (smc)-&gt;hw.fp.tx_q[queue].tx_used</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_CURR_TXD)</span>
<span class="cm"> *	txd *HWM_GET_CURR_TXD(smc,queue)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to get the</span>
<span class="cm"> *		pointer to the TxD which points to the current queue put</span>
<span class="cm"> *		position.</span>
<span class="cm"> *</span>
<span class="cm"> * para	queue	the number of the send queue: Can be specified by</span>
<span class="cm"> *		QUEUE_A0, QUEUE_S or (frame_status &amp; QUEUE_A0)</span>
<span class="cm"> *</span>
<span class="cm"> * return	pointer to the current TxD</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_CURR_TXD(smc,queue)	(struct s_smt_fp_txd volatile *)\</span>
<span class="cp">					(smc)-&gt;hw.fp.tx_q[queue].tx_curr_put</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_RX_FRAG_LEN)</span>
<span class="cm"> *	int HWM_GET_RX_FRAG_LEN(rxd)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to read</span>
<span class="cm"> *		the fragment length of the specified RxD</span>
<span class="cm"> *</span>
<span class="cm"> * para	rxd	pointer to the RxD</span>
<span class="cm"> *</span>
<span class="cm"> * return	the length of the fragment in bytes</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_RX_FRAG_LEN(rxd)	((int)AIX_REVERSE((rxd)-&gt;rxd_rbctrl)&amp; \</span>
<span class="cp">				RD_LENGTH)</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_RX_PHYS)</span>
<span class="cm"> *	u_long HWM_GET_RX_PHYS(rxd)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to read</span>
<span class="cm"> *		the physical address of the specified RxD.</span>
<span class="cm"> *</span>
<span class="cm"> * para	rxd	pointer to the RxD</span>
<span class="cm"> *</span>
<span class="cm"> * return	the RxD&#39;s physical pointer to the data fragment</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_RX_PHYS(rxd)	(u_long)AIX_REVERSE((rxd)-&gt;rxd_rbadr)</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_RX_USED)</span>
<span class="cm"> *	int HWM_GET_RX_USED(smc)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to get</span>
<span class="cm"> *		the count of used RXDs in receive queue 1.</span>
<span class="cm"> *</span>
<span class="cm"> * return	the used RXD count of receive queue 1</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Remember, because of an ASIC bug at least one RXD should be unused</span>
<span class="cm"> *	 in the descriptor ring !</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_RX_USED(smc)	((int)(smc)-&gt;hw.fp.rx_q[QUEUE_R1].rx_used)</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_RX_FREE)</span>
<span class="cm"> *	int HWM_GET_RX_FREE(smc)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to get</span>
<span class="cm"> *		the rxd_free count of receive queue 1.</span>
<span class="cm"> *</span>
<span class="cm"> * return	the rxd_free count of receive queue 1</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_RX_FREE(smc)	((int)(smc)-&gt;hw.fp.rx_q[QUEUE_R1].rx_free-1)</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_GET_CURR_RXD)</span>
<span class="cm"> *	rxd *HWM_GET_CURR_RXD(smc)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro may be invoked by the OS-specific module to get the</span>
<span class="cm"> *		pointer to the RxD which points to the current queue put</span>
<span class="cm"> *		position.</span>
<span class="cm"> *</span>
<span class="cm"> * return	pointer to the current RxD</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#define	HWM_GET_CURR_RXD(smc)	(struct s_smt_fp_rxd volatile *)\</span>
<span class="cp">				(smc)-&gt;hw.fp.rx_q[QUEUE_R1].rx_curr_put</span>

<span class="cm">/*</span>
<span class="cm"> *	BEGIN_MANUAL_ENTRY(HWM_RX_CHECK)</span>
<span class="cm"> *	void HWM_RX_CHECK(smc,low_water)</span>
<span class="cm"> *</span>
<span class="cm"> * function	MACRO		(hardware module, hwmtm.h)</span>
<span class="cm"> *		This macro is invoked by the OS-specific before it left the</span>
<span class="cm"> *		function mac_drv_rx_complete. This macro calls mac_drv_fill_rxd</span>
<span class="cm"> *		if the number of used RxDs is equal or lower than the</span>
<span class="cm"> *		the given low water mark.</span>
<span class="cm"> *</span>
<span class="cm"> * para	low_water	low water mark of used RxD&#39;s</span>
<span class="cm"> *</span>
<span class="cm"> *	END_MANUAL_ENTRY</span>
<span class="cm"> */</span>
<span class="cp">#ifndef HWM_NO_FLOW_CTL</span>
<span class="cp">#define	HWM_RX_CHECK(smc,low_water) {\</span>
<span class="cp">	if ((low_water) &gt;= (smc)-&gt;hw.fp.rx_q[QUEUE_R1].rx_used) {\</span>
<span class="cp">		mac_drv_fill_rxd(smc) ;\</span>
<span class="cp">	}\</span>
<span class="cp">}</span>
<span class="cp">#else</span>
<span class="cp">#define	HWM_RX_CHECK(smc,low_water)		mac_drv_fill_rxd(smc)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	HWM_EBASE</span>
<span class="cp">#define	HWM_EBASE	500</span>
<span class="cp">#endif</span>

<span class="cp">#define	HWM_E0001	HWM_EBASE + 1</span>
<span class="cp">#define	HWM_E0001_MSG	&quot;HWM: Wrong size of s_rxd_os struct&quot;</span>
<span class="cp">#define	HWM_E0002	HWM_EBASE + 2</span>
<span class="cp">#define	HWM_E0002_MSG	&quot;HWM: Wrong size of s_txd_os struct&quot;</span>
<span class="cp">#define	HWM_E0003	HWM_EBASE + 3</span>
<span class="cp">#define	HWM_E0003_MSG	&quot;HWM: smt_free_mbuf() called with NULL pointer&quot;</span>
<span class="cp">#define	HWM_E0004	HWM_EBASE + 4</span>
<span class="cp">#define	HWM_E0004_MSG	&quot;HWM: Parity error rx queue 1&quot;</span>
<span class="cp">#define	HWM_E0005	HWM_EBASE + 5</span>
<span class="cp">#define	HWM_E0005_MSG	&quot;HWM: Encoding error rx queue 1&quot;</span>
<span class="cp">#define	HWM_E0006	HWM_EBASE + 6</span>
<span class="cp">#define	HWM_E0006_MSG	&quot;HWM: Encoding error async tx queue&quot;</span>
<span class="cp">#define	HWM_E0007	HWM_EBASE + 7</span>
<span class="cp">#define	HWM_E0007_MSG	&quot;HWM: Encoding error sync tx queue&quot;</span>
<span class="cp">#define	HWM_E0008	HWM_EBASE + 8</span>
<span class="cp">#define	HWM_E0008_MSG	&quot;&quot;</span>
<span class="cp">#define	HWM_E0009	HWM_EBASE + 9</span>
<span class="cp">#define	HWM_E0009_MSG	&quot;HWM: Out of RxD condition detected&quot;</span>
<span class="cp">#define	HWM_E0010	HWM_EBASE + 10</span>
<span class="cp">#define	HWM_E0010_MSG	&quot;HWM: A protocol layer has tried to send a frame with an invalid frame control&quot;</span>
<span class="cp">#define HWM_E0011	HWM_EBASE + 11</span>
<span class="cp">#define HWM_E0011_MSG	&quot;HWM: mac_drv_clear_tx_queue was called although the hardware wasn&#39;t stopped&quot;</span>
<span class="cp">#define HWM_E0012	HWM_EBASE + 12</span>
<span class="cp">#define HWM_E0012_MSG	&quot;HWM: mac_drv_clear_rx_queue was called although the hardware wasn&#39;t stopped&quot;</span>
<span class="cp">#define HWM_E0013	HWM_EBASE + 13</span>
<span class="cp">#define HWM_E0013_MSG	&quot;HWM: mac_drv_repair_descr was called although the hardware wasn&#39;t stopped&quot;</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
