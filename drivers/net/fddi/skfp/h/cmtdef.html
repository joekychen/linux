<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › fddi › skfp › h › cmtdef.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>cmtdef.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *	(C)Copyright 1998,1999 SysKonnect,</span>
<span class="cm"> *	a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	The information in this file is provided &quot;AS IS&quot; without warranty.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cp">#ifndef	_CMTDEF_</span>
<span class="cp">#define _CMTDEF_</span>

<span class="cm">/* **************************************************************** */</span>

<span class="cm">/*</span>
<span class="cm"> * implementation specific constants</span>
<span class="cm"> * MODIIFY THE FOLLOWING THREE DEFINES</span>
<span class="cm"> */</span>
<span class="cp">#define AMDPLC			</span><span class="cm">/* if Amd PLC chip used */</span><span class="cp"></span>
<span class="cp">#ifdef	CONC</span>
<span class="cp">#define NUMPHYS		12	</span><span class="cm">/* 2 for SAS or DAS, more for Concentrator */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#ifdef	CONC_II</span>
<span class="cp">#define NUMPHYS		24	</span><span class="cm">/* 2 for SAS or DAS, more for Concentrator */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define NUMPHYS		2	</span><span class="cm">/* 2 for SAS or DAS, more for Concentrator */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="cp">#define NUMMACS		1	</span><span class="cm">/* only 1 supported at the moment */</span><span class="cp"></span>
<span class="cp">#define NUMPATHS	2	</span><span class="cm">/* primary and secondary path supported */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * DO NOT MODIFY BEYOND THIS POINT</span>
<span class="cm"> */</span>

<span class="cm">/* **************************************************************** */</span>

<span class="cp">#if	NUMPHYS &gt; 2</span>
<span class="cp">#define CONCENTRATOR</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Definitions for comfortable LINT usage</span>
<span class="cm"> */</span>
<span class="cp">#ifdef	lint</span>
<span class="cp">#define LINT_USE(x)	(x)=(x)</span>
<span class="cp">#else</span>
<span class="cp">#define LINT_USE(x)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	DEBUG</span>
<span class="cp">#define	DB_PR(flag,a,b,c)	{ if (flag) printf(a,b,c) ; }</span>
<span class="cp">#else</span>
<span class="cp">#define	DB_PR(flag,a,b,c)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG_BRD</span>
<span class="cp">#define DB_ECM(a,b,c)		DB_PR((smc-&gt;debug.d_smt&amp;1),a,b,c)</span>
<span class="cp">#define DB_ECMN(n,a,b,c)	DB_PR((smc-&gt;debug.d_ecm &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_RMT(a,b,c)		DB_PR((smc-&gt;debug.d_smt&amp;2),a,b,c)</span>
<span class="cp">#define DB_RMTN(n,a,b,c)	DB_PR((smc-&gt;debug.d_rmt &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_CFM(a,b,c)		DB_PR((smc-&gt;debug.d_smt&amp;4),a,b,c)</span>
<span class="cp">#define DB_CFMN(n,a,b,c)	DB_PR((smc-&gt;debug.d_cfm &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_PCM(a,b,c)		DB_PR((smc-&gt;debug.d_smt&amp;8),a,b,c)</span>
<span class="cp">#define DB_PCMN(n,a,b,c)	DB_PR((smc-&gt;debug.d_pcm &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_SMT(a,b,c)		DB_PR((smc-&gt;debug.d_smtf),a,b,c)</span>
<span class="cp">#define DB_SMTN(n,a,b,c)	DB_PR((smc-&gt;debug.d_smtf &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_SBA(a,b,c)		DB_PR((smc-&gt;debug.d_sba),a,b,c)</span>
<span class="cp">#define DB_SBAN(n,a,b,c)	DB_PR((smc-&gt;debug.d_sba &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_ESS(a,b,c)		DB_PR((smc-&gt;debug.d_ess),a,b,c)</span>
<span class="cp">#define DB_ESSN(n,a,b,c)	DB_PR((smc-&gt;debug.d_ess &gt;=(n)),a,b,c)</span>
<span class="cp">#else</span>
<span class="cp">#define DB_ECM(a,b,c)		DB_PR((debug.d_smt&amp;1),a,b,c)</span>
<span class="cp">#define DB_ECMN(n,a,b,c)	DB_PR((debug.d_ecm &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_RMT(a,b,c)		DB_PR((debug.d_smt&amp;2),a,b,c)</span>
<span class="cp">#define DB_RMTN(n,a,b,c)	DB_PR((debug.d_rmt &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_CFM(a,b,c)		DB_PR((debug.d_smt&amp;4),a,b,c)</span>
<span class="cp">#define DB_CFMN(n,a,b,c)	DB_PR((debug.d_cfm &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_PCM(a,b,c)		DB_PR((debug.d_smt&amp;8),a,b,c)</span>
<span class="cp">#define DB_PCMN(n,a,b,c)	DB_PR((debug.d_pcm &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_SMT(a,b,c)		DB_PR((debug.d_smtf),a,b,c)</span>
<span class="cp">#define DB_SMTN(n,a,b,c)	DB_PR((debug.d_smtf &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_SBA(a,b,c)		DB_PR((debug.d_sba),a,b,c)</span>
<span class="cp">#define DB_SBAN(n,a,b,c)	DB_PR((debug.d_sba &gt;=(n)),a,b,c)</span>
<span class="cp">#define DB_ESS(a,b,c)		DB_PR((debug.d_ess),a,b,c)</span>
<span class="cp">#define DB_ESSN(n,a,b,c)	DB_PR((debug.d_ess &gt;=(n)),a,b,c)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	SS_NOT_DS</span>
<span class="cp">#define	SK_LOC_DECL(type,var)	type var</span>
<span class="cp">#else</span>
<span class="cp">#define	SK_LOC_DECL(type,var)	static type var</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> * PHYs and PORTS</span>
<span class="cm"> * Note: Don&#39;t touch the definition of PA and PB. Those might be used</span>
<span class="cm"> *	by some &quot;for&quot; loops.</span>
<span class="cm"> */</span>
<span class="cp">#define PA		0</span>
<span class="cp">#define PB		1</span>
<span class="cp">#if	defined(SUPERNET_3) || defined(CONC_II)</span>
<span class="cm">/*</span>
<span class="cm"> * The port indices have to be different,</span>
<span class="cm"> * because the MAC output goes through the 2. PLC</span>
<span class="cm"> * Conc II: It has to be the first port in the row.</span>
<span class="cm"> */</span>
<span class="cp">#define PS		0	</span><span class="cm">/* Internal PLC which is the same as PA */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define PS		1</span>
<span class="cp">#endif</span>
<span class="cp">#define PM		2		</span><span class="cm">/* PM .. PA+NUM_PHYS-1 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * PHY types - as in path descriptor &#39;fddiPHYType&#39;</span>
<span class="cm"> */</span>
<span class="cp">#define TA			0	</span><span class="cm">/* A port */</span><span class="cp"></span>
<span class="cp">#define TB			1	</span><span class="cm">/* B port */</span><span class="cp"></span>
<span class="cp">#define TS			2	</span><span class="cm">/* S port */</span><span class="cp"></span>
<span class="cp">#define TM			3	</span><span class="cm">/* M port */</span><span class="cp"></span>
<span class="cp">#define TNONE			4</span>


<span class="cm">/*</span>
<span class="cm"> * indexes in MIB</span>
<span class="cm"> */</span>
<span class="cp">#define INDEX_MAC	1</span>
<span class="cp">#define INDEX_PATH	1</span>
<span class="cp">#define INDEX_PORT	1</span>


<span class="cm">/*</span>
<span class="cm"> * policies</span>
<span class="cm"> */</span>
<span class="cp">#define POLICY_AA	(1&lt;&lt;0)		</span><span class="cm">/* reject AA */</span><span class="cp"></span>
<span class="cp">#define POLICY_AB	(1&lt;&lt;1)		</span><span class="cm">/* reject AB */</span><span class="cp"></span>
<span class="cp">#define POLICY_AS	(1&lt;&lt;2)		</span><span class="cm">/* reject AS */</span><span class="cp"></span>
<span class="cp">#define POLICY_AM	(1&lt;&lt;3)		</span><span class="cm">/* reject AM */</span><span class="cp"></span>
<span class="cp">#define POLICY_BA	(1&lt;&lt;4)		</span><span class="cm">/* reject BA */</span><span class="cp"></span>
<span class="cp">#define POLICY_BB	(1&lt;&lt;5)		</span><span class="cm">/* reject BB */</span><span class="cp"></span>
<span class="cp">#define POLICY_BS	(1&lt;&lt;6)		</span><span class="cm">/* reject BS */</span><span class="cp"></span>
<span class="cp">#define POLICY_BM	(1&lt;&lt;7)		</span><span class="cm">/* reject BM */</span><span class="cp"></span>
<span class="cp">#define POLICY_SA	(1&lt;&lt;8)		</span><span class="cm">/* reject SA */</span><span class="cp"></span>
<span class="cp">#define POLICY_SB	(1&lt;&lt;9)		</span><span class="cm">/* reject SB */</span><span class="cp"></span>
<span class="cp">#define POLICY_SS	(1&lt;&lt;10)		</span><span class="cm">/* reject SS */</span><span class="cp"></span>
<span class="cp">#define POLICY_SM	(1&lt;&lt;11)		</span><span class="cm">/* reject SM */</span><span class="cp"></span>
<span class="cp">#define POLICY_MA	(1&lt;&lt;12)		</span><span class="cm">/* reject MA */</span><span class="cp"></span>
<span class="cp">#define POLICY_MB	(1&lt;&lt;13)		</span><span class="cm">/* reject MB */</span><span class="cp"></span>
<span class="cp">#define POLICY_MS	(1&lt;&lt;14)		</span><span class="cm">/* reject MS */</span><span class="cp"></span>
<span class="cp">#define POLICY_MM	(1&lt;&lt;15)		</span><span class="cm">/* reject MM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * commands</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * EVENTS</span>
<span class="cm"> * event classes</span>
<span class="cm"> */</span>
<span class="cp">#define EVENT_ECM	1		</span><span class="cm">/* event class ECM */</span><span class="cp"></span>
<span class="cp">#define EVENT_CFM	2		</span><span class="cm">/* event class CFM */</span><span class="cp"></span>
<span class="cp">#define EVENT_RMT	3		</span><span class="cm">/* event class RMT */</span><span class="cp"></span>
<span class="cp">#define EVENT_SMT	4		</span><span class="cm">/* event class SMT */</span><span class="cp"></span>
<span class="cp">#define EVENT_PCM	5		</span><span class="cm">/* event class PCM */</span><span class="cp"></span>
<span class="cp">#define EVENT_PCMA	5		</span><span class="cm">/* event class PCMA */</span><span class="cp"></span>
<span class="cp">#define EVENT_PCMB	6		</span><span class="cm">/* event class PCMB */</span><span class="cp"></span>

<span class="cm">/* WARNING :</span>
<span class="cm"> * EVENT_PCM* must be last in the above list</span>
<span class="cm"> * if more than two ports are used, EVENT_PCM .. EVENT_PCMA+NUM_PHYS-1</span>
<span class="cm"> * are used !</span>
<span class="cm"> */</span>

<span class="cp">#define EV_TOKEN(class,event)	(((u_long)(class)&lt;&lt;16L)|((u_long)(event)))</span>
<span class="cp">#define EV_T_CLASS(token)	((int)((token)&gt;&gt;16)&amp;0xffff)</span>
<span class="cp">#define EV_T_EVENT(token)	((int)(token)&amp;0xffff)</span>

<span class="cm">/*</span>
<span class="cm"> * ECM events</span>
<span class="cm"> */</span>
<span class="cp">#define EC_CONNECT	1		</span><span class="cm">/* connect request */</span><span class="cp"></span>
<span class="cp">#define EC_DISCONNECT	2		</span><span class="cm">/* disconnect request */</span><span class="cp"></span>
<span class="cp">#define EC_TRACE_PROP	3		</span><span class="cm">/* trace propagation */</span><span class="cp"></span>
<span class="cp">#define EC_PATH_TEST	4		</span><span class="cm">/* path test */</span><span class="cp"></span>
<span class="cp">#define EC_TIMEOUT_TD	5		</span><span class="cm">/* timer TD_min */</span><span class="cp"></span>
<span class="cp">#define EC_TIMEOUT_TMAX	6		</span><span class="cm">/* timer trace_max */</span><span class="cp"></span>
<span class="cp">#define EC_TIMEOUT_IMAX	7		</span><span class="cm">/* timer I_max */</span><span class="cp"></span>
<span class="cp">#define EC_TIMEOUT_INMAX 8		</span><span class="cm">/* timer IN_max */</span><span class="cp"></span>
<span class="cp">#define EC_TEST_DONE	9		</span><span class="cm">/* path test done */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * CFM events</span>
<span class="cm"> */</span>
<span class="cp">#define CF_LOOP		1		</span><span class="cm">/* cf_loop flag from PCM */</span><span class="cp"></span>
<span class="cp">#define CF_LOOP_A	1		</span><span class="cm">/* cf_loop flag from PCM */</span><span class="cp"></span>
<span class="cp">#define CF_LOOP_B	2		</span><span class="cm">/* cf_loop flag from PCM */</span><span class="cp"></span>
<span class="cp">#define CF_JOIN		3		</span><span class="cm">/* cf_join flag from PCM */</span><span class="cp"></span>
<span class="cp">#define CF_JOIN_A	3		</span><span class="cm">/* cf_join flag from PCM */</span><span class="cp"></span>
<span class="cp">#define CF_JOIN_B	4		</span><span class="cm">/* cf_join flag from PCM */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * PCM events</span>
<span class="cm"> */</span>
<span class="cp">#define PC_START		1</span>
<span class="cp">#define PC_STOP			2</span>
<span class="cp">#define PC_LOOP			3</span>
<span class="cp">#define PC_JOIN			4</span>
<span class="cp">#define PC_SIGNAL		5</span>
<span class="cp">#define PC_REJECT		6</span>
<span class="cp">#define PC_MAINT    		7</span>
<span class="cp">#define PC_TRACE		8</span>
<span class="cp">#define PC_PDR			9</span>
<span class="cp">#define PC_ENABLE		10</span>
<span class="cp">#define PC_DISABLE		11</span>

<span class="cm">/*</span>
<span class="cm"> * must be ordered as in LineStateType</span>
<span class="cm"> */</span>
<span class="cp">#define PC_QLS			12</span>
<span class="cp">#define PC_ILS			13</span>
<span class="cp">#define PC_MLS			14</span>
<span class="cp">#define PC_HLS			15</span>
<span class="cp">#define PC_LS_PDR		16</span>
<span class="cp">#define PC_LS_NONE		17</span>
<span class="cp">#define LS2MIB(x)	((x)-PC_QLS)</span>
<span class="cp">#define MIB2LS(x)	((x)+PC_QLS)</span>

<span class="cp">#define PC_TIMEOUT_TB_MAX	18	</span><span class="cm">/* timer TB_max */</span><span class="cp"></span>
<span class="cp">#define PC_TIMEOUT_TB_MIN	19	</span><span class="cm">/* timer TB_min */</span><span class="cp"></span>
<span class="cp">#define PC_TIMEOUT_C_MIN	20	</span><span class="cm">/* timer C_Min */</span><span class="cp"></span>
<span class="cp">#define PC_TIMEOUT_T_OUT	21	</span><span class="cm">/* timer T_Out */</span><span class="cp"></span>
<span class="cp">#define PC_TIMEOUT_TL_MIN	22	</span><span class="cm">/* timer TL_Min */</span><span class="cp"></span>
<span class="cp">#define PC_TIMEOUT_T_NEXT	23	</span><span class="cm">/* timer t_next[] */</span><span class="cp"></span>
<span class="cp">#define PC_TIMEOUT_LCT		24</span>
<span class="cp">#define PC_NSE			25	</span><span class="cm">/* NOISE hardware timer */</span><span class="cp"></span>
<span class="cp">#define PC_LEM			26	</span><span class="cm">/* LEM done */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * RMT events				  meaning		from</span>
<span class="cm"> */</span>
<span class="cp">#define RM_RING_OP	1		</span><span class="cm">/* ring operational	MAC	*/</span><span class="cp"></span>
<span class="cp">#define RM_RING_NON_OP	2		</span><span class="cm">/* ring not operational	MAC	*/</span><span class="cp"></span>
<span class="cp">#define RM_MY_BEACON	3		</span><span class="cm">/* recvd my beacon	MAC	*/</span><span class="cp"></span>
<span class="cp">#define RM_OTHER_BEACON	4		</span><span class="cm">/* recvd other beacon	MAC	*/</span><span class="cp"></span>
<span class="cp">#define RM_MY_CLAIM	5		</span><span class="cm">/* recvd my claim	MAC	*/</span><span class="cp"></span>
<span class="cp">#define RM_TRT_EXP	6		</span><span class="cm">/* TRT exp		MAC	*/</span><span class="cp"></span>
<span class="cp">#define RM_VALID_CLAIM	7		</span><span class="cm">/* claim from dup addr	MAC	*/</span><span class="cp"></span>
<span class="cp">#define RM_JOIN		8		</span><span class="cm">/* signal rm_join	CFM	*/</span><span class="cp"></span>
<span class="cp">#define RM_LOOP		9		</span><span class="cm">/* signal rm_loop	CFM	*/</span><span class="cp"></span>
<span class="cp">#define RM_DUP_ADDR	10		</span><span class="cm">/* dup_addr_test hange	SMT-NIF	*/</span><span class="cp"></span>
<span class="cp">#define RM_ENABLE_FLAG	11		</span><span class="cm">/* enable flag */</span><span class="cp"></span>

<span class="cp">#define RM_TIMEOUT_NON_OP	12	</span><span class="cm">/* timeout T_Non_OP	*/</span><span class="cp"></span>
<span class="cp">#define RM_TIMEOUT_T_STUCK	13	</span><span class="cm">/* timeout T_Stuck	*/</span><span class="cp"></span>
<span class="cp">#define RM_TIMEOUT_ANNOUNCE	14	</span><span class="cm">/* timeout T_Announce	*/</span><span class="cp"></span>
<span class="cp">#define RM_TIMEOUT_T_DIRECT	15	</span><span class="cm">/* timeout T_Direct	*/</span><span class="cp"></span>
<span class="cp">#define RM_TIMEOUT_D_MAX	16	</span><span class="cm">/* timeout D_Max	*/</span><span class="cp"></span>
<span class="cp">#define RM_TIMEOUT_POLL		17	</span><span class="cm">/* claim/beacon poller	*/</span><span class="cp"></span>
<span class="cp">#define RM_TX_STATE_CHANGE	18	</span><span class="cm">/* To restart timer for D_Max */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * SMT events</span>
<span class="cm"> */</span>
<span class="cp">#define SM_TIMER	1		</span><span class="cm">/* timer */</span><span class="cp"></span>
<span class="cp">#define SM_FAST		2		</span><span class="cm">/* smt_force_irq */</span><span class="cp"></span>

<span class="cm">/* PC modes */</span>
<span class="cp">#define PM_NONE		0</span>
<span class="cp">#define PM_PEER		1</span>
<span class="cp">#define PM_TREE		2</span>

<span class="cm">/*</span>
<span class="cm"> * PCM withhold codes</span>
<span class="cm"> * MIB PC-WithholdType ENUM</span>
<span class="cm"> */</span>
<span class="cp">#define PC_WH_NONE	0		</span><span class="cm">/* ok */</span><span class="cp"></span>
<span class="cp">#define PC_WH_M_M	1		</span><span class="cm">/* M to M */</span><span class="cp"></span>
<span class="cp">#define PC_WH_OTHER	2		</span><span class="cm">/* other incompatible phys */</span><span class="cp"></span>
<span class="cp">#define PC_WH_PATH	3		</span><span class="cm">/* path not available */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * LCT duration</span>
<span class="cm"> */</span>
<span class="cp">#define LC_SHORT	1		</span><span class="cm">/* short LCT */</span><span class="cp"></span>
<span class="cp">#define LC_MEDIUM	2		</span><span class="cm">/* medium LCT */</span><span class="cp"></span>
<span class="cp">#define LC_LONG		3		</span><span class="cm">/* long LCT */</span><span class="cp"></span>
<span class="cp">#define LC_EXTENDED	4		</span><span class="cm">/* extended LCT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * path_test values</span>
<span class="cm"> */</span>
<span class="cp">#define PT_NONE		0</span>
<span class="cp">#define PT_TESTING	1		</span><span class="cm">/* test is running */</span><span class="cp"></span>
<span class="cp">#define PT_PASSED	2		</span><span class="cm">/* test passed */</span><span class="cp"></span>
<span class="cp">#define PT_FAILED	3		</span><span class="cm">/* test failed */</span><span class="cp"></span>
<span class="cp">#define PT_PENDING	4		</span><span class="cm">/* path test follows */</span><span class="cp"></span>
<span class="cp">#define PT_EXITING	5		</span><span class="cm">/* disconnected while in trace/leave */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * duplicate address test</span>
<span class="cm"> * MIB DupAddressTest ENUM</span>
<span class="cm"> */</span>
<span class="cp">#define DA_NONE		0		</span><span class="cm">/* 		*/</span><span class="cp"></span>
<span class="cp">#define DA_PASSED	1		</span><span class="cm">/* test passed */</span><span class="cp"></span>
<span class="cp">#define DA_FAILED	2		</span><span class="cm">/* test failed */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * optical bypass</span>
<span class="cm"> */</span>
<span class="cp">#define BP_DEINSERT	0		</span><span class="cm">/* disable bypass */</span><span class="cp"></span>
<span class="cp">#define BP_INSERT	1		</span><span class="cm">/* enable bypass */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ODL enable/disable</span>
<span class="cm"> */</span>
<span class="cp">#define PM_TRANSMIT_DISABLE	0	</span><span class="cm">/* disable xmit */</span><span class="cp"></span>
<span class="cp">#define PM_TRANSMIT_ENABLE	1	</span><span class="cm">/* enable xmit */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * parameter for config_mux</span>
<span class="cm"> * note : number is index in config_endec table !</span>
<span class="cm"> */</span>
<span class="cp">#define MUX_THRUA	0		</span><span class="cm">/* through A */</span><span class="cp"></span>
<span class="cp">#define MUX_THRUB	1		</span><span class="cm">/* through B */</span><span class="cp"></span>
<span class="cp">#define MUX_WRAPA	2		</span><span class="cm">/* wrap A */</span><span class="cp"></span>
<span class="cp">#define MUX_WRAPB	3		</span><span class="cm">/* wrap B */</span><span class="cp"></span>
<span class="cp">#define MUX_ISOLATE	4		</span><span class="cm">/* isolated */</span><span class="cp"></span>
<span class="cp">#define MUX_WRAPS	5		</span><span class="cm">/* SAS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * MAC control</span>
<span class="cm"> */</span>
<span class="cp">#define MA_RESET	0</span>
<span class="cp">#define MA_BEACON	1</span>
<span class="cp">#define MA_CLAIM	2</span>
<span class="cp">#define MA_DIRECTED	3		</span><span class="cm">/* directed beacon */</span><span class="cp"></span>
<span class="cp">#define MA_TREQ		4		</span><span class="cm">/* change T_Req */</span><span class="cp"></span>
<span class="cp">#define MA_OFFLINE	5		</span><span class="cm">/* switch MAC to offline */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * trace prop</span>
<span class="cm"> * bit map for trace propagation</span>
<span class="cm"> */</span>
<span class="cp">#define ENTITY_MAC	(NUMPHYS)</span>
<span class="cp">#define ENTITY_PHY(p)	(p)</span>
<span class="cp">#define ENTITY_BIT(m)	(1&lt;&lt;(m))</span>

<span class="cm">/*</span>
<span class="cm"> * Resource Tag Types</span>
<span class="cm"> */</span>
<span class="cp">#define PATH_ISO	0	</span><span class="cm">/* isolated */</span><span class="cp"></span>
<span class="cp">#define PATH_PRIM	3	</span><span class="cm">/* primary path */</span><span class="cp"></span>
<span class="cp">#define PATH_THRU	5	</span><span class="cm">/* through path */</span><span class="cp"></span>

<span class="cp">#define RES_MAC		2	</span><span class="cm">/* resource type MAC */</span><span class="cp"></span>
<span class="cp">#define RES_PORT	4	</span><span class="cm">/* resource type PORT */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * CFM state</span>
<span class="cm"> * oops: MUST MATCH CF-StateType in SMT7.2 !</span>
<span class="cm"> */</span>
<span class="cp">#define SC0_ISOLATED	0		</span><span class="cm">/* isolated */</span><span class="cp"></span>
<span class="cp">#define SC1_WRAP_A	5		</span><span class="cm">/* wrap A (not used) */</span><span class="cp"></span>
<span class="cp">#define SC2_WRAP_B	6		</span><span class="cm">/* wrap B (not used) */</span><span class="cp"></span>
<span class="cp">#define SC4_THRU_A	12		</span><span class="cm">/* through A */</span><span class="cp"></span>
<span class="cp">#define SC5_THRU_B	7		</span><span class="cm">/* through B (used in SMT 6.2) */</span><span class="cp"></span>
<span class="cp">#define SC7_WRAP_S	8		</span><span class="cm">/* SAS (not used) */</span><span class="cp"></span>
<span class="cp">#define SC9_C_WRAP_A	9		</span><span class="cm">/* c wrap A */</span><span class="cp"></span>
<span class="cp">#define SC10_C_WRAP_B	10		</span><span class="cm">/* c wrap B */</span><span class="cp"></span>
<span class="cp">#define SC11_C_WRAP_S	11		</span><span class="cm">/* c wrap S */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * convert MIB time in units of 80nS to uS</span>
<span class="cm"> */</span>
<span class="cp">#define MIB2US(t)		((t)/12)</span>
<span class="cp">#define SEC2MIB(s)	((s)*12500000L)</span>
<span class="cm">/*</span>
<span class="cm"> * SMT timer</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">smt_timer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smt_timer</span>	<span class="o">*</span><span class="n">tm_next</span> <span class="p">;</span>	<span class="cm">/* linked list */</span>
	<span class="k">struct</span> <span class="n">s_smc</span>		<span class="o">*</span><span class="n">tm_smc</span> <span class="p">;</span>	<span class="cm">/* pointer to context */</span>
	<span class="n">u_long</span>			<span class="n">tm_delta</span> <span class="p">;</span>	<span class="cm">/* delta time */</span>
	<span class="n">u_long</span>			<span class="n">tm_token</span> <span class="p">;</span>	<span class="cm">/* token value */</span>
	<span class="n">u_short</span>			<span class="n">tm_active</span> <span class="p">;</span>	<span class="cm">/* flag : active/inactive */</span>
	<span class="n">u_short</span>			<span class="n">tm_pad</span> <span class="p">;</span>	<span class="cm">/* pad field */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * communication structures</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mac_parameter</span> <span class="p">{</span>
	<span class="n">u_long</span>	<span class="n">t_neg</span> <span class="p">;</span>		<span class="cm">/* T_Neg parameter */</span>
	<span class="n">u_long</span>	<span class="n">t_pri</span> <span class="p">;</span>		<span class="cm">/* T_Pri register in MAC */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * MAC counters</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mac_counter</span> <span class="p">{</span>
	<span class="n">u_long</span>	<span class="n">mac_nobuf_counter</span> <span class="p">;</span>	<span class="cm">/* MAC SW counter: no buffer */</span>
	<span class="n">u_long</span>	<span class="n">mac_r_restart_counter</span> <span class="p">;</span>	<span class="cm">/* MAC SW counter: rx restarted */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * para struct context for SMT parameters</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">s_pcon</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">pc_len</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">pc_err</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">pc_badset</span> <span class="p">;</span>
	<span class="kt">void</span>	<span class="o">*</span><span class="n">pc_p</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * link error monitor</span>
<span class="cm"> */</span>
<span class="cp">#define LEM_AVG	5</span>
<span class="k">struct</span> <span class="n">lem_counter</span> <span class="p">{</span>
<span class="cp">#ifdef	AM29K</span>
	<span class="kt">int</span>	<span class="n">lem_on</span>	<span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">lem_errors</span> <span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">lem_symbols</span> <span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">lem_tsymbols</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">lem_s_count</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">lem_n_s</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">lem_values</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">lem_index</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">lem_avg_ber</span><span class="p">[</span><span class="n">LEM_AVG</span><span class="p">]</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">lem_sum</span> <span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">u_short</span>	<span class="n">lem_float_ber</span> <span class="p">;</span>		<span class="cm">/* 10E-nn bit error rate */</span>
	<span class="n">u_long</span>	<span class="n">lem_errors</span> <span class="p">;</span>		<span class="cm">/* accumulated error count */</span>
	<span class="n">u_short</span>	<span class="n">lem_on</span>	<span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cp">#define NUMBITS	10</span>

<span class="cp">#ifdef	AMDPLC</span>

<span class="cm">/*</span>
<span class="cm"> * PLC state table</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">s_plc</span> <span class="p">{</span>
	<span class="n">u_short</span>	<span class="n">p_state</span> <span class="p">;</span>		<span class="cm">/* current state */</span>
	<span class="n">u_short</span>	<span class="n">p_bits</span> <span class="p">;</span>		<span class="cm">/* number of bits to send */</span>
	<span class="n">u_short</span>	<span class="n">p_start</span> <span class="p">;</span>		<span class="cm">/* first bit pos */</span>
	<span class="n">u_short</span>	<span class="n">p_pad</span> <span class="p">;</span>			<span class="cm">/* padding for alignment */</span>
	<span class="n">u_long</span> <span class="n">soft_err</span> <span class="p">;</span>		<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">parity_err</span> <span class="p">;</span>		<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">ebuf_err</span> <span class="p">;</span>		<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">ebuf_cont</span> <span class="p">;</span>		<span class="cm">/* continuous error counter */</span>
	<span class="n">u_long</span> <span class="n">phyinv</span> <span class="p">;</span>			<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">vsym_ctr</span> <span class="p">;</span>		<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">mini_ctr</span> <span class="p">;</span>		<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">tpc_exp</span> <span class="p">;</span>		<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">np_err</span> <span class="p">;</span>			<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">b_pcs</span> <span class="p">;</span>			<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">b_tpc</span> <span class="p">;</span>			<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">b_tne</span> <span class="p">;</span>			<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">b_qls</span> <span class="p">;</span>			<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">b_ils</span> <span class="p">;</span>			<span class="cm">/* error counter */</span>
	<span class="n">u_long</span> <span class="n">b_hls</span> <span class="p">;</span>			<span class="cm">/* error counter */</span>
<span class="p">}</span> <span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	PROTOTYP_INC</span>
<span class="cp">#include &quot;fddi/driver.pro&quot;</span>
<span class="cp">#else	</span><span class="cm">/* PROTOTYP_INC */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * function prototypes</span>
<span class="cm"> */</span>
<span class="cp">#include &quot;mbuf.h&quot;	</span><span class="cm">/* Type definitions for MBUFs */</span><span class="cp"></span>
<span class="cp">#include &quot;smtstate.h&quot;	</span><span class="cm">/* struct smt_state */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">hwt_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>	<span class="cm">/* hwt.c */</span>
<span class="n">SMbuf</span> <span class="o">*</span><span class="n">smt_build_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>	<span class="cm">/* smt.c */</span>
<span class="n">SMbuf</span> <span class="o">*</span><span class="n">smt_get_mbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>	<span class="cm">/* drvsr.c */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">sm_to_para</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smt_header</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span>
		 <span class="kt">int</span> <span class="n">para</span><span class="p">);</span>		<span class="cm">/* smt.c */</span>

<span class="cp">#ifndef SK_UNUSED</span>
<span class="cp">#define SK_UNUSED(var)		(void)(var)</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="n">queue_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecm</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rmt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcm</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">cfm</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">cfm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_timer_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smt_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">time</span><span class="p">,</span>
		     <span class="n">u_long</span> <span class="n">token</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_timer_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smt_timer</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcm_status_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="o">*</span><span class="n">remote</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mac</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">plc_config_mux</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mux</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sm_lem_evaluate</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_update_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sm_pm_ls_latch</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on_off</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sm_ma_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sm_mac_check_beacon_claim</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">config_mux</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mux</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_agent_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_timer_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_received_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">SMbuf</span> <span class="o">*</span><span class="n">mb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_add_para</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">s_pcon</span> <span class="o">*</span><span class="n">pcon</span><span class="p">,</span> <span class="n">u_short</span> <span class="n">para</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_swap_para</span><span class="p">(</span><span class="k">struct</span> <span class="n">smt_header</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hwt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="n">u_long</span> <span class="n">hwt_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hwt_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hwt_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">time</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_send_mbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">SMbuf</span> <span class="o">*</span><span class="n">mb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_free_mbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">SMbuf</span> <span class="o">*</span><span class="n">mb</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">sm_pm_bypass_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rmt_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">cfm_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c_state</span><span class="p">);</span>

<span class="cp">#if defined(DEBUG) || !defined(NO_SMT_PANIC)</span>
<span class="kt">void</span> <span class="n">smt_panic</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define	smt_panic(smc,text)</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG || !NO_SMT_PANIC */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">smt_stat_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stat</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_timer_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="n">u_long</span> <span class="n">smt_get_time</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">u_long</span> <span class="n">smt_get_tid</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_timer_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_fixup_mib</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_reset_defaults</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_agent_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">smt_check_para</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smt_header</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span>
		   <span class="k">const</span> <span class="n">u_short</span> <span class="n">list</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="n">driver_get_bia</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fddi_addr</span> <span class="o">*</span><span class="n">bia_addr</span><span class="p">);</span>

<span class="cp">#ifdef SUPERNET_3</span>
<span class="kt">void</span> <span class="n">drv_reset_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* SUPERNET_3 */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">smt_start_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">timer_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">token</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ev_dispatcher</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcm_get_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smt_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ecm_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e_state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sm_pm_bypass_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">pcm_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p_state</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rmt_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r_state</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sm_pm_get_ls</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phy</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcm_get_s_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pcm_rooted_station</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cfm_get_mac_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cfm_get_mac_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">cem_build_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">path_index</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sm_mac_get_tx_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">get_pcmstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">np</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">smt_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">class</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span>
<span class="n">u_short</span> <span class="n">smt_online</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_force_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_pmf_received_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">SMbuf</span> <span class="o">*</span><span class="n">mb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_send_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">SMbuf</span> <span class="o">*</span><span class="n">mb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">local</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_set_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span>	<span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">mac_add_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fddi_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">can</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_update_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_clear_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">set_formac_tsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">long</span> <span class="n">sync_bw</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">formac_reinit_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">formac_tx_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">process_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">init_driver_fplus</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rtm_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">rtm_set_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ring_status_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">status</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">llc_recover_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">llc_restart_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">plc_clear_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">plc_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span>	<span class="kt">int</span> <span class="n">np</span><span class="p">,</span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">smt_set_mac_opvalues</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>

<span class="cp">#ifdef TAG_MODE</span>
<span class="kt">void</span> <span class="n">mac_do_pci_fix</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_drv_clear_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">mac_drv_repair_descr</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="n">u_long</span> <span class="n">hwt_quick_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">hwt_wait_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">long</span> <span class="n">duration</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SMT_PNMI</span>
<span class="kt">int</span> <span class="n">pnmi_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span><span class="o">*</span> <span class="n">smc</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">pnmi_process_ndis_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">ndis_oid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="o">*</span><span class="n">BytesAccessed</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">BytesNeeded</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">action</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	SBA</span>
<span class="cp">#ifndef _H2INC</span>
<span class="kt">void</span> <span class="n">sba</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="kt">void</span> <span class="n">sba_raf_received_pack</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">sba_timer_poll</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">smt_init_sba</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	ESS</span>
<span class="kt">int</span> <span class="n">ess_raf_received_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">SMbuf</span> <span class="o">*</span><span class="n">mb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smt_header</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">fs</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ess_timer_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ess_para_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	BOOT</span>
<span class="kt">void</span> <span class="n">smt_init_evc</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">smt_srf_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cond</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define smt_init_evc(smc)</span>
<span class="cp">#define smt_srf_event(smc,code,index,cond)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef SMT_REAL_TOKEN_CT</span>
<span class="kt">void</span> <span class="n">smt_emulate_token_ct</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mac_index</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(DEBUG) &amp;&amp; !defined(BOOT)</span>
<span class="kt">void</span> <span class="n">dump_smt</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smt_header</span> <span class="o">*</span><span class="n">sm</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define	dump_smt(smc,sm,text)</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	DEBUG</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">addr_to_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">fddi_addr</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dump_hex</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#endif	</span><span class="cm">/* PROTOTYP_INC */</span><span class="cp"></span>

<span class="cm">/* PNMI default defines */</span>
<span class="cp">#ifndef PNMI_INIT</span>
<span class="cp">#define	PNMI_INIT(smc)	</span><span class="cm">/* Nothing */</span><span class="cp"></span>
<span class="cp">#endif</span>
<span class="cp">#ifndef PNMI_GET_ID</span>
<span class="cp">#define PNMI_GET_ID( smc, ndis_oid, buf, len, BytesWritten, BytesNeeded ) \</span>
<span class="cp">		( 1 ? (-1) : (-1) )</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef PNMI_SET_ID</span>
<span class="cp">#define PNMI_SET_ID( smc, ndis_oid, buf, len, BytesRead, BytesNeeded, \</span>
<span class="cp">		set_type) ( 1 ? (-1) : (-1) )</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * SMT_PANIC defines</span>
<span class="cm"> */</span>
<span class="cp">#ifndef	SMT_PANIC</span>
<span class="cp">#define	SMT_PANIC(smc,nr,msg)	smt_panic (smc, msg)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	SMT_ERR_LOG</span>
<span class="cp">#define	SMT_ERR_LOG(smc,nr,msg)	SMT_PANIC (smc, nr, msg)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef	SMT_EBASE</span>
<span class="cp">#define	SMT_EBASE	100</span>
<span class="cp">#endif</span>

<span class="cp">#define	SMT_E0100	SMT_EBASE + 0</span>
<span class="cp">#define	SMT_E0100_MSG	&quot;cfm FSM: invalid ce_type&quot;</span>
<span class="cp">#define	SMT_E0101	SMT_EBASE + 1</span>
<span class="cp">#define	SMT_E0101_MSG	&quot;CEM: case ???&quot;</span>
<span class="cp">#define	SMT_E0102	SMT_EBASE + 2</span>
<span class="cp">#define	SMT_E0102_MSG	&quot;CEM A: invalid state&quot;</span>
<span class="cp">#define	SMT_E0103	SMT_EBASE + 3</span>
<span class="cp">#define	SMT_E0103_MSG	&quot;CEM B: invalid state&quot;</span>
<span class="cp">#define	SMT_E0104	SMT_EBASE + 4</span>
<span class="cp">#define	SMT_E0104_MSG	&quot;CEM M: invalid state&quot;</span>
<span class="cp">#define	SMT_E0105	SMT_EBASE + 5</span>
<span class="cp">#define	SMT_E0105_MSG	&quot;CEM S: invalid state&quot;</span>
<span class="cp">#define	SMT_E0106	SMT_EBASE + 6</span>
<span class="cp">#define	SMT_E0106_MSG	&quot;CFM : invalid state&quot;</span>
<span class="cp">#define	SMT_E0107	SMT_EBASE + 7</span>
<span class="cp">#define	SMT_E0107_MSG	&quot;ECM : invalid state&quot;</span>
<span class="cp">#define	SMT_E0108	SMT_EBASE + 8</span>
<span class="cp">#define	SMT_E0108_MSG	&quot;prop_actions : NAC in DAS CFM&quot;</span>
<span class="cp">#define	SMT_E0109	SMT_EBASE + 9</span>
<span class="cp">#define	SMT_E0109_MSG	&quot;ST2U.FM_SERRSF error in special frame&quot;</span>
<span class="cp">#define	SMT_E0110	SMT_EBASE + 10</span>
<span class="cp">#define	SMT_E0110_MSG	&quot;ST2U.FM_SRFRCTOV recv. count. overflow&quot;</span>
<span class="cp">#define	SMT_E0111	SMT_EBASE + 11</span>
<span class="cp">#define	SMT_E0111_MSG	&quot;ST2U.FM_SNFSLD NP &amp; FORMAC simult. load&quot;</span>
<span class="cp">#define	SMT_E0112	SMT_EBASE + 12</span>
<span class="cp">#define	SMT_E0112_MSG	&quot;ST2U.FM_SRCVFRM single-frame recv.-mode&quot;</span>
<span class="cp">#define	SMT_E0113	SMT_EBASE + 13</span>
<span class="cp">#define	SMT_E0113_MSG	&quot;FPLUS: Buffer Memory Error&quot;</span>
<span class="cp">#define	SMT_E0114	SMT_EBASE + 14</span>
<span class="cp">#define	SMT_E0114_MSG	&quot;ST2U.FM_SERRSF error in special frame&quot;</span>
<span class="cp">#define	SMT_E0115	SMT_EBASE + 15</span>
<span class="cp">#define	SMT_E0115_MSG	&quot;ST3L: parity error in receive queue 2&quot;</span>
<span class="cp">#define	SMT_E0116	SMT_EBASE + 16</span>
<span class="cp">#define	SMT_E0116_MSG	&quot;ST3L: parity error in receive queue 1&quot;</span>
<span class="cp">#define	SMT_E0117	SMT_EBASE + 17</span>
<span class="cp">#define	SMT_E0117_MSG	&quot;E_SMT_001: RxD count for receive queue 1 = 0&quot;</span>
<span class="cp">#define	SMT_E0118	SMT_EBASE + 18</span>
<span class="cp">#define	SMT_E0118_MSG	&quot;PCM : invalid state&quot;</span>
<span class="cp">#define	SMT_E0119	SMT_EBASE + 19</span>
<span class="cp">#define	SMT_E0119_MSG	&quot;smt_add_para&quot;</span>
<span class="cp">#define	SMT_E0120	SMT_EBASE + 20</span>
<span class="cp">#define	SMT_E0120_MSG	&quot;smt_set_para&quot;</span>
<span class="cp">#define	SMT_E0121	SMT_EBASE + 21</span>
<span class="cp">#define	SMT_E0121_MSG	&quot;invalid event in dispatcher&quot;</span>
<span class="cp">#define	SMT_E0122	SMT_EBASE + 22</span>
<span class="cp">#define	SMT_E0122_MSG	&quot;RMT : invalid state&quot;</span>
<span class="cp">#define	SMT_E0123	SMT_EBASE + 23</span>
<span class="cp">#define	SMT_E0123_MSG	&quot;SBA: state machine has invalid state&quot;</span>
<span class="cp">#define	SMT_E0124	SMT_EBASE + 24</span>
<span class="cp">#define	SMT_E0124_MSG	&quot;sba_free_session() called with NULL pointer&quot;</span>
<span class="cp">#define	SMT_E0125	SMT_EBASE + 25</span>
<span class="cp">#define	SMT_E0125_MSG	&quot;SBA : invalid session pointer&quot;</span>
<span class="cp">#define	SMT_E0126	SMT_EBASE + 26</span>
<span class="cp">#define	SMT_E0126_MSG	&quot;smt_free_mbuf() called with NULL pointer\n&quot;</span>
<span class="cp">#define	SMT_E0127	SMT_EBASE + 27</span>
<span class="cp">#define	SMT_E0127_MSG	&quot;sizeof evcs&quot;</span>
<span class="cp">#define	SMT_E0128	SMT_EBASE + 28</span>
<span class="cp">#define	SMT_E0128_MSG	&quot;evc-&gt;evc_cond_state = 0&quot;</span>
<span class="cp">#define	SMT_E0129	SMT_EBASE + 29</span>
<span class="cp">#define	SMT_E0129_MSG	&quot;evc-&gt;evc_multiple = 0&quot;</span>
<span class="cp">#define	SMT_E0130	SMT_EBASE + 30</span>
<span class="cp">#define	SMT_E0130_MSG	write_mdr_warning</span>
<span class="cp">#define	SMT_E0131	SMT_EBASE + 31</span>
<span class="cp">#define	SMT_E0131_MSG	cam_warning</span>
<span class="cp">#define SMT_E0132	SMT_EBASE + 32</span>
<span class="cp">#define SMT_E0132_MSG	&quot;ST1L.FM_SPCEPDx parity/coding error&quot;</span>
<span class="cp">#define SMT_E0133	SMT_EBASE + 33</span>
<span class="cp">#define SMT_E0133_MSG	&quot;ST1L.FM_STBURx tx buffer underrun&quot;</span>
<span class="cp">#define SMT_E0134	SMT_EBASE + 34</span>
<span class="cp">#define SMT_E0134_MSG	&quot;ST1L.FM_SPCEPDx parity error&quot;</span>
<span class="cp">#define SMT_E0135	SMT_EBASE + 35</span>
<span class="cp">#define SMT_E0135_MSG	&quot;RMT: duplicate MAC address detected. Ring left!&quot;</span>
<span class="cp">#define SMT_E0136	SMT_EBASE + 36</span>
<span class="cp">#define SMT_E0136_MSG	&quot;Elasticity Buffer hang-up&quot;</span>
<span class="cp">#define SMT_E0137	SMT_EBASE + 37</span>
<span class="cp">#define SMT_E0137_MSG	&quot;SMT: queue overrun&quot;</span>
<span class="cp">#define SMT_E0138	SMT_EBASE + 38</span>
<span class="cp">#define SMT_E0138_MSG	&quot;RMT: duplicate MAC address detected. Ring NOT left!&quot;</span>
<span class="cp">#endif	</span><span class="cm">/* _CMTDEF_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
