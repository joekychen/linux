<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › fddi › skfp › h › fplustm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>fplustm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *	(C)Copyright 1998,1999 SysKonnect,</span>
<span class="cm"> *	a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	The information in this file is provided &quot;AS IS&quot; without warranty.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> *	AMD Fplus in tag mode data structs</span>
<span class="cm"> *	defs for fplustm.c</span>
<span class="cm"> */</span>

<span class="cp">#ifndef	_FPLUS_</span>
<span class="cp">#define _FPLUS_</span>

<span class="cp">#ifndef	HW_PTR</span>
<span class="cp">#define	HW_PTR	void __iomem *</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * fplus error statistic structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">err_st</span> <span class="p">{</span>
	<span class="n">u_long</span> <span class="n">err_valid</span> <span class="p">;</span>		<span class="cm">/* memory status valid */</span>
	<span class="n">u_long</span> <span class="n">err_abort</span> <span class="p">;</span>		<span class="cm">/* memory status receive abort */</span>
	<span class="n">u_long</span> <span class="n">err_e_indicator</span> <span class="p">;</span>	<span class="cm">/* error indicator */</span>
	<span class="n">u_long</span> <span class="n">err_crc</span> <span class="p">;</span>		<span class="cm">/* error detected (CRC or length) */</span>
	<span class="n">u_long</span> <span class="n">err_llc_frame</span> <span class="p">;</span>		<span class="cm">/* LLC frame */</span>
	<span class="n">u_long</span> <span class="n">err_mac_frame</span> <span class="p">;</span>		<span class="cm">/* MAC frame */</span>
	<span class="n">u_long</span> <span class="n">err_smt_frame</span> <span class="p">;</span>		<span class="cm">/* SMT frame */</span>
	<span class="n">u_long</span> <span class="n">err_imp_frame</span> <span class="p">;</span>		<span class="cm">/* implementer frame */</span>
	<span class="n">u_long</span> <span class="n">err_no_buf</span> <span class="p">;</span>		<span class="cm">/* no buffer available */</span>
	<span class="n">u_long</span> <span class="n">err_too_long</span> <span class="p">;</span>		<span class="cm">/* longer than max. buffer */</span>
	<span class="n">u_long</span> <span class="n">err_bec_stat</span> <span class="p">;</span>		<span class="cm">/* beacon state entered */</span>
	<span class="n">u_long</span> <span class="n">err_clm_stat</span> <span class="p">;</span>		<span class="cm">/* claim state entered */</span>
	<span class="n">u_long</span> <span class="n">err_sifg_det</span> <span class="p">;</span>		<span class="cm">/* short interframe gap detect */</span>
	<span class="n">u_long</span> <span class="n">err_phinv</span> <span class="p">;</span>		<span class="cm">/* PHY invalid */</span>
	<span class="n">u_long</span> <span class="n">err_tkiss</span> <span class="p">;</span>		<span class="cm">/* token issued */</span>
	<span class="n">u_long</span> <span class="n">err_tkerr</span> <span class="p">;</span>		<span class="cm">/* token error */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	Transmit Descriptor struct</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">txd_tbctrl</span> <span class="p">;</span>		<span class="cm">/* transmit buffer control */</span>
	<span class="n">__le32</span> <span class="n">txd_txdscr</span> <span class="p">;</span>		<span class="cm">/* transmit frame status word */</span>
	<span class="n">__le32</span> <span class="n">txd_tbadr</span> <span class="p">;</span>		<span class="cm">/* physical tx buffer address */</span>
	<span class="n">__le32</span> <span class="n">txd_ntdadr</span> <span class="p">;</span>		<span class="cm">/* physical pointer to the next TxD */</span>
<span class="cp">#ifdef	ENA_64BIT_SUP</span>
	<span class="n">__le32</span> <span class="n">txd_tbadr_hi</span> <span class="p">;</span>		<span class="cm">/* physical tx buffer addr (high dword)*/</span>
<span class="cp">#endif</span>
	<span class="kt">char</span> <span class="n">far</span> <span class="o">*</span><span class="n">txd_virt</span> <span class="p">;</span>		<span class="cm">/* virtual pointer to the data frag */</span>
					<span class="cm">/* virt pointer to the next TxD */</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="k">volatile</span> <span class="n">far</span> <span class="o">*</span><span class="n">txd_next</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_txd_os</span> <span class="n">txd_os</span> <span class="p">;</span>	<span class="cm">/* OS - specific struct */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	Receive Descriptor struct</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">rxd_rbctrl</span> <span class="p">;</span>		<span class="cm">/* receive buffer control */</span>
	<span class="n">__le32</span> <span class="n">rxd_rfsw</span> <span class="p">;</span>		<span class="cm">/* receive frame status word */</span>
	<span class="n">__le32</span> <span class="n">rxd_rbadr</span> <span class="p">;</span>		<span class="cm">/* physical rx buffer address */</span>
	<span class="n">__le32</span> <span class="n">rxd_nrdadr</span> <span class="p">;</span>		<span class="cm">/* physical pointer to the next RxD */</span>
<span class="cp">#ifdef	ENA_64BIT_SUP</span>
	<span class="n">__le32</span> <span class="n">rxd_rbadr_hi</span> <span class="p">;</span>		<span class="cm">/* physical tx buffer addr (high dword)*/</span>
<span class="cp">#endif</span>
	<span class="kt">char</span> <span class="n">far</span> <span class="o">*</span><span class="n">rxd_virt</span> <span class="p">;</span>		<span class="cm">/* virtual pointer to the data frag */</span>
					<span class="cm">/* virt pointer to the next RxD */</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="k">volatile</span> <span class="n">far</span> <span class="o">*</span><span class="n">rxd_next</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_rxd_os</span> <span class="n">rxd_os</span> <span class="p">;</span>	<span class="cm">/* OS - specific struct */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	Descriptor Union Definition</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">s_fp_descr</span> <span class="p">{</span>
	<span class="k">struct</span>	<span class="n">s_smt_fp_txd</span> <span class="n">t</span> <span class="p">;</span>		<span class="cm">/* pointer to the TxD */</span>
	<span class="k">struct</span>	<span class="n">s_smt_fp_rxd</span> <span class="n">r</span> <span class="p">;</span>		<span class="cm">/* pointer to the RxD */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	TxD Ring Control struct</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">s_smt_tx_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">tx_curr_put</span> <span class="p">;</span> <span class="cm">/* next free TxD */</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">tx_prev_put</span> <span class="p">;</span> <span class="cm">/* shadow put pointer */</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_txd</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">tx_curr_get</span> <span class="p">;</span> <span class="cm">/* next TxD to release*/</span>
	<span class="n">u_short</span> <span class="n">tx_free</span> <span class="p">;</span>			<span class="cm">/* count of free TxD&#39;s */</span>
	<span class="n">u_short</span> <span class="n">tx_used</span> <span class="p">;</span>			<span class="cm">/* count of used TxD&#39;s */</span>
	<span class="n">HW_PTR</span> <span class="n">tx_bmu_ctl</span> <span class="p">;</span>			<span class="cm">/* BMU addr for tx start */</span>
	<span class="n">HW_PTR</span> <span class="n">tx_bmu_dsc</span> <span class="p">;</span>			<span class="cm">/* BMU addr for curr dsc. */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	RxD Ring Control struct</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">s_smt_rx_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">rx_curr_put</span> <span class="p">;</span> <span class="cm">/* next RxD to queue into */</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">rx_prev_put</span> <span class="p">;</span> <span class="cm">/* shadow put pointer */</span>
	<span class="k">struct</span> <span class="n">s_smt_fp_rxd</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">rx_curr_get</span> <span class="p">;</span> <span class="cm">/* next RxD to fill */</span>
	<span class="n">u_short</span> <span class="n">rx_free</span> <span class="p">;</span>			<span class="cm">/* count of free RxD&#39;s */</span>
	<span class="n">u_short</span> <span class="n">rx_used</span> <span class="p">;</span>			<span class="cm">/* count of used RxD&#39;s */</span>
	<span class="n">HW_PTR</span> <span class="n">rx_bmu_ctl</span> <span class="p">;</span>			<span class="cm">/* BMU addr for rx start */</span>
	<span class="n">HW_PTR</span> <span class="n">rx_bmu_dsc</span> <span class="p">;</span>			<span class="cm">/* BMU addr for curr dsc. */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cp">#define VOID_FRAME_OFF		0x00</span>
<span class="cp">#define CLAIM_FRAME_OFF		0x08</span>
<span class="cp">#define BEACON_FRAME_OFF	0x10</span>
<span class="cp">#define DBEACON_FRAME_OFF	0x18</span>
<span class="cp">#define RX_FIFO_OFF		0x21		</span><span class="cm">/* to get a prime number for */</span><span class="cp"></span>
						<span class="cm">/* the RX_FIFO_SPACE */</span>

<span class="cp">#define RBC_MEM_SIZE		0x8000</span>
<span class="cp">#define SEND_ASYNC_AS_SYNC	0x1</span>
<span class="cp">#define	SYNC_TRAFFIC_ON		0x2</span>

<span class="cm">/* big FIFO memory */</span>
<span class="cp">#define	RX_FIFO_SPACE		0x4000 - RX_FIFO_OFF</span>
<span class="cp">#define	TX_FIFO_SPACE		0x4000</span>

<span class="cp">#define	TX_SMALL_FIFO		0x0900</span>
<span class="cp">#define	TX_MEDIUM_FIFO		TX_FIFO_SPACE / 2	</span>
<span class="cp">#define	TX_LARGE_FIFO		TX_FIFO_SPACE - TX_SMALL_FIFO	</span>

<span class="cp">#define	RX_SMALL_FIFO		0x0900</span>
<span class="cp">#define	RX_LARGE_FIFO		RX_FIFO_SPACE - RX_SMALL_FIFO	</span>

<span class="k">struct</span> <span class="n">s_smt_fifo_conf</span> <span class="p">{</span>
	<span class="n">u_short</span>	<span class="n">rbc_ram_start</span> <span class="p">;</span>		<span class="cm">/* FIFO start address */</span>
	<span class="n">u_short</span>	<span class="n">rbc_ram_end</span> <span class="p">;</span>		<span class="cm">/* FIFO size */</span>
	<span class="n">u_short</span>	<span class="n">rx1_fifo_start</span> <span class="p">;</span>	<span class="cm">/* rx queue start address */</span>
	<span class="n">u_short</span>	<span class="n">rx1_fifo_size</span> <span class="p">;</span>		<span class="cm">/* rx queue size */</span>
	<span class="n">u_short</span>	<span class="n">rx2_fifo_start</span> <span class="p">;</span>	<span class="cm">/* rx queue start address */</span>
	<span class="n">u_short</span>	<span class="n">rx2_fifo_size</span> <span class="p">;</span>		<span class="cm">/* rx queue size */</span>
	<span class="n">u_short</span>	<span class="n">tx_s_start</span> <span class="p">;</span>		<span class="cm">/* sync queue start address */</span>
	<span class="n">u_short</span>	<span class="n">tx_s_size</span> <span class="p">;</span>		<span class="cm">/* sync queue size */</span>
	<span class="n">u_short</span>	<span class="n">tx_a0_start</span> <span class="p">;</span>		<span class="cm">/* async queue A0 start address */</span>
	<span class="n">u_short</span>	<span class="n">tx_a0_size</span> <span class="p">;</span>		<span class="cm">/* async queue A0 size */</span>
	<span class="n">u_short</span>	<span class="n">fifo_config_mode</span> <span class="p">;</span>	<span class="cm">/* FIFO configuration mode */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cp">#define FM_ADDRX	(FM_ADDET|FM_EXGPA0|FM_EXGPA1)</span>

<span class="k">struct</span> <span class="n">s_smt_fp</span> <span class="p">{</span>
	<span class="n">u_short</span>	<span class="n">mdr2init</span> <span class="p">;</span>		<span class="cm">/* mode register 2 init value */</span>
	<span class="n">u_short</span>	<span class="n">mdr3init</span> <span class="p">;</span>		<span class="cm">/* mode register 3 init value */</span>
	<span class="n">u_short</span> <span class="n">frselreg_init</span> <span class="p">;</span>		<span class="cm">/* frame selection register init val */</span>
	<span class="n">u_short</span>	<span class="n">rx_mode</span> <span class="p">;</span>		<span class="cm">/* address mode broad/multi/promisc */</span>
	<span class="n">u_short</span>	<span class="n">nsa_mode</span> <span class="p">;</span>
	<span class="n">u_short</span> <span class="n">rx_prom</span> <span class="p">;</span>
	<span class="n">u_short</span>	<span class="n">exgpa</span> <span class="p">;</span>

	<span class="k">struct</span> <span class="n">err_st</span> <span class="n">err_stats</span> <span class="p">;</span>	<span class="cm">/* error statistics */</span>

	<span class="cm">/*</span>
<span class="cm">	 * MAC buffers</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">fddi_mac_sf</span> <span class="p">{</span>		<span class="cm">/* special frame build buffer */</span>
		<span class="n">u_char</span>			<span class="n">mac_fc</span> <span class="p">;</span>
		<span class="k">struct</span> <span class="n">fddi_addr</span>	<span class="n">mac_dest</span> <span class="p">;</span>
		<span class="k">struct</span> <span class="n">fddi_addr</span>	<span class="n">mac_source</span> <span class="p">;</span>
		<span class="n">u_char</span>			<span class="n">mac_info</span><span class="p">[</span><span class="mh">0x20</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span> <span class="n">mac_sfb</span> <span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * queues</span>
<span class="cm">	 */</span>
<span class="cp">#define QUEUE_S			0</span>
<span class="cp">#define QUEUE_A0		1</span>
<span class="cp">#define QUEUE_R1		0</span>
<span class="cp">#define QUEUE_R2		1</span>
<span class="cp">#define USED_QUEUES		2</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue pointers; points to the queue dependent variables</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">s_smt_tx_queue</span> <span class="o">*</span><span class="n">tx</span><span class="p">[</span><span class="n">USED_QUEUES</span><span class="p">]</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_smt_rx_queue</span> <span class="o">*</span><span class="n">rx</span><span class="p">[</span><span class="n">USED_QUEUES</span><span class="p">]</span> <span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * queue dependent variables</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">s_smt_tx_queue</span> <span class="n">tx_q</span><span class="p">[</span><span class="n">USED_QUEUES</span><span class="p">]</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_smt_rx_queue</span> <span class="n">rx_q</span><span class="p">[</span><span class="n">USED_QUEUES</span><span class="p">]</span> <span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * FIFO configuration struct</span>
<span class="cm">	 */</span>
	<span class="k">struct</span>	<span class="n">s_smt_fifo_conf</span>	<span class="n">fifo</span> <span class="p">;</span>

	<span class="cm">/* last formac status */</span>
	<span class="n">u_short</span>	 <span class="n">s2u</span> <span class="p">;</span>
	<span class="n">u_short</span>	 <span class="n">s2l</span> <span class="p">;</span>

	<span class="cm">/* calculated FORMAC+ reg.addr. */</span>
	<span class="n">HW_PTR</span>	<span class="n">fm_st1u</span> <span class="p">;</span>
	<span class="n">HW_PTR</span>	<span class="n">fm_st1l</span> <span class="p">;</span>
	<span class="n">HW_PTR</span>	<span class="n">fm_st2u</span> <span class="p">;</span>
	<span class="n">HW_PTR</span>	<span class="n">fm_st2l</span> <span class="p">;</span>
	<span class="n">HW_PTR</span>	<span class="n">fm_st3u</span> <span class="p">;</span>
	<span class="n">HW_PTR</span>	<span class="n">fm_st3l</span> <span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * multicast table</span>
<span class="cm">	 */</span>
<span class="cp">#define FPMAX_MULTICAST 32 </span>
<span class="cp">#define	SMT_MAX_MULTI	4</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">s_fpmc</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fddi_addr</span>	<span class="n">a</span> <span class="p">;</span>	<span class="cm">/* mc address */</span>
			<span class="n">u_char</span>			<span class="n">n</span> <span class="p">;</span>	<span class="cm">/* usage counter */</span>
			<span class="n">u_char</span>			<span class="n">perm</span> <span class="p">;</span>	<span class="cm">/* flag: permanent */</span>
		<span class="p">}</span> <span class="n">table</span><span class="p">[</span><span class="n">FPMAX_MULTICAST</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span> <span class="n">mc</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">fddi_addr</span>	<span class="n">group_addr</span> <span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">func_addr</span> <span class="p">;</span>		<span class="cm">/* functional address */</span>
	<span class="kt">int</span>	<span class="n">smt_slots_used</span> <span class="p">;</span>	<span class="cm">/* count of table entries for the SMT */</span>
	<span class="kt">int</span>	<span class="n">os_slots_used</span> <span class="p">;</span>		<span class="cm">/* count of table entries */</span> 
					<span class="cm">/* used by the os-specific module */</span>
<span class="p">}</span> <span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * modes for mac_set_rx_mode()</span>
<span class="cm"> */</span>
<span class="cp">#define RX_ENABLE_ALLMULTI	1	</span><span class="cm">/* enable all multicasts */</span><span class="cp"></span>
<span class="cp">#define RX_DISABLE_ALLMULTI	2	</span><span class="cm">/* disable &quot;enable all multicasts&quot; */</span><span class="cp"></span>
<span class="cp">#define RX_ENABLE_PROMISC	3	</span><span class="cm">/* enable promiscuous */</span><span class="cp"></span>
<span class="cp">#define RX_DISABLE_PROMISC	4	</span><span class="cm">/* disable promiscuous */</span><span class="cp"></span>
<span class="cp">#define RX_ENABLE_NSA		5	</span><span class="cm">/* enable reception of NSA frames */</span><span class="cp"></span>
<span class="cp">#define RX_DISABLE_NSA		6	</span><span class="cm">/* disable reception of NSA frames */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * support for byte reversal in AIX</span>
<span class="cm"> * (descriptors and pointers must be byte reversed in memory</span>
<span class="cm"> *  CPU is big endian; M-Channel is little endian)</span>
<span class="cm"> */</span>
<span class="cp">#ifdef	AIX</span>
<span class="cp">#define MDR_REV</span>
<span class="cp">#define	AIX_REVERSE(x)		((((x)&lt;&lt;24L)&amp;0xff000000L)	+	\</span>
<span class="cp">				 (((x)&lt;&lt; 8L)&amp;0x00ff0000L)	+	\</span>
<span class="cp">				 (((x)&gt;&gt; 8L)&amp;0x0000ff00L)	+	\</span>
<span class="cp">				 (((x)&gt;&gt;24L)&amp;0x000000ffL))</span>
<span class="cp">#else</span>
<span class="cp">#ifndef AIX_REVERSE</span>
<span class="cp">#define	AIX_REVERSE(x)	(x)</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef	MDR_REV	</span>
<span class="cp">#define	MDR_REVERSE(x)		((((x)&lt;&lt;24L)&amp;0xff000000L)	+	\</span>
<span class="cp">				 (((x)&lt;&lt; 8L)&amp;0x00ff0000L)	+	\</span>
<span class="cp">				 (((x)&gt;&gt; 8L)&amp;0x0000ff00L)	+	\</span>
<span class="cp">				 (((x)&gt;&gt;24L)&amp;0x000000ffL))</span>
<span class="cp">#else</span>
<span class="cp">#ifndef MDR_REVERSE</span>
<span class="cp">#define	MDR_REVERSE(x)	(x)</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
