<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › fddi › skfp › h › skfbi.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>skfbi.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *	(C)Copyright 1998,1999 SysKonnect,</span>
<span class="cm"> *	a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	The information in this file is provided &quot;AS IS&quot; without warranty.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cp">#ifndef	_SKFBI_H_</span>
<span class="cp">#define	_SKFBI_H_</span>

<span class="cm">/*</span>
<span class="cm"> * FDDI-Fx (x := {I(SA), P(CI)})</span>
<span class="cm"> *	address calculation &amp; function defines</span>
<span class="cm"> */</span>

<span class="cm">/*--------------------------------------------------------------------------*/</span>
<span class="cp">#ifdef	PCI</span>

<span class="cm">/*</span>
<span class="cm"> *	(DV)	= only defined for Da Vinci</span>
<span class="cm"> *	(ML)	= only defined for Monalisa</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Configuration Space header</span>
<span class="cm"> */</span>
<span class="cp">#define	PCI_VENDOR_ID	0x00	</span><span class="cm">/* 16 bit	Vendor ID */</span><span class="cp"></span>
<span class="cp">#define	PCI_DEVICE_ID	0x02	</span><span class="cm">/* 16 bit	Device ID */</span><span class="cp"></span>
<span class="cp">#define	PCI_COMMAND	0x04	</span><span class="cm">/* 16 bit	Command */</span><span class="cp"></span>
<span class="cp">#define	PCI_STATUS	0x06	</span><span class="cm">/* 16 bit	Status */</span><span class="cp"></span>
<span class="cp">#define	PCI_REV_ID	0x08	</span><span class="cm">/*  8 bit	Revision ID */</span><span class="cp"></span>
<span class="cp">#define	PCI_CLASS_CODE	0x09	</span><span class="cm">/* 24 bit	Class Code */</span><span class="cp"></span>
<span class="cp">#define	PCI_CACHE_LSZ	0x0c	</span><span class="cm">/*  8 bit	Cache Line Size */</span><span class="cp"></span>
<span class="cp">#define	PCI_LAT_TIM	0x0d	</span><span class="cm">/*  8 bit	Latency Timer */</span><span class="cp"></span>
<span class="cp">#define	PCI_HEADER_T	0x0e	</span><span class="cm">/*  8 bit	Header Type */</span><span class="cp"></span>
<span class="cp">#define	PCI_BIST	0x0f	</span><span class="cm">/*  8 bit	Built-in selftest */</span><span class="cp"></span>
<span class="cp">#define	PCI_BASE_1ST	0x10	</span><span class="cm">/* 32 bit	1st Base address */</span><span class="cp"></span>
<span class="cp">#define	PCI_BASE_2ND	0x14	</span><span class="cm">/* 32 bit	2nd Base address */</span><span class="cp"></span>
<span class="cm">/* Byte 18..2b:	Reserved */</span>
<span class="cp">#define	PCI_SUB_VID	0x2c	</span><span class="cm">/* 16 bit	Subsystem Vendor ID */</span><span class="cp"></span>
<span class="cp">#define	PCI_SUB_ID	0x2e	</span><span class="cm">/* 16 bit	Subsystem ID */</span><span class="cp"></span>
<span class="cp">#define	PCI_BASE_ROM	0x30	</span><span class="cm">/* 32 bit	Expansion ROM Base Address */</span><span class="cp"></span>
<span class="cm">/* Byte 34..33:	Reserved */</span>
<span class="cp">#define PCI_CAP_PTR	0x34	</span><span class="cm">/*  8 bit (ML)	Capabilities Ptr */</span><span class="cp"></span>
<span class="cm">/* Byte 35..3b:	Reserved */</span>
<span class="cp">#define	PCI_IRQ_LINE	0x3c	</span><span class="cm">/*  8 bit	Interrupt Line */</span><span class="cp"></span>
<span class="cp">#define	PCI_IRQ_PIN	0x3d	</span><span class="cm">/*  8 bit	Interrupt Pin */</span><span class="cp"></span>
<span class="cp">#define	PCI_MIN_GNT	0x3e	</span><span class="cm">/*  8 bit	Min_Gnt */</span><span class="cp"></span>
<span class="cp">#define	PCI_MAX_LAT	0x3f	</span><span class="cm">/*  8 bit	Max_Lat */</span><span class="cp"></span>
<span class="cm">/* Device Dependent Region */</span>
<span class="cp">#define	PCI_OUR_REG	0x40	</span><span class="cm">/* 32 bit (DV)	Our Register */</span><span class="cp"></span>
<span class="cp">#define	PCI_OUR_REG_1	0x40	</span><span class="cm">/* 32 bit (ML)	Our Register 1 */</span><span class="cp"></span>
<span class="cp">#define	PCI_OUR_REG_2	0x44	</span><span class="cm">/* 32 bit (ML)	Our Register 2 */</span><span class="cp"></span>
<span class="cm">/* Power Management Region */</span>
<span class="cp">#define PCI_PM_CAP_ID	0x48	</span><span class="cm">/*  8 bit (ML)	Power Management Cap. ID */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_NITEM	0x49	</span><span class="cm">/*  8 bit (ML)	Next Item Ptr */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_CAP_REG	0x4a	</span><span class="cm">/* 16 bit (ML)	Power Management Capabilities */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_CTL_STS	0x4c	</span><span class="cm">/* 16 bit (ML)	Power Manag. Control/Status */</span><span class="cp"></span>
<span class="cm">/* Byte 0x4e:	Reserved */</span>
<span class="cp">#define PCI_PM_DAT_REG	0x4f	</span><span class="cm">/*  8 bit (ML)	Power Manag. Data Register */</span><span class="cp"></span>
<span class="cm">/* VPD Region */</span>
<span class="cp">#define	PCI_VPD_CAP_ID	0x50	</span><span class="cm">/*  8 bit (ML)	VPD Cap. ID */</span><span class="cp"></span>
<span class="cp">#define PCI_VPD_NITEM	0x51	</span><span class="cm">/*  8 bit (ML)	Next Item Ptr */</span><span class="cp"></span>
<span class="cp">#define PCI_VPD_ADR_REG	0x52	</span><span class="cm">/* 16 bit (ML)	VPD Address Register */</span><span class="cp"></span>
<span class="cp">#define PCI_VPD_DAT_REG	0x54	</span><span class="cm">/* 32 bit (ML)	VPD Data Register */</span><span class="cp"></span>
<span class="cm">/* Byte 58..ff:	Reserved */</span>

<span class="cm">/*</span>
<span class="cm"> * I2C Address (PCI Config)</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The temperature and voltage sensors are relocated on a different</span>
<span class="cm"> *	 I2C bus.</span>
<span class="cm"> */</span>
<span class="cp">#define I2C_ADDR_VPD	0xA0	</span><span class="cm">/* I2C address for the VPD EEPROM */</span><span class="cp"> </span>

<span class="cm">/*</span>
<span class="cm"> * Define Bits and Values of the registers</span>
<span class="cm"> */</span>
<span class="cm">/*	PCI_VENDOR_ID	16 bit	Vendor ID */</span>
<span class="cm">/*	PCI_DEVICE_ID	16 bit	Device ID */</span>
<span class="cm">/* Values for Vendor ID and Device ID shall be patched into the code */</span>
<span class="cm">/*	PCI_COMMAND	16 bit	Command */</span>
<span class="cp">#define	PCI_FBTEN	0x0200	</span><span class="cm">/* Bit 9:	Fast Back-To-Back enable */</span><span class="cp"></span>
<span class="cp">#define	PCI_SERREN	0x0100	</span><span class="cm">/* Bit 8:	SERR enable */</span><span class="cp"></span>
<span class="cp">#define	PCI_ADSTEP	0x0080	</span><span class="cm">/* Bit 7:	Address Stepping */</span><span class="cp"></span>
<span class="cp">#define	PCI_PERREN	0x0040	</span><span class="cm">/* Bit 6:	Parity Report Response enable */</span><span class="cp"></span>
<span class="cp">#define	PCI_VGA_SNOOP	0x0020	</span><span class="cm">/* Bit 5:	VGA palette snoop */</span><span class="cp"></span>
<span class="cp">#define	PCI_MWIEN	0x0010	</span><span class="cm">/* Bit 4:	Memory write an inv cycl ena */</span><span class="cp"></span>
<span class="cp">#define	PCI_SCYCEN	0x0008	</span><span class="cm">/* Bit 3:	Special Cycle enable */</span><span class="cp"></span>
<span class="cp">#define	PCI_BMEN	0x0004	</span><span class="cm">/* Bit 2:	Bus Master enable */</span><span class="cp"></span>
<span class="cp">#define	PCI_MEMEN	0x0002	</span><span class="cm">/* Bit 1:	Memory Space Access enable */</span><span class="cp"></span>
<span class="cp">#define	PCI_IOEN	0x0001	</span><span class="cm">/* Bit 0:	IO Space Access enable */</span><span class="cp"></span>

<span class="cm">/*	PCI_STATUS	16 bit	Status */</span>
<span class="cp">#define	PCI_PERR	0x8000	</span><span class="cm">/* Bit 15:	Parity Error */</span><span class="cp"></span>
<span class="cp">#define	PCI_SERR	0x4000	</span><span class="cm">/* Bit 14:	Signaled SERR */</span><span class="cp"></span>
<span class="cp">#define	PCI_RMABORT	0x2000	</span><span class="cm">/* Bit 13:	Received Master Abort */</span><span class="cp"></span>
<span class="cp">#define	PCI_RTABORT	0x1000	</span><span class="cm">/* Bit 12:	Received Target Abort */</span><span class="cp"></span>
<span class="cp">#define	PCI_STABORT	0x0800	</span><span class="cm">/* Bit 11:	Sent Target Abort */</span><span class="cp"></span>
<span class="cp">#define	PCI_DEVSEL	0x0600	</span><span class="cm">/* Bit 10..9:	DEVSEL Timing */</span><span class="cp"></span>
<span class="cp">#define	PCI_DEV_FAST	(0&lt;&lt;9)	</span><span class="cm">/*		fast */</span><span class="cp"></span>
<span class="cp">#define	PCI_DEV_MEDIUM	(1&lt;&lt;9)	</span><span class="cm">/*		medium */</span><span class="cp"></span>
<span class="cp">#define	PCI_DEV_SLOW	(2&lt;&lt;9)	</span><span class="cm">/*		slow */</span><span class="cp"></span>
<span class="cp">#define	PCI_DATAPERR	0x0100	</span><span class="cm">/* Bit 8:	DATA Parity error detected */</span><span class="cp"></span>
<span class="cp">#define	PCI_FB2BCAP	0x0080	</span><span class="cm">/* Bit 7:	Fast Back-to-Back Capability */</span><span class="cp"></span>
<span class="cp">#define	PCI_UDF		0x0040	</span><span class="cm">/* Bit 6:	User Defined Features */</span><span class="cp"></span>
<span class="cp">#define PCI_66MHZCAP	0x0020	</span><span class="cm">/* Bit 5:	66 MHz PCI bus clock capable */</span><span class="cp"></span>
<span class="cp">#define PCI_NEWCAP	0x0010	</span><span class="cm">/* Bit 4:	New cap. list implemented */</span><span class="cp"></span>

<span class="cp">#define PCI_ERRBITS	(PCI_PERR|PCI_SERR|PCI_RMABORT|PCI_STABORT|PCI_DATAPERR)</span>

<span class="cm">/*	PCI_REV_ID	8 bit	Revision ID */</span>
<span class="cm">/*	PCI_CLASS_CODE	24 bit	Class Code */</span>
<span class="cm">/*	Byte 2:		Base Class		(02) */</span>
<span class="cm">/*	Byte 1:		SubClass		(02) */</span>
<span class="cm">/*	Byte 0:		Programming Interface	(00) */</span>

<span class="cm">/*	PCI_CACHE_LSZ	8 bit	Cache Line Size */</span>
<span class="cm">/*	Possible values: 0,2,4,8,16	*/</span>

<span class="cm">/*	PCI_LAT_TIM	8 bit	Latency Timer */</span>

<span class="cm">/*	PCI_HEADER_T	8 bit	Header Type */</span>
<span class="cp">#define	PCI_HD_MF_DEV	0x80	</span><span class="cm">/* Bit 7:	0= single, 1= multi-func dev */</span><span class="cp"></span>
<span class="cp">#define	PCI_HD_TYPE	0x7f	</span><span class="cm">/* Bit 6..0:	Header Layout 0= normal */</span><span class="cp"></span>

<span class="cm">/*	PCI_BIST	8 bit	Built-in selftest */</span>
<span class="cp">#define	PCI_BIST_CAP	0x80	</span><span class="cm">/* Bit 7:	BIST Capable */</span><span class="cp"></span>
<span class="cp">#define	PCI_BIST_ST	0x40	</span><span class="cm">/* Bit 6:	Start BIST */</span><span class="cp"></span>
<span class="cp">#define	PCI_BIST_RET	0x0f	</span><span class="cm">/* Bit 3..0:	Completion Code */</span><span class="cp"></span>

<span class="cm">/*	PCI_BASE_1ST	32 bit	1st Base address */</span>
<span class="cp">#define	PCI_MEMSIZE	0x800L       </span><span class="cm">/* use 2 kB Memory Base */</span><span class="cp"></span>
<span class="cp">#define	PCI_MEMBASE_BITS 0xfffff800L </span><span class="cm">/* Bit 31..11:	Memory Base Address */</span><span class="cp"></span>
<span class="cp">#define	PCI_MEMSIZE_BIIS 0x000007f0L </span><span class="cm">/* Bit 10..4:	Memory Size Req. */</span><span class="cp"></span>
<span class="cp">#define	PCI_PREFEN	0x00000008L  </span><span class="cm">/* Bit 3:		Prefetchable */</span><span class="cp"></span>
<span class="cp">#define	PCI_MEM_TYP	0x00000006L  </span><span class="cm">/* Bit 2..1:	Memory Type */</span><span class="cp"></span>
<span class="cp">#define	PCI_MEM32BIT	(0&lt;&lt;1)	     </span><span class="cm">/* Base addr anywhere in 32 Bit range */</span><span class="cp"></span>
<span class="cp">#define	PCI_MEM1M	(1&lt;&lt;1)	     </span><span class="cm">/* Base addr below 1 MegaByte */</span><span class="cp"></span>
<span class="cp">#define	PCI_MEM64BIT	(2&lt;&lt;1)	     </span><span class="cm">/* Base addr anywhere in 64 Bit range */</span><span class="cp"></span>
<span class="cp">#define	PCI_MEMSPACE	0x00000001L  </span><span class="cm">/* Bit 0:	Memory Space Indic. */</span><span class="cp"></span>

<span class="cm">/*	PCI_BASE_2ND	32 bit	2nd Base address */</span>
<span class="cp">#define	PCI_IOBASE	0xffffff00L  </span><span class="cm">/* Bit 31..8:  I/O Base address */</span><span class="cp"></span>
<span class="cp">#define	PCI_IOSIZE	0x000000fcL  </span><span class="cm">/* Bit 7..2:   I/O Size Requirements */</span><span class="cp"></span>
<span class="cp">#define	PCI_IOSPACE	0x00000001L  </span><span class="cm">/* Bit 0:	    I/O Space Indicator */</span><span class="cp"></span>

<span class="cm">/*	PCI_SUB_VID	16 bit	Subsystem Vendor ID */</span>
<span class="cm">/*	PCI_SUB_ID	16 bit	Subsystem ID */</span>

<span class="cm">/*	PCI_BASE_ROM	32 bit	Expansion ROM Base Address */</span>
<span class="cp">#define	PCI_ROMBASE	0xfffe0000L  </span><span class="cm">/* Bit 31..17: ROM BASE address (1st) */</span><span class="cp"></span>
<span class="cp">#define	PCI_ROMBASZ	0x0001c000L  </span><span class="cm">/* Bit 16..14: Treat as BASE or SIZE */</span><span class="cp"></span>
<span class="cp">#define	PCI_ROMSIZE	0x00003800L  </span><span class="cm">/* Bit 13..11: ROM Size Requirements */</span><span class="cp"></span>
<span class="cp">#define	PCI_ROMEN	0x00000001L  </span><span class="cm">/* Bit 0:	    Address Decode enable */</span><span class="cp"></span>

<span class="cm">/*	PCI_CAP_PTR	8 bit	New Capabilities Pointers */</span>
<span class="cm">/*	PCI_IRQ_LINE	8 bit	Interrupt Line */</span>
<span class="cm">/*	PCI_IRQ_PIN	8 bit	Interrupt Pin */</span>
<span class="cm">/*	PCI_MIN_GNT	8 bit	Min_Gnt */</span>
<span class="cm">/*	PCI_MAX_LAT	8 bit	Max_Lat */</span>
<span class="cm">/* Device Dependent Region */</span>
<span class="cm">/*	PCI_OUR_REG	(DV)	32 bit	Our Register */</span>
<span class="cm">/*	PCI_OUR_REG_1	(ML)	32 bit	Our Register 1 */</span>
				  <span class="cm">/*	 Bit 31..29:	reserved */</span>
<span class="cp">#define	PCI_PATCH_DIR	(3L&lt;&lt;27)  </span><span class="cm">/*(DV) Bit 28..27:	Ext Patchs direction */</span><span class="cp"></span>
<span class="cp">#define PCI_PATCH_DIR_0	(1L&lt;&lt;27)  </span><span class="cm">/*(DV) Type of the pins EXT_PATCHS&lt;1..0&gt;   */</span><span class="cp"></span>
<span class="cp">#define PCI_PATCH_DIR_1 (1L&lt;&lt;28)  </span><span class="cm">/*	   0 = input			     */</span><span class="cp"></span>
				  <span class="cm">/*	   1 = output			     */</span>
<span class="cp">#define	PCI_EXT_PATCHS	(3L&lt;&lt;25)  </span><span class="cm">/*(DV) Bit 26..25:	Extended Patches     */</span><span class="cp"></span>
<span class="cp">#define PCI_EXT_PATCH_0 (1L&lt;&lt;25)  </span><span class="cm">/*(DV)				     */</span><span class="cp"></span>
<span class="cp">#define PCI_EXT_PATCH_1 (1L&lt;&lt;26)  </span><span class="cm">/*	 CLK for MicroWire (ML)		     */</span><span class="cp"></span>
<span class="cp">#define PCI_VIO		(1L&lt;&lt;25)  </span><span class="cm">/*(ML)				     */</span><span class="cp"></span>
<span class="cp">#define	PCI_EN_BOOT	(1L&lt;&lt;24)  </span><span class="cm">/*	 Bit 24:	Enable BOOT via ROM  */</span><span class="cp"></span>
				  <span class="cm">/*	   1 = Don&#39;t boot with ROM	     */</span>
				  <span class="cm">/*	   0 = Boot with ROM		     */</span>
<span class="cp">#define	PCI_EN_IO	(1L&lt;&lt;23)  </span><span class="cm">/*	 Bit 23:	Mapping to IO space  */</span><span class="cp"></span>
<span class="cp">#define	PCI_EN_FPROM	(1L&lt;&lt;22)  </span><span class="cm">/*	 Bit 22:	FLASH mapped to mem? */</span><span class="cp"></span>
				  <span class="cm">/*	   1 = Map Flash to Memory	     */</span>
			  	  <span class="cm">/*	   0 = Disable all addr. decoding    */</span>
<span class="cp">#define	PCI_PAGESIZE	(3L&lt;&lt;20)  </span><span class="cm">/*	 Bit 21..20:	FLASH Page Size	     */</span><span class="cp"></span>
<span class="cp">#define	PCI_PAGE_16	(0L&lt;&lt;20)  </span><span class="cm">/*		16 k pages		     */</span><span class="cp"></span>
<span class="cp">#define	PCI_PAGE_32K	(1L&lt;&lt;20)  </span><span class="cm">/*		32 k pages		     */</span><span class="cp"></span>
<span class="cp">#define	PCI_PAGE_64K	(2L&lt;&lt;20)  </span><span class="cm">/*		64 k pages		     */</span><span class="cp"></span>
<span class="cp">#define	PCI_PAGE_128K	(3L&lt;&lt;20)  </span><span class="cm">/*		128 k pages		     */</span><span class="cp"></span>
				  <span class="cm">/*	 Bit 19: reserved (ML) and (DV)	     */</span>
<span class="cp">#define	PCI_PAGEREG	(7L&lt;&lt;16)  </span><span class="cm">/*	 Bit 18..16:	Page Register	     */</span><span class="cp"></span>
				  <span class="cm">/*	 Bit 15:	reserved	     */</span>
<span class="cp">#define	PCI_FORCE_BE	(1L&lt;&lt;14)  </span><span class="cm">/*	 Bit 14:	Assert all BEs on MR */</span><span class="cp"></span>
<span class="cp">#define	PCI_DIS_MRL	(1L&lt;&lt;13)  </span><span class="cm">/*	 Bit 13:	Disable Mem R Line   */</span><span class="cp"></span>
<span class="cp">#define	PCI_DIS_MRM	(1L&lt;&lt;12)  </span><span class="cm">/*	 Bit 12:	Disable Mem R multip */</span><span class="cp"></span>
<span class="cp">#define	PCI_DIS_MWI	(1L&lt;&lt;11)  </span><span class="cm">/*	 Bit 11:	Disable Mem W &amp; inv  */</span><span class="cp"></span>
<span class="cp">#define	PCI_DISC_CLS	(1L&lt;&lt;10)  </span><span class="cm">/*	 Bit 10:	Disc: cacheLsz bound */</span><span class="cp"></span>
<span class="cp">#define	PCI_BURST_DIS	(1L&lt;&lt;9)	  </span><span class="cm">/*	 Bit  9:	Burst Disable	     */</span><span class="cp"></span>
<span class="cp">#define	PCI_BYTE_SWAP	(1L&lt;&lt;8)	  </span><span class="cm">/*(DV) Bit  8:	Byte Swap in DATA    */</span><span class="cp"></span>
<span class="cp">#define	PCI_SKEW_DAS	(0xfL&lt;&lt;4) </span><span class="cm">/*	 Bit 7..4:	Skew Ctrl, DAS Ext   */</span><span class="cp"></span>
<span class="cp">#define	PCI_SKEW_BASE	(0xfL&lt;&lt;0) </span><span class="cm">/*	 Bit 3..0:	Skew Ctrl, Base	     */</span><span class="cp"></span>

<span class="cm">/*	PCI_OUR_REG_2	(ML)	32 bit	Our Register 2 (Monalisa only) */</span>
<span class="cp">#define PCI_VPD_WR_TH	(0xffL&lt;&lt;24)	</span><span class="cm">/* Bit 24..31	VPD Write Threshold  */</span><span class="cp"></span>
<span class="cp">#define	PCI_DEV_SEL	(0x7fL&lt;&lt;17)	</span><span class="cm">/* Bit 17..23	EEPROM Device Select */</span><span class="cp"></span>
<span class="cp">#define	PCI_VPD_ROM_SZ	(7L&lt;&lt;14)	</span><span class="cm">/* Bit 14..16	VPD ROM Size	     */</span><span class="cp"></span>
					<span class="cm">/* Bit 12..13	reserved	     */</span>
<span class="cp">#define	PCI_PATCH_DIR2	(0xfL&lt;&lt;8)	</span><span class="cm">/* Bit  8..11	Ext Patchs dir 2..5  */</span><span class="cp"></span>
<span class="cp">#define	PCI_PATCH_DIR_2	(1L&lt;&lt;8)		</span><span class="cm">/* Bit  8	CS for MicroWire     */</span><span class="cp"></span>
<span class="cp">#define	PCI_PATCH_DIR_3	(1L&lt;&lt;9)</span>
<span class="cp">#define	PCI_PATCH_DIR_4	(1L&lt;&lt;10)</span>
<span class="cp">#define	PCI_PATCH_DIR_5	(1L&lt;&lt;11)</span>
<span class="cp">#define PCI_EXT_PATCHS2 (0xfL&lt;&lt;4)	</span><span class="cm">/* Bit  4..7	Extended Patches     */</span><span class="cp"></span>
<span class="cp">#define	PCI_EXT_PATCH_2	(1L&lt;&lt;4)		</span><span class="cm">/* Bit  4	CS for MicroWire     */</span><span class="cp"></span>
<span class="cp">#define	PCI_EXT_PATCH_3	(1L&lt;&lt;5)</span>
<span class="cp">#define	PCI_EXT_PATCH_4	(1L&lt;&lt;6)</span>
<span class="cp">#define	PCI_EXT_PATCH_5	(1L&lt;&lt;7)</span>
<span class="cp">#define	PCI_EN_DUMMY_RD	(1L&lt;&lt;3)		</span><span class="cm">/* Bit  3	Enable Dummy Read    */</span><span class="cp"></span>
<span class="cp">#define PCI_REV_DESC	(1L&lt;&lt;2)		</span><span class="cm">/* Bit  2	Reverse Desc. Bytes  */</span><span class="cp"></span>
<span class="cp">#define PCI_USEADDR64	(1L&lt;&lt;1)		</span><span class="cm">/* Bit  1	Use 64 Bit Addresse  */</span><span class="cp"></span>
<span class="cp">#define PCI_USEDATA64	(1L&lt;&lt;0)		</span><span class="cm">/* Bit  0	Use 64 Bit Data bus ext*/</span><span class="cp"></span>

<span class="cm">/* Power Management Region */</span>
<span class="cm">/*	PCI_PM_CAP_ID		 8 bit (ML)	Power Management Cap. ID */</span>
<span class="cm">/*	PCI_PM_NITEM		 8 bit (ML)	Next Item Ptr */</span>
<span class="cm">/*	PCI_PM_CAP_REG		16 bit (ML)	Power Management Capabilities*/</span>
<span class="cp">#define	PCI_PME_SUP	(0x1f&lt;&lt;11)	</span><span class="cm">/* Bit 11..15	PM Manag. Event Support*/</span><span class="cp"></span>
<span class="cp">#define PCI_PM_D2_SUB	(1&lt;&lt;10)		</span><span class="cm">/* Bit 10	D2 Support Bit	     */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_D1_SUB	(1&lt;&lt;9)		</span><span class="cm">/* Bit 9	D1 Support Bit       */</span><span class="cp"></span>
					<span class="cm">/* Bit 6..8 reserved		     */</span>
<span class="cp">#define PCI_PM_DSI	(1&lt;&lt;5)		</span><span class="cm">/* Bit 5	Device Specific Init.*/</span><span class="cp"></span>
<span class="cp">#define PCI_PM_APS	(1&lt;&lt;4)		</span><span class="cm">/* Bit 4	Auxialiary Power Src */</span><span class="cp"></span>
<span class="cp">#define PCI_PME_CLOCK	(1&lt;&lt;3)		</span><span class="cm">/* Bit 3	PM Event Clock       */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_VER	(7&lt;&lt;0)		</span><span class="cm">/* Bit 0..2	PM PCI Spec. version */</span><span class="cp"></span>

<span class="cm">/*	PCI_PM_CTL_STS		16 bit (ML)	Power Manag. Control/Status  */</span>
<span class="cp">#define	PCI_PME_STATUS	(1&lt;&lt;15)		</span><span class="cm">/* Bit 15 	PFA doesn&#39;t sup. PME#*/</span><span class="cp"></span>
<span class="cp">#define PCI_PM_DAT_SCL	(3&lt;&lt;13)		</span><span class="cm">/* Bit 13..14	dat reg Scaling factor */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_DAT_SEL	(0xf&lt;&lt;9)	</span><span class="cm">/* Bit  9..12	PM data selector field */</span><span class="cp"></span>
					<span class="cm">/* Bit  7.. 2	reserved	     */</span>
<span class="cp">#define PCI_PM_STATE	(3&lt;&lt;0)		</span><span class="cm">/* Bit  0.. 1	Power Management State */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_STATE_D0	(0&lt;&lt;0)		</span><span class="cm">/* D0:	Operational (default) */</span><span class="cp"></span>
<span class="cp">#define	PCI_PM_STATE_D1	(1&lt;&lt;0)		</span><span class="cm">/* D1:	not supported */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_STATE_D2	(2&lt;&lt;0)		</span><span class="cm">/* D2:	not supported */</span><span class="cp"></span>
<span class="cp">#define PCI_PM_STATE_D3 (3&lt;&lt;0)		</span><span class="cm">/* D3:	HOT, Power Down and Reset */</span><span class="cp"></span>

<span class="cm">/*	PCI_PM_DAT_REG		 8 bit (ML)	Power Manag. Data Register */</span>
<span class="cm">/* VPD Region */</span>
<span class="cm">/*	PCI_VPD_CAP_ID		 8 bit (ML)	VPD Cap. ID */</span>
<span class="cm">/*	PCI_VPD_NITEM		 8 bit (ML)	Next Item Ptr */</span>
<span class="cm">/*	PCI_VPD_ADR_REG		16 bit (ML)	VPD Address Register */</span>
<span class="cp">#define	PCI_VPD_FLAG	(1&lt;&lt;15)		</span><span class="cm">/* Bit 15	starts VPD rd/wd cycle*/</span><span class="cp"></span>

<span class="cm">/*	PCI_VPD_DAT_REG		32 bit (ML)	VPD Data Register */</span>

<span class="cm">/*</span>
<span class="cm"> *	Control Register File:</span>
<span class="cm"> *	Bank 0</span>
<span class="cm"> */</span>
<span class="cp">#define	B0_RAP		0x0000	</span><span class="cm">/*  8 bit register address port */</span><span class="cp"></span>
	<span class="cm">/* 0x0001 - 0x0003:	reserved */</span>
<span class="cp">#define	B0_CTRL		0x0004	</span><span class="cm">/*  8 bit control register */</span><span class="cp"></span>
<span class="cp">#define	B0_DAS		0x0005	</span><span class="cm">/*  8 Bit control register (DAS) */</span><span class="cp"></span>
<span class="cp">#define	B0_LED		0x0006	</span><span class="cm">/*  8 Bit LED register */</span><span class="cp"></span>
<span class="cp">#define	B0_TST_CTRL	0x0007	</span><span class="cm">/*  8 bit test control register */</span><span class="cp"></span>
<span class="cp">#define	B0_ISRC		0x0008	</span><span class="cm">/* 32 bit Interrupt source register */</span><span class="cp"></span>
<span class="cp">#define	B0_IMSK		0x000c	</span><span class="cm">/* 32 bit Interrupt mask register */</span><span class="cp"></span>

<span class="cm">/* 0x0010 - 0x006b:	formac+ (supernet_3) fequently used registers */</span>
<span class="cp">#define B0_CMDREG1	0x0010	</span><span class="cm">/* write command reg 1 instruction */</span><span class="cp"></span>
<span class="cp">#define B0_CMDREG2	0x0014	</span><span class="cm">/* write command reg 2 instruction */</span><span class="cp"></span>
<span class="cp">#define B0_ST1U		0x0010	</span><span class="cm">/* read upper 16-bit of status reg 1 */</span><span class="cp"></span>
<span class="cp">#define B0_ST1L		0x0014	</span><span class="cm">/* read lower 16-bit of status reg 1 */</span><span class="cp"></span>
<span class="cp">#define B0_ST2U		0x0018	</span><span class="cm">/* read upper 16-bit of status reg 2 */</span><span class="cp"></span>
<span class="cp">#define B0_ST2L		0x001c	</span><span class="cm">/* read lower 16-bit of status reg 2 */</span><span class="cp"></span>

<span class="cp">#define B0_MARR		0x0020	</span><span class="cm">/* r/w the memory read addr register */</span><span class="cp"></span>
<span class="cp">#define B0_MARW		0x0024	</span><span class="cm">/* r/w the memory write addr register*/</span><span class="cp"></span>
<span class="cp">#define B0_MDRU		0x0028	</span><span class="cm">/* r/w upper 16-bit of mem. data reg */</span><span class="cp"></span>
<span class="cp">#define B0_MDRL		0x002c	</span><span class="cm">/* r/w lower 16-bit of mem. data reg */</span><span class="cp"></span>

<span class="cp">#define	B0_MDREG3	0x0030	</span><span class="cm">/* r/w Mode Register 3 */</span><span class="cp"></span>
<span class="cp">#define	B0_ST3U		0x0034	</span><span class="cm">/* read upper 16-bit of status reg 3 */</span><span class="cp"></span>
<span class="cp">#define	B0_ST3L		0x0038	</span><span class="cm">/* read lower 16-bit of status reg 3 */</span><span class="cp"></span>
<span class="cp">#define	B0_IMSK3U	0x003c	</span><span class="cm">/* r/w upper 16-bit of IMSK reg 3 */</span><span class="cp"></span>
<span class="cp">#define	B0_IMSK3L	0x0040	</span><span class="cm">/* r/w lower 16-bit of IMSK reg 3 */</span><span class="cp"></span>
<span class="cp">#define	B0_IVR		0x0044	</span><span class="cm">/* read Interrupt Vector register */</span><span class="cp"></span>
<span class="cp">#define	B0_IMR		0x0048	</span><span class="cm">/* r/w Interrupt mask register */</span><span class="cp"></span>
<span class="cm">/* 0x4c	Hidden */</span>

<span class="cp">#define B0_CNTRL_A	0x0050	</span><span class="cm">/* control register A (r/w) */</span><span class="cp"></span>
<span class="cp">#define B0_CNTRL_B	0x0054	</span><span class="cm">/* control register B (r/w) */</span><span class="cp"></span>
<span class="cp">#define B0_INTR_MASK	0x0058	</span><span class="cm">/* interrupt mask (r/w) */</span><span class="cp"></span>
<span class="cp">#define B0_XMIT_VECTOR	0x005c	</span><span class="cm">/* transmit vector register (r/w) */</span><span class="cp"></span>

<span class="cp">#define B0_STATUS_A	0x0060	</span><span class="cm">/* status register A (read only) */</span><span class="cp"></span>
<span class="cp">#define B0_STATUS_B	0x0064	</span><span class="cm">/* status register B (read only) */</span><span class="cp"></span>
<span class="cp">#define B0_CNTRL_C	0x0068	</span><span class="cm">/* control register C (r/w) */</span><span class="cp"></span>
<span class="cp">#define	B0_MDREG1	0x006c	</span><span class="cm">/* r/w Mode Register 1 */</span><span class="cp"></span>

<span class="cp">#define	B0_R1_CSR	0x0070	</span><span class="cm">/* 32 bit BMU control/status reg (rec q 1) */</span><span class="cp"></span>
<span class="cp">#define	B0_R2_CSR	0x0074	</span><span class="cm">/* 32 bit BMU control/status reg (rec q 2)(DV)*/</span><span class="cp"></span>
<span class="cp">#define	B0_XA_CSR	0x0078	</span><span class="cm">/* 32 bit BMU control/status reg (a xmit q) */</span><span class="cp"></span>
<span class="cp">#define	B0_XS_CSR	0x007c	</span><span class="cm">/* 32 bit BMU control/status reg (s xmit q) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	Bank 1</span>
<span class="cm"> *	- completely empty (this is the RAP Block window)</span>
<span class="cm"> *	Note: if RAP = 1 this page is reserved</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	Bank 2</span>
<span class="cm"> */</span>
<span class="cp">#define	B2_MAC_0	0x0100	</span><span class="cm">/*  8 bit MAC address Byte 0 */</span><span class="cp"></span>
<span class="cp">#define	B2_MAC_1	0x0101	</span><span class="cm">/*  8 bit MAC address Byte 1 */</span><span class="cp"></span>
<span class="cp">#define	B2_MAC_2	0x0102	</span><span class="cm">/*  8 bit MAC address Byte 2 */</span><span class="cp"></span>
<span class="cp">#define	B2_MAC_3	0x0103	</span><span class="cm">/*  8 bit MAC address Byte 3 */</span><span class="cp"></span>
<span class="cp">#define	B2_MAC_4	0x0104	</span><span class="cm">/*  8 bit MAC address Byte 4 */</span><span class="cp"></span>
<span class="cp">#define	B2_MAC_5	0x0105	</span><span class="cm">/*  8 bit MAC address Byte 5 */</span><span class="cp"></span>
<span class="cp">#define	B2_MAC_6	0x0106	</span><span class="cm">/*  8 bit MAC address Byte 6 (== 0) (DV) */</span><span class="cp"></span>
<span class="cp">#define	B2_MAC_7	0x0107	</span><span class="cm">/*  8 bit MAC address Byte 7 (== 0) (DV) */</span><span class="cp"></span>

<span class="cp">#define B2_CONN_TYP	0x0108	</span><span class="cm">/*  8 bit Connector type */</span><span class="cp"></span>
<span class="cp">#define B2_PMD_TYP	0x0109	</span><span class="cm">/*  8 bit PMD type */</span><span class="cp"></span>
				<span class="cm">/* 0x010a - 0x010b:	reserved */</span>
	<span class="cm">/* Eprom registers are currently of no use */</span>
<span class="cp">#define B2_E_0		0x010c	</span><span class="cm">/*  8 bit EPROM Byte 0 */</span><span class="cp"></span>
<span class="cp">#define B2_E_1		0x010d	</span><span class="cm">/*  8 bit EPROM Byte 1 */</span><span class="cp"></span>
<span class="cp">#define B2_E_2		0x010e	</span><span class="cm">/*  8 bit EPROM Byte 2 */</span><span class="cp"></span>
<span class="cp">#define B2_E_3		0x010f	</span><span class="cm">/*  8 bit EPROM Byte 3 */</span><span class="cp"></span>
<span class="cp">#define B2_FAR		0x0110	</span><span class="cm">/* 32 bit Flash-Prom Address Register/Counter */</span><span class="cp"></span>
<span class="cp">#define B2_FDP		0x0114	</span><span class="cm">/*  8 bit Flash-Prom Data Port */</span><span class="cp"></span>
				<span class="cm">/* 0x0115 - 0x0117:	reserved */</span>
<span class="cp">#define B2_LD_CRTL	0x0118	</span><span class="cm">/*  8 bit loader control */</span><span class="cp"></span>
<span class="cp">#define B2_LD_TEST	0x0119	</span><span class="cm">/*  8 bit loader test */</span><span class="cp"></span>
				<span class="cm">/* 0x011a - 0x011f:	reserved */</span>
<span class="cp">#define B2_TI_INI	0x0120	</span><span class="cm">/* 32 bit Timer init value */</span><span class="cp"></span>
<span class="cp">#define B2_TI_VAL	0x0124	</span><span class="cm">/* 32 bit Timer value */</span><span class="cp"></span>
<span class="cp">#define B2_TI_CRTL	0x0128	</span><span class="cm">/*  8 bit Timer control */</span><span class="cp"></span>
<span class="cp">#define B2_TI_TEST	0x0129	</span><span class="cm">/*  8 Bit Timer Test */</span><span class="cp"></span>
				<span class="cm">/* 0x012a - 0x012f:	reserved */</span>
<span class="cp">#define B2_WDOG_INI	0x0130	</span><span class="cm">/* 32 bit Watchdog init value */</span><span class="cp"></span>
<span class="cp">#define B2_WDOG_VAL	0x0134	</span><span class="cm">/* 32 bit Watchdog value */</span><span class="cp"></span>
<span class="cp">#define B2_WDOG_CRTL	0x0138	</span><span class="cm">/*  8 bit Watchdog control */</span><span class="cp"></span>
<span class="cp">#define B2_WDOG_TEST	0x0139	</span><span class="cm">/*  8 Bit Watchdog Test */</span><span class="cp"></span>
				<span class="cm">/* 0x013a - 0x013f:	reserved */</span>
<span class="cp">#define B2_RTM_INI	0x0140	</span><span class="cm">/* 32 bit RTM init value */</span><span class="cp"></span>
<span class="cp">#define B2_RTM_VAL	0x0144	</span><span class="cm">/* 32 bit RTM value */</span><span class="cp"></span>
<span class="cp">#define B2_RTM_CRTL	0x0148	</span><span class="cm">/*  8 bit RTM control */</span><span class="cp"></span>
<span class="cp">#define B2_RTM_TEST	0x0149	</span><span class="cm">/*  8 Bit RTM Test */</span><span class="cp"></span>

<span class="cp">#define B2_TOK_COUNT	0x014c	</span><span class="cm">/* (ML)	32 bit	Token Counter */</span><span class="cp"></span>
<span class="cp">#define B2_DESC_ADDR_H	0x0150	</span><span class="cm">/* (ML) 32 bit	Desciptor Base Addr Reg High */</span><span class="cp"></span>
<span class="cp">#define B2_CTRL_2	0x0154	</span><span class="cm">/* (ML)	 8 bit	Control Register 2 */</span><span class="cp"></span>
<span class="cp">#define B2_IFACE_REG	0x0155	</span><span class="cm">/* (ML)	 8 bit	Interface Register */</span><span class="cp"></span>
				<span class="cm">/* 0x0156:		reserved */</span>
<span class="cp">#define B2_TST_CTRL_2	0x0157	</span><span class="cm">/* (ML)  8 bit	Test Control Register 2 */</span><span class="cp"></span>
<span class="cp">#define B2_I2C_CTRL	0x0158	</span><span class="cm">/* (ML)	32 bit	I2C Control Register */</span><span class="cp"></span>
<span class="cp">#define B2_I2C_DATA	0x015c	</span><span class="cm">/* (ML) 32 bit	I2C Data Register */</span><span class="cp"></span>

<span class="cp">#define B2_IRQ_MOD_INI	0x0160	</span><span class="cm">/* (ML) 32 bit	IRQ Moderation Timer Init Reg. */</span><span class="cp"></span>
<span class="cp">#define B2_IRQ_MOD_VAL	0x0164	</span><span class="cm">/* (ML)	32 bit	IRQ Moderation Timer Value */</span><span class="cp"></span>
<span class="cp">#define B2_IRQ_MOD_CTRL	0x0168	</span><span class="cm">/* (ML)  8 bit	IRQ Moderation Timer Control */</span><span class="cp"></span>
<span class="cp">#define B2_IRQ_MOD_TEST	0x0169	</span><span class="cm">/* (ML)	 8 bit	IRQ Moderation Timer Test */</span><span class="cp"></span>
				<span class="cm">/* 0x016a - 0x017f:	reserved */</span>

<span class="cm">/*</span>
<span class="cm"> *	Bank 3</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * This is a copy of the Configuration register file (lower half)</span>
<span class="cm"> */</span>
<span class="cp">#define B3_CFG_SPC	0x180</span>

<span class="cm">/*</span>
<span class="cm"> *	Bank 4</span>
<span class="cm"> */</span>
<span class="cp">#define B4_R1_D		0x0200	</span><span class="cm">/* 	4*32 bit current receive Descriptor  */</span><span class="cp"></span>
<span class="cp">#define B4_R1_DA	0x0210	</span><span class="cm">/* 	32 bit current rec desc address	     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_AC	0x0214	</span><span class="cm">/* 	32 bit current receive Address Count */</span><span class="cp"></span>
<span class="cp">#define B4_R1_BC	0x0218	</span><span class="cm">/*	32 bit current receive Byte Counter  */</span><span class="cp"></span>
<span class="cp">#define B4_R1_CSR	0x021c	</span><span class="cm">/* 	32 bit BMU Control/Status Register   */</span><span class="cp"></span>
<span class="cp">#define B4_R1_F		0x0220	</span><span class="cm">/* 	32 bit flag register		     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_T1	0x0224	</span><span class="cm">/* 	32 bit Test Register 1		     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_T1_TR	0x0224	</span><span class="cm">/* 	8 bit Test Register 1 TR	     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_T1_WR	0x0225	</span><span class="cm">/* 	8 bit Test Register 1 WR	     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_T1_RD	0x0226	</span><span class="cm">/* 	8 bit Test Register 1 RD	     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_T1_SV	0x0227	</span><span class="cm">/* 	8 bit Test Register 1 SV	     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_T2	0x0228	</span><span class="cm">/* 	32 bit Test Register 2		     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_T3	0x022c	</span><span class="cm">/* 	32 bit Test Register 3		     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_DA_H	0x0230	</span><span class="cm">/* (ML)	32 bit Curr Rx Desc Address High     */</span><span class="cp"></span>
<span class="cp">#define B4_R1_AC_H	0x0234	</span><span class="cm">/* (ML)	32 bit Curr Addr Counter High dword  */</span><span class="cp"></span>
				<span class="cm">/* 0x0238 - 0x023f:	reserved	  */</span>
				<span class="cm">/* Receive queue 2 is removed on Monalisa */</span>
<span class="cp">#define B4_R2_D		0x0240	</span><span class="cm">/* 4*32 bit current receive Descriptor	(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_DA	0x0250	</span><span class="cm">/* 32 bit current rec desc address	(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_AC	0x0254	</span><span class="cm">/* 32 bit current receive Address Count	(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_BC	0x0258	</span><span class="cm">/* 32 bit current receive Byte Counter	(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_CSR	0x025c	</span><span class="cm">/* 32 bit BMU Control/Status Register	(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_F		0x0260	</span><span class="cm">/* 32 bit flag register			(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_T1	0x0264	</span><span class="cm">/* 32 bit Test Register 1		(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_T1_TR	0x0264	</span><span class="cm">/* 8 bit Test Register 1 TR		(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_T1_WR	0x0265	</span><span class="cm">/* 8 bit Test Register 1 WR		(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_T1_RD	0x0266	</span><span class="cm">/* 8 bit Test Register 1 RD		(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_T1_SV	0x0267	</span><span class="cm">/* 8 bit Test Register 1 SV		(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_T2	0x0268	</span><span class="cm">/* 32 bit Test Register 2		(q2) */</span><span class="cp"></span>
<span class="cp">#define B4_R2_T3	0x026c	</span><span class="cm">/* 32 bit Test Register 3		(q2) */</span><span class="cp"></span>
				<span class="cm">/* 0x0270 - 0x027c:	reserved */</span>

<span class="cm">/*</span>
<span class="cm"> *	Bank 5</span>
<span class="cm"> */</span>
<span class="cp">#define B5_XA_D		0x0280	</span><span class="cm">/* 4*32 bit current transmit Descriptor	(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_DA	0x0290	</span><span class="cm">/* 32 bit current tx desc address	(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_AC	0x0294	</span><span class="cm">/* 32 bit current tx Address Count	(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_BC	0x0298	</span><span class="cm">/* 32 bit current tx Byte Counter	(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_CSR	0x029c	</span><span class="cm">/* 32 bit BMU Control/Status Register	(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_F		0x02a0	</span><span class="cm">/* 32 bit flag register			(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_T1	0x02a4	</span><span class="cm">/* 32 bit Test Register 1		(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_T1_TR	0x02a4	</span><span class="cm">/* 8 bit Test Register 1 TR		(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_T1_WR	0x02a5	</span><span class="cm">/* 8 bit Test Register 1 WR		(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_T1_RD	0x02a6	</span><span class="cm">/* 8 bit Test Register 1 RD		(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_T1_SV	0x02a7	</span><span class="cm">/* 8 bit Test Register 1 SV		(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_T2	0x02a8	</span><span class="cm">/* 32 bit Test Register 2		(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_T3	0x02ac	</span><span class="cm">/* 32 bit Test Register 3		(xa) */</span><span class="cp"></span>
<span class="cp">#define B5_XA_DA_H	0x02b0	</span><span class="cm">/* (ML)	32 bit Curr Tx Desc Address High     */</span><span class="cp"></span>
<span class="cp">#define B5_XA_AC_H	0x02b4	</span><span class="cm">/* (ML)	32 bit Curr Addr Counter High dword  */</span><span class="cp"></span>
				<span class="cm">/* 0x02b8 - 0x02bc:	reserved */</span>
<span class="cp">#define B5_XS_D		0x02c0	</span><span class="cm">/* 4*32 bit current transmit Descriptor	(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_DA	0x02d0	</span><span class="cm">/* 32 bit current tx desc address	(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_AC	0x02d4	</span><span class="cm">/* 32 bit current transmit Address Count(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_BC	0x02d8	</span><span class="cm">/* 32 bit current transmit Byte Counter	(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_CSR	0x02dc	</span><span class="cm">/* 32 bit BMU Control/Status Register	(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_F		0x02e0	</span><span class="cm">/* 32 bit flag register			(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_T1	0x02e4	</span><span class="cm">/* 32 bit Test Register 1		(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_T1_TR	0x02e4	</span><span class="cm">/* 8 bit Test Register 1 TR		(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_T1_WR	0x02e5	</span><span class="cm">/* 8 bit Test Register 1 WR		(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_T1_RD	0x02e6	</span><span class="cm">/* 8 bit Test Register 1 RD		(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_T1_SV	0x02e7	</span><span class="cm">/* 8 bit Test Register 1 SV		(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_T2	0x02e8	</span><span class="cm">/* 32 bit Test Register 2		(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_T3	0x02ec	</span><span class="cm">/* 32 bit Test Register 3		(xs) */</span><span class="cp"></span>
<span class="cp">#define B5_XS_DA_H	0x02f0	</span><span class="cm">/* (ML)	32 bit Curr Tx Desc Address High     */</span><span class="cp"></span>
<span class="cp">#define B5_XS_AC_H	0x02f4	</span><span class="cm">/* (ML)	32 bit Curr Addr Counter High dword  */</span><span class="cp"></span>
				<span class="cm">/* 0x02f8 - 0x02fc:	reserved */</span>

<span class="cm">/*</span>
<span class="cm"> *	Bank 6</span>
<span class="cm"> */</span>
<span class="cm">/* External PLC-S registers (SN2 compatibility for DV) */</span>
<span class="cm">/* External registers (ML) */</span>
<span class="cp">#define B6_EXT_REG	0x300</span>

<span class="cm">/*</span>
<span class="cm"> *	Bank 7</span>
<span class="cm"> */</span>
<span class="cm">/* DAS PLC-S Registers */</span>

<span class="cm">/*</span>
<span class="cm"> *	Bank 8 - 15</span>
<span class="cm"> */</span>
<span class="cm">/* IFCP registers */</span>

<span class="cm">/*---------------------------------------------------------------------------*/</span>
<span class="cm">/* Definitions of the Bits in the registers */</span>

<span class="cm">/*	B0_RAP		16 bit register address port */</span>
<span class="cp">#define	RAP_RAP		0x0f	</span><span class="cm">/* Bit 3..0:	0 = block0, .., f = block15 */</span><span class="cp"></span>

<span class="cm">/*	B0_CTRL		8 bit control register */</span>
<span class="cp">#define CTRL_FDDI_CLR	(1&lt;&lt;7)	</span><span class="cm">/* Bit 7: (ML)	Clear FDDI Reset */</span><span class="cp"></span>
<span class="cp">#define CTRL_FDDI_SET	(1&lt;&lt;6)	</span><span class="cm">/* Bit 6: (ML)	Set FDDI Reset */</span><span class="cp"></span>
<span class="cp">#define	CTRL_HPI_CLR	(1&lt;&lt;5)	</span><span class="cm">/* Bit 5:	Clear HPI SM reset */</span><span class="cp"></span>
<span class="cp">#define	CTRL_HPI_SET	(1&lt;&lt;4)	</span><span class="cm">/* Bit 4:	Set HPI SM reset */</span><span class="cp"></span>
<span class="cp">#define	CTRL_MRST_CLR	(1&lt;&lt;3)	</span><span class="cm">/* Bit 3:	Clear Master reset */</span><span class="cp"></span>
<span class="cp">#define	CTRL_MRST_SET	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:	Set Master reset */</span><span class="cp"></span>
<span class="cp">#define	CTRL_RST_CLR	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:	Clear Software reset */</span><span class="cp"></span>
<span class="cp">#define	CTRL_RST_SET	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:	Set Software reset */</span><span class="cp"></span>

<span class="cm">/*	B0_DAS		8 Bit control register (DAS) */</span>
<span class="cp">#define BUS_CLOCK	(1&lt;&lt;7)	</span><span class="cm">/* Bit 7: (ML)	Bus Clock 0/1 = 33/66MHz */</span><span class="cp"></span>
<span class="cp">#define BUS_SLOT_SZ	(1&lt;&lt;6)	</span><span class="cm">/* Bit 6: (ML)	Slot Size 0/1 = 32/64 bit slot*/</span><span class="cp"></span>
				<span class="cm">/* Bit 5..4:	reserved */</span>
<span class="cp">#define	DAS_AVAIL	(1&lt;&lt;3)	</span><span class="cm">/* Bit 3:	1 = DAS, 0 = SAS */</span><span class="cp"></span>
<span class="cp">#define DAS_BYP_ST	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:	1 = avail,SAS, 0 = not avail */</span><span class="cp"></span>
<span class="cp">#define DAS_BYP_INS	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:	1 = insert Bypass */</span><span class="cp"></span>
<span class="cp">#define DAS_BYP_RMV	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:	1 = remove Bypass */</span><span class="cp"></span>

<span class="cm">/*	B0_LED		8 Bit LED register */</span>
				<span class="cm">/* Bit 7..6:	reserved */</span>
<span class="cp">#define LED_2_ON	(1&lt;&lt;5)	</span><span class="cm">/* Bit 5:	1 = switch LED_2 on (left,gn)*/</span><span class="cp"></span>
<span class="cp">#define LED_2_OFF	(1&lt;&lt;4)	</span><span class="cm">/* Bit 4:	1 = switch LED_2 off */</span><span class="cp"></span>
<span class="cp">#define LED_1_ON	(1&lt;&lt;3)	</span><span class="cm">/* Bit 3:	1 = switch LED_1 on (mid,yel)*/</span><span class="cp"></span>
<span class="cp">#define LED_1_OFF	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:	1 = switch LED_1 off */</span><span class="cp"></span>
<span class="cp">#define LED_0_ON	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:	1 = switch LED_0 on (rght,gn)*/</span><span class="cp"></span>
<span class="cp">#define LED_0_OFF	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:	1 = switch LED_0 off */</span><span class="cp"></span>
<span class="cm">/* This hardware defines are very ugly therefore we define some others */</span>

<span class="cp">#define LED_GA_ON	LED_2_ON	</span><span class="cm">/* S port = A port */</span><span class="cp"></span>
<span class="cp">#define LED_GA_OFF	LED_2_OFF	</span><span class="cm">/* S port = A port */</span><span class="cp"></span>
<span class="cp">#define LED_MY_ON	LED_1_ON</span>
<span class="cp">#define LED_MY_OFF	LED_1_OFF</span>
<span class="cp">#define LED_GB_ON	LED_0_ON</span>
<span class="cp">#define LED_GB_OFF	LED_0_OFF</span>

<span class="cm">/*	B0_TST_CTRL	8 bit test control register */</span>
<span class="cp">#define	TST_FRC_DPERR_MR	(1&lt;&lt;7)	</span><span class="cm">/* Bit 7:  force DATAPERR on MST RE. */</span><span class="cp"></span>
<span class="cp">#define	TST_FRC_DPERR_MW	(1&lt;&lt;6)	</span><span class="cm">/* Bit 6:  force DATAPERR on MST WR. */</span><span class="cp"></span>
<span class="cp">#define	TST_FRC_DPERR_TR	(1&lt;&lt;5)	</span><span class="cm">/* Bit 5:  force DATAPERR on TRG RE. */</span><span class="cp"></span>
<span class="cp">#define	TST_FRC_DPERR_TW	(1&lt;&lt;4)	</span><span class="cm">/* Bit 4:  force DATAPERR on TRG WR. */</span><span class="cp"></span>
<span class="cp">#define	TST_FRC_APERR_M		(1&lt;&lt;3)	</span><span class="cm">/* Bit 3:  force ADDRPERR on MST     */</span><span class="cp"></span>
<span class="cp">#define	TST_FRC_APERR_T		(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:  force ADDRPERR on TRG     */</span><span class="cp"></span>
<span class="cp">#define	TST_CFG_WRITE_ON	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:  ena configuration reg. WR */</span><span class="cp"></span>
<span class="cp">#define	TST_CFG_WRITE_OFF	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:  dis configuration reg. WR */</span><span class="cp"></span>

<span class="cm">/*	B0_ISRC		32 bit Interrupt source register */</span>
					<span class="cm">/* Bit 31..28:	reserved	     */</span>
<span class="cp">#define IS_I2C_READY	(1L&lt;&lt;27)	</span><span class="cm">/* Bit 27: (ML)	IRQ on end of I2C tx */</span><span class="cp"></span>
<span class="cp">#define IS_IRQ_SW	(1L&lt;&lt;26)	</span><span class="cm">/* Bit 26: (ML)	SW forced IRQ	     */</span><span class="cp"></span>
<span class="cp">#define IS_EXT_REG	(1L&lt;&lt;25)	</span><span class="cm">/* Bit 25: (ML) IRQ from external reg*/</span><span class="cp"></span>
<span class="cp">#define	IS_IRQ_STAT	(1L&lt;&lt;24)	</span><span class="cm">/* Bit 24:	IRQ status exception */</span><span class="cp"></span>
					<span class="cm">/*   PERR, RMABORT, RTABORT DATAPERR */</span>
<span class="cp">#define	IS_IRQ_MST_ERR	(1L&lt;&lt;23)	</span><span class="cm">/* Bit 23:	IRQ master error     */</span><span class="cp"></span>
					<span class="cm">/*   RMABORT, RTABORT, DATAPERR	     */</span>
<span class="cp">#define	IS_TIMINT	(1L&lt;&lt;22)	</span><span class="cm">/* Bit 22:	IRQ_TIMER	*/</span><span class="cp"></span>
<span class="cp">#define	IS_TOKEN	(1L&lt;&lt;21)	</span><span class="cm">/* Bit 21:	IRQ_RTM		*/</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * Note: The DAS is our First Port (!=PA)</span>
<span class="cm"> */</span>
<span class="cp">#define	IS_PLINT1	(1L&lt;&lt;20)	</span><span class="cm">/* Bit 20:	IRQ_PHY_DAS	*/</span><span class="cp"></span>
<span class="cp">#define	IS_PLINT2	(1L&lt;&lt;19)	</span><span class="cm">/* Bit 19:	IRQ_IFCP_4	*/</span><span class="cp"></span>
<span class="cp">#define	IS_MINTR3	(1L&lt;&lt;18)	</span><span class="cm">/* Bit 18:	IRQ_IFCP_3/IRQ_PHY */</span><span class="cp"></span>
<span class="cp">#define	IS_MINTR2	(1L&lt;&lt;17)	</span><span class="cm">/* Bit 17:	IRQ_IFCP_2/IRQ_MAC_2 */</span><span class="cp"></span>
<span class="cp">#define	IS_MINTR1	(1L&lt;&lt;16)	</span><span class="cm">/* Bit 16:	IRQ_IFCP_1/IRQ_MAC_1 */</span><span class="cp"></span>
<span class="cm">/* Receive Queue 1 */</span>
<span class="cp">#define	IS_R1_P		(1L&lt;&lt;15)	</span><span class="cm">/* Bit 15:	Parity Error (q1) */</span><span class="cp"></span>
<span class="cp">#define	IS_R1_B		(1L&lt;&lt;14)	</span><span class="cm">/* Bit 14:	End of Buffer (q1) */</span><span class="cp"></span>
<span class="cp">#define	IS_R1_F		(1L&lt;&lt;13)	</span><span class="cm">/* Bit 13:	End of Frame (q1) */</span><span class="cp"></span>
<span class="cp">#define	IS_R1_C		(1L&lt;&lt;12)	</span><span class="cm">/* Bit 12:	Encoding Error (q1) */</span><span class="cp"></span>
<span class="cm">/* Receive Queue 2 */</span>
<span class="cp">#define	IS_R2_P		(1L&lt;&lt;11)	</span><span class="cm">/* Bit 11: (DV)	Parity Error (q2) */</span><span class="cp"></span>
<span class="cp">#define	IS_R2_B		(1L&lt;&lt;10)	</span><span class="cm">/* Bit 10: (DV)	End of Buffer (q2) */</span><span class="cp"></span>
<span class="cp">#define	IS_R2_F		(1L&lt;&lt;9)		</span><span class="cm">/* Bit	9: (DV)	End of Frame (q2) */</span><span class="cp"></span>
<span class="cp">#define	IS_R2_C		(1L&lt;&lt;8)		</span><span class="cm">/* Bit	8: (DV)	Encoding Error (q2) */</span><span class="cp"></span>
<span class="cm">/* Asynchronous Transmit queue */</span>
					<span class="cm">/* Bit  7:	reserved */</span>
<span class="cp">#define	IS_XA_B		(1L&lt;&lt;6)		</span><span class="cm">/* Bit	6:	End of Buffer (xa) */</span><span class="cp"></span>
<span class="cp">#define	IS_XA_F		(1L&lt;&lt;5)		</span><span class="cm">/* Bit	5:	End of Frame (xa) */</span><span class="cp"></span>
<span class="cp">#define	IS_XA_C		(1L&lt;&lt;4)		</span><span class="cm">/* Bit	4:	Encoding Error (xa) */</span><span class="cp"></span>
<span class="cm">/* Synchronous Transmit queue */</span>
					<span class="cm">/* Bit  3:	reserved */</span>
<span class="cp">#define	IS_XS_B		(1L&lt;&lt;2)		</span><span class="cm">/* Bit	2:	End of Buffer (xs) */</span><span class="cp"></span>
<span class="cp">#define	IS_XS_F		(1L&lt;&lt;1)		</span><span class="cm">/* Bit	1:	End of Frame (xs) */</span><span class="cp"></span>
<span class="cp">#define	IS_XS_C		(1L&lt;&lt;0)		</span><span class="cm">/* Bit	0:	Encoding Error (xs) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Define all valid interrupt source Bits from GET_ISR ()</span>
<span class="cm"> */</span>
<span class="cp">#define	ALL_IRSR	0x01ffff77L	</span><span class="cm">/* (DV) */</span><span class="cp"></span>
<span class="cp">#define	ALL_IRSR_ML	0x0ffff077L	</span><span class="cm">/* (ML) */</span><span class="cp"></span>


<span class="cm">/*	B0_IMSK		32 bit Interrupt mask register */</span>
<span class="cm">/*</span>
<span class="cm"> * The Bit definnition of this register are the same as of the interrupt</span>
<span class="cm"> * source register. These definition are directly derived from the Hardware</span>
<span class="cm"> * spec.</span>
<span class="cm"> */</span>
					<span class="cm">/* Bit 31..28:	reserved	     */</span>
<span class="cp">#define IRQ_I2C_READY	(1L&lt;&lt;27)	</span><span class="cm">/* Bit 27: (ML)	IRQ on end of I2C tx */</span><span class="cp"></span>
<span class="cp">#define IRQ_SW		(1L&lt;&lt;26)	</span><span class="cm">/* Bit 26: (ML)	SW forced IRQ	     */</span><span class="cp"></span>
<span class="cp">#define IRQ_EXT_REG	(1L&lt;&lt;25)	</span><span class="cm">/* Bit 25: (ML) IRQ from external reg*/</span><span class="cp"></span>
<span class="cp">#define	IRQ_STAT	(1L&lt;&lt;24)	</span><span class="cm">/* Bit 24:	IRQ status exception */</span><span class="cp"></span>
					<span class="cm">/*   PERR, RMABORT, RTABORT DATAPERR */</span>
<span class="cp">#define	IRQ_MST_ERR	(1L&lt;&lt;23)	</span><span class="cm">/* Bit 23:	IRQ master error     */</span><span class="cp"></span>
					<span class="cm">/*   RMABORT, RTABORT, DATAPERR	     */</span>
<span class="cp">#define	IRQ_TIMER	(1L&lt;&lt;22)	</span><span class="cm">/* Bit 22:	IRQ_TIMER	*/</span><span class="cp"></span>
<span class="cp">#define	IRQ_RTM		(1L&lt;&lt;21)	</span><span class="cm">/* Bit 21:	IRQ_RTM		*/</span><span class="cp"></span>
<span class="cp">#define	IRQ_DAS		(1L&lt;&lt;20)	</span><span class="cm">/* Bit 20:	IRQ_PHY_DAS	*/</span><span class="cp"></span>
<span class="cp">#define	IRQ_IFCP_4	(1L&lt;&lt;19)	</span><span class="cm">/* Bit 19:	IRQ_IFCP_4	*/</span><span class="cp"></span>
<span class="cp">#define	IRQ_IFCP_3	(1L&lt;&lt;18)	</span><span class="cm">/* Bit 18:	IRQ_IFCP_3/IRQ_PHY */</span><span class="cp"></span>
<span class="cp">#define	IRQ_IFCP_2	(1L&lt;&lt;17)	</span><span class="cm">/* Bit 17:	IRQ_IFCP_2/IRQ_MAC_2 */</span><span class="cp"></span>
<span class="cp">#define	IRQ_IFCP_1	(1L&lt;&lt;16)	</span><span class="cm">/* Bit 16:	IRQ_IFCP_1/IRQ_MAC_1 */</span><span class="cp"></span>
<span class="cm">/* Receive Queue 1 */</span>
<span class="cp">#define	IRQ_R1_P	(1L&lt;&lt;15)	</span><span class="cm">/* Bit 15:	Parity Error (q1) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_R1_B	(1L&lt;&lt;14)	</span><span class="cm">/* Bit 14:	End of Buffer (q1) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_R1_F	(1L&lt;&lt;13)	</span><span class="cm">/* Bit 13:	End of Frame (q1) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_R1_C	(1L&lt;&lt;12)	</span><span class="cm">/* Bit 12:	Encoding Error (q1) */</span><span class="cp"></span>
<span class="cm">/* Receive Queue 2 */</span>
<span class="cp">#define	IRQ_R2_P	(1L&lt;&lt;11)	</span><span class="cm">/* Bit 11: (DV)	Parity Error (q2) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_R2_B	(1L&lt;&lt;10)	</span><span class="cm">/* Bit 10: (DV)	End of Buffer (q2) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_R2_F	(1L&lt;&lt;9)		</span><span class="cm">/* Bit	9: (DV)	End of Frame (q2) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_R2_C	(1L&lt;&lt;8)		</span><span class="cm">/* Bit	8: (DV)	Encoding Error (q2) */</span><span class="cp"></span>
<span class="cm">/* Asynchronous Transmit queue */</span>
					<span class="cm">/* Bit  7:	reserved */</span>
<span class="cp">#define	IRQ_XA_B	(1L&lt;&lt;6)		</span><span class="cm">/* Bit	6:	End of Buffer (xa) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_XA_F	(1L&lt;&lt;5)		</span><span class="cm">/* Bit	5:	End of Frame (xa) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_XA_C	(1L&lt;&lt;4)		</span><span class="cm">/* Bit	4:	Encoding Error (xa) */</span><span class="cp"></span>
<span class="cm">/* Synchronous Transmit queue */</span>
					<span class="cm">/* Bit  3:	reserved */</span>
<span class="cp">#define	IRQ_XS_B	(1L&lt;&lt;2)		</span><span class="cm">/* Bit	2:	End of Buffer (xs) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_XS_F	(1L&lt;&lt;1)		</span><span class="cm">/* Bit	1:	End of Frame (xs) */</span><span class="cp"></span>
<span class="cp">#define	IRQ_XS_C	(1L&lt;&lt;0)		</span><span class="cm">/* Bit	0:	Encoding Error (xs) */</span><span class="cp"></span>

<span class="cm">/* 0x0010 - 0x006b:	formac+ (supernet_3) fequently used registers */</span>
<span class="cm">/*	B0_R1_CSR	32 bit BMU control/status reg (rec q 1 ) */</span>
<span class="cm">/*	B0_R2_CSR	32 bit BMU control/status reg (rec q 2 ) */</span>
<span class="cm">/*	B0_XA_CSR	32 bit BMU control/status reg (a xmit q ) */</span>
<span class="cm">/*	B0_XS_CSR	32 bit BMU control/status reg (s xmit q ) */</span>
<span class="cm">/* The registers are the same as B4_R1_CSR, B4_R2_CSR, B5_Xa_CSR, B5_XS_CSR */</span>

<span class="cm">/*	B2_MAC_0	8 bit MAC address Byte 0 */</span>
<span class="cm">/*	B2_MAC_1	8 bit MAC address Byte 1 */</span>
<span class="cm">/*	B2_MAC_2	8 bit MAC address Byte 2 */</span>
<span class="cm">/*	B2_MAC_3	8 bit MAC address Byte 3 */</span>
<span class="cm">/*	B2_MAC_4	8 bit MAC address Byte 4 */</span>
<span class="cm">/*	B2_MAC_5	8 bit MAC address Byte 5 */</span>
<span class="cm">/*	B2_MAC_6	8 bit MAC address Byte 6 (== 0) (DV) */</span>
<span class="cm">/*	B2_MAC_7	8 bit MAC address Byte 7 (== 0) (DV) */</span>

<span class="cm">/*	B2_CONN_TYP	8 bit Connector type */</span>
<span class="cm">/*	B2_PMD_TYP	8 bit PMD type */</span>
<span class="cm">/*	Values of connector and PMD type comply to SysKonnect internal std */</span>

<span class="cm">/*	The EPROM register are currently of no use */</span>
<span class="cm">/*	B2_E_0		8 bit EPROM Byte 0 */</span>
<span class="cm">/*	B2_E_1		8 bit EPROM Byte 1 */</span>
<span class="cm">/*	B2_E_2		8 bit EPROM Byte 2 */</span>
<span class="cm">/*	B2_E_3		8 bit EPROM Byte 3 */</span>

<span class="cm">/*	B2_FAR		32 bit Flash-Prom Address Register/Counter */</span>
<span class="cp">#define	FAR_ADDR	0x1ffffL	</span><span class="cm">/* Bit 16..0:	FPROM Address mask */</span><span class="cp"></span>

<span class="cm">/*	B2_FDP		8 bit Flash-Prom Data Port */</span>

<span class="cm">/*	B2_LD_CRTL	8 bit loader control */</span>
<span class="cm">/*	Bits are currently reserved */</span>

<span class="cm">/*	B2_LD_TEST	8 bit loader test */</span>
<span class="cp">#define	LD_T_ON		(1&lt;&lt;3)	</span><span class="cm">/* Bit 3:    Loader Testmode on */</span><span class="cp"></span>
<span class="cp">#define	LD_T_OFF	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:    Loader Testmode off */</span><span class="cp"></span>
<span class="cp">#define	LD_T_STEP	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:    Decrement FPROM addr. Counter */</span><span class="cp"></span>
<span class="cp">#define	LD_START	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:    Start loading FPROM */</span><span class="cp"></span>

<span class="cm">/*	B2_TI_INI	32 bit Timer init value */</span>
<span class="cm">/*	B2_TI_VAL	32 bit Timer value */</span>
<span class="cm">/*	B2_TI_CRTL	8 bit Timer control */</span>
<span class="cm">/*	B2_TI_TEST	8 Bit Timer Test */</span>
<span class="cm">/*	B2_WDOG_INI	32 bit Watchdog init value */</span>
<span class="cm">/*	B2_WDOG_VAL	32 bit Watchdog value */</span>
<span class="cm">/*	B2_WDOG_CRTL	8 bit Watchdog control */</span>
<span class="cm">/*	B2_WDOG_TEST	8 Bit Watchdog Test */</span>
<span class="cm">/*	B2_RTM_INI	32 bit RTM init value */</span>
<span class="cm">/*	B2_RTM_VAL	32 bit RTM value */</span>
<span class="cm">/*	B2_RTM_CRTL	8 bit RTM control */</span>
<span class="cm">/*	B2_RTM_TEST	8 Bit RTM Test */</span>
<span class="cm">/*	B2_&lt;TIM&gt;_CRTL	8 bit &lt;TIM&gt; control */</span>
<span class="cm">/*	B2_IRQ_MOD_INI	32 bit IRQ Moderation Timer Init Reg.	(ML) */</span>
<span class="cm">/*	B2_IRQ_MOD_VAL	32 bit IRQ Moderation Timer Value	(ML) */</span>
<span class="cm">/*	B2_IRQ_MOD_CTRL	8 bit IRQ Moderation Timer Control	(ML) */</span>
<span class="cm">/*	B2_IRQ_MOD_TEST	8 bit IRQ Moderation Timer Test		(ML) */</span>
<span class="cp">#define GET_TOK_CT	(1&lt;&lt;4)	</span><span class="cm">/* Bit 4: Get the Token Counter (RTM) */</span><span class="cp"></span>
<span class="cp">#define TIM_RES_TOK	(1&lt;&lt;3)	</span><span class="cm">/* Bit 3: RTM Status: 1 == restricted */</span><span class="cp"></span>
<span class="cp">#define TIM_ALARM	(1&lt;&lt;3)	</span><span class="cm">/* Bit 3: Timer Alarm (WDOG) */</span><span class="cp"></span>
<span class="cp">#define TIM_START	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2: Start Timer (TI,WDOG,RTM,IRQ_MOD)*/</span><span class="cp"></span>
<span class="cp">#define TIM_STOP	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1: Stop Timer (TI,WDOG,RTM,IRQ_MOD) */</span><span class="cp"></span>
<span class="cp">#define TIM_CL_IRQ	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0: Clear Timer IRQ (TI,WDOG,RTM) */</span><span class="cp"></span>
<span class="cm">/*	B2_&lt;TIM&gt;_TEST	8 Bit &lt;TIM&gt; Test */</span>
<span class="cp">#define	TIM_T_ON	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2: Test mode on (TI,WDOG,RTM,IRQ_MOD) */</span><span class="cp"></span>
<span class="cp">#define	TIM_T_OFF	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1: Test mode off (TI,WDOG,RTM,IRQ_MOD) */</span><span class="cp"></span>
<span class="cp">#define	TIM_T_STEP	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0: Test step (TI,WDOG,RTM,IRQ_MOD) */</span><span class="cp"></span>

<span class="cm">/*	B2_TOK_COUNT	0x014c	(ML)	32 bit	Token Counter */</span>
<span class="cm">/*	B2_DESC_ADDR_H	0x0150	(ML)	32 bit	Desciptor Base Addr Reg High */</span>
<span class="cm">/*	B2_CTRL_2	0x0154	(ML)	 8 bit	Control Register 2 */</span>
				<span class="cm">/* Bit 7..5:	reserved		*/</span>
<span class="cp">#define CTRL_CL_I2C_IRQ (1&lt;&lt;4)	</span><span class="cm">/* Bit 4:	Clear I2C IRQ		*/</span><span class="cp"></span>
<span class="cp">#define CTRL_ST_SW_IRQ	(1&lt;&lt;3)	</span><span class="cm">/* Bit 3:	Set IRQ SW Request	*/</span><span class="cp"></span>
<span class="cp">#define CTRL_CL_SW_IRQ	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:	Clear IRQ SW Request	*/</span><span class="cp"></span>
<span class="cp">#define CTRL_STOP_DONE	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:	Stop Master is finished */</span><span class="cp"></span>
<span class="cp">#define	CTRL_STOP_MAST	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:	Command Bit to stop the master*/</span><span class="cp"></span>

<span class="cm">/*	B2_IFACE_REG	0x0155	(ML)	 8 bit	Interface Register */</span>
				<span class="cm">/* Bit 7..3:	reserved		*/</span>
<span class="cp">#define	IF_I2C_DATA_DIR	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:	direction of IF_I2C_DATA*/</span><span class="cp"></span>
<span class="cp">#define IF_I2C_DATA	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:	I2C Data Port		*/</span><span class="cp"></span>
<span class="cp">#define	IF_I2C_CLK	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:	I2C Clock Port		*/</span><span class="cp"></span>

				<span class="cm">/* 0x0156:		reserved */</span>
<span class="cm">/*	B2_TST_CTRL_2	0x0157	(ML)	 8 bit	Test Control Register 2 */</span>
					<span class="cm">/* Bit 7..4:	reserved */</span>
					<span class="cm">/* force the following error on */</span>
					<span class="cm">/* the next master read/write	*/</span>
<span class="cp">#define TST_FRC_DPERR_MR64	(1&lt;&lt;3)	</span><span class="cm">/* Bit 3:	DataPERR RD 64	*/</span><span class="cp"></span>
<span class="cp">#define TST_FRC_DPERR_MW64	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:	DataPERR WR 64	*/</span><span class="cp"></span>
<span class="cp">#define TST_FRC_APERR_1M64	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:	AddrPERR on 1. phase */</span><span class="cp"></span>
<span class="cp">#define TST_FRC_APERR_2M64	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:	AddrPERR on 2. phase */</span><span class="cp"></span>

<span class="cm">/*	B2_I2C_CTRL	0x0158	(ML)	32 bit	I2C Control Register	       */</span>
<span class="cp">#define	I2C_FLAG	(1L&lt;&lt;31)	</span><span class="cm">/* Bit 31:	Start read/write if WR */</span><span class="cp"></span>
<span class="cp">#define I2C_ADDR	(0x7fffL&lt;&lt;16)	</span><span class="cm">/* Bit 30..16:	Addr to be read/written*/</span><span class="cp"></span>
<span class="cp">#define	I2C_DEV_SEL	(0x7fL&lt;&lt;9)	</span><span class="cm">/* Bit  9..15:	I2C Device Select      */</span><span class="cp"></span>
					<span class="cm">/* Bit  5.. 8:	reserved	       */</span>
<span class="cp">#define I2C_BURST_LEN	(1L&lt;&lt;4)		</span><span class="cm">/* Bit  4	Burst Len, 1/4 bytes   */</span><span class="cp"></span>
<span class="cp">#define I2C_DEV_SIZE	(7L&lt;&lt;1)		</span><span class="cm">/* Bit	1.. 3:	I2C Device Size	       */</span><span class="cp"></span>
<span class="cp">#define I2C_025K_DEV	(0L&lt;&lt;1)		</span><span class="cm">/*		0: 256 Bytes or smaller*/</span><span class="cp"></span>
<span class="cp">#define I2C_05K_DEV	(1L&lt;&lt;1)		</span><span class="cm">/* 		1: 512	Bytes	       */</span><span class="cp"></span>
<span class="cp">#define	I2C_1K_DEV	(2L&lt;&lt;1)		</span><span class="cm">/*		2: 1024 Bytes	       */</span><span class="cp"></span>
<span class="cp">#define I2C_2K_DEV	(3L&lt;&lt;1)		</span><span class="cm">/*		3: 2048	Bytes	       */</span><span class="cp"></span>
<span class="cp">#define	I2C_4K_DEV	(4L&lt;&lt;1)		</span><span class="cm">/*		4: 4096 Bytes	       */</span><span class="cp"></span>
<span class="cp">#define	I2C_8K_DEV	(5L&lt;&lt;1)		</span><span class="cm">/*		5: 8192 Bytes	       */</span><span class="cp"></span>
<span class="cp">#define	I2C_16K_DEV	(6L&lt;&lt;1)		</span><span class="cm">/*		6: 16384 Bytes	       */</span><span class="cp"></span>
<span class="cp">#define	I2C_32K_DEV	(7L&lt;&lt;1)		</span><span class="cm">/*		7: 32768 Bytes	       */</span><span class="cp"></span>
<span class="cp">#define I2C_STOP_BIT	(1&lt;&lt;0)		</span><span class="cm">/* Bit  0:	Interrupt I2C transfer */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * I2C Addresses</span>
<span class="cm"> *</span>
<span class="cm"> * The temperature sensor and the voltage sensor are on the same I2C bus.</span>
<span class="cm"> * Note: The voltage sensor (Micorwire) will be selected by PCI_EXT_PATCH_1</span>
<span class="cm"> *	 in PCI_OUR_REG 1.</span>
<span class="cm"> */</span>
<span class="cp">#define	I2C_ADDR_TEMP	0x90	</span><span class="cm">/* I2C Address Temperature Sensor */</span><span class="cp"></span>

<span class="cm">/*	B2_I2C_DATA	0x015c	(ML)	32 bit	I2C Data Register */</span>

<span class="cm">/*	B4_R1_D		4*32 bit current receive Descriptor	(q1) */</span>
<span class="cm">/*	B4_R1_DA	32 bit current rec desc address		(q1) */</span>
<span class="cm">/*	B4_R1_AC	32 bit current receive Address Count	(q1) */</span>
<span class="cm">/*	B4_R1_BC	32 bit current receive Byte Counter	(q1) */</span>
<span class="cm">/*	B4_R1_CSR	32 bit BMU Control/Status Register	(q1) */</span>
<span class="cm">/*	B4_R1_F		32 bit flag register			(q1) */</span>
<span class="cm">/*	B4_R1_T1	32 bit Test Register 1		 	(q1) */</span>
<span class="cm">/*	B4_R1_T2	32 bit Test Register 2		 	(q1) */</span>
<span class="cm">/*	B4_R1_T3	32 bit Test Register 3		 	(q1) */</span>
<span class="cm">/*	B4_R2_D		4*32 bit current receive Descriptor	(q2) */</span>
<span class="cm">/*	B4_R2_DA	32 bit current rec desc address		(q2) */</span>
<span class="cm">/*	B4_R2_AC	32 bit current receive Address Count	(q2) */</span>
<span class="cm">/*	B4_R2_BC	32 bit current receive Byte Counter	(q2) */</span>
<span class="cm">/*	B4_R2_CSR	32 bit BMU Control/Status Register	(q2) */</span>
<span class="cm">/*	B4_R2_F		32 bit flag register			(q2) */</span>
<span class="cm">/*	B4_R2_T1	32 bit Test Register 1			(q2) */</span>
<span class="cm">/*	B4_R2_T2	32 bit Test Register 2			(q2) */</span>
<span class="cm">/*	B4_R2_T3	32 bit Test Register 3			(q2) */</span>
<span class="cm">/*	B5_XA_D		4*32 bit current receive Descriptor	(xa) */</span>
<span class="cm">/*	B5_XA_DA	32 bit current rec desc address		(xa) */</span>
<span class="cm">/*	B5_XA_AC	32 bit current receive Address Count	(xa) */</span>
<span class="cm">/*	B5_XA_BC	32 bit current receive Byte Counter	(xa) */</span>
<span class="cm">/*	B5_XA_CSR	32 bit BMU Control/Status Register	(xa) */</span>
<span class="cm">/*	B5_XA_F		32 bit flag register			(xa) */</span>
<span class="cm">/*	B5_XA_T1	32 bit Test Register 1			(xa) */</span>
<span class="cm">/*	B5_XA_T2	32 bit Test Register 2			(xa) */</span>
<span class="cm">/*	B5_XA_T3	32 bit Test Register 3			(xa) */</span>
<span class="cm">/*	B5_XS_D		4*32 bit current receive Descriptor	(xs) */</span>
<span class="cm">/*	B5_XS_DA	32 bit current rec desc address		(xs) */</span>
<span class="cm">/*	B5_XS_AC	32 bit current receive Address Count	(xs) */</span>
<span class="cm">/*	B5_XS_BC	32 bit current receive Byte Counter	(xs) */</span>
<span class="cm">/*	B5_XS_CSR	32 bit BMU Control/Status Register	(xs) */</span>
<span class="cm">/*	B5_XS_F		32 bit flag register			(xs) */</span>
<span class="cm">/*	B5_XS_T1	32 bit Test Register 1			(xs) */</span>
<span class="cm">/*	B5_XS_T2	32 bit Test Register 2			(xs) */</span>
<span class="cm">/*	B5_XS_T3	32 bit Test Register 3			(xs) */</span>
<span class="cm">/*	B5_&lt;xx&gt;_CSR	32 bit BMU Control/Status Register	(xx) */</span>
<span class="cp">#define	CSR_DESC_CLEAR	(1L&lt;&lt;21)    </span><span class="cm">/* Bit 21:	Clear Reset for Descr */</span><span class="cp"></span>
<span class="cp">#define	CSR_DESC_SET	(1L&lt;&lt;20)    </span><span class="cm">/* Bit 20:	Set Reset for Descr */</span><span class="cp"></span>
<span class="cp">#define	CSR_FIFO_CLEAR	(1L&lt;&lt;19)    </span><span class="cm">/* Bit 19:	Clear Reset for FIFO */</span><span class="cp"></span>
<span class="cp">#define	CSR_FIFO_SET	(1L&lt;&lt;18)    </span><span class="cm">/* Bit 18:	Set Reset for FIFO */</span><span class="cp"></span>
<span class="cp">#define	CSR_HPI_RUN	(1L&lt;&lt;17)    </span><span class="cm">/* Bit 17:	Release HPI SM */</span><span class="cp"></span>
<span class="cp">#define	CSR_HPI_RST	(1L&lt;&lt;16)    </span><span class="cm">/* Bit 16:	Reset HPI SM to Idle */</span><span class="cp"></span>
<span class="cp">#define	CSR_SV_RUN	(1L&lt;&lt;15)    </span><span class="cm">/* Bit 15:	Release Supervisor SM */</span><span class="cp"></span>
<span class="cp">#define	CSR_SV_RST	(1L&lt;&lt;14)    </span><span class="cm">/* Bit 14:	Reset Supervisor SM */</span><span class="cp"></span>
<span class="cp">#define	CSR_DREAD_RUN	(1L&lt;&lt;13)    </span><span class="cm">/* Bit 13:	Release Descr Read SM */</span><span class="cp"></span>
<span class="cp">#define	CSR_DREAD_RST	(1L&lt;&lt;12)    </span><span class="cm">/* Bit 12:	Reset Descr Read SM */</span><span class="cp"></span>
<span class="cp">#define	CSR_DWRITE_RUN	(1L&lt;&lt;11)    </span><span class="cm">/* Bit 11:	Rel. Descr Write SM */</span><span class="cp"></span>
<span class="cp">#define	CSR_DWRITE_RST	(1L&lt;&lt;10)    </span><span class="cm">/* Bit 10:	Reset Descr Write SM */</span><span class="cp"></span>
<span class="cp">#define	CSR_TRANS_RUN	(1L&lt;&lt;9)     </span><span class="cm">/* Bit 9:	Release Transfer SM */</span><span class="cp"></span>
<span class="cp">#define	CSR_TRANS_RST	(1L&lt;&lt;8)     </span><span class="cm">/* Bit 8:	Reset Transfer SM */</span><span class="cp"></span>
				    <span class="cm">/* Bit 7..5: reserved */</span>
<span class="cp">#define	CSR_START	(1L&lt;&lt;4)     </span><span class="cm">/* Bit 4:	Start Rec/Xmit Queue */</span><span class="cp"></span>
<span class="cp">#define	CSR_IRQ_CL_P	(1L&lt;&lt;3)     </span><span class="cm">/* Bit 3:	Clear Parity IRQ, Rcv */</span><span class="cp"></span>
<span class="cp">#define	CSR_IRQ_CL_B	(1L&lt;&lt;2)     </span><span class="cm">/* Bit 2:	Clear EOB IRQ */</span><span class="cp"></span>
<span class="cp">#define	CSR_IRQ_CL_F	(1L&lt;&lt;1)     </span><span class="cm">/* Bit 1:	Clear EOF IRQ */</span><span class="cp"></span>
<span class="cp">#define	CSR_IRQ_CL_C	(1L&lt;&lt;0)     </span><span class="cm">/* Bit 0:	Clear ERR IRQ */</span><span class="cp"></span>

<span class="cp">#define CSR_SET_RESET	(CSR_DESC_SET|CSR_FIFO_SET|CSR_HPI_RST|CSR_SV_RST|\</span>
<span class="cp">			CSR_DREAD_RST|CSR_DWRITE_RST|CSR_TRANS_RST)</span>
<span class="cp">#define CSR_CLR_RESET	(CSR_DESC_CLEAR|CSR_FIFO_CLEAR|CSR_HPI_RUN|CSR_SV_RUN|\</span>
<span class="cp">			CSR_DREAD_RUN|CSR_DWRITE_RUN|CSR_TRANS_RUN)</span>


<span class="cm">/*	B5_&lt;xx&gt;_F	32 bit flag register		 (xx) */</span>
					<span class="cm">/* Bit 28..31:	reserved	      */</span>
<span class="cp">#define F_ALM_FULL	(1L&lt;&lt;27)	</span><span class="cm">/* Bit 27: (ML)	FIFO almost full      */</span><span class="cp"></span>
<span class="cp">#define F_FIFO_EOF	(1L&lt;&lt;26)	</span><span class="cm">/* Bit 26: (ML)	Fag bit in FIFO       */</span><span class="cp"></span>
<span class="cp">#define F_WM_REACHED	(1L&lt;&lt;25)	</span><span class="cm">/* Bit 25: (ML)	Watermark reached     */</span><span class="cp"></span>
<span class="cp">#define F_UP_DW_USED	(1L&lt;&lt;24)	</span><span class="cm">/* Bit 24: (ML) Upper Dword used (bug)*/</span><span class="cp"></span>
					<span class="cm">/* Bit 23: 	reserved	      */</span>
<span class="cp">#define F_FIFO_LEVEL	(0x1fL&lt;&lt;16)	</span><span class="cm">/* Bit 16..22:(ML) # of Qwords in FIFO*/</span><span class="cp"></span>
					<span class="cm">/* Bit  8..15: 	reserved	      */</span>
<span class="cp">#define F_ML_WATER_M	0x0000ffL	</span><span class="cm">/* Bit  0.. 7:(ML) Watermark	      */</span><span class="cp"></span>
<span class="cp">#define	FLAG_WATER	0x00001fL	</span><span class="cm">/* Bit 4..0:(DV) Level of req data tr.*/</span><span class="cp"></span>

<span class="cm">/*	B5_&lt;xx&gt;_T1	32 bit Test Register 1		 (xx) */</span>
<span class="cm">/*		Holds four State Machine control Bytes */</span>
<span class="cp">#define	SM_CRTL_SV	(0xffL&lt;&lt;24) </span><span class="cm">/* Bit 31..24:  Control Supervisor SM */</span><span class="cp"></span>
<span class="cp">#define	SM_CRTL_RD	(0xffL&lt;&lt;16) </span><span class="cm">/* Bit 23..16:  Control Read Desc SM */</span><span class="cp"></span>
<span class="cp">#define	SM_CRTL_WR	(0xffL&lt;&lt;8)  </span><span class="cm">/* Bit 15..8:   Control Write Desc SM */</span><span class="cp"></span>
<span class="cp">#define	SM_CRTL_TR	(0xffL&lt;&lt;0)  </span><span class="cm">/* Bit 7..0:    Control Transfer SM */</span><span class="cp"></span>

<span class="cm">/*	B4_&lt;xx&gt;_T1_TR	8 bit Test Register 1 TR		(xx) */</span>
<span class="cm">/*	B4_&lt;xx&gt;_T1_WR	8 bit Test Register 1 WR		(xx) */</span>
<span class="cm">/*	B4_&lt;xx&gt;_T1_RD	8 bit Test Register 1 RD		(xx) */</span>
<span class="cm">/*	B4_&lt;xx&gt;_T1_SV	8 bit Test Register 1 SV		(xx) */</span>
<span class="cm">/* The control status byte of each machine looks like ... */</span>
<span class="cp">#define	SM_STATE	0xf0	</span><span class="cm">/* Bit 7..4:	State which shall be loaded */</span><span class="cp"></span>
<span class="cp">#define	SM_LOAD		0x08	</span><span class="cm">/* Bit 3:	Load the SM with SM_STATE */</span><span class="cp"></span>
<span class="cp">#define	SM_TEST_ON	0x04	</span><span class="cm">/* Bit 2:	Switch on SM Test Mode */</span><span class="cp"></span>
<span class="cp">#define	SM_TEST_OFF	0x02	</span><span class="cm">/* Bit 1:	Go off the Test Mode */</span><span class="cp"></span>
<span class="cp">#define	SM_STEP		0x01	</span><span class="cm">/* Bit 0:	Step the State Machine */</span><span class="cp"></span>

<span class="cm">/* The coding of the states */</span>
<span class="cp">#define	SM_SV_IDLE	0x0	</span><span class="cm">/* Supervisor	Idle		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_SV_RES_START	0x1	</span><span class="cm">/* Supervisor	Res_Start	Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_SV_GET_DESC	0x3	</span><span class="cm">/* Supervisor	Get_Desc	Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_SV_CHECK	0x2	</span><span class="cm">/* Supervisor	Check		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_SV_MOV_DATA	0x6	</span><span class="cm">/* Supervisor	Move_Data	Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_SV_PUT_DESC	0x7	</span><span class="cm">/* Supervisor	Put_Desc	Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_SV_SET_IRQ	0x5	</span><span class="cm">/* Supervisor	Set_Irq		Tr/Re	     */</span><span class="cp"></span>

<span class="cp">#define	SM_RD_IDLE	0x0	</span><span class="cm">/* Read Desc.	Idle		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_RD_LOAD	0x1	</span><span class="cm">/* Read Desc.	Load		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_RD_WAIT_TC	0x3	</span><span class="cm">/* Read Desc.	Wait_TC		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_RD_RST_EOF	0x6	</span><span class="cm">/* Read Desc.	Reset_EOF	   Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_RD_WDONE_R	0x2	</span><span class="cm">/* Read Desc.	Wait_Done	   Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_RD_WDONE_T	0x4	</span><span class="cm">/* Read Desc.	Wait_Done	Tr   	     */</span><span class="cp"></span>

<span class="cp">#define	SM_TR_IDLE	0x0	</span><span class="cm">/* Trans. Data	Idle		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_TR_LOAD	0x3	</span><span class="cm">/* Trans. Data	Load		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_TR_LOAD_R_ML	0x1	</span><span class="cm">/* Trans. Data	Load		  /Re	(ML) */</span><span class="cp"></span>
<span class="cp">#define	SM_TR_WAIT_TC	0x2	</span><span class="cm">/* Trans. Data	Wait_TC		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_TR_WDONE	0x4	</span><span class="cm">/* Trans. Data	Wait_Done	Tr/Re	     */</span><span class="cp"></span>

<span class="cp">#define	SM_WR_IDLE	0x0	</span><span class="cm">/* Write Desc.	Idle		Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_ABLEN	0x1	</span><span class="cm">/* Write Desc.	Act_Buf_Length	Tr/Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_LD_A4	0x2	</span><span class="cm">/* Write Desc.	Load_A4		   Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_RES_OWN	0x2	</span><span class="cm">/* Write Desc.	Res_OWN		Tr   	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_WAIT_EOF	0x3	</span><span class="cm">/* Write Desc.	Wait_EOF	   Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_LD_N2C_R	0x4	</span><span class="cm">/* Write Desc.	Load_N2C	   Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_WAIT_TC_R	0x5	</span><span class="cm">/* Write Desc.	Wait_TC		   Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_WAIT_TC4	0x6	</span><span class="cm">/* Write Desc.	Wait_TC4	   Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_LD_A_T	0x6	</span><span class="cm">/* Write Desc.	Load_A		Tr   	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_LD_A_R	0x7	</span><span class="cm">/* Write Desc.	Load_A		   Re	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_WAIT_TC_T	0x7	</span><span class="cm">/* Write Desc.	Wait_TC		Tr   	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_LD_N2C_T	0xc	</span><span class="cm">/* Write Desc.	Load_N2C	Tr   	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_WDONE_T	0x9	</span><span class="cm">/* Write Desc.	Wait_Done	Tr   	     */</span><span class="cp"></span>
<span class="cp">#define	SM_WR_WDONE_R	0xc	</span><span class="cm">/* Write Desc.	Wait_Done	   Re	     */</span><span class="cp"></span>
<span class="cp">#define SM_WR_LD_D_AD	0xe	</span><span class="cm">/* Write Desc.  Load_Dumr_A	   Re	(ML) */</span><span class="cp"></span>
<span class="cp">#define SM_WR_WAIT_D_TC	0xf	</span><span class="cm">/* Write Desc.	Wait_Dumr_TC	   Re	(ML) */</span><span class="cp"></span>

<span class="cm">/*	B5_&lt;xx&gt;_T2	32 bit Test Register 2		 (xx) */</span>
<span class="cm">/* Note: This register is only defined for the transmit queues */</span>
				<span class="cm">/* Bit 31..8:	reserved */</span>
<span class="cp">#define	AC_TEST_ON	(1&lt;&lt;7)	</span><span class="cm">/* Bit 7:	Address Counter Test Mode on */</span><span class="cp"></span>
<span class="cp">#define	AC_TEST_OFF	(1&lt;&lt;6)	</span><span class="cm">/* Bit 6:	Address Counter Test Mode off*/</span><span class="cp"></span>
<span class="cp">#define	BC_TEST_ON	(1&lt;&lt;5)	</span><span class="cm">/* Bit 5:	Byte Counter Test Mode on */</span><span class="cp"></span>
<span class="cp">#define	BC_TEST_OFF	(1&lt;&lt;4)	</span><span class="cm">/* Bit 4:	Byte Counter Test Mode off */</span><span class="cp"></span>
<span class="cp">#define	TEST_STEP04	(1&lt;&lt;3)	</span><span class="cm">/* Bit 3:	Inc AC/Dec BC by 4 */</span><span class="cp"></span>
<span class="cp">#define	TEST_STEP03	(1&lt;&lt;2)	</span><span class="cm">/* Bit 2:	Inc AC/Dec BC by 3 */</span><span class="cp"></span>
<span class="cp">#define	TEST_STEP02	(1&lt;&lt;1)	</span><span class="cm">/* Bit 1:	Inc AC/Dec BC by 2 */</span><span class="cp"></span>
<span class="cp">#define	TEST_STEP01	(1&lt;&lt;0)	</span><span class="cm">/* Bit 0:	Inc AC/Dec BC by 1 */</span><span class="cp"></span>

<span class="cm">/*	B5_&lt;xx&gt;_T3	32 bit Test Register 3		 (xx) */</span>
<span class="cm">/* Note: This register is only defined for the transmit queues */</span>
				<span class="cm">/* Bit 31..8:	reserved */</span>
<span class="cp">#define T3_MUX_2	(1&lt;&lt;7)	</span><span class="cm">/* Bit 7: (ML)	Mux position MSB */</span><span class="cp"></span>
<span class="cp">#define T3_VRAM_2	(1&lt;&lt;6)	</span><span class="cm">/* Bit 6: (ML)	Virtual RAM buffer addr MSB */</span><span class="cp"></span>
<span class="cp">#define	T3_LOOP		(1&lt;&lt;5)	</span><span class="cm">/* Bit 5: 	Set Loopback (Xmit) */</span><span class="cp"></span>
<span class="cp">#define	T3_UNLOOP	(1&lt;&lt;4)	</span><span class="cm">/* Bit 4: 	Unset Loopback (Xmit) */</span><span class="cp"></span>
<span class="cp">#define	T3_MUX		(3&lt;&lt;2)	</span><span class="cm">/* Bit 3..2:	Mux position */</span><span class="cp"></span>
<span class="cp">#define	T3_VRAM		(3&lt;&lt;0)	</span><span class="cm">/* Bit 1..0:	Virtual RAM buffer Address */</span><span class="cp"></span>

<span class="cm">/* PCI card IDs */</span>
<span class="cm">/*</span>
<span class="cm"> * Note: The following 4 byte definitions shall not be used! Use OEM Concept!</span>
<span class="cm"> */</span>
<span class="cp">#define	PCI_VEND_ID0	0x48		</span><span class="cm">/* PCI vendor ID (SysKonnect) */</span><span class="cp"></span>
<span class="cp">#define	PCI_VEND_ID1	0x11		</span><span class="cm">/* PCI vendor ID (SysKonnect) */</span><span class="cp"></span>
					<span class="cm">/*		 (High byte) */</span>
<span class="cp">#define	PCI_DEV_ID0	0x00		</span><span class="cm">/* PCI device ID */</span><span class="cp"></span>
<span class="cp">#define	PCI_DEV_ID1	0x40		</span><span class="cm">/* PCI device ID (High byte) */</span><span class="cp"></span>

<span class="cm">/*#define PCI_CLASS	0x02*/</span>		<span class="cm">/* PCI class code: network device */</span>
<span class="cp">#define PCI_NW_CLASS	0x02		</span><span class="cm">/* PCI class code: network device */</span><span class="cp"></span>
<span class="cp">#define PCI_SUB_CLASS	0x02		</span><span class="cm">/* PCI subclass ID: FDDI device */</span><span class="cp"></span>
<span class="cp">#define PCI_PROG_INTFC	0x00		</span><span class="cm">/* PCI programming Interface (=0) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * address transmission from logical to physical offset address on board</span>
<span class="cm"> */</span>
<span class="cp">#define	FMA(a)	(0x0400|((a)&lt;&lt;2))	</span><span class="cm">/* FORMAC+ (r/w) (SN3) */</span><span class="cp"></span>
<span class="cp">#define	P1(a)	(0x0380|((a)&lt;&lt;2))	</span><span class="cm">/* PLC1 (r/w) (DAS) */</span><span class="cp"></span>
<span class="cp">#define	P2(a)	(0x0600|((a)&lt;&lt;2))	</span><span class="cm">/* PLC2 (r/w) (covered by the SN3) */</span><span class="cp"></span>
<span class="cp">#define PRA(a)	(B2_MAC_0 + (a))	</span><span class="cm">/* configuration PROM (MAC address) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * FlashProm specification</span>
<span class="cm"> */</span>
<span class="cp">#define	MAX_PAGES	0x20000L	</span><span class="cm">/* Every byte has a single page */</span><span class="cp"></span>
<span class="cp">#define	MAX_FADDR	1		</span><span class="cm">/* 1 byte per page */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Receive / Transmit Buffer Control word</span>
<span class="cm"> */</span>
<span class="cp">#define	BMU_OWN		(1UL&lt;&lt;31)	</span><span class="cm">/* OWN bit: 0 == host, 1 == adapter */</span><span class="cp"></span>
<span class="cp">#define	BMU_STF		(1L&lt;&lt;30)	</span><span class="cm">/* Start of Frame ?		*/</span><span class="cp"></span>
<span class="cp">#define	BMU_EOF		(1L&lt;&lt;29)	</span><span class="cm">/* End of Frame ?		*/</span><span class="cp"></span>
<span class="cp">#define	BMU_EN_IRQ_EOB	(1L&lt;&lt;28)	</span><span class="cm">/* Enable &quot;End of Buffer&quot; IRQ	*/</span><span class="cp"></span>
<span class="cp">#define	BMU_EN_IRQ_EOF	(1L&lt;&lt;27)	</span><span class="cm">/* Enable &quot;End of Frame&quot; IRQ	*/</span><span class="cp"></span>
<span class="cp">#define	BMU_DEV_0	(1L&lt;&lt;26)	</span><span class="cm">/* RX: don&#39;t transfer to system mem */</span><span class="cp"></span>
<span class="cp">#define BMU_SMT_TX	(1L&lt;&lt;25)	</span><span class="cm">/* TX: if set, buffer type SMT_MBuf */</span><span class="cp"></span>
<span class="cp">#define BMU_ST_BUF	(1L&lt;&lt;25)	</span><span class="cm">/* RX: copy of start of frame */</span><span class="cp"></span>
<span class="cp">#define BMU_UNUSED	(1L&lt;&lt;24)	</span><span class="cm">/* Set if the Descr is curr unused */</span><span class="cp"></span>
<span class="cp">#define BMU_SW		(3L&lt;&lt;24)	</span><span class="cm">/* 2 Bits reserved for SW usage */</span><span class="cp"></span>
<span class="cp">#define	BMU_CHECK	0x00550000L	</span><span class="cm">/* To identify the control word */</span><span class="cp"></span>
<span class="cp">#define	BMU_BBC		0x0000FFFFL	</span><span class="cm">/* R/T Buffer Byte Count        */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * physical address offset + IO-Port base address</span>
<span class="cm"> */</span>
<span class="cp">#ifdef MEM_MAPPED_IO</span>
<span class="cp">#define	ADDR(a)		(char far *) smc-&gt;hw.iop+(a)</span>
<span class="cp">#define	ADDRS(smc,a)	(char far *) (smc)-&gt;hw.iop+(a)</span>
<span class="cp">#else</span>
<span class="cp">#define	ADDR(a)	(((a)&gt;&gt;7) ? (outp(smc-&gt;hw.iop+B0_RAP,(a)&gt;&gt;7), \</span>
<span class="cp">	(smc-&gt;hw.iop+(((a)&amp;0x7F)|((a)&gt;&gt;7 ? 0x80:0)))) : \</span>
<span class="cp">	(smc-&gt;hw.iop+(((a)&amp;0x7F)|((a)&gt;&gt;7 ? 0x80:0))))</span>
<span class="cp">#define	ADDRS(smc,a) (((a)&gt;&gt;7) ? (outp((smc)-&gt;hw.iop+B0_RAP,(a)&gt;&gt;7), \</span>
<span class="cp">	((smc)-&gt;hw.iop+(((a)&amp;0x7F)|((a)&gt;&gt;7 ? 0x80:0)))) : \</span>
<span class="cp">	((smc)-&gt;hw.iop+(((a)&amp;0x7F)|((a)&gt;&gt;7 ? 0x80:0))))</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Define a macro to access the configuration space</span>
<span class="cm"> */</span>
<span class="cp">#define PCI_C(a)	ADDR(B3_CFG_SPC + (a))	</span><span class="cm">/* PCI Config Space */</span><span class="cp"></span>

<span class="cp">#define EXT_R(a)	ADDR(B6_EXT_REG + (a))	</span><span class="cm">/* External Registers */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Define some values needed for the MAC address (PROM)</span>
<span class="cm"> */</span>
<span class="cp">#define	SA_MAC		(0)	</span><span class="cm">/* start addr. MAC_AD within the PROM */</span><span class="cp"></span>
<span class="cp">#define	PRA_OFF		(0)	</span><span class="cm">/* offset correction when 4th byte reading */</span><span class="cp"></span>

<span class="cp">#define	SKFDDI_PSZ	8	</span><span class="cm">/* address PROM size */</span><span class="cp"></span>

<span class="cp">#define	FM_A(a)	ADDR(FMA(a))	</span><span class="cm">/* FORMAC Plus physical addr */</span><span class="cp"></span>
<span class="cp">#define	P1_A(a)	ADDR(P1(a))	</span><span class="cm">/* PLC1 (r/w) */</span><span class="cp"></span>
<span class="cp">#define	P2_A(a)	ADDR(P2(a))	</span><span class="cm">/* PLC2 (r/w) (DAS) */</span><span class="cp"></span>
<span class="cp">#define PR_A(a)	ADDR(PRA(a))	</span><span class="cm">/* config. PROM (MAC address) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Macro to read the PROM</span>
<span class="cm"> */</span>
<span class="cp">#define	READ_PROM(a)	((u_char)inp(a))</span>

<span class="cp">#define	GET_PAGE(bank)	outpd(ADDR(B2_FAR),bank)</span>
<span class="cp">#define	VPP_ON()</span>
<span class="cp">#define	VPP_OFF()</span>

<span class="cm">/*</span>
<span class="cm"> * Note: Values of the Interrupt Source Register are defined above</span>
<span class="cm"> */</span>
<span class="cp">#define ISR_A		ADDR(B0_ISRC)</span>
<span class="cp">#define	GET_ISR()		inpd(ISR_A)</span>
<span class="cp">#define GET_ISR_SMP(iop)	inpd((iop)+B0_ISRC)</span>
<span class="cp">#define	CHECK_ISR()		(inpd(ISR_A) &amp; inpd(ADDR(B0_IMSK)))</span>
<span class="cp">#define CHECK_ISR_SMP(iop)	(inpd((iop)+B0_ISRC) &amp; inpd((iop)+B0_IMSK))</span>

<span class="cp">#define	BUS_CHECK()</span>

<span class="cm">/*</span>
<span class="cm"> * CLI_FBI:	Disable Board Interrupts</span>
<span class="cm"> * STI_FBI:	Enable Board Interrupts</span>
<span class="cm"> */</span>
<span class="cp">#ifndef UNIX</span>
<span class="cp">#define	CLI_FBI()	outpd(ADDR(B0_IMSK),0)</span>
<span class="cp">#else</span>
<span class="cp">#define	CLI_FBI(smc)	outpd(ADDRS((smc),B0_IMSK),0)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef UNIX</span>
<span class="cp">#define	STI_FBI()	outpd(ADDR(B0_IMSK),smc-&gt;hw.is_imask)</span>
<span class="cp">#else</span>
<span class="cp">#define	STI_FBI(smc)	outpd(ADDRS((smc),B0_IMSK),(smc)-&gt;hw.is_imask)</span>
<span class="cp">#endif</span>

<span class="cp">#define CLI_FBI_SMP(iop)	outpd((iop)+B0_IMSK,0)</span>
<span class="cp">#define	STI_FBI_SMP(smc,iop)	outpd((iop)+B0_IMSK,(smc)-&gt;hw.is_imask)</span>

<span class="cp">#endif	</span><span class="cm">/* PCI */</span><span class="cp"></span>
<span class="cm">/*--------------------------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * 12 bit transfer (dword) counter:</span>
<span class="cm"> *	(ISA:	2*trc = number of byte)</span>
<span class="cm"> *	(EISA:	4*trc = number of byte)</span>
<span class="cm"> *	(MCA:	4*trc = number of byte)</span>
<span class="cm"> */</span>
<span class="cp">#define	MAX_TRANS	(0x0fff)</span>

<span class="cm">/*</span>
<span class="cm"> * PC PIC</span>
<span class="cm"> */</span>
<span class="cp">#define	MST_8259 (0x20)</span>
<span class="cp">#define	SLV_8259 (0xA0)</span>

<span class="cp">#define TPS		(18)		</span><span class="cm">/* ticks per second */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * error timer defs</span>
<span class="cm"> */</span>
<span class="cp">#define	TN		(4)	</span><span class="cm">/* number of supported timer = TN+1 */</span><span class="cp"></span>
<span class="cp">#define	SNPPND_TIME	(5)	</span><span class="cm">/* buffer memory access over mem. data reg. */</span><span class="cp"></span>

<span class="cp">#define	MAC_AD	0x405a0000</span>

<span class="cp">#define MODR1	FM_A(FM_MDREG1)	</span><span class="cm">/* mode register 1 */</span><span class="cp"></span>
<span class="cp">#define MODR2	FM_A(FM_MDREG2)	</span><span class="cm">/* mode register 2 */</span><span class="cp"></span>

<span class="cp">#define CMDR1	FM_A(FM_CMDREG1)	</span><span class="cm">/* command register 1 */</span><span class="cp"></span>
<span class="cp">#define CMDR2	FM_A(FM_CMDREG2)	</span><span class="cm">/* command register 2 */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * function defines</span>
<span class="cm"> */</span>
<span class="cp">#define	CLEAR(io,mask)		outpw((io),inpw(io)&amp;(~(mask)))</span>
<span class="cp">#define	SET(io,mask)		outpw((io),inpw(io)|(mask))</span>
<span class="cp">#define	GET(io,mask)		(inpw(io)&amp;(mask))</span>
<span class="cp">#define	SETMASK(io,val,mask)	outpw((io),(inpw(io) &amp; ~(mask)) | (val))</span>

<span class="cm">/*</span>
<span class="cm"> * PHY Port A (PA) = PLC 1</span>
<span class="cm"> * With SuperNet 3 PHY-A and PHY S are identical.</span>
<span class="cm"> */</span>
<span class="cp">#define	PLC(np,reg)	(((np) == PA) ? P2_A(reg) : P1_A(reg))</span>

<span class="cm">/*</span>
<span class="cm"> * set memory address register for write and read</span>
<span class="cm"> */</span>
<span class="cp">#define	MARW(ma)	outpw(FM_A(FM_MARW),(unsigned int)(ma))</span>
<span class="cp">#define	MARR(ma)	outpw(FM_A(FM_MARR),(unsigned int)(ma))</span>

<span class="cm">/*</span>
<span class="cm"> * read/write from/to memory data register</span>
<span class="cm"> */</span>
<span class="cm">/* write double word */</span>
<span class="cp">#define	MDRW(dd)	outpw(FM_A(FM_MDRU),(unsigned int)((dd)&gt;&gt;16)) ;\</span>
<span class="cp">			outpw(FM_A(FM_MDRL),(unsigned int)(dd))</span>

<span class="cp">#ifndef WINNT</span>
<span class="cm">/* read double word */</span>
<span class="cp">#define	MDRR()		(((long)inpw(FM_A(FM_MDRU))&lt;&lt;16) + inpw(FM_A(FM_MDRL)))</span>

<span class="cm">/* read FORMAC+ 32-bit status register */</span>
<span class="cp">#define	GET_ST1()	(((long)inpw(FM_A(FM_ST1U))&lt;&lt;16) + inpw(FM_A(FM_ST1L)))</span>
<span class="cp">#define	GET_ST2()	(((long)inpw(FM_A(FM_ST2U))&lt;&lt;16) + inpw(FM_A(FM_ST2L)))</span>
<span class="cp">#ifdef	SUPERNET_3</span>
<span class="cp">#define	GET_ST3()	(((long)inpw(FM_A(FM_ST3U))&lt;&lt;16) + inpw(FM_A(FM_ST3L)))</span>
<span class="cp">#endif</span>
<span class="cp">#else</span>
<span class="cm">/* read double word */</span>
<span class="cp">#define MDRR()		inp2w((FM_A(FM_MDRU)),(FM_A(FM_MDRL)))</span>

<span class="cm">/* read FORMAC+ 32-bit status register */</span>
<span class="cp">#define GET_ST1()	inp2w((FM_A(FM_ST1U)),(FM_A(FM_ST1L)))</span>
<span class="cp">#define GET_ST2()	inp2w((FM_A(FM_ST2U)),(FM_A(FM_ST2L)))</span>
<span class="cp">#ifdef	SUPERNET_3</span>
<span class="cp">#define GET_ST3()	inp2w((FM_A(FM_ST3U)),(FM_A(FM_ST3L)))</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/* Special timer macro for 82c54 */</span>
				<span class="cm">/* timer access over data bus bit 8..15 */</span>
<span class="cp">#define	OUT_82c54_TIMER(port,val)	outpw(TI_A(port),(val)&lt;&lt;8)</span>
<span class="cp">#define	IN_82c54_TIMER(port)		((inpw(TI_A(port))&gt;&gt;8) &amp; 0xff)</span>


<span class="cp">#ifdef	DEBUG</span>
<span class="cp">#define	DB_MAC(mac,st) {if (debug_mac &amp; 0x1)\</span>
<span class="cp">				printf(&quot;M&quot;) ;\</span>
<span class="cp">			if (debug_mac &amp; 0x2)\</span>
<span class="cp">				printf(&quot;\tMAC %d status 0x%08lx\n&quot;,mac,st) ;\</span>
<span class="cp">			if (debug_mac &amp; 0x4)\</span>
<span class="cp">				dp_mac(mac,st) ;\</span>
<span class="cp">}</span>

<span class="cp">#define	DB_PLC(p,iev) {	if (debug_plc &amp; 0x1)\</span>
<span class="cp">				printf(&quot;P&quot;) ;\</span>
<span class="cp">			if (debug_plc &amp; 0x2)\</span>
<span class="cp">				printf(&quot;\tPLC %s Int 0x%04x\n&quot;, \</span>
<span class="cp">					(p == PA) ? &quot;A&quot; : &quot;B&quot;, iev) ;\</span>
<span class="cp">			if (debug_plc &amp; 0x4)\</span>
<span class="cp">				dp_plc(p,iev) ;\</span>
<span class="cp">}</span>

<span class="cp">#define	DB_TIMER() {	if (debug_timer &amp; 0x1)\</span>
<span class="cp">				printf(&quot;T&quot;) ;\</span>
<span class="cp">			if (debug_timer &amp; 0x2)\</span>
<span class="cp">				printf(&quot;\tTimer ISR\n&quot;) ;\</span>
<span class="cp">}</span>

<span class="cp">#else	</span><span class="cm">/* no DEBUG */</span><span class="cp"></span>

<span class="cp">#define	DB_MAC(mac,st)</span>
<span class="cp">#define	DB_PLC(p,iev)</span>
<span class="cp">#define	DB_TIMER()</span>

<span class="cp">#endif	</span><span class="cm">/* no DEBUG */</span><span class="cp"></span>

<span class="cp">#define	INC_PTR(sp,cp,ep)	if (++cp == ep) cp = sp</span>
<span class="cm">/*</span>
<span class="cm"> * timer defs</span>
<span class="cm"> */</span>
<span class="cp">#define	COUNT(t)	((t)&lt;&lt;6)	</span><span class="cm">/* counter */</span><span class="cp"></span>
<span class="cp">#define	RW_OP(o)	((o)&lt;&lt;4)	</span><span class="cm">/* read/write operation */</span><span class="cp"></span>
<span class="cp">#define	TMODE(m)	((m)&lt;&lt;1)	</span><span class="cm">/* timer mode */</span><span class="cp"></span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
