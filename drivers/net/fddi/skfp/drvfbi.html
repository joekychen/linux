<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › fddi › skfp › drvfbi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>drvfbi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm"> *</span>
<span class="cm"> *	(C)Copyright 1998,1999 SysKonnect,</span>
<span class="cm"> *	a business unit of Schneider &amp; Koch &amp; Co. Datensysteme GmbH.</span>
<span class="cm"> *</span>
<span class="cm"> *	See the file &quot;skfddi.c&quot; for further information.</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *	it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *	the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> *	(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	The information in this file is provided &quot;AS IS&quot; without warranty.</span>
<span class="cm"> *</span>
<span class="cm"> ******************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * FBI board dependent Driver for SMT and LLC</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;h/types.h&quot;</span>
<span class="cp">#include &quot;h/fddi.h&quot;</span>
<span class="cp">#include &quot;h/smc.h&quot;</span>
<span class="cp">#include &quot;h/supern_2.h&quot;</span>
<span class="cp">#include &quot;h/skfbiinc.h&quot;</span>
<span class="cp">#include &lt;linux/bitrev.h&gt;</span>

<span class="cp">#ifndef	lint</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ID_sccs</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;@(#)drvfbi.c	1.63 99/02/11 (C) SK &quot;</span> <span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * PCM active state</span>
<span class="cm"> */</span>
<span class="cp">#define PC8_ACTIVE	8</span>

<span class="cp">#define	LED_Y_ON	0x11	</span><span class="cm">/* Used for ring up/down indication */</span><span class="cp"></span>
<span class="cp">#define	LED_Y_OFF	0x10</span>


<span class="cp">#define MS2BCLK(x)	((x)*12500L)</span>

<span class="cm">/*</span>
<span class="cm"> * valid configuration values are:</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	xPOS_ID:xxxx</span>
<span class="cm"> *	|	\  /</span>
<span class="cm"> *	|	 \/</span>
<span class="cm"> *	|	  --------------------- the patched POS_ID of the Adapter</span>
<span class="cm"> *	|				xxxx = (Vendor ID low byte,</span>
<span class="cm"> *	|					Vendor ID high byte,</span>
<span class="cm"> *	|					Device ID low byte,</span>
<span class="cm"> *	|					Device ID high byte)</span>
<span class="cm"> *	+------------------------------ the patched oem_id must be</span>
<span class="cm"> *					&#39;S&#39; for SK or &#39;I&#39; for IBM</span>
<span class="cm"> *					this is a short id for the driver.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef MULT_OEM</span>
<span class="cp">#ifndef	OEM_CONCEPT</span>
<span class="k">const</span> <span class="n">u_char</span> <span class="n">oem_id</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;xPOS_ID:xxxx&quot;</span> <span class="p">;</span>
<span class="cp">#else	</span><span class="cm">/* OEM_CONCEPT */</span><span class="cp"></span>
<span class="k">const</span> <span class="n">u_char</span> <span class="n">oem_id</span><span class="p">[]</span> <span class="o">=</span> <span class="n">OEM_ID</span> <span class="p">;</span>
<span class="cp">#endif	</span><span class="cm">/* OEM_CONCEPT */</span><span class="cp"></span>
<span class="cp">#define	ID_BYTE0	8</span>
<span class="cp">#define	OEMID(smc,i)	oem_id[ID_BYTE0 + i]</span>
<span class="cp">#else	</span><span class="cm">/* MULT_OEM */</span><span class="cp"></span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">s_oem_ids</span> <span class="n">oem_ids</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#include &quot;oemids.h&quot;</span>
<span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="p">};</span>
<span class="cp">#define	OEMID(smc,i)	smc-&gt;hw.oem_id-&gt;oi_id[i]</span>
<span class="cp">#endif	</span><span class="cm">/* MULT_OEM */</span><span class="cp"></span>

<span class="cm">/* Prototypes of external functions */</span>
<span class="cp">#ifdef AIX</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">AIX_vpdReadByte</span><span class="p">()</span> <span class="p">;</span>
<span class="cp">#endif</span>


<span class="cm">/* Prototype of a local function. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">smt_stop_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * FDDI card reset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">card_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="p">;</span>
<span class="cp">#ifdef	PCI</span>
	<span class="n">u_char</span>	<span class="n">rev_id</span> <span class="p">;</span>
	<span class="n">u_short</span> <span class="n">word</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">smt_stop_watchdog</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>

<span class="cp">#ifdef	PCI</span>
	<span class="cm">/*</span>
<span class="cm">	 * make sure no transfer activity is pending</span>
<span class="cm">	 */</span>
	<span class="n">outpw</span><span class="p">(</span><span class="n">FM_A</span><span class="p">(</span><span class="n">FM_MDREG1</span><span class="p">),</span><span class="n">FM_MINIT</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">),</span> <span class="n">CTRL_HPI_SET</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">hwt_wait_time</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">hwt_quick_read</span><span class="p">(</span><span class="n">smc</span><span class="p">),</span><span class="n">MS2BCLK</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * now reset everything</span>
<span class="cm">	 */</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">),</span><span class="n">CTRL_RST_SET</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* reset for all chips */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">inp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">))</span> <span class="p">;</span>		<span class="cm">/* do dummy read */</span>
	<span class="n">SK_UNUSED</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">;</span>				<span class="cm">/* Make LINT happy. */</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">),</span> <span class="n">CTRL_RST_CLR</span><span class="p">)</span> <span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset all bits in the PCI STATUS register</span>
<span class="cm">	 */</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_TST_CTRL</span><span class="p">),</span> <span class="n">TST_CFG_WRITE_ON</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* enable for writes */</span>
	<span class="n">word</span> <span class="o">=</span> <span class="n">inpw</span><span class="p">(</span><span class="n">PCI_C</span><span class="p">(</span><span class="n">PCI_STATUS</span><span class="p">))</span> <span class="p">;</span>
	<span class="n">outpw</span><span class="p">(</span><span class="n">PCI_C</span><span class="p">(</span><span class="n">PCI_STATUS</span><span class="p">),</span> <span class="n">word</span> <span class="o">|</span> <span class="n">PCI_ERRBITS</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_TST_CTRL</span><span class="p">),</span> <span class="n">TST_CFG_WRITE_OFF</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* disable writes */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release the reset of all the State machines</span>
<span class="cm">	 * Release Master_Reset</span>
<span class="cm">	 * Release HPI_SM_Reset</span>
<span class="cm">	 */</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">),</span> <span class="n">CTRL_MRST_CLR</span><span class="o">|</span><span class="n">CTRL_HPI_CLR</span><span class="p">)</span> <span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * determine the adapter type</span>
<span class="cm">	 * Note: Do it here, because some drivers may call card_start() once</span>
<span class="cm">	 *	 at very first before any other initialization functions is</span>
<span class="cm">	 *	 executed.</span>
<span class="cm">	 */</span>
	<span class="n">rev_id</span> <span class="o">=</span> <span class="n">inp</span><span class="p">(</span><span class="n">PCI_C</span><span class="p">(</span><span class="n">PCI_REV_ID</span><span class="p">))</span> <span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rev_id</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="n">SK_ML_ID_1</span> <span class="o">||</span> <span class="p">(</span><span class="n">rev_id</span> <span class="o">&amp;</span> <span class="mh">0xf0</span><span class="p">)</span> <span class="o">==</span> <span class="n">SK_ML_ID_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_is_64bit</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_is_64bit</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Watermark initialization</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_is_64bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outpd</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B4_R1_F</span><span class="p">),</span> <span class="n">RX_WATERMARK</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">outpd</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B5_XA_F</span><span class="p">),</span> <span class="n">TX_WATERMARK</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">outpd</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B5_XS_F</span><span class="p">),</span> <span class="n">TX_WATERMARK</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">),</span><span class="n">CTRL_RST_CLR</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* clear the reset chips */</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_LED</span><span class="p">),</span><span class="n">LED_GA_OFF</span><span class="o">|</span><span class="n">LED_MY_ON</span><span class="o">|</span><span class="n">LED_GB_OFF</span><span class="p">)</span> <span class="p">;</span> <span class="cm">/* ye LED on */</span>

	<span class="cm">/* init the timer value for the watch dog 2,5 minutes */</span>
	<span class="n">outpd</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B2_WDOG_INI</span><span class="p">),</span><span class="mh">0x6FC23AC0</span><span class="p">)</span> <span class="p">;</span>

	<span class="cm">/* initialize the ISR mask */</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">is_imask</span> <span class="o">=</span> <span class="n">ISR_MASK</span> <span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_state</span> <span class="o">=</span> <span class="n">STOPPED</span> <span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">GET_PAGE</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>		<span class="cm">/* necessary for BOOT */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">card_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smt_stop_watchdog</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac_ring_is_up</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>		<span class="cm">/* ring down */</span>

<span class="cp">#ifdef	PCI</span>
	<span class="cm">/*</span>
<span class="cm">	 * make sure no transfer activity is pending</span>
<span class="cm">	 */</span>
	<span class="n">outpw</span><span class="p">(</span><span class="n">FM_A</span><span class="p">(</span><span class="n">FM_MDREG1</span><span class="p">),</span><span class="n">FM_MINIT</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">),</span> <span class="n">CTRL_HPI_SET</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">hwt_wait_time</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">hwt_quick_read</span><span class="p">(</span><span class="n">smc</span><span class="p">),</span><span class="n">MS2BCLK</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * now reset everything</span>
<span class="cm">	 */</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">),</span><span class="n">CTRL_RST_SET</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* reset for all chips */</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_CTRL</span><span class="p">),</span><span class="n">CTRL_RST_CLR</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* reset for all chips */</span>
	<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_LED</span><span class="p">),</span><span class="n">LED_GA_OFF</span><span class="o">|</span><span class="n">LED_MY_OFF</span><span class="o">|</span><span class="n">LED_GB_OFF</span><span class="p">)</span> <span class="p">;</span> <span class="cm">/* all LEDs off */</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_state</span> <span class="o">=</span> <span class="n">STOPPED</span> <span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cm">/*--------------------------- ISR handling ----------------------------------*/</span>

<span class="kt">void</span> <span class="nf">mac1_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_short</span> <span class="n">stu</span><span class="p">,</span> <span class="n">u_short</span> <span class="n">stl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">restart_tx</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="nl">again:</span>

	<span class="cm">/*</span>
<span class="cm">	 * parity error: note encoding error is not possible in tag mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FM_SPCEPDS</span>  <span class="o">|</span>	<span class="cm">/* parity err. syn.q.*/</span>
		   <span class="n">FM_SPCEPDA0</span> <span class="o">|</span>	<span class="cm">/* parity err. a.q.0 */</span>
		   <span class="n">FM_SPCEPDA1</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* parity err. a.q.1 */</span>
		<span class="n">SMT_PANIC</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">SMT_E0134</span><span class="p">,</span> <span class="n">SMT_E0134_MSG</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * buffer underrun: can only occur if a tx threshold is specified</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FM_STBURS</span>  <span class="o">|</span>		<span class="cm">/* tx buffer underrun syn.q.*/</span>
		   <span class="n">FM_STBURA0</span> <span class="o">|</span>		<span class="cm">/* tx buffer underrun a.q.0 */</span>
		   <span class="n">FM_STBURA1</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* tx buffer underrun a.q.2 */</span>
		<span class="n">SMT_PANIC</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">SMT_E0133</span><span class="p">,</span> <span class="n">SMT_E0133_MSG</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">stu</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FM_SXMTABT</span> <span class="o">|</span>		<span class="cm">/* transmit abort */</span>
		     <span class="n">FM_STXABRS</span> <span class="o">|</span>		<span class="cm">/* syn. tx abort */</span>
		     <span class="n">FM_STXABRA0</span><span class="p">))</span> <span class="o">||</span>		<span class="cm">/* asyn. tx abort */</span>
	     <span class="p">(</span><span class="n">stl</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FM_SQLCKS</span> <span class="o">|</span>		<span class="cm">/* lock for syn. q. */</span>
		     <span class="n">FM_SQLCKA0</span><span class="p">))</span> <span class="p">)</span> <span class="p">{</span>		<span class="cm">/* lock for asyn. q. */</span>
		<span class="n">formac_tx_restart</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* init tx */</span>
		<span class="n">restart_tx</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>
		<span class="n">stu</span> <span class="o">=</span> <span class="n">inpw</span><span class="p">(</span><span class="n">FM_A</span><span class="p">(</span><span class="n">FM_ST1U</span><span class="p">))</span> <span class="p">;</span>
		<span class="n">stl</span> <span class="o">=</span> <span class="n">inpw</span><span class="p">(</span><span class="n">FM_A</span><span class="p">(</span><span class="n">FM_ST1L</span><span class="p">))</span> <span class="p">;</span>
		<span class="n">stu</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="n">FM_STECFRMA0</span> <span class="o">|</span> <span class="n">FM_STEFRMA0</span> <span class="o">|</span> <span class="n">FM_STEFRMS</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stu</span> <span class="o">||</span> <span class="n">stl</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stu</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FM_STEFRMA0</span> <span class="o">|</span>	<span class="cm">/* end of asyn tx */</span>
		    <span class="n">FM_STEFRMS</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* end of sync tx */</span>
		<span class="n">restart_tx</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">restart_tx</span><span class="p">)</span>
		<span class="n">llc_restart_tx</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * interrupt source= plc1</span>
<span class="cm"> * this function is called in nwfbisr.asm</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">plc1_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_short</span>	<span class="n">st</span> <span class="o">=</span> <span class="n">inpw</span><span class="p">(</span><span class="n">PLC</span><span class="p">(</span><span class="n">PB</span><span class="p">,</span><span class="n">PL_INTR_EVENT</span><span class="p">))</span> <span class="p">;</span>

	<span class="n">plc_irq</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">PB</span><span class="p">,</span><span class="n">st</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * interrupt source= plc2</span>
<span class="cm"> * this function is called in nwfbisr.asm</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">plc2_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_short</span>	<span class="n">st</span> <span class="o">=</span> <span class="n">inpw</span><span class="p">(</span><span class="n">PLC</span><span class="p">(</span><span class="n">PA</span><span class="p">,</span><span class="n">PL_INTR_EVENT</span><span class="p">))</span> <span class="p">;</span>

	<span class="n">plc_irq</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">PA</span><span class="p">,</span><span class="n">st</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * interrupt source= timer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">timer_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hwt_restart</span><span class="p">(</span><span class="n">smc</span><span class="p">);</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">t_stop</span> <span class="o">=</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">t_start</span><span class="p">;</span>
	<span class="n">smt_timer_done</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return S-port (PA or PB)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">pcm_get_s_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SK_UNUSED</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>
	<span class="k">return</span> <span class="n">PS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Station Label = &quot;FDDI-XYZ&quot; where</span>
<span class="cm"> *</span>
<span class="cm"> *	X = connector type</span>
<span class="cm"> *	Y = PMD type</span>
<span class="cm"> *	Z = port type</span>
<span class="cm"> */</span>
<span class="cp">#define STATION_LABEL_CONNECTOR_OFFSET	5</span>
<span class="cp">#define STATION_LABEL_PMD_OFFSET	6</span>
<span class="cp">#define STATION_LABEL_PORT_OFFSET	7</span>

<span class="kt">void</span> <span class="nf">read_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">ConnectorType</span> <span class="p">;</span>
	<span class="kt">char</span> <span class="n">PmdType</span> <span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span> <span class="p">;</span>

<span class="cp">#ifdef	PCI</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* read mac address from board */</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_phys_addr</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">bitrev8</span><span class="p">(</span><span class="n">inp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B2_MAC_0</span><span class="o">+</span><span class="n">i</span><span class="p">)));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">ConnectorType</span> <span class="o">=</span> <span class="n">inp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B2_CONN_TYP</span><span class="p">))</span> <span class="p">;</span>
	<span class="n">PmdType</span> <span class="o">=</span> <span class="n">inp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B2_PMD_TYP</span><span class="p">))</span> <span class="p">;</span>

	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">[</span><span class="n">PA</span><span class="p">].</span><span class="n">pmd_type</span><span class="p">[</span><span class="n">PMD_SK_CONN</span><span class="p">]</span> <span class="o">=</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">[</span><span class="n">PB</span><span class="p">].</span><span class="n">pmd_type</span><span class="p">[</span><span class="n">PMD_SK_CONN</span><span class="p">]</span> <span class="o">=</span> <span class="n">ConnectorType</span> <span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">[</span><span class="n">PA</span><span class="p">].</span><span class="n">pmd_type</span><span class="p">[</span><span class="n">PMD_SK_PMD</span> <span class="p">]</span> <span class="o">=</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">[</span><span class="n">PB</span><span class="p">].</span><span class="n">pmd_type</span><span class="p">[</span><span class="n">PMD_SK_PMD</span> <span class="p">]</span> <span class="o">=</span> <span class="n">PmdType</span> <span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_canon_addr</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
			<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_home_addr</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitrev8</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_home_addr</span> <span class="o">=</span> <span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_phys_addr</span> <span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_canon_addr</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">bitrev8</span><span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_phys_addr</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * FDDI card soft reset</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">init_board</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">card_start</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">read_address</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">mac_addr</span><span class="p">)</span> <span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_DAS</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">DAS_AVAIL</span><span class="p">))</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">sas</span> <span class="o">=</span> <span class="n">SMT_SAS</span> <span class="p">;</span>	<span class="cm">/* Single att. station */</span>
	<span class="k">else</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">sas</span> <span class="o">=</span> <span class="n">SMT_DAS</span> <span class="p">;</span>	<span class="cm">/* Dual att. station */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_DAS</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">DAS_BYP_ST</span><span class="p">))</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">mib</span><span class="p">.</span><span class="n">fddiSMTBypassPresent</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
		<span class="cm">/* without opt. bypass */</span>
	<span class="k">else</span>
		<span class="n">smc</span><span class="o">-&gt;</span><span class="n">mib</span><span class="p">.</span><span class="n">fddiSMTBypassPresent</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>
		<span class="cm">/* with opt. bypass */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * insert or deinsert optical bypass (called by ECM)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sm_pm_bypass_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DB_ECMN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;ECM : sm_pm_bypass_req(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">BP_INSERT</span><span class="p">)</span> <span class="o">?</span>
					<span class="s">&quot;BP_INSERT&quot;</span> <span class="o">:</span> <span class="s">&quot;BP_DEINSERT&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">sas</span> <span class="o">!=</span> <span class="n">SMT_DAS</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">;</span>

<span class="cp">#ifdef	PCI</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BP_INSERT</span> :
		<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_DAS</span><span class="p">),</span><span class="n">DAS_BYP_INS</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* insert station */</span>
		<span class="k">break</span> <span class="p">;</span>
	<span class="k">case</span> <span class="n">BP_DEINSERT</span> :
		<span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_DAS</span><span class="p">),</span><span class="n">DAS_BYP_RMV</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* bypass station */</span>
		<span class="k">break</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * check if bypass connected</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sm_pm_bypass_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">inp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_DAS</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">DAS_BYP_ST</span><span class="p">)</span> <span class="o">?</span> <span class="n">TRUE</span> <span class="o">:</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">plc_clear_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SK_UNUSED</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">;</span>

	<span class="n">SK_UNUSED</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * led_indication called by rmt_indication() and</span>
<span class="cm"> * pcm_state_change()</span>
<span class="cm"> *</span>
<span class="cm"> * Input:</span>
<span class="cm"> *	smc:	SMT context</span>
<span class="cm"> *	led_event:</span>
<span class="cm"> *	0	Only switch green LEDs according to their respective PCM state</span>
<span class="cm"> *	LED_Y_OFF	just switch yellow LED off</span>
<span class="cm"> *	LED_Y_ON	just switch yello LED on</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">led_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">led_event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* use smc-&gt;hw.mac_ring_is_up == TRUE </span>
<span class="cm">	 * as indication for Ring Operational</span>
<span class="cm">	 */</span>
	<span class="n">u_short</span>			<span class="n">led_state</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">s_phy</span>		<span class="o">*</span><span class="n">phy</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">fddi_mib_p</span>	<span class="o">*</span><span class="n">mib_a</span> <span class="p">;</span>
	<span class="k">struct</span> <span class="n">fddi_mib_p</span>	<span class="o">*</span><span class="n">mib_b</span> <span class="p">;</span>

	<span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">[</span><span class="n">PA</span><span class="p">]</span> <span class="p">;</span>
	<span class="n">mib_a</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">mib</span> <span class="p">;</span>
	<span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">[</span><span class="n">PB</span><span class="p">]</span> <span class="p">;</span>
	<span class="n">mib_b</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">mib</span> <span class="p">;</span>

<span class="cp">#ifdef	PCI</span>
        <span class="n">led_state</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	
	<span class="cm">/* Ring up = yellow led OFF*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">led_event</span> <span class="o">==</span> <span class="n">LED_Y_ON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">led_state</span> <span class="o">|=</span> <span class="n">LED_MY_ON</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">led_event</span> <span class="o">==</span> <span class="n">LED_Y_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">led_state</span> <span class="o">|=</span> <span class="n">LED_MY_OFF</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>	<span class="cm">/* PCM state changed */</span>
		<span class="cm">/* Link at Port A/S = green led A ON */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mib_a</span><span class="o">-&gt;</span><span class="n">fddiPORTPCMState</span> <span class="o">==</span> <span class="n">PC8_ACTIVE</span><span class="p">)</span> <span class="p">{</span>	
			<span class="n">led_state</span> <span class="o">|=</span> <span class="n">LED_GA_ON</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">led_state</span> <span class="o">|=</span> <span class="n">LED_GA_OFF</span> <span class="p">;</span>
		<span class="p">}</span>
		
		<span class="cm">/* Link at Port B = green led B ON */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mib_b</span><span class="o">-&gt;</span><span class="n">fddiPORTPCMState</span> <span class="o">==</span> <span class="n">PC8_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">led_state</span> <span class="o">|=</span> <span class="n">LED_GB_ON</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">led_state</span> <span class="o">|=</span> <span class="n">LED_GB_OFF</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

        <span class="n">outp</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B0_LED</span><span class="p">),</span> <span class="n">led_state</span><span class="p">)</span> <span class="p">;</span>
<span class="cp">#endif	</span><span class="cm">/* PCI */</span><span class="cp"></span>

<span class="p">}</span>


<span class="kt">void</span> <span class="nf">pcm_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * the current implementation of pcm_state_change() in the driver</span>
<span class="cm">	 * parts must be renamed to drv_pcm_state_change() which will be called</span>
<span class="cm">	 * now after led_indication.</span>
<span class="cm">	 */</span>
	<span class="n">DRV_PCM_STATE_CHANGE</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">plc</span><span class="p">,</span><span class="n">p_state</span><span class="p">)</span> <span class="p">;</span>
	
	<span class="n">led_indication</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">rmt_indication</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Call a driver special function if defined */</span>
	<span class="n">DRV_RMT_INDICATION</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="p">;</span>

        <span class="n">led_indication</span><span class="p">(</span><span class="n">smc</span><span class="p">,</span> <span class="n">i</span> <span class="o">?</span> <span class="n">LED_Y_OFF</span> <span class="o">:</span> <span class="n">LED_Y_ON</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * llc_recover_tx called by init_tx (fplus.c)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_recover_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef	LOAD_GEN</span>
	<span class="k">extern</span>	<span class="kt">int</span> <span class="n">load_gen_flag</span> <span class="p">;</span>

	<span class="n">load_gen_flag</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef	SYNC</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">n_a_send</span><span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">SK_UNUSED</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#ifdef MULT_OEM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_equal_num</span><span class="p">(</span><span class="kt">char</span> <span class="n">comp1</span><span class="p">[],</span> <span class="kt">char</span> <span class="n">comp2</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">comp1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">comp2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>	<span class="cm">/* is_equal_num */</span>


<span class="cm">/*</span>
<span class="cm"> * set the OEM ID defaults, and test the contents of the OEM data base</span>
<span class="cm"> * The default OEM is the first ACTIVE entry in the OEM data base </span>
<span class="cm"> *</span>
<span class="cm"> * returns:	0	success</span>
<span class="cm"> *		1	error in data base</span>
<span class="cm"> *		2	data base empty</span>
<span class="cm"> *		3	no active entry	</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">set_oi_id_def</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sel_id</span> <span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="p">;</span>
	<span class="kt">int</span> <span class="n">act_entries</span> <span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">sel_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">;</span>
	<span class="n">act_entries</span> <span class="o">=</span> <span class="n">FALSE</span> <span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">oem_id</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">oem_min_status</span> <span class="o">=</span> <span class="n">OI_STAT_ACTIVE</span> <span class="p">;</span>
	
	<span class="cm">/* check OEM data base */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">oem_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">oi_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">oem_ids</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">oi_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">OI_STAT_ACTIVE</span>:
			<span class="n">act_entries</span> <span class="o">=</span> <span class="n">TRUE</span> <span class="p">;</span>	<span class="cm">/* we have active IDs */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sel_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">sel_id</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span>	<span class="cm">/* save the first active ID */</span>
		<span class="k">case</span> <span class="n">OI_STAT_VALID</span>:
		<span class="k">case</span> <span class="n">OI_STAT_PRESENT</span>:
			<span class="n">i</span><span class="o">++</span> <span class="p">;</span>
			<span class="k">break</span> <span class="p">;</span>			<span class="cm">/* entry ok */</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* invalid oi_status */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">act_entries</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="cm">/* ok, we have a valid OEM data base with an active entry */</span>
	<span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">oem_id</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">s_oem_ids</span> <span class="o">*</span><span class="p">)</span>  <span class="o">&amp;</span><span class="n">oem_ids</span><span class="p">[</span><span class="n">sel_id</span><span class="p">]</span> <span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* MULT_OEM */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">driver_get_bia</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fddi_addr</span> <span class="o">*</span><span class="n">bia_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">bia_addr</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitrev8</span><span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fddi_phys_addr</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">smt_start_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SK_UNUSED</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* Make LINT happy. */</span>

<span class="cp">#ifndef	DEBUG</span>

<span class="cp">#ifdef	PCI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">wdog_used</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outpw</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B2_WDOG_CRTL</span><span class="p">),</span><span class="n">TIM_START</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* Start timer. */</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif	</span><span class="cm">/* DEBUG */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">smt_stop_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SK_UNUSED</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* Make LINT happy. */</span>
<span class="cp">#ifndef	DEBUG</span>

<span class="cp">#ifdef	PCI</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smc</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">wdog_used</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">outpw</span><span class="p">(</span><span class="n">ADDR</span><span class="p">(</span><span class="n">B2_WDOG_CRTL</span><span class="p">),</span><span class="n">TIM_STOP</span><span class="p">)</span> <span class="p">;</span>	<span class="cm">/* Stop timer. */</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif	</span><span class="cm">/* DEBUG */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cp">#ifdef	PCI</span>

<span class="kt">void</span> <span class="nf">mac_do_pci_fix</span><span class="p">(</span><span class="k">struct</span> <span class="n">s_smc</span> <span class="o">*</span><span class="n">smc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SK_UNUSED</span><span class="p">(</span><span class="n">smc</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* PCI */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
