<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › macvtap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>macvtap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_macvlan.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/if_tun.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>

<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;linux/virtio_net.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * A macvtap queue is the central object of this driver, it connects</span>
<span class="cm"> * an open character device to a macvlan interface. There can be</span>
<span class="cm"> * multiple queues on one interface, which map back to queues</span>
<span class="cm"> * implemented in hardware on the underlying device.</span>
<span class="cm"> *</span>
<span class="cm"> * macvtap_proto is used to allocate queues through the sock allocation</span>
<span class="cm"> * mechanism.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: multiqueue support is currently not implemented, even though</span>
<span class="cm"> * macvtap is basically prepared for that. We will need to add this</span>
<span class="cm"> * here as well as in virtio-net and qemu to get line rate on 10gbit</span>
<span class="cm"> * adapters from a guest.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="n">wq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vnet_hdr_sz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">macvtap_proto</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;macvtap&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">macvtap_queue</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Variables for dealing with macvtaps device numbers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">dev_t</span> <span class="n">macvtap_major</span><span class="p">;</span>
<span class="cp">#define MACVTAP_NUM_DEVS (1U &lt;&lt; MINORBITS)</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">minor_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_IDR</span><span class="p">(</span><span class="n">minor_idr</span><span class="p">);</span>

<span class="cp">#define GOODCOPY_LEN 128</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">macvtap_class</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">cdev</span> <span class="n">macvtap_cdev</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">macvtap_socket_ops</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * RCU usage:</span>
<span class="cm"> * The macvtap_queue and the macvlan_dev are loosely coupled, the</span>
<span class="cm"> * pointers from one to the other can only be read while rcu_read_lock</span>
<span class="cm"> * or macvtap_lock is held.</span>
<span class="cm"> *</span>
<span class="cm"> * Both the file and the macvlan_dev hold a reference on the macvtap_queue</span>
<span class="cm"> * through sock_hold(&amp;q-&gt;sk). When the macvlan_dev goes away first,</span>
<span class="cm"> * q-&gt;vlan becomes inaccessible. When the files gets closed,</span>
<span class="cm"> * macvtap_get_queue() fails.</span>
<span class="cm"> *</span>
<span class="cm"> * There may still be references to the struct sock inside of the</span>
<span class="cm"> * queue from outbound SKBs, but these never reference back to the</span>
<span class="cm"> * file or the dev. The data structure is freed through __sk_free</span>
<span class="cm"> * when both our references and any pending SKBs are gone.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">macvtap_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * get_slot: return a [unused/occupied] slot in vlan-&gt;taps[]:</span>
<span class="cm"> *	- if &#39;q&#39; is NULL, return the first empty slot;</span>
<span class="cm"> *	- otherwise, return the slot this pointer occupies.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_MACVTAP_QUEUES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Should never happen */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_set_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">numvtaps</span> <span class="o">==</span> <span class="n">MAX_MACVTAP_QUEUES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">get_slot</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">,</span> <span class="n">vlan</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">q</span><span class="p">);</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

	<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">numvtaps</span><span class="o">++</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The file owning the queue got closed, give up both</span>
<span class="cm"> * the reference that the files holds as well as the</span>
<span class="cm"> * one from the macvlan_dev if that still exists.</span>
<span class="cm"> *</span>
<span class="cm"> * Using the spinlock makes sure that we don&#39;t get</span>
<span class="cm"> * to the queue again after destroying it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">macvtap_put_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_lock</span><span class="p">);</span>
	<span class="n">vlan</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">,</span>
					 <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_lock</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">get_slot</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>

		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
		<span class="o">--</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">numvtaps</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_lock</span><span class="p">);</span>

	<span class="n">synchronize_rcu</span><span class="p">();</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Select a queue based on the rxq of the device on which this packet</span>
<span class="cm"> * arrived. If the incoming device is not mq, calculate a flow hash</span>
<span class="cm"> * to select a queue. If all fails, find the first available queue.</span>
<span class="cm"> * Cache vlan-&gt;numvtaps since it can become zero during the execution</span>
<span class="cm"> * of this function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="nf">macvtap_get_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">tap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numvtaps</span> <span class="o">=</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">numvtaps</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">rxq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">numvtaps</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Check if we can use flow to select a queue */</span>
	<span class="n">rxq</span> <span class="o">=</span> <span class="n">skb_get_rxhash</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tap</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">rxq</span> <span class="o">%</span> <span class="n">numvtaps</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tap</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb_rx_queue_recorded</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rxq</span> <span class="o">=</span> <span class="n">skb_get_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rxq</span> <span class="o">&gt;=</span> <span class="n">numvtaps</span><span class="p">))</span>
			<span class="n">rxq</span> <span class="o">-=</span> <span class="n">numvtaps</span><span class="p">;</span>

		<span class="n">tap</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">rxq</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tap</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Everything failed - find first available queue */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rxq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rxq</span> <span class="o">&lt;</span> <span class="n">MAX_MACVTAP_QUEUES</span><span class="p">;</span> <span class="n">rxq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tap</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">rxq</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tap</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">tap</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The net_device is going away, give up the reference</span>
<span class="cm"> * that it holds on all queues and safely set the pointer</span>
<span class="cm"> * from the queues to NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">macvtap_del_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">qlist</span><span class="p">[</span><span class="n">MAX_MACVTAP_QUEUES</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* macvtap_put_queue can free some slots, so go through all slots */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_MACVTAP_QUEUES</span> <span class="o">&amp;&amp;</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">numvtaps</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					      <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_lock</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">qlist</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
			<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">numvtaps</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">numvtaps</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* guarantee that any future macvtap_set_queue will fail */</span>
	<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">numvtaps</span> <span class="o">=</span> <span class="n">MAX_MACVTAP_QUEUES</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_lock</span><span class="p">);</span>

	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="o">--</span><span class="n">j</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qlist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Forward happens for data that gets sent from one macvlan</span>
<span class="cm"> * endpoint to another one in bridge mode. We just take</span>
<span class="cm"> * the skb and put it into the receive queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">macvtap_get_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">.</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">.</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">),</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span> <span class="o">|</span> <span class="n">POLLRDBAND</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

<span class="nl">drop:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Receive is for data from the external interface (lowerdev),</span>
<span class="cm"> * in case of macvtap, we can treat that the same way as</span>
<span class="cm"> * forward, which macvlan cannot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">macvtap_forward</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_get_minor</span><span class="p">(</span><span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_idr</span><span class="p">,</span> <span class="n">vlan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">MACVTAP_NUM_DEVS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;too many macvtap devices</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_idr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">macvtap_free_minor</span><span class="p">(</span><span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_idr</span><span class="p">,</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_get_by_macvtap_minor</span><span class="p">(</span><span class="kt">int</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_lock</span><span class="p">);</span>
	<span class="n">vlan</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_idr</span><span class="p">,</span> <span class="n">minor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minor_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_newlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">src_net</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span>
			   <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t put anything that may fail after macvlan_common_newlink</span>
<span class="cm">	 * because we can&#39;t undo what it does.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">macvlan_common_newlink</span><span class="p">(</span><span class="n">src_net</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
				      <span class="n">macvtap_receive</span><span class="p">,</span> <span class="n">macvtap_forward</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">macvtap_dellink</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">macvtap_del_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">macvlan_dellink</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">macvtap_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">macvlan_common_setup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="n">TUN_READQ_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_ops</span> <span class="n">macvtap_link_ops</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kind</span>		<span class="o">=</span> <span class="s">&quot;macvtap&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">macvtap_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">newlink</span>	<span class="o">=</span> <span class="n">macvtap_newlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dellink</span>	<span class="o">=</span> <span class="n">macvtap_dellink</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">macvtap_sock_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqueue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">wqueue</span> <span class="o">=</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wqueue</span> <span class="o">&amp;&amp;</span> <span class="n">waitqueue_active</span><span class="p">(</span><span class="n">wqueue</span><span class="p">))</span>
		<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="n">wqueue</span><span class="p">,</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">macvtap_sock_destruct</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">net_ns</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_macvtap_minor</span><span class="p">(</span><span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="p">)</span><span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">macvtap_proto</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">.</span><span class="n">wq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SOCK_RAW</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">macvtap_socket_ops</span><span class="p">;</span>
	<span class="n">sock_init_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">.</span><span class="n">sk_write_space</span> <span class="o">=</span> <span class="n">macvtap_sock_write_space</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">.</span><span class="n">sk_destruct</span> <span class="o">=</span> <span class="n">macvtap_sock_destruct</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IFF_VNET_HDR</span> <span class="o">|</span> <span class="n">IFF_NO_PI</span> <span class="o">|</span> <span class="n">IFF_TAP</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">vnet_hdr_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_net_hdr</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * so far only KVM virtio_net uses macvtap, enable zero copy between</span>
<span class="cm">	 * guest kernel and host kernel when lower device supports zerocopy</span>
<span class="cm">	 *</span>
<span class="cm">	 * The macvlan supports zerocopy iff the lower device supports zero</span>
<span class="cm">	 * copy so we don&#39;t have to look at the lower device directly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">))</span>
		<span class="n">sock_set_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZEROCOPY</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">macvtap_set_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">macvtap_put_queue</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">macvtap_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">POLLERR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">.</span><span class="n">sk_receive_queue</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_writeable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">sock_writeable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">macvtap_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">prepad</span><span class="p">,</span>
						<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">linear</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Under a page?  Don&#39;t bother with paged skb. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prepad</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span> <span class="o">||</span> <span class="o">!</span><span class="n">linear</span><span class="p">)</span>
		<span class="n">linear</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_pskb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">prepad</span> <span class="o">+</span> <span class="n">linear</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">linear</span><span class="p">,</span> <span class="n">noblock</span><span class="p">,</span>
				   <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">prepad</span><span class="p">);</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">linear</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">linear</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">linear</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* set skb frags from iovec, this can move to core network code for reuse */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">zerocopy_sg_from_iovec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">offset1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Skip over from offset */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">-=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="o">++</span><span class="n">from</span><span class="p">;</span>
		<span class="o">--</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* copy up to skb headlen */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">,</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
				   <span class="n">size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">from</span><span class="p">;</span>
			<span class="o">--</span><span class="n">count</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">copy</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">offset1</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">offset1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">num_pages</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">truesize</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">++</span><span class="n">from</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">((</span><span class="n">base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="n">num_pages</span> <span class="o">=</span> <span class="n">get_user_pages_fast</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">truesize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">truesize</span><span class="p">;</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="n">base</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">off</span><span class="p">);</span>
			<span class="n">__skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">off</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* increase sk_wmem_alloc */</span>
			<span class="n">base</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">++</span><span class="n">from</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * macvtap_skb_from_vnet_hdr and macvtap_skb_to_vnet_hdr should</span>
<span class="cm"> * be shared with the tun/tap driver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_skb_from_vnet_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">virtio_net_hdr</span> <span class="o">*</span><span class="n">vnet_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">gso_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">!=</span> <span class="n">VIRTIO_NET_HDR_GSO_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VIRTIO_NET_HDR_GSO_ECN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">VIRTIO_NET_HDR_GSO_TCPV4</span>:
			<span class="n">gso_type</span> <span class="o">=</span> <span class="n">SKB_GSO_TCPV4</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VIRTIO_NET_HDR_GSO_TCPV6</span>:
			<span class="n">gso_type</span> <span class="o">=</span> <span class="n">SKB_GSO_TCPV6</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">VIRTIO_NET_HDR_GSO_UDP</span>:
			<span class="n">gso_type</span> <span class="o">=</span> <span class="n">SKB_GSO_UDP</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">&amp;</span> <span class="n">VIRTIO_NET_HDR_GSO_ECN</span><span class="p">)</span>
			<span class="n">gso_type</span> <span class="o">|=</span> <span class="n">SKB_GSO_TCP_ECN</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VIRTIO_NET_HDR_F_NEEDS_CSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_partial_csum_set</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">csum_start</span><span class="p">,</span>
					  <span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">!=</span> <span class="n">VIRTIO_NET_HDR_GSO_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">gso_type</span><span class="p">;</span>

		<span class="cm">/* Header must be checked, and gso_segs computed. */</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">|=</span> <span class="n">SKB_GSO_DODGY</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_skb_to_vnet_hdr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">virtio_net_hdr</span> <span class="o">*</span><span class="n">vnet_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">vnet_hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vnet_hdr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">sinfo</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* This is a hint as to how much should be linear. */</span>
		<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">&amp;</span> <span class="n">SKB_GSO_TCPV4</span><span class="p">)</span>
			<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">VIRTIO_NET_HDR_GSO_TCPV4</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">&amp;</span> <span class="n">SKB_GSO_TCPV6</span><span class="p">)</span>
			<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">VIRTIO_NET_HDR_GSO_TCPV6</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">&amp;</span> <span class="n">SKB_GSO_UDP</span><span class="p">)</span>
			<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">VIRTIO_NET_HDR_GSO_UDP</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">&amp;</span> <span class="n">SKB_GSO_TCP_ECN</span><span class="p">)</span>
			<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">|=</span> <span class="n">VIRTIO_NET_HDR_GSO_ECN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">VIRTIO_NET_HDR_GSO_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VIRTIO_NET_HDR_F_NEEDS_CSUM</span><span class="p">;</span>
		<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">csum_offset</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vnet_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VIRTIO_NET_HDR_F_DATA_VALID</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* else everything is zero */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Get packet from user space buffer */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">macvtap_get_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_len</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">noblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">total_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtio_net_hdr</span> <span class="n">vnet_hdr</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">vnet_hdr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copylen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">zerocopy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_VNET_HDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vnet_hdr_len</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">vnet_hdr_sz</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">vnet_hdr_len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">vnet_hdr_len</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovecend</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vnet_hdr</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="n">vnet_hdr</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vnet_hdr</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">VIRTIO_NET_HDR_F_NEEDS_CSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">vnet_hdr</span><span class="p">.</span><span class="n">csum_start</span> <span class="o">+</span> <span class="n">vnet_hdr</span><span class="p">.</span><span class="n">csum_offset</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span>
							<span class="n">vnet_hdr</span><span class="p">.</span><span class="n">hdr_len</span><span class="p">)</span>
			<span class="n">vnet_hdr</span><span class="p">.</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="n">vnet_hdr</span><span class="p">.</span><span class="n">csum_start</span> <span class="o">+</span>
						<span class="n">vnet_hdr</span><span class="p">.</span><span class="n">csum_offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vnet_hdr</span><span class="p">.</span><span class="n">hdr_len</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">ETH_HLEN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">UIO_MAXIOV</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_control</span> <span class="o">&amp;&amp;</span> <span class="n">sock_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZEROCOPY</span><span class="p">))</span>
		<span class="n">zerocopy</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zerocopy</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Userspace may produce vectors with count greater than</span>
<span class="cm">		 * MAX_SKB_FRAGS, so we need to linearize parts of the skb</span>
<span class="cm">		 * to let the rest of data to be fit in the frags.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">copylen</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copylen</span> <span class="o">&lt;</span> <span class="n">vnet_hdr_len</span><span class="p">)</span>
				<span class="n">copylen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">copylen</span> <span class="o">-=</span> <span class="n">vnet_hdr_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* There are 256 bytes to be copied in skb, so there is enough</span>
<span class="cm">		 * room for skb expand head in case it is used.</span>
<span class="cm">		 * The rest buffer is mapped from userspace.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copylen</span> <span class="o">&lt;</span> <span class="n">vnet_hdr</span><span class="p">.</span><span class="n">hdr_len</span><span class="p">)</span>
			<span class="n">copylen</span> <span class="o">=</span> <span class="n">vnet_hdr</span><span class="p">.</span><span class="n">hdr_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copylen</span><span class="p">)</span>
			<span class="n">copylen</span> <span class="o">=</span> <span class="n">GOODCOPY_LEN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">copylen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">macvtap_alloc_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">NET_IP_ALIGN</span><span class="p">,</span> <span class="n">copylen</span><span class="p">,</span>
				<span class="n">vnet_hdr</span><span class="p">.</span><span class="n">hdr_len</span><span class="p">,</span> <span class="n">noblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zerocopy</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">zerocopy_sg_from_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">vnet_hdr_len</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_datagram_from_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">vnet_hdr_len</span><span class="p">,</span>
						   <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_kfree</span><span class="p">;</span>

	<span class="n">skb_set_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">h_proto</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vnet_hdr_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">macvtap_skb_from_vnet_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnet_hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_kfree</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
	<span class="n">vlan</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">);</span>
	<span class="cm">/* copy skb_ubuf_info for callback when skb has no error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">zerocopy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">destructor_arg</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="p">)</span>
		<span class="n">macvlan_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">total_len</span><span class="p">;</span>

<span class="nl">err_kfree:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
	<span class="n">vlan</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="p">)</span>
		<span class="n">vlan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">macvtap_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">macvtap_get_user</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">count</span><span class="p">),</span> <span class="n">count</span><span class="p">,</span>
				  <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Put packet to the user space buffer */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">macvtap_put_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vnet_hdr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vlan_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copied</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_VNET_HDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">virtio_net_hdr</span> <span class="n">vnet_hdr</span><span class="p">;</span>
		<span class="n">vnet_hdr_len</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">vnet_hdr_sz</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">vnet_hdr_len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">macvtap_skb_to_vnet_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vnet_hdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memcpy_toiovecend</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vnet_hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vnet_hdr</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">vnet_hdr_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">copy</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__be16</span> <span class="n">h_vlan_proto</span><span class="p">;</span>
			<span class="n">__be16</span> <span class="n">h_vlan_TCI</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">veth</span><span class="p">;</span>
		<span class="n">veth</span><span class="p">.</span><span class="n">h_vlan_proto</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">);</span>
		<span class="n">veth</span><span class="p">.</span><span class="n">h_vlan_TCI</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

		<span class="n">vlan_offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vlan_ethhdr</span><span class="p">,</span> <span class="n">h_vlan_proto</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">copy</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">vlan_offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">skb_copy_datagram_const_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

		<span class="n">copy</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">veth</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">memcpy_toiovecend</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">veth</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">skb_copy_datagram_const_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vlan_offset</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
	<span class="n">vlan</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="p">)</span>
		<span class="n">macvlan_count_rx</span><span class="p">(</span><span class="n">vlan</span><span class="p">,</span> <span class="n">copied</span> <span class="o">-</span> <span class="n">vnet_hdr_len</span><span class="p">,</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">macvtap_do_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">noblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">;</span>

		<span class="cm">/* Read frames from the queue */</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">.</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">noblock</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Nothing to read, let&#39;s sleep */</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">macvtap_put_user</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">macvtap_aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iv</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">macvtap_do_read</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iv</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">ssize_t</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="cm">/* XXX copied from tun.c. Why? */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * provide compatibility with generic tun/tap interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">macvtap_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ifr</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">up</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TUNSETIFF</span>:
		<span class="cm">/* ignore the name, just look at flags */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">u</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IFF_VNET_HDR</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">IFF_NO_PI</span> <span class="o">|</span> <span class="n">IFF_TAP</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TUNGETIFF</span>:
		<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
		<span class="n">vlan</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">vlan</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vlan</span><span class="p">)</span>
			<span class="n">dev_hold</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOLINK</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">put_user</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_flags</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">vlan</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TUNGETFEATURES</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">IFF_TAP</span> <span class="o">|</span> <span class="n">IFF_NO_PI</span> <span class="o">|</span> <span class="n">IFF_VNET_HDR</span><span class="p">,</span> <span class="n">up</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TUNSETSNDBUF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">up</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">.</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TUNGETVNETHDRSZ</span>:
		<span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">vnet_hdr_sz</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TUNSETVNETHDRSZ</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">virtio_net_hdr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">q</span><span class="o">-&gt;</span><span class="n">vnet_hdr_sz</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TUNSETOFFLOAD</span>:
		<span class="cm">/* let the user check for future flags */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TUN_F_CSUM</span> <span class="o">|</span> <span class="n">TUN_F_TSO4</span> <span class="o">|</span> <span class="n">TUN_F_TSO6</span> <span class="o">|</span>
			    <span class="n">TUN_F_TSO_ECN</span> <span class="o">|</span> <span class="n">TUN_F_UFO</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* TODO: only accept frames with the features that</span>
<span class="cm">			 got enabled for forwarded frames */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_VNET_HDR</span><span class="p">))</span>
			<span class="k">return</span>  <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">macvtap_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">macvtap_ioctl</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">compat_ptr</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">macvtap_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">macvtap_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">macvtap_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span>	<span class="o">=</span> <span class="n">macvtap_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span>	<span class="o">=</span> <span class="n">macvtap_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">macvtap_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">macvtap_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">macvtap_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">macvtap_queue</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">macvtap_get_user</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">total_len</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span><span class="p">,</span>
			    <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total_len</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">macvtap_queue</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MSG_DONTWAIT</span><span class="o">|</span><span class="n">MSG_TRUNC</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">macvtap_do_read</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">total_len</span><span class="p">,</span>
			  <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="n">total_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_TRUNC</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_TRUNC</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">total_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Ops structure to mimic raw sockets with tun */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">macvtap_socket_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sendmsg</span> <span class="o">=</span> <span class="n">macvtap_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span> <span class="o">=</span> <span class="n">macvtap_recvmsg</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Get an underlying socket object from tun file.  Returns error unless file is</span>
<span class="cm"> * attached to a device.  The returned object works like a packet socket, it</span>
<span class="cm"> * can be used for sock_sendmsg/sock_recvmsg.  The caller is responsible for</span>
<span class="cm"> * holding a reference to the file for as long as the socket is in use. */</span>
<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="nf">macvtap_get_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">macvtap_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">macvtap_fops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EBADFD</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">sock</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">macvtap_get_socket</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_device_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">unused</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">macvlan_dev</span> <span class="o">*</span><span class="n">vlan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">classdev</span><span class="p">;</span>
	<span class="n">dev_t</span> <span class="n">devt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">macvtap_link_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="n">vlan</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_REGISTER</span>:
		<span class="cm">/* Create the device node here after the network device has</span>
<span class="cm">		 * been registered but before register_netdevice has</span>
<span class="cm">		 * finished running.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">macvtap_get_minor</span><span class="p">(</span><span class="n">vlan</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

		<span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">macvtap_major</span><span class="p">),</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="n">classdev</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="n">macvtap_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">devt</span><span class="p">,</span>
					 <span class="n">dev</span><span class="p">,</span> <span class="s">&quot;tap%d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">classdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">macvtap_free_minor</span><span class="p">(</span><span class="n">vlan</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">classdev</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_UNREGISTER</span>:
		<span class="n">devt</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">macvtap_major</span><span class="p">),</span> <span class="n">vlan</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">);</span>
		<span class="n">device_destroy</span><span class="p">(</span><span class="n">macvtap_class</span><span class="p">,</span> <span class="n">devt</span><span class="p">);</span>
		<span class="n">macvtap_free_minor</span><span class="p">(</span><span class="n">vlan</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">macvtap_notifier_block</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">macvtap_device_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">macvtap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_major</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">MACVTAP_NUM_DEVS</span><span class="p">,</span> <span class="s">&quot;macvtap&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">macvtap_fops</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_cdev</span><span class="p">,</span> <span class="n">macvtap_major</span><span class="p">,</span> <span class="n">MACVTAP_NUM_DEVS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="n">macvtap_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="s">&quot;macvtap&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">macvtap_class</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">macvtap_class</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_notifier_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out4</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">macvlan_link_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_link_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out5</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out5:</span>
	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_notifier_block</span><span class="p">);</span>
<span class="nl">out4:</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="n">macvtap_class</span><span class="p">);</span>
<span class="nl">out3:</span>
	<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_cdev</span><span class="p">);</span>
<span class="nl">out2:</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">macvtap_major</span><span class="p">,</span> <span class="n">MACVTAP_NUM_DEVS</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">macvtap_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">macvtap_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rtnl_link_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_link_ops</span><span class="p">);</span>
	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_notifier_block</span><span class="p">);</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="n">macvtap_class</span><span class="p">);</span>
	<span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">macvtap_cdev</span><span class="p">);</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">macvtap_major</span><span class="p">,</span> <span class="n">MACVTAP_NUM_DEVS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">macvtap_exit</span><span class="p">);</span>

<span class="n">MODULE_ALIAS_RTNL_LINK</span><span class="p">(</span><span class="s">&quot;macvtap&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Arnd Bergmann &lt;arnd@arndb.de&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
