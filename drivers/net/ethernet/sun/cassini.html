<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › sun › cassini.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>cassini.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* cassini.c: Sun Microsystems Cassini(+) ethernet driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2004 Sun Microsystems Inc.</span>
<span class="cm"> * Copyright (C) 2003 Adrian Sun (asun@darksunrising.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License as</span>
<span class="cm"> * published by the Free Software Foundation; either version 2 of the</span>
<span class="cm"> * License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</span>
<span class="cm"> * 02111-1307, USA.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver uses the sungem driver (c) David Miller</span>
<span class="cm"> * (davem@redhat.com) as its basis.</span>
<span class="cm"> *</span>
<span class="cm"> * The cassini chip has a number of features that distinguish it from</span>
<span class="cm"> * the gem chip:</span>
<span class="cm"> *  4 transmit descriptor rings that are used for either QoS (VLAN) or</span>
<span class="cm"> *      load balancing (non-VLAN mode)</span>
<span class="cm"> *  batching of multiple packets</span>
<span class="cm"> *  multiple CPU dispatching</span>
<span class="cm"> *  page-based RX descriptor engine with separate completion rings</span>
<span class="cm"> *  Gigabit support (GMII and PCS interface)</span>
<span class="cm"> *  MIF link up/down detection works</span>
<span class="cm"> *</span>
<span class="cm"> * RX is handled by page sized buffers that are attached as fragments to</span>
<span class="cm"> * the skb. here&#39;s what&#39;s done:</span>
<span class="cm"> *  -- driver allocates pages at a time and keeps reference counts</span>
<span class="cm"> *     on them.</span>
<span class="cm"> *  -- the upper protocol layers assume that the header is in the skb</span>
<span class="cm"> *     itself. as a result, cassini will copy a small amount (64 bytes)</span>
<span class="cm"> *     to make them happy.</span>
<span class="cm"> *  -- driver appends the rest of the data pages as frags to skbuffs</span>
<span class="cm"> *     and increments the reference count</span>
<span class="cm"> *  -- on page reclamation, the driver swaps the page with a spare page.</span>
<span class="cm"> *     if that page is still in use, it frees its reference to that page,</span>
<span class="cm"> *     and allocates a new page for use. otherwise, it just recycles the</span>
<span class="cm"> *     the page.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: cassini can parse the header. however, it&#39;s not worth it</span>
<span class="cm"> *       as long as the network stack requires a header copy.</span>
<span class="cm"> *</span>
<span class="cm"> * TX has 4 queues. currently these queues are used in a round-robin</span>
<span class="cm"> * fashion for load balancing. They can also be used for QoS. for that</span>
<span class="cm"> * to work, however, QoS information needs to be exposed down to the driver</span>
<span class="cm"> * level so that subqueues get targeted to particular transmit rings.</span>
<span class="cm"> * alternatively, the queues can be configured via use of the all-purpose</span>
<span class="cm"> * ioctl.</span>
<span class="cm"> *</span>
<span class="cm"> * RX DATA: the rx completion ring has all the info, but the rx desc</span>
<span class="cm"> * ring has all of the data. RX can conceivably come in under multiple</span>
<span class="cm"> * interrupts, but the INT# assignment needs to be set up properly by</span>
<span class="cm"> * the BIOS and conveyed to the driver. PCI BIOSes don&#39;t know how to do</span>
<span class="cm"> * that. also, the two descriptor rings are designed to distinguish between</span>
<span class="cm"> * encrypted and non-encrypted packets, but we use them for buffering</span>
<span class="cm"> * instead.</span>
<span class="cm"> *</span>
<span class="cm"> * by default, the selective clear mask is set up to process rx packets.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>

<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/firmware.h&gt;</span>

<span class="cp">#include &lt;net/checksum.h&gt;</span>

<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#define cas_page_map(x)      kmap_atomic((x))</span>
<span class="cp">#define cas_page_unmap(x)    kunmap_atomic((x))</span>
<span class="cp">#define CAS_NCPUS            num_online_cpus()</span>

<span class="cp">#define cas_skb_release(x)  netif_rx(x)</span>

<span class="cm">/* select which firmware to use */</span>
<span class="cp">#define USE_HP_WORKAROUND</span>
<span class="cp">#define HP_WORKAROUND_DEFAULT </span><span class="cm">/* select which firmware to use as default */</span><span class="cp"></span>
<span class="cp">#define CAS_HP_ALT_FIRMWARE   cas_prog_null </span><span class="cm">/* alternate firmware */</span><span class="cp"></span>

<span class="cp">#include &quot;cassini.h&quot;</span>

<span class="cp">#define USE_TX_COMPWB      </span><span class="cm">/* use completion writeback registers */</span><span class="cp"></span>
<span class="cp">#define USE_CSMA_CD_PROTO  </span><span class="cm">/* standard CSMA/CD */</span><span class="cp"></span>
<span class="cp">#define USE_RX_BLANK       </span><span class="cm">/* hw interrupt mitigation */</span><span class="cp"></span>
<span class="cp">#undef USE_ENTROPY_DEV     </span><span class="cm">/* don&#39;t test for entropy device */</span><span class="cp"></span>

<span class="cm">/* NOTE: these aren&#39;t useable unless PCI interrupts can be assigned.</span>
<span class="cm"> * also, we need to make cp-&gt;lock finer-grained.</span>
<span class="cm"> */</span>
<span class="cp">#undef  USE_PCI_INTB</span>
<span class="cp">#undef  USE_PCI_INTC</span>
<span class="cp">#undef  USE_PCI_INTD</span>
<span class="cp">#undef  USE_QOS</span>

<span class="cp">#undef  USE_VPD_DEBUG       </span><span class="cm">/* debug vpd information if defined */</span><span class="cp"></span>

<span class="cm">/* rx processing options */</span>
<span class="cp">#define USE_PAGE_ORDER      </span><span class="cm">/* specify to allocate large rx pages */</span><span class="cp"></span>
<span class="cp">#define RX_DONT_BATCH  0    </span><span class="cm">/* if 1, don&#39;t batch flows */</span><span class="cp"></span>
<span class="cp">#define RX_COPY_ALWAYS 0    </span><span class="cm">/* if 0, use frags */</span><span class="cp"></span>
<span class="cp">#define RX_COPY_MIN    64   </span><span class="cm">/* copy a little to make upper layers happy */</span><span class="cp"></span>
<span class="cp">#undef  RX_COUNT_BUFFERS    </span><span class="cm">/* define to calculate RX buffer stats */</span><span class="cp"></span>

<span class="cp">#define DRV_MODULE_NAME		&quot;cassini&quot;</span>
<span class="cp">#define DRV_MODULE_VERSION	&quot;1.6&quot;</span>
<span class="cp">#define DRV_MODULE_RELDATE	&quot;21 May 2008&quot;</span>

<span class="cp">#define CAS_DEF_MSG_ENABLE	  \</span>
<span class="cp">	(NETIF_MSG_DRV		| \</span>
<span class="cp">	 NETIF_MSG_PROBE	| \</span>
<span class="cp">	 NETIF_MSG_LINK		| \</span>
<span class="cp">	 NETIF_MSG_TIMER	| \</span>
<span class="cp">	 NETIF_MSG_IFDOWN	| \</span>
<span class="cp">	 NETIF_MSG_IFUP		| \</span>
<span class="cp">	 NETIF_MSG_RX_ERR	| \</span>
<span class="cp">	 NETIF_MSG_TX_ERR)</span>

<span class="cm">/* length of time before we decide the hardware is borked,</span>
<span class="cm"> * and dev-&gt;tx_timeout() should be called to fix the problem</span>
<span class="cm"> */</span>
<span class="cp">#define CAS_TX_TIMEOUT			(HZ)</span>
<span class="cp">#define CAS_LINK_TIMEOUT                (22*HZ/10)</span>
<span class="cp">#define CAS_LINK_FAST_TIMEOUT           (1)</span>

<span class="cm">/* timeout values for state changing. these specify the number</span>
<span class="cm"> * of 10us delays to be used before giving up.</span>
<span class="cm"> */</span>
<span class="cp">#define STOP_TRIES_PHY 1000</span>
<span class="cp">#define STOP_TRIES     5000</span>

<span class="cm">/* specify a minimum frame size to deal with some fifo issues</span>
<span class="cm"> * max mtu == 2 * page size - ethernet header - 64 - swivel =</span>
<span class="cm"> *            2 * page_size - 0x50</span>
<span class="cm"> */</span>
<span class="cp">#define CAS_MIN_FRAME			97</span>
<span class="cp">#define CAS_1000MB_MIN_FRAME            255</span>
<span class="cp">#define CAS_MIN_MTU                     60</span>
<span class="cp">#define CAS_MAX_MTU                     min(((cp-&gt;page_size &lt;&lt; 1) - 0x50), 9000)</span>

<span class="cp">#if 1</span>
<span class="cm">/*</span>
<span class="cm"> * Eliminate these and use separate atomic counters for each, to</span>
<span class="cm"> * avoid a race condition.</span>
<span class="cm"> */</span>
<span class="cp">#else</span>
<span class="cp">#define CAS_RESET_MTU                   1</span>
<span class="cp">#define CAS_RESET_ALL                   2</span>
<span class="cp">#define CAS_RESET_SPARE                 3</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">version</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span>
	<span class="n">DRV_MODULE_NAME</span> <span class="s">&quot;.c:v&quot;</span> <span class="n">DRV_MODULE_VERSION</span> <span class="s">&quot; (&quot;</span> <span class="n">DRV_MODULE_RELDATE</span> <span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">cassini_debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* -1 == use CAS_DEF_MSG_ENABLE as value */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">link_mode</span><span class="p">;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Adrian Sun (asun@darksunrising.com)&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Sun Cassini(+) ethernet driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_FIRMWARE</span><span class="p">(</span><span class="s">&quot;sun/cassini.bin&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">cassini_debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cassini_debug</span><span class="p">,</span> <span class="s">&quot;Cassini bitmapped debugging message enable value&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">link_mode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">link_mode</span><span class="p">,</span> <span class="s">&quot;default link mode&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Work around for a PCS bug in which the link goes down due to the chip</span>
<span class="cm"> * being confused and never showing a link status of &quot;up.&quot;</span>
<span class="cm"> */</span>
<span class="cp">#define DEFAULT_LINKDOWN_TIMEOUT 5</span>
<span class="cm">/*</span>
<span class="cm"> * Value in seconds, for user input.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">linkdown_timeout</span> <span class="o">=</span> <span class="n">DEFAULT_LINKDOWN_TIMEOUT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">linkdown_timeout</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">linkdown_timeout</span><span class="p">,</span>
<span class="s">&quot;min reset interval in sec. for PCS linkdown issue; disabled if not positive&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * value in &#39;ticks&#39; (units used by jiffies). Set when we init the</span>
<span class="cm"> * module because &#39;HZ&#39; in actually a function call on some flavors of</span>
<span class="cm"> * Linux.  This will default to DEFAULT_LINKDOWN_TIMEOUT * HZ.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">link_transition_timeout</span><span class="p">;</span>



<span class="k">static</span> <span class="n">u16</span> <span class="n">link_modes</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">BMCR_ANENABLE</span><span class="p">,</span>			 <span class="cm">/* 0 : autoneg */</span>
	<span class="mi">0</span><span class="p">,</span>				 <span class="cm">/* 1 : 10bt half duplex */</span>
	<span class="n">BMCR_SPEED100</span><span class="p">,</span>			 <span class="cm">/* 2 : 100bt half duplex */</span>
	<span class="n">BMCR_FULLDPLX</span><span class="p">,</span>			 <span class="cm">/* 3 : 10bt full duplex */</span>
	<span class="n">BMCR_SPEED100</span><span class="o">|</span><span class="n">BMCR_FULLDPLX</span><span class="p">,</span>	 <span class="cm">/* 4 : 100bt full duplex */</span>
	<span class="n">CAS_BMCR_SPEED1000</span><span class="o">|</span><span class="n">BMCR_FULLDPLX</span> <span class="cm">/* 5 : 1000bt full duplex */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">cas_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_SUN</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_SUN_CASSINI</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_NS</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NS_SATURN</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">cas_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cas_set_link_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_lock_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_lock_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cas_lock_tx</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* WTZ: QA was finding deadlock problems with the previous</span>
<span class="cm"> * versions after long test runs with multiple cards per machine.</span>
<span class="cm"> * See if replacing cas_lock_all with safer versions helps. The</span>
<span class="cm"> * symptoms QA is reporting match those we&#39;d expect if interrupts</span>
<span class="cm"> * aren&#39;t being properly restored, and we fixed a previous deadlock</span>
<span class="cm"> * with similar symptoms by using save/restore versions in other</span>
<span class="cm"> * places.</span>
<span class="cm"> */</span>
<span class="cp">#define cas_lock_all_save(cp, flags) \</span>
<span class="cp">do { \</span>
<span class="cp">	struct cas *xxxcp = (cp); \</span>
<span class="cp">	spin_lock_irqsave(&amp;xxxcp-&gt;lock, flags); \</span>
<span class="cp">	cas_lock_tx(xxxcp); \</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_unlock_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_unlock_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_unlock_tx</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define cas_unlock_all_restore(cp, flags) \</span>
<span class="cp">do { \</span>
<span class="cp">	struct cas *xxxcp = (cp); \</span>
<span class="cp">	cas_unlock_tx(xxxcp); \</span>
<span class="cp">	spin_unlock_irqrestore(&amp;xxxcp-&gt;lock, flags); \</span>
<span class="cp">} while (0)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_disable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Make sure we won&#39;t get any more interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_INTR_MASK</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* disable completion interrupts and selectively mask */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined (USE_PCI_INTB) || defined(USE_PCI_INTC) || defined(USE_PCI_INTD)</span>
<span class="cp">#ifdef USE_PCI_INTB</span>
		<span class="k">case</span> <span class="mi">1</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef USE_PCI_INTC</span>
		<span class="k">case</span> <span class="mi">2</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef USE_PCI_INTD</span>
		<span class="k">case</span> <span class="mi">3</span>:
<span class="cp">#endif</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">INTRN_MASK_CLEAR_ALL</span> <span class="o">|</span> <span class="n">INTRN_MASK_RX_EN</span><span class="p">,</span>
			       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_INTRN_MASK</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="nl">default:</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">INTRN_MASK_CLEAR_ALL</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
			       <span class="n">REG_PLUS_INTRN_MASK</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_mask_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cas_disable_irq</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_enable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* all but TX_DONE */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">INTR_TX_DONE</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_INTR_MASK</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined (USE_PCI_INTB) || defined(USE_PCI_INTC) || defined(USE_PCI_INTD)</span>
<span class="cp">#ifdef USE_PCI_INTB</span>
		<span class="k">case</span> <span class="mi">1</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef USE_PCI_INTC</span>
		<span class="k">case</span> <span class="mi">2</span>:
<span class="cp">#endif</span>
<span class="cp">#ifdef USE_PCI_INTD</span>
		<span class="k">case</span> <span class="mi">3</span>:
<span class="cp">#endif</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">INTRN_MASK_RX_EN</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
			       <span class="n">REG_PLUS_INTRN_MASK</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_unmask_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cas_enable_irq</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_entropy_gather</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef USE_ENTROPY_DEV</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_ENTROPY_DEV</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">batch_entropy_store</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_ENTROPY_IV</span><span class="p">),</span>
			    <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_ENTROPY_IV</span><span class="p">),</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_entropy_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef USE_ENTROPY_DEV</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_ENTROPY_DEV</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">BIM_LOCAL_DEV_PAD</span> <span class="o">|</span> <span class="n">BIM_LOCAL_DEV_PROM</span> <span class="o">|</span> <span class="n">BIM_LOCAL_DEV_EXT</span><span class="p">,</span>
	       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_BIM_LOCAL_DEV_EN</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">ENTROPY_RESET_STC_MODE</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_ENTROPY_RESET</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_ENTROPY_RAND_REG</span><span class="p">);</span>

	<span class="cm">/* if we read back 0x0, we don&#39;t have an entropy device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_ENTROPY_RAND_REG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CAS_FLAG_ENTROPY_DEV</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* access to the phy. the following assumes that we&#39;ve initialized the MIF to</span>
<span class="cm"> * be in frame rather than bit-bang mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">cas_phy_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">STOP_TRIES_PHY</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">MIF_FRAME_ST</span> <span class="o">|</span> <span class="n">MIF_FRAME_OP_READ</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">MIF_FRAME_PHY_ADDR</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">MIF_FRAME_REG_ADDR</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">|=</span> <span class="n">MIF_FRAME_TURN_AROUND_MSB</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_FRAME</span><span class="p">);</span>

	<span class="cm">/* poll for completion */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">limit</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_FRAME</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">MIF_FRAME_TURN_AROUND_LSB</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">MIF_FRAME_DATA_MASK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mh">0xFFFF</span><span class="p">;</span> <span class="cm">/* -1 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_phy_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">,</span> <span class="n">u16</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">STOP_TRIES_PHY</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">MIF_FRAME_ST</span> <span class="o">|</span> <span class="n">MIF_FRAME_OP_WRITE</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">MIF_FRAME_PHY_ADDR</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">MIF_FRAME_REG_ADDR</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">|=</span> <span class="n">MIF_FRAME_TURN_AROUND_MSB</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">MIF_FRAME_DATA_MASK</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_FRAME</span><span class="p">);</span>

	<span class="cm">/* poll for completion */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">limit</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_FRAME</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">MIF_FRAME_TURN_AROUND_LSB</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_phy_powerup</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ctl</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">BMCR_PDOWN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BMCR_PDOWN</span><span class="p">;</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_phy_powerdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ctl</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">BMCR_PDOWN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ctl</span> <span class="o">|=</span> <span class="n">BMCR_PDOWN</span><span class="p">;</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* cp-&gt;lock held. note: the last put_page will free the buffer */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_page_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">cas_page_t</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span>
		       <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef RX_COUNT_BUFFERS</span>
<span class="cp">#define RX_USED_ADD(x, y)       ((x)-&gt;used += (y))</span>
<span class="cp">#define RX_USED_SET(x, y)       ((x)-&gt;used  = (y))</span>
<span class="cp">#else</span>
<span class="cp">#define RX_USED_ADD(x, y)</span>
<span class="cp">#define RX_USED_SET(x, y)</span>
<span class="cp">#endif</span>

<span class="cm">/* local page allocation routines for the receive buffers. jumbo pages</span>
<span class="cm"> * require at least 8K contiguous and 8K aligned buffers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">cas_page_t</span> <span class="o">*</span><span class="nf">cas_page_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cas_page_t</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">RX_USED_SET</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">page_err</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">=</span> <span class="n">pci_map_page</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				      <span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>

<span class="nl">page_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* initialize spare pool of rx buffers, but allocate during the open */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_spare_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
  	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_list</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spares_needed</span> <span class="o">=</span> <span class="n">RX_SPARE_COUNT</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* used on close. free all the spare buffers. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_spare_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">,</span> <span class="o">*</span><span class="n">elem</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* free spare buffers */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_page_free</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">cas_page_t</span><span class="p">,</span> <span class="n">list</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
<span class="cp">#if 1</span>
	<span class="cm">/*</span>
<span class="cm">	 * Looks like Adrian had protected this with a different</span>
<span class="cm">	 * lock than used everywhere else to manipulate this list.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_page_free</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">cas_page_t</span><span class="p">,</span> <span class="n">list</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* replenish spares if needed */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_spare_recover</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">,</span> <span class="o">*</span><span class="n">elem</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needed</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* check inuse list. if we don&#39;t need any more free buffers,</span>
<span class="cm">	 * just free it</span>
<span class="cm">	 */</span>

	<span class="cm">/* make a local copy of the list */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">cas_page_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * With the lockless pagecache, cassini buffering scheme gets</span>
<span class="cm">		 * slightly less accurate: we might find that a page has an</span>
<span class="cm">		 * elevated reference count here, due to a speculative ref,</span>
<span class="cm">		 * and skip it as in-use. Ideally we would be able to reclaim</span>
<span class="cm">		 * it. However this would be such a rare case, it doesn&#39;t</span>
<span class="cm">		 * matter too much as we should pick it up the next time round.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Importantly, if we find that the page has a refcount of 1</span>
<span class="cm">		 * here (our refcount), then we know it is definitely not inuse</span>
<span class="cm">		 * so we can reuse it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_del</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spares_needed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_list</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spares_needed</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
			<span class="n">cas_page_free</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* put any inuse buffers back on the list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="n">needed</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spares_needed</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">needed</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* we still need spares, so try to allocate some */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">spare</span> <span class="o">=</span> <span class="n">cas_page_alloc</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spare</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spare</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_list</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spares_needed</span> <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* pull a page from the list. */</span>
<span class="k">static</span> <span class="n">cas_page_t</span> <span class="o">*</span><span class="nf">cas_page_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recover</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* try to do a quick recovery */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
		<span class="n">cas_spare_recover</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_err</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				  <span class="s">&quot;no spare buffers available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">recover</span> <span class="o">=</span> <span class="o">++</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spares_needed</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>

	<span class="cm">/* trigger the timer to do the recovery */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">recover</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RX_SPARE_RECOVER_VAL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if 1</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_spare</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">,</span> <span class="n">CAS_RESET_SPARE</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cas_page_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_mif_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>

	<span class="n">cfg</span>  <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_CFG</span><span class="p">);</span>
	<span class="n">cfg</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">MIF_CFG_MDIO_0</span> <span class="o">|</span> <span class="n">MIF_CFG_MDIO_1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">&amp;</span> <span class="n">CAS_PHY_MII_MDIO1</span><span class="p">)</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">MIF_CFG_PHY_SELECT</span><span class="p">;</span>

	<span class="cm">/* poll and interrupt on link status change. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">MIF_CFG_POLL_EN</span><span class="p">;</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">MIF_CFG_POLL_REG</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>
		<span class="n">cfg</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">MIF_CFG_POLL_PHY</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">enable</span><span class="p">)</span> <span class="o">?</span> <span class="o">~</span><span class="p">(</span><span class="n">BMSR_LSTATUS</span> <span class="o">|</span> <span class="n">BMSR_ANEGCOMPLETE</span><span class="p">)</span> <span class="o">:</span> <span class="mh">0xFFFF</span><span class="p">,</span>
	       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_MASK</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_CFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_begin_auto_negotiation</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">ep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ctl</span><span class="p">;</span>
<span class="cp">#if 1</span>
	<span class="kt">int</span> <span class="n">lcntl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oldstate</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">link_was_not_down</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">link_down</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* Setup link parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">start_aneg</span><span class="p">;</span>
	<span class="n">lcntl</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="n">AUTONEG_ENABLE</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">=</span> <span class="n">BMCR_ANENABLE</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">ethtool_cmd_speed</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_100</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">|=</span> <span class="n">BMCR_SPEED100</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">|=</span> <span class="n">CAS_BMCR_SPEED1000</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">|=</span> <span class="n">BMCR_FULLDPLX</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#if 1</span>
	<span class="n">changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">lcntl</span> <span class="o">!=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="nl">start_aneg:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">==</span> <span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCS link down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;link configuration changed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_down</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_DOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#if 1</span>
	<span class="cm">/*</span>
<span class="cm">	 * WTZ: If the old state was link_up, we turn off the carrier</span>
<span class="cm">	 * to replicate everything we do elsewhere on a link-down</span>
<span class="cm">	 * event when we were already in a link-up state..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">link_up</span><span class="p">)</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span>  <span class="o">&amp;&amp;</span> <span class="n">link_was_not_down</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * WTZ: This branch will simply schedule a full reset after</span>
<span class="cm">		 * we explicitly changed link modes in an ioctl. See if this</span>
<span class="cm">		 * fixes the link-problems we were having for forced mode.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">CAS_LINK_TIMEOUT</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">&amp;</span> <span class="n">CAS_PHY_SERDES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_CTRL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">PCS_MII_RESTART_AUTONEG</span> <span class="o">|</span> <span class="n">PCS_MII_AUTONEG_EN</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_aneg</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">&amp;</span> <span class="n">BMCR_FULLDPLX</span><span class="p">)</span>
				<span class="n">val</span> <span class="o">|=</span> <span class="n">PCS_MII_CTRL_DUPLEX</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCS_MII_AUTONEG_EN</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_force_ok</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_CONFIG</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_CTRL</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ctl</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
		<span class="n">ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BMCR_FULLDPLX</span> <span class="o">|</span> <span class="n">BMCR_SPEED100</span> <span class="o">|</span>
			 <span class="n">CAS_BMCR_SPEED1000</span> <span class="o">|</span> <span class="n">BMCR_ANENABLE</span><span class="p">);</span>
		<span class="n">ctl</span> <span class="o">|=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctl</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctl</span> <span class="o">|=</span> <span class="n">BMCR_ANRESTART</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_aneg</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_force_ok</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_CONFIG</span><span class="p">;</span>
		<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">CAS_LINK_TIMEOUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_reset_mii_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">STOP_TRIES_PHY</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">BMCR_RESET</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">BMCR_RESET</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_saturn_firmware_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">firmware</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">fw_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;sun/cassini.bin&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PHY_NS_DP83065</span> <span class="o">!=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fw</span><span class="p">,</span> <span class="n">fw_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Failed to load firmware </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fw_name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;bogus length %zu in </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">fw_name</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_load_addr</span><span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_size</span> <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_data</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fw</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_size</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">release_firmware</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_saturn_firmware_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cas_phy_powerdown</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="cm">/* expanded memory access mode */</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_MEM</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

	<span class="cm">/* pointer configuration for new firmware */</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGE</span><span class="p">,</span> <span class="mh">0x8ff9</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGD</span><span class="p">,</span> <span class="mh">0xbd</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGE</span><span class="p">,</span> <span class="mh">0x8ffa</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGD</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGE</span><span class="p">,</span> <span class="mh">0x8ffb</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGD</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGE</span><span class="p">,</span> <span class="mh">0x8ffc</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGD</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">);</span>

	<span class="cm">/* download new firmware */</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_MEM</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGE</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_load_addr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGD</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* enable firmware */</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGE</span><span class="p">,</span> <span class="mh">0x8ff8</span><span class="p">);</span>
	<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">DP83065_MII_REGD</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* phy initialization */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_phy_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="cm">/* if we&#39;re in MII/GMII mode, set up phy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CAS_PHY_MII</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">PCS_DATAPATH_MODE_MII</span><span class="p">,</span>
		       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_DATAPATH_MODE</span><span class="p">);</span>

		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cas_reset_mii_phy</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span> <span class="cm">/* take out of isolate mode */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PHY_LUCENT_B0</span> <span class="o">==</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* workaround link up/down issue with lucent */</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">LUCENT_MII_REG</span><span class="p">,</span> <span class="mh">0x8000</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="mh">0x00f1</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">LUCENT_MII_REG</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PHY_BROADCOM_B0</span> <span class="o">==</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFC</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* workarounds for broadcom phy */</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG8</span><span class="p">,</span> <span class="mh">0x0C20</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG7</span><span class="p">,</span> <span class="mh">0x0012</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG5</span><span class="p">,</span> <span class="mh">0x1804</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG7</span><span class="p">,</span> <span class="mh">0x0013</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG5</span><span class="p">,</span> <span class="mh">0x1204</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG7</span><span class="p">,</span> <span class="mh">0x8006</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG5</span><span class="p">,</span> <span class="mh">0x0132</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG7</span><span class="p">,</span> <span class="mh">0x8006</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG5</span><span class="p">,</span> <span class="mh">0x0232</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG7</span><span class="p">,</span> <span class="mh">0x201F</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG5</span><span class="p">,</span> <span class="mh">0x0A20</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PHY_BROADCOM_5411</span> <span class="o">==</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG4</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG4</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x0080</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* link workaround */</span>
				<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">BROADCOM_MII_REG4</span><span class="p">,</span>
					      <span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x0080</span><span class="p">);</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_SATURN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writel</span><span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">&amp;</span> <span class="n">CAS_PHY_MII_MDIO0</span><span class="p">)</span> <span class="o">?</span>
			       <span class="n">SATURN_PCFG_FSI</span> <span class="o">:</span> <span class="mh">0x0</span><span class="p">,</span>
			       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_SATURN_PCFG</span><span class="p">);</span>

			<span class="cm">/* load firmware to address 10Mbps auto-negotiation</span>
<span class="cm">			 * issue. NOTE: this will need to be changed if the</span>
<span class="cm">			 * default firmware gets fixed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PHY_NS_DP83065</span> <span class="o">==</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cas_saturn_firmware_load</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">cas_phy_powerup</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* advertise capabilities */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BMCR_ANENABLE</span><span class="p">;</span>
		<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">,</span>
			      <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_ADVERTISE</span><span class="p">)</span> <span class="o">|</span>
			      <span class="p">(</span><span class="n">ADVERTISE_10HALF</span> <span class="o">|</span> <span class="n">ADVERTISE_10FULL</span> <span class="o">|</span>
			       <span class="n">ADVERTISE_100HALF</span> <span class="o">|</span> <span class="n">ADVERTISE_100FULL</span> <span class="o">|</span>
			       <span class="n">CAS_ADVERTISE_PAUSE</span> <span class="o">|</span>
			       <span class="n">CAS_ADVERTISE_ASYM_PAUSE</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_1000MB_CAP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* make sure that we don&#39;t advertise half</span>
<span class="cm">			 * duplex to avoid a chip issue</span>
<span class="cm">			 */</span>
			<span class="n">val</span>  <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">CAS_MII_1000_CTRL</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CAS_ADVERTISE_1000HALF</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_ADVERTISE_1000FULL</span><span class="p">;</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">CAS_MII_1000_CTRL</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* reset pcs for serdes */</span>
		<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">PCS_DATAPATH_MODE_SERDES</span><span class="p">,</span>
		       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_DATAPATH_MODE</span><span class="p">);</span>

		<span class="cm">/* enable serdes pins on saturn */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_SATURN</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_SATURN_PCFG</span><span class="p">);</span>

		<span class="cm">/* Reset PCS unit. */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_CTRL</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">PCS_MII_RESET</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_CTRL</span><span class="p">);</span>

		<span class="n">limit</span> <span class="o">=</span> <span class="n">STOP_TRIES</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_CTRL</span><span class="p">)</span> <span class="o">&amp;</span>
			     <span class="n">PCS_MII_RESET</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">netdev_warn</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCS reset bit would not clear [%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_STATE_MACHINE</span><span class="p">));</span>

		<span class="cm">/* Make sure PCS is disabled while changing advertisement</span>
<span class="cm">		 * configuration.</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_CFG</span><span class="p">);</span>

		<span class="cm">/* Advertise all capabilities except half-duplex. */</span>
		<span class="n">val</span>  <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_ADVERT</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCS_MII_ADVERT_HD</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">PCS_MII_ADVERT_FD</span> <span class="o">|</span> <span class="n">PCS_MII_ADVERT_SYM_PAUSE</span> <span class="o">|</span>
			<span class="n">PCS_MII_ADVERT_ASYM_PAUSE</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_ADVERT</span><span class="p">);</span>

		<span class="cm">/* enable PCS */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">PCS_CFG_EN</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_CFG</span><span class="p">);</span>

		<span class="cm">/* pcs workaround: enable sync detect */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">PCS_SERDES_CTRL_SYNCD_EN</span><span class="p">,</span>
		       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_SERDES_CTRL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_pcs_link_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">stat</span><span class="p">,</span> <span class="n">state_machine</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The link status bit latches on zero, so you must</span>
<span class="cm">	 * read it twice in such a case to see a transition</span>
<span class="cm">	 * to the link being up.</span>
<span class="cm">	 */</span>
	<span class="n">stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCS_MII_STATUS_LINK_STATUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_STATUS</span><span class="p">);</span>

	<span class="cm">/* The remote-fault indication is only valid</span>
<span class="cm">	 * when autoneg has completed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PCS_MII_STATUS_AUTONEG_COMP</span> <span class="o">|</span>
		     <span class="n">PCS_MII_STATUS_REMOTE_FAULT</span><span class="p">))</span> <span class="o">==</span>
	    <span class="p">(</span><span class="n">PCS_MII_STATUS_AUTONEG_COMP</span> <span class="o">|</span> <span class="n">PCS_MII_STATUS_REMOTE_FAULT</span><span class="p">))</span>
		<span class="n">netif_info</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCS RemoteFault</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* work around link detection issue by querying the PCS state</span>
<span class="cm">	 * machine directly.</span>
<span class="cm">	 */</span>
	<span class="n">state_machine</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_STATE_MACHINE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">state_machine</span> <span class="o">&amp;</span> <span class="n">PCS_SM_LINK_STATE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SM_LINK_STATE_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stat</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCS_MII_STATUS_LINK_STATUS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state_machine</span> <span class="o">&amp;</span> <span class="n">PCS_SM_WORD_SYNC_STATE_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stat</span> <span class="o">|=</span> <span class="n">PCS_MII_STATUS_LINK_STATUS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCS_MII_STATUS_LINK_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">!=</span> <span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_up</span><span class="p">;</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_UP</span><span class="p">;</span>

				<span class="n">cas_set_link_modes</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
				<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">==</span> <span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_down</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">link_transition_timeout</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">!=</span> <span class="n">LINK_TRANSITION_REQUESTED_RESET</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies_valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * force a reset, as a workaround for the</span>
<span class="cm">			 * link-failure problem. May want to move this to a</span>
<span class="cm">			 * point a bit earlier in the sequence. If we had</span>
<span class="cm">			 * generated a reset a short time ago, we&#39;ll wait for</span>
<span class="cm">			 * the link timer to check the status until a</span>
<span class="cm">			 * timer expires (link_transistion_jiffies_valid is</span>
<span class="cm">			 * true when the timer is running.)  Instead of using</span>
<span class="cm">			 * a system timer, we just do a check whenever the</span>
<span class="cm">			 * link timer is running - this clears the flag after</span>
<span class="cm">			 * a suitable delay.</span>
<span class="cm">			 */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_REQUESTED_RESET</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_ON_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span>
			<span class="n">netif_info</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCS link down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Cassini only: if you force a mode, there can be</span>
<span class="cm">		 * sync problems on link down. to fix that, the following</span>
<span class="cm">		 * things need to be checked:</span>
<span class="cm">		 * 1) read serialink state register</span>
<span class="cm">		 * 2) read pcs status register to verify link down.</span>
<span class="cm">		 * 3) if link down and serial link == 0x03, then you need</span>
<span class="cm">		 *    to global reset the chip.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* should check to see if we&#39;re in a forced mode */</span>
			<span class="n">stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_SERDES_STATE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">==</span> <span class="n">link_down</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">link_transition_timeout</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">!=</span> <span class="n">LINK_TRANSITION_REQUESTED_RESET</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies_valid</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* force a reset, as a workaround for the</span>
<span class="cm">			 * link-failure problem.  May want to move</span>
<span class="cm">			 * this to a point a bit earlier in the</span>
<span class="cm">			 * sequence.</span>
<span class="cm">			 */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_REQUESTED_RESET</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_STILL_FAILED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_pcs_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_INTR_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCS_INTR_STATUS_LINK_CHANGE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cas_pcs_link_check</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_txmac_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">txmac_stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">txmac_stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;txmac interrupt, txmac_stat: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">txmac_stat</span><span class="p">);</span>

	<span class="cm">/* Defer timer expiration is quite normal,</span>
<span class="cm">	 * don&#39;t even log the event.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">txmac_stat</span> <span class="o">&amp;</span> <span class="n">MAC_TX_DEFER_TIMER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">txmac_stat</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAC_TX_DEFER_TIMER</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txmac_stat</span> <span class="o">&amp;</span> <span class="n">MAC_TX_UNDERRUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX MAC xmit underrun</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txmac_stat</span> <span class="o">&amp;</span> <span class="n">MAC_TX_MAX_PACKET_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX MAC max packet size error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The rest are all cases of one of the 16-bit TX</span>
<span class="cm">	 * counters expiring.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">txmac_stat</span> <span class="o">&amp;</span> <span class="n">MAC_TX_COLL_NORMAL</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">collisions</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txmac_stat</span> <span class="o">&amp;</span> <span class="n">MAC_TX_COLL_EXCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_aborted_errors</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">collisions</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txmac_stat</span> <span class="o">&amp;</span> <span class="n">MAC_TX_COLL_LATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_aborted_errors</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">collisions</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* We do not keep track of MAC_TX_COLL_FIRST and</span>
<span class="cm">	 * MAC_TX_PEAK_ATTEMPTS events.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_load_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">cas_hp_inst_t</span> <span class="o">*</span><span class="n">firmware</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_hp_inst_t</span> <span class="o">*</span><span class="n">inst</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">inst</span> <span class="o">=</span> <span class="n">firmware</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">note</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_INSTR_RAM_ADDR</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_HI_VAL</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_HI_MASK</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_INSTR_RAM_DATA_HI</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_MID_OUTARG</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">outarg</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_MID_OUTOP</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">outop</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_MID_FNEXT</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">fnext</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_MID_FOFF</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">foff</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_MID_SNEXT</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">snext</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_MID_SOFF</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">soff</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_MID_OP</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_INSTR_RAM_DATA_MID</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_LOW_OUTMASK</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">outmask</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_LOW_OUTSHIFT</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">outshift</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_LOW_OUTEN</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">outenab</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_INSTR_RAM_LOW_OUTARG</span><span class="p">,</span> <span class="n">inst</span><span class="o">-&gt;</span><span class="n">outarg</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_INSTR_RAM_DATA_LOW</span><span class="p">);</span>
		<span class="o">++</span><span class="n">firmware</span><span class="p">;</span>
		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_init_rx_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">desc_dma</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">block_dvma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* rx free descriptors */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_CFG_SWIVEL</span><span class="p">,</span> <span class="n">RX_SWIVEL_OFF_VAL</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_CFG_DESC_RING</span><span class="p">,</span> <span class="n">RX_DESC_RINGN_INDEX</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_CFG_COMP_RING</span><span class="p">,</span> <span class="n">RX_COMP_RINGN_INDEX</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">N_RX_DESC_RINGS</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">))</span>  <span class="cm">/* do desc 2 */</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_CFG_DESC_RING1</span><span class="p">,</span> <span class="n">RX_DESC_RINGN_INDEX</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CFG</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_DB_HI</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_DB_LOW</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_KICK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* rx desc 2 is for IPSEC packets. however,</span>
<span class="cm">		 * we don&#39;t it that for that purpose.</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_RX_DB1_HI</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
		       <span class="n">REG_PLUS_RX_DB1_LOW</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
		       <span class="n">REG_PLUS_RX_KICK1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* rx completion registers */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CB_HI</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CB_LOW</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* rx comp 2-4 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">;</span>
			<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
			       <span class="n">REG_PLUS_RX_CBN_HI</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
			       <span class="n">REG_PLUS_RX_CBN_LOW</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* read selective clear regs to prevent spurious interrupts</span>
<span class="cm">	 * on reset because complete == kick.</span>
<span class="cm">	 * selective clear set up to prevent interrupts on resets</span>
<span class="cm">	 */</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_INTR_STATUS_ALIAS</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">INTR_RX_DONE</span> <span class="o">|</span> <span class="n">INTR_RX_BUF_UNAVAIL</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_ALIAS_CLEAR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_INTRN_STATUS_ALIAS</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

		<span class="cm">/* 2 is different from 3 and 4 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">N_RX_COMP_RINGS</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">INTR_RX_DONE_ALT</span> <span class="o">|</span> <span class="n">INTR_RX_BUF_UNAVAIL_1</span><span class="p">,</span>
			       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_ALIASN_CLEAR</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">INTR_RX_DONE_ALT</span><span class="p">,</span>
			       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_ALIASN_CLEAR</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* set up pause thresholds */</span>
	<span class="n">val</span>  <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_PAUSE_THRESH_OFF</span><span class="p">,</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_off</span> <span class="o">/</span> <span class="n">RX_PAUSE_THRESH_QUANTUM</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_PAUSE_THRESH_ON</span><span class="p">,</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_on</span> <span class="o">/</span> <span class="n">RX_PAUSE_THRESH_QUANTUM</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_PAUSE_THRESH</span><span class="p">);</span>

	<span class="cm">/* zero out dma reassembly buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_TABLE_ADDR</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_TABLE_DATA_LOW</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_TABLE_DATA_MID</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_TABLE_DATA_HI</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* make sure address register is 0 for normal operation */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CTRL_FIFO_ADDR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_IPP_FIFO_ADDR</span><span class="p">);</span>

	<span class="cm">/* interrupt mitigation */</span>
<span class="cp">#ifdef USE_RX_BLANK</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_BLANK_INTR_TIME</span><span class="p">,</span> <span class="n">RX_BLANK_INTR_TIME_VAL</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_BLANK_INTR_PKT</span><span class="p">,</span> <span class="n">RX_BLANK_INTR_PKT_VAL</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_BLANK</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_BLANK</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* interrupt generation as a function of low water marks for</span>
<span class="cm">	 * free desc and completion entries. these are used to trigger</span>
<span class="cm">	 * housekeeping for rx descs. we don&#39;t use the free interrupt</span>
<span class="cm">	 * as it&#39;s not very useful</span>
<span class="cm">	 */</span>
	<span class="cm">/* val = CAS_BASE(RX_AE_THRESH_FREE, RX_AE_FREEN_VAL(0)); */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_AE_THRESH_COMP</span><span class="p">,</span> <span class="n">RX_AE_COMP_VAL</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_AE_THRESH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_AE1_THRESH_FREE</span><span class="p">,</span> <span class="n">RX_AE_FREEN_VAL</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_RX_AE1_THRESH</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Random early detect registers. useful for congestion avoidance.</span>
<span class="cm">	 * this should be tunable.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_RED</span><span class="p">);</span>

	<span class="cm">/* receive page sizes. default == 2K (0x800) */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">==</span> <span class="mh">0x1000</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">==</span> <span class="mh">0x2000</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">==</span> <span class="mh">0x4000</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>

	<span class="cm">/* round mtu + offset. constrain to page size. */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="mi">64</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mh">0x400</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mh">0x800</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mh">0x1000</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">mtu_stride</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">val</span>  <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_PAGE_SIZE</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_PAGE_SIZE_MTU_STRIDE</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_PAGE_SIZE_MTU_COUNT</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">));</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_PAGE_SIZE_MTU_OFF</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/* enable the header parser if desired */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CAS_HP_FIRMWARE</span> <span class="o">==</span> <span class="n">cas_prog_null</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_CFG_NUM_CPU</span><span class="p">,</span> <span class="n">CAS_NCPUS</span> <span class="o">&gt;</span> <span class="mi">63</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">CAS_NCPUS</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">HP_CFG_PARSE_EN</span> <span class="o">|</span> <span class="n">HP_CFG_SYN_INC_MASK</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">HP_CFG_TCP_THRESH</span><span class="p">,</span> <span class="n">HP_TCP_THRESH_VAL</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_CFG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_rxc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas_rx_comp</span> <span class="o">*</span><span class="n">rxc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rxc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rxc</span><span class="p">));</span>
	<span class="n">rxc</span><span class="o">-&gt;</span><span class="n">word4</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">RX_COMP4_ZERO</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* NOTE: we use the ENC RX DESC ring for spares. the rx_page[0,1]</span>
<span class="cm"> * flipping is protected by the fact that the chip will not</span>
<span class="cm"> * hand back the same page index while it&#39;s being processed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">cas_page_t</span> <span class="o">*</span><span class="nf">cas_page_spare</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">];</span>
	<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">cas_page_dequeue</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* this needs to be changed if we actually use the ENC RX DESC ring */</span>
<span class="k">static</span> <span class="n">cas_page_t</span> <span class="o">*</span><span class="nf">cas_page_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span>
				 <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_page_t</span> <span class="o">**</span><span class="n">page0</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">cas_page_t</span> <span class="o">**</span><span class="n">page1</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* swap if buffer is in use */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page0</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">cas_page_spare</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">page0</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
			<span class="n">page0</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">RX_USED_SET</span><span class="p">(</span><span class="n">page0</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page0</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_clean_rxds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* only clean ring 0 as ring 1 is used for spare buffers */</span>
        <span class="k">struct</span> <span class="n">cas_rx_desc</span> <span class="o">*</span><span class="n">rxd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* release all rx flows */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_FLOWS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_flows</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="p">{</span>
			<span class="n">cas_skb_release</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* initialize descriptors */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">cas_page_swap</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">rxd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
		<span class="n">rxd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span>  <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">|</span>
					    <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_old</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_last</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CAS_FLAG_RXD_POST</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_clean_rxcs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* take ownership of rx comp descriptors */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_cur</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_cur</span><span class="p">)</span><span class="o">*</span><span class="n">N_RX_COMP_RINGS</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_new</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_new</span><span class="p">)</span><span class="o">*</span><span class="n">N_RX_COMP_RINGS</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cas_rx_comp</span> <span class="o">*</span><span class="n">rxc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxcs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">RX_COMP_RINGN_SIZE</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cas_rxc_init</span><span class="p">(</span><span class="n">rxc</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* When we get a RX fifo overflow, the RX unit is probably hung</span>
<span class="c"> * so we do the following.</span>
<span class="c"> *</span>
<span class="c"> * If any part of the reset goes wrong, we return 1 and that causes the</span>
<span class="c"> * whole chip to be reset.</span>
<span class="c"> */</span>
<span class="c">static int cas_rxmac_reset(struct cas *cp)</span>
<span class="c">{</span>
<span class="c">	struct net_device *dev = cp-&gt;dev;</span>
<span class="c">	int limit;</span>
<span class="c">	u32 val;</span>

<span class="c">	/* First, reset MAC RX. */</span>
<span class="c">	writel(cp-&gt;mac_rx_cfg &amp; ~MAC_RX_CFG_EN, cp-&gt;regs + REG_MAC_RX_CFG);</span>
<span class="c">	for (limit = 0; limit &lt; STOP_TRIES; limit++) {</span>
<span class="c">		if (!(readl(cp-&gt;regs + REG_MAC_RX_CFG) &amp; MAC_RX_CFG_EN))</span>
<span class="c">			break;</span>
<span class="c">		udelay(10);</span>
<span class="c">	}</span>
<span class="c">	if (limit == STOP_TRIES) {</span>
<span class="c">		netdev_err(dev, &quot;RX MAC will not disable, resetting whole chip\n&quot;);</span>
<span class="c">		return 1;</span>
<span class="c">	}</span>

<span class="c">	/* Second, disable RX DMA. */</span>
<span class="c">	writel(0, cp-&gt;regs + REG_RX_CFG);</span>
<span class="c">	for (limit = 0; limit &lt; STOP_TRIES; limit++) {</span>
<span class="c">		if (!(readl(cp-&gt;regs + REG_RX_CFG) &amp; RX_CFG_DMA_EN))</span>
<span class="c">			break;</span>
<span class="c">		udelay(10);</span>
<span class="c">	}</span>
<span class="c">	if (limit == STOP_TRIES) {</span>
<span class="c">		netdev_err(dev, &quot;RX DMA will not disable, resetting whole chip\n&quot;);</span>
<span class="c">		return 1;</span>
<span class="c">	}</span>

<span class="c">	mdelay(5);</span>

<span class="c">	/* Execute RX reset command. */</span>
<span class="c">	writel(SW_RESET_RX, cp-&gt;regs + REG_SW_RESET);</span>
<span class="c">	for (limit = 0; limit &lt; STOP_TRIES; limit++) {</span>
<span class="c">		if (!(readl(cp-&gt;regs + REG_SW_RESET) &amp; SW_RESET_RX))</span>
<span class="c">			break;</span>
<span class="c">		udelay(10);</span>
<span class="c">	}</span>
<span class="c">	if (limit == STOP_TRIES) {</span>
<span class="c">		netdev_err(dev, &quot;RX reset command will not execute, resetting whole chip\n&quot;);</span>
<span class="c">		return 1;</span>
<span class="c">	}</span>

<span class="c">	/* reset driver rx state */</span>
<span class="c">	cas_clean_rxds(cp);</span>
<span class="c">	cas_clean_rxcs(cp);</span>

<span class="c">	/* Now, reprogram the rest of RX unit. */</span>
<span class="c">	cas_init_rx_dma(cp);</span>

<span class="c">	/* re-enable */</span>
<span class="c">	val = readl(cp-&gt;regs + REG_RX_CFG);</span>
<span class="c">	writel(val | RX_CFG_DMA_EN, cp-&gt;regs + REG_RX_CFG);</span>
<span class="c">	writel(MAC_RX_FRAME_RECV, cp-&gt;regs + REG_MAC_RX_MASK);</span>
<span class="c">	val = readl(cp-&gt;regs + REG_MAC_RX_CFG);</span>
<span class="c">	writel(val | MAC_RX_CFG_EN, cp-&gt;regs + REG_MAC_RX_CFG);</span>
<span class="c">	return 0;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_rxmac_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_dbg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rxmac interrupt, stat: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="cm">/* these are all rollovers */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">MAC_RX_ALIGN_ERR</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_frame_errors</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">MAC_RX_CRC_ERR</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_crc_errors</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">MAC_RX_LEN_ERR</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_length_errors</span> <span class="o">+=</span> <span class="mh">0x10000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">MAC_RX_OVERFLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_over_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_fifo_errors</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We do not track MAC_RX_FRAME_COUNT and MAC_RX_VIOL_ERR</span>
<span class="cm">	 * events.</span>
<span class="cm">	 */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_mac_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_CTRL_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;mac interrupt, stat: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>

	<span class="cm">/* This interrupt is just for pause frame and pause</span>
<span class="cm">	 * tracking.  It is useful for diagnostics and debug</span>
<span class="cm">	 * but probably by default we will mask these events.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">MAC_CTRL_PAUSE_STATE</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">pause_entered</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">MAC_CTRL_PAUSE_RECEIVED</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">pause_last_time_recvd</span> <span class="o">=</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cas_mdio_link_not_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">link_force_ret</span>:
		<span class="n">netif_info</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Autoneg failed again, keeping forced mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_fcntl</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_force_ok</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_CONFIG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">link_aneg</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>

		<span class="cm">/* Try forced modes. we try things in the following order:</span>
<span class="cm">		 * 1000 full -&gt; 100 full/half -&gt; 10 half</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BMCR_ANRESTART</span> <span class="o">|</span> <span class="n">BMCR_ANENABLE</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">BMCR_FULLDPLX</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_1000MB_CAP</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">CAS_BMCR_SPEED1000</span> <span class="o">:</span> <span class="n">BMCR_SPEED100</span><span class="p">;</span>
		<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_force_try</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_CONFIG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">link_force_try</span>:
		<span class="cm">/* Downgrade from 1000 to 100 to 10 Mbps if necessary. */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">CAS_BMCR_SPEED1000</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* gigabit */</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CAS_BMCR_SPEED1000</span><span class="p">;</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">BMCR_SPEED100</span> <span class="o">|</span> <span class="n">BMCR_FULLDPLX</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">BMCR_SPEED100</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">BMCR_FULLDPLX</span><span class="p">)</span> <span class="cm">/* fd failed */</span>
				<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BMCR_FULLDPLX</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span> <span class="cm">/* 100Mbps failed */</span>
				<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BMCR_SPEED100</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* must be invoked with cp-&gt;lock held */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_mii_link_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">bmsr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">restart</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmsr</span> <span class="o">&amp;</span> <span class="n">BMSR_LSTATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Ok, here we got a link. If we had it due to a forced</span>
<span class="cm">		 * fallback, and we were configured for autoneg, we</span>
<span class="cm">		 * retry a short autoneg pass. If you know your hub is</span>
<span class="cm">		 * broken, use ethtool ;)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">==</span> <span class="n">link_force_try</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_force_ret</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_CONFIG</span><span class="p">;</span>
			<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_fcntl</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span>
				<span class="n">netif_info</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					   <span class="s">&quot;Got link after fallback, retrying autoneg once...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">,</span>
				      <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_fcntl</span> <span class="o">|</span> <span class="n">BMCR_ANENABLE</span> <span class="o">|</span>
				      <span class="n">BMCR_ANRESTART</span><span class="p">);</span>
			<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">!=</span> <span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_up</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_UP</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cas_set_link_modes</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
				<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* link not up. if the link was previously up, we restart the</span>
<span class="cm">	 * whole process</span>
<span class="cm">	 */</span>
	<span class="n">restart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">==</span> <span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_down</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_DOWN</span><span class="p">;</span>

		<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span>
			<span class="n">netif_info</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Link down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">restart</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
		<span class="n">cas_mdio_link_not_up</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">restart</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_mif_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_STATUS</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">bmsr</span><span class="p">;</span>

	<span class="cm">/* check for a link change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">MIF_STATUS_POLL_STATUS</span><span class="p">,</span> <span class="n">stat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bmsr</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">MIF_STATUS_POLL_DATA</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cas_mii_link_check</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">bmsr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_pci_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCI_ERR_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI error [%04x:%04x]&quot;</span><span class="p">,</span>
		   <span class="n">stat</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_BIM_DIAG</span><span class="p">));</span>

	<span class="cm">/* cassini+ has this reserved */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_BADACK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; &lt;No ACK64# during ABS64 cycle&gt;&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_DTRTO</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; &lt;Delayed transaction timeout&gt;&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_OTHER</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; &lt;other&gt;&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_BIM_DMA_WRITE</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; &lt;BIM DMA 0 write req&gt;&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_BIM_DMA_READ</span><span class="p">)</span>
		<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot; &lt;BIM DMA 0 read req&gt;&quot;</span><span class="p">);</span>
	<span class="n">pr_cont</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">PCI_ERR_OTHER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">cfg</span><span class="p">;</span>

		<span class="cm">/* Interrogate PCI config space for the</span>
<span class="cm">		 * true cause.</span>
<span class="cm">		 */</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">);</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Read PCI cfg space status [%04x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_PARITY</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI parity error detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_SIG_TARGET_ABORT</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI target abort</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_REC_TARGET_ABORT</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI master acks target abort</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_REC_MASTER_ABORT</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI master abort</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_SIG_SYSTEM_ERROR</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI system error SERR#</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_DETECTED_PARITY</span><span class="p">)</span>
			<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;PCI parity error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Write the error bits back to clear them. */</span>
		<span class="n">cfg</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">PCI_STATUS_PARITY</span> <span class="o">|</span>
			<span class="n">PCI_STATUS_SIG_TARGET_ABORT</span> <span class="o">|</span>
			<span class="n">PCI_STATUS_REC_TARGET_ABORT</span> <span class="o">|</span>
			<span class="n">PCI_STATUS_REC_MASTER_ABORT</span> <span class="o">|</span>
			<span class="n">PCI_STATUS_SIG_SYSTEM_ERROR</span> <span class="o">|</span>
			<span class="n">PCI_STATUS_DETECTED_PARITY</span><span class="p">);</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="n">cfg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* For all PCI errors, we should reset the chip. */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* All non-normal interrupt conditions get serviced here.</span>
<span class="cm"> * Returns non-zero if we should just exit the interrupt</span>
<span class="cm"> * handler right now (ie. if we reset the card which invalidates</span>
<span class="cm"> * all of the other original irq status bits).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_abnormal_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_TAG_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* corrupt RX tag framing */</span>
		<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;corrupt rx tag framing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">do_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_LEN_MISMATCH</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* length mismatch. */</span>
		<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;length mismatch for rx frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">do_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_PCS_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cas_pcs_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">do_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_TX_MAC_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cas_txmac_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">do_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_MAC_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cas_rxmac_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">do_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_MAC_CTRL_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cas_mac_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">do_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_MIF_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cas_mif_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">do_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_PCI_ERROR_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cas_pci_interrupt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">do_reset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">do_reset:</span>
<span class="cp">#if 1</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">);</span>
	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reset called in cas_abnormal_irq [0x%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">,</span> <span class="n">CAS_RESET_ALL</span><span class="p">);</span>
	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;reset called in cas_abnormal_irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* NOTE: CAS_TABORT returns 1 or 2 so that it can be used when</span>
<span class="cm"> *       determining whether to do a netif_stop/wakeup</span>
<span class="cm"> */</span>
<span class="cp">#define CAS_TABORT(x)      (((x)-&gt;cas_flags &amp; CAS_FLAG_TARGET_ABORT) ? 2 : 1)</span>
<span class="cp">#define CAS_ROUND_PAGE(x)  (((x) + PAGE_SIZE - 1) &amp; PAGE_MASK)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cas_calc_tabort</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CAS_TABORT</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">CAS_ROUND_PAGE</span><span class="p">(</span><span class="n">off</span><span class="p">)</span> <span class="o">-</span> <span class="n">off</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TX_TARGET_ABORT_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">TX_TARGET_ABORT_LEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_tx_ringN</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas_tx_desc</span> <span class="o">*</span><span class="n">txds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>
	<span class="n">txds</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_txds</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="n">skbs</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_skbs</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_old</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">TX_BUFF_COUNT</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skbs</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>
		<span class="n">dma_addr_t</span> <span class="n">daddr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">dlen</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">frag</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this should never occur */</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">TX_DESC_NEXT</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* however, we might get only a partial skb release. */</span>
		<span class="n">count</span> <span class="o">-=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span>
			<span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">].</span><span class="n">nbufs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">tx_done</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			     <span class="s">&quot;tx[%d] done, slot %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

		<span class="n">skbs</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">].</span><span class="n">nbufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">frag</span> <span class="o">&lt;=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">frag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">cas_tx_desc</span> <span class="o">*</span><span class="n">txd</span> <span class="o">=</span> <span class="n">txds</span> <span class="o">+</span> <span class="n">entry</span><span class="p">;</span>

			<span class="n">daddr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
			<span class="n">dlen</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">TX_DESC_BUFLEN</span><span class="p">,</span>
				       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">txd</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">));</span>
			<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span>
				       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">TX_DESC_NEXT</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

			<span class="cm">/* tiny buffer may follow */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">].</span><span class="n">used</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">].</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">entry</span> <span class="o">=</span> <span class="n">TX_DESC_NEXT</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="n">ring</span><span class="p">].</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="n">ring</span><span class="p">].</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_old</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

	<span class="cm">/* this is wrong for multiple tx rings. the net device needs</span>
<span class="cm">	 * multiple queues for this to do the right thing.  we wait</span>
<span class="cm">	 * for 2*packets to be available when using tiny buffers</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">TX_BUFFS_AVAIL</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">CAS_TABORT</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span>
		   <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">limit</span><span class="p">,</span> <span class="n">ring</span><span class="p">;</span>
<span class="cp">#ifdef USE_TX_COMPWB</span>
	<span class="n">u64</span> <span class="n">compwb</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">tx_compwb</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;tx interrupt, status: 0x%x, %llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">status</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">compwb</span><span class="p">);</span>
	<span class="cm">/* process all the rings */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ring</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ring</span> <span class="o">&lt;</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">ring</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef USE_TX_COMPWB</span>
		<span class="cm">/* use the completion writeback registers */</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">TX_COMPWB_MSB</span><span class="p">,</span> <span class="n">compwb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">CAS_VAL</span><span class="p">(</span><span class="n">TX_COMPWB_LSB</span><span class="p">,</span> <span class="n">compwb</span><span class="p">);</span>
		<span class="n">compwb</span> <span class="o">=</span> <span class="n">TX_COMPWB_NEXT</span><span class="p">(</span><span class="n">compwb</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_COMPN</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_old</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">!=</span> <span class="n">limit</span><span class="p">)</span>
			<span class="n">cas_tx_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_rx_process_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas_rx_comp</span> <span class="o">*</span><span class="n">rxc</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">words</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skbref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dlen</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="n">swivel</span> <span class="o">=</span> <span class="n">RX_SWIVEL_OFF_VAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cas_page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">crcaddr</span><span class="p">;</span>
	<span class="n">__sum16</span> <span class="n">csum</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">hlen</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP2_HDR_SIZE</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">dlen</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP1_DATA_SIZE</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">len</span>  <span class="o">=</span> <span class="n">hlen</span> <span class="o">+</span> <span class="n">dlen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">RX_COPY_ALWAYS</span> <span class="o">||</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP3_SMALL_PKT</span><span class="p">))</span>
		<span class="n">alloclen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">alloclen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">hlen</span><span class="p">,</span> <span class="n">RX_COPY_MIN</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">alloclen</span> <span class="o">+</span> <span class="n">swivel</span> <span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">skbref</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">swivel</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">crcaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hlen</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* always copy header pages */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP2_HDR_INDEX</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">i</span><span class="p">)][</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">)];</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP2_HDR_OFF</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mh">0x100</span> <span class="o">+</span>
			<span class="n">swivel</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">hlen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlen</span><span class="p">)</span> <span class="cm">/* attach FCS */</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">;</span>
		<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">cas_page_map</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">cas_page_unmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">RX_USED_ADD</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">hlen</span><span class="p">;</span>
		<span class="n">swivel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">alloclen</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">hlen</span> <span class="o">+</span> <span class="n">dlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">;</span>

		<span class="cm">/* normal or jumbo packets. we use frags */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP1_DATA_INDEX</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">i</span><span class="p">)][</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">)];</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP1_DATA_OFF</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">swivel</span><span class="p">;</span>

		<span class="n">hlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">-</span> <span class="n">off</span><span class="p">,</span> <span class="n">dlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;rx page overflow: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">hlen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">dlen</span><span class="p">)</span>  <span class="cm">/* attach FCS */</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">;</span>
		<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

		<span class="cm">/* make sure we always copy a header */</span>
		<span class="n">swivel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* not split */</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">cas_page_map</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">RX_COPY_MIN</span><span class="p">);</span>
			<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">cas_page_unmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">off</span> <span class="o">+=</span> <span class="n">RX_COPY_MIN</span><span class="p">;</span>
			<span class="n">swivel</span> <span class="o">=</span> <span class="n">RX_COPY_MIN</span><span class="p">;</span>
			<span class="n">RX_USED_ADD</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">mtu_stride</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">RX_USED_ADD</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">);</span>

		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">hlen</span> <span class="o">-</span> <span class="n">swivel</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">hlen</span> <span class="o">-</span> <span class="n">swivel</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>      <span class="o">+=</span> <span class="n">hlen</span> <span class="o">-</span> <span class="n">swivel</span><span class="p">;</span>

		<span class="n">__skb_frag_set_page</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
		<span class="n">__skb_frag_ref</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
		<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">hlen</span> <span class="o">-</span> <span class="n">swivel</span><span class="p">);</span>

		<span class="cm">/* any more data? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP1_SPLIT_PKT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">dlen</span> <span class="o">-=</span> <span class="n">hlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hlen</span> <span class="o">=</span> <span class="n">dlen</span><span class="p">;</span>
			<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP2_NEXT_INDEX</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">i</span><span class="p">)][</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">)];</span>
			<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
					    <span class="n">hlen</span> <span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
					    <span class="n">hlen</span> <span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">hlen</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>      <span class="o">+=</span> <span class="n">hlen</span><span class="p">;</span>
			<span class="n">frag</span><span class="o">++</span><span class="p">;</span>

			<span class="n">__skb_frag_set_page</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
			<span class="n">__skb_frag_ref</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
			<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
			<span class="n">RX_USED_ADD</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">hlen</span> <span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">cas_page_map</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
			<span class="n">crcaddr</span>  <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">off</span> <span class="o">+</span> <span class="n">hlen</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* copying packet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlen</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_copy_pkt</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP1_DATA_INDEX</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">i</span><span class="p">)][</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">)];</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP1_DATA_OFF</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">swivel</span><span class="p">;</span>
		<span class="n">hlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">-</span> <span class="n">off</span><span class="p">,</span> <span class="n">dlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">rx_err</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;rx page overflow: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">hlen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">dlen</span><span class="p">)</span> <span class="cm">/* attach FCS */</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">;</span>
		<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">cas_page_map</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
				    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">cas_page_unmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="cm">/* not split */</span>
			<span class="n">RX_USED_ADD</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">mtu_stride</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">RX_USED_ADD</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/* any more data? */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP1_SPLIT_PKT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">dlen</span> <span class="o">-=</span> <span class="n">hlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">hlen</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP2_NEXT_INDEX</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">i</span><span class="p">)][</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">)];</span>
			<span class="n">pci_dma_sync_single_for_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
					    <span class="n">dlen</span> <span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">cas_page_map</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dlen</span> <span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">);</span>
			<span class="n">pci_dma_sync_single_for_device</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">,</span>
					    <span class="n">dlen</span> <span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">,</span>
					    <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
			<span class="n">cas_page_unmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">RX_USED_ADD</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">dlen</span> <span class="o">+</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">end_copy_pkt:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span>    <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">crcaddr</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">alloclen</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">csum</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__sum16</span><span class="p">)</span><span class="n">htons</span><span class="p">(</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP4_TCP_CSUM</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">]));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* checksum includes FCS. strip it out. */</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="n">csum_fold</span><span class="p">(</span><span class="n">csum_partial</span><span class="p">(</span><span class="n">crcaddr</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">,</span>
					      <span class="n">csum_unfold</span><span class="p">(</span><span class="n">csum</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span>
			<span class="n">cas_page_unmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_unfold</span><span class="p">(</span><span class="o">~</span><span class="n">csum</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* we can handle up to 64 rx flows at a time. we do the same thing</span>
<span class="cm"> * as nonreassm except that we batch up the buffers.</span>
<span class="cm"> * NOTE: we currently just treat each flow as a bunch of packets that</span>
<span class="cm"> *       we pass up. a better way would be to coalesce the packets</span>
<span class="cm"> *       into a jumbo packet. to do that, we need to do the following:</span>
<span class="cm"> *       1) the first packet will have a clean split between header and</span>
<span class="cm"> *          data. save both.</span>
<span class="cm"> *       2) each time the next flow packet comes in, extend the</span>
<span class="cm"> *          data length and merge the checksums.</span>
<span class="cm"> *       3) on flow release, fix up the header.</span>
<span class="cm"> *       4) make sure the higher layer doesn&#39;t care.</span>
<span class="cm"> * because packets get coalesced, we shouldn&#39;t run into fragment count</span>
<span class="cm"> * issues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_rx_flow_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">words</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flowid</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP3_FLOWID</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">N_RX_FLOWS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">flow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_flows</span><span class="p">[</span><span class="n">flowid</span><span class="p">];</span>

	<span class="cm">/* this is protected at a higher layer, so no need to</span>
<span class="cm">	 * do any additional locking here. stick the buffer</span>
<span class="cm">	 * at the end.</span>
<span class="cm">	 */</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP1_RELEASE_FLOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="n">flow</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">cas_skb_release</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* put rx descriptor back on ring. if a buffer is in use by a higher</span>
<span class="cm"> * layer, this will need to put in a replacement.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_post_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_old</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">cas_page_swap</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxds</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">].</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxds</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">].</span><span class="n">index</span>  <span class="o">=</span>
		<span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">|</span>
			    <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">ring</span><span class="p">));</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">RX_DESC_ENTRY</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_old</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_KICK</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">N_RX_DESC_RINGS</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_RX_KICK1</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* only when things are bad */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_post_rxds_ringN</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">released</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cluster</span><span class="p">;</span>
	<span class="n">cas_page_t</span> <span class="o">**</span><span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_old</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;rxd[%d] interrupt, done: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="n">cluster</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">entry</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">;</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">RX_DESC_ENTRY</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">num</span> <span class="o">?</span> <span class="n">entry</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">4</span><span class="o">:</span> <span class="n">entry</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">released</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* make a new buffer if it&#39;s still in use */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cas_page_t</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">cas_page_dequeue</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* let the timer know that we need to</span>
<span class="cm">				 * do this again</span>
<span class="cm">				 */</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_RXD_POST</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">))</span>
					<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span>
						  <span class="n">CAS_LINK_FAST_TIMEOUT</span><span class="p">);</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_old</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span>  <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_last</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">?</span> <span class="n">num</span> <span class="o">-</span> <span class="n">released</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxds</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">].</span><span class="n">buffer</span> <span class="o">=</span>
				<span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">dma_addr</span><span class="p">);</span>
			<span class="n">page</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cluster</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">released</span><span class="o">++</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">RX_DESC_ENTRY</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_old</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cluster</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_KICK</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">N_RX_DESC_RINGS</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_RX_KICK1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* process a completion ring. packets are set up in three basic ways:</span>
<span class="cm"> * small packets: should be copied header + data in single buffer.</span>
<span class="cm"> * large packets: header and data in a single buffer.</span>
<span class="cm"> * split packets: header in a separate buffer from data.</span>
<span class="cm"> *                data may be in multiple pages. data may be &gt; 256</span>
<span class="cm"> *                bytes but in a single page.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: RX page posting is done in this routine as well. while there&#39;s</span>
<span class="cm"> *       the capability of using multiple RX completion rings, it isn&#39;t</span>
<span class="cm"> *       really worthwhile due to the fact that the page posting will</span>
<span class="cm"> *       force serialization on the single descriptor ring.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_rx_ringN</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas_rx_comp</span> <span class="o">*</span><span class="n">rxcs</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxcs</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="n">drops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">npackets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;rx[%d] interrupt, done: %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ring</span><span class="p">,</span>
		     <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_COMP_HEAD</span><span class="p">),</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_new</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_new</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="n">drops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cas_rx_comp</span> <span class="o">*</span><span class="n">rxc</span> <span class="o">=</span> <span class="n">rxcs</span> <span class="o">+</span> <span class="n">entry</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">words</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">dring</span><span class="p">;</span>

		<span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rxc</span><span class="o">-&gt;</span><span class="n">word1</span><span class="p">);</span>
		<span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rxc</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rxc</span><span class="o">-&gt;</span><span class="n">word3</span><span class="p">);</span>
		<span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">rxc</span><span class="o">-&gt;</span><span class="n">word4</span><span class="p">);</span>

		<span class="cm">/* don&#39;t touch if still owned by hw */</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP1_TYPE</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* hw hasn&#39;t cleared the zero bit yet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP4_ZERO</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* get info on the packet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RX_COMP4_LEN_MISMATCH</span> <span class="o">|</span> <span class="n">RX_COMP4_BAD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="n">ring</span><span class="p">].</span><span class="n">rx_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP4_LEN_MISMATCH</span><span class="p">)</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="n">ring</span><span class="p">].</span><span class="n">rx_length_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP4_BAD</span><span class="p">)</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="n">ring</span><span class="p">].</span><span class="n">rx_crc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>

			<span class="cm">/* We&#39;ll just return it to Cassini. */</span>
		<span class="nl">drop_it:</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>
			<span class="o">++</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="n">ring</span><span class="p">].</span><span class="n">rx_dropped</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">cas_rx_process_pkt</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">rxc</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">drops</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">drop_it</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* see if it&#39;s a flow re-assembly or not. the driver</span>
<span class="cm">		 * itself handles release back up.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">RX_DONT_BATCH</span> <span class="o">||</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* non-reassm: these always get released */</span>
			<span class="n">cas_skb_release</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cas_rx_flow_pkt</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="n">ring</span><span class="p">].</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="n">ring</span><span class="p">].</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">]);</span>

	<span class="nl">next:</span>
		<span class="n">npackets</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* should it be released? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP1_RELEASE_HDR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP2_HDR_INDEX</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">dring</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">cas_post_page</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">dring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP1_RELEASE_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP1_DATA_INDEX</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">dring</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">cas_post_page</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">dring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RX_COMP1_RELEASE_NEXT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP2_NEXT_INDEX</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">dring</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_RING</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_INDEX_NUM</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">cas_post_page</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">dring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* skip to the next entry */</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">RX_COMP_ENTRY</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span>
				      <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">RX_COMP1_SKIP</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="cp">#ifdef USE_NAPI</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">budget</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">npackets</span> <span class="o">&gt;=</span> <span class="n">budget</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_new</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drops</span><span class="p">)</span>
		<span class="n">netdev_info</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory squeeze, deferring packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">npackets</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* put completion entries back on the ring */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_post_rxcs_ringN</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas_rx_comp</span> <span class="o">*</span><span class="n">rxc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxcs</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">last</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_cur</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_new</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">intr</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;rxc[%d] interrupt, done: %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ring</span><span class="p">,</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_COMP_HEAD</span><span class="p">),</span> <span class="n">entry</span><span class="p">);</span>

	<span class="cm">/* zero and re-mark descriptors */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">last</span> <span class="o">!=</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_rxc_init</span><span class="p">(</span><span class="n">rxc</span> <span class="o">+</span> <span class="n">last</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">RX_COMP_ENTRY</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_cur</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_COMP_TAIL</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_RX_COMPN_TAIL</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
<span class="p">}</span>



<span class="cm">/* cassini can use all four PCI interrupts for the completion ring.</span>
<span class="cm"> * rings 3 and 4 are identical</span>
<span class="cm"> */</span>
<span class="cp">#if defined(USE_PCI_INTC) || defined(USE_PCI_INTD)</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_handle_irqN</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">status</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_RX_COMP_FULL_ALT</span> <span class="o">|</span> <span class="n">INTR_RX_COMP_AF_ALT</span><span class="p">))</span>
		<span class="n">cas_post_rxcs_ringN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">cas_interruptN</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ring</span> <span class="o">=</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">pci_irq_INTC</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_INTRN_STATUS</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>

	<span class="cm">/* check for shared irq */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_DONE_ALT</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* handle rx separately */</span>
<span class="cp">#ifdef USE_NAPI</span>
		<span class="n">cas_mask_intr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">cas_rx_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INTR_RX_DONE_ALT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">cas_handle_irqN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">ring</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef USE_PCI_INTB</span>
<span class="cm">/* everything but rx packets */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_handle_irq1</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_BUF_UNAVAIL_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Frame arrived, no free RX buffers available.</span>
<span class="cm">		 * NOTE: we can get this on a link transition. */</span>
		<span class="n">cas_post_rxds_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_BUF_AE_1</span><span class="p">)</span>
		<span class="n">cas_post_rxds_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
				    <span class="n">RX_AE_FREEN_VAL</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_RX_COMP_AF</span> <span class="o">|</span> <span class="n">INTR_RX_COMP_FULL</span><span class="p">))</span>
		<span class="n">cas_post_rxcs_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ring 2 handles a few more events than 3 and 4 */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">cas_interrupt1</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_INTRN_STATUS</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* check for shared interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_DONE_ALT</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* handle rx separately */</span>
<span class="cp">#ifdef USE_NAPI</span>
		<span class="n">cas_mask_intr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">cas_rx_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INTR_RX_DONE_ALT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">cas_handle_irq1</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_handle_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* housekeeping interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_ERROR_MASK</span><span class="p">)</span>
		<span class="n">cas_abnormal_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_BUF_UNAVAIL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Frame arrived, no free RX buffers available.</span>
<span class="cm">		 * NOTE: we can get this on a link transition.</span>
<span class="cm">		 */</span>
		<span class="n">cas_post_rxds_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_BUF_AE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_post_rxds_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span>
				    <span class="n">RX_AE_FREEN_VAL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_RX_COMP_AF</span> <span class="o">|</span> <span class="n">INTR_RX_COMP_FULL</span><span class="p">))</span>
		<span class="n">cas_post_rxcs_ringN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">cas_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_INTR_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTR_TX_ALL</span> <span class="o">|</span> <span class="n">INTR_TX_INTME</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cas_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">INTR_TX_ALL</span> <span class="o">|</span> <span class="n">INTR_TX_INTME</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">INTR_RX_DONE</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef USE_NAPI</span>
		<span class="n">cas_mask_intr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">cas_rx_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">INTR_RX_DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">cas_handle_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef USE_NAPI</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">enable_intr</span><span class="p">,</span> <span class="n">credits</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_INTR_STATUS</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cas_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* NAPI rx packets. we spread the credits across all of the</span>
<span class="cm">	 * rxc rings</span>
<span class="cm">	 *</span>
<span class="cm">	 * to make sure we&#39;re fair with the work we loop through each</span>
<span class="cm">	 * ring N_RX_COMP_RING times with a request of</span>
<span class="cm">	 * budget / N_RX_COMP_RINGS</span>
<span class="cm">	 */</span>
	<span class="n">enable_intr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">credits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">credits</span> <span class="o">+=</span> <span class="n">cas_rx_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">budget</span> <span class="o">/</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">credits</span> <span class="o">&gt;=</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">enable_intr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">rx_comp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">rx_comp:</span>
	<span class="cm">/* final rx completion */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">cas_handle_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

<span class="cp">#ifdef USE_PCI_INTB</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">N_RX_COMP_RINGS</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_INTRN_STATUS</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">cas_handle_irq1</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef USE_PCI_INTC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">N_RX_COMP_RINGS</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_INTRN_STATUS</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">cas_handle_irqN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef USE_PCI_INTD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">N_RX_COMP_RINGS</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_INTRN_STATUS</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">cas_handle_irqN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enable_intr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="n">cas_unmask_intr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">credits</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">cas_disable_irq</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cas_interrupt</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">cas_enable_irq</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef USE_PCI_INTB</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">N_RX_COMP_RINGS</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cas_interrupt1(); */</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef USE_PCI_INTC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">N_RX_COMP_RINGS</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cas_interruptN(); */</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef USE_PCI_INTD</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">N_RX_COMP_RINGS</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cas_interruptN(); */</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;transmit timed out, resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hrm.. hw not running!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MIF_STATE[%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_STATE_MACHINE</span><span class="p">));</span>

	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;MAC_STATE[%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_STATE_MACHINE</span><span class="p">));</span>

	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX_STATE[%08x:%08x:%08x] FIFO[%08x:%08x:%08x] SM1[%08x] SM2[%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_CFG</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_STATUS</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_CFG</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_FIFO_PKT_CNT</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_FIFO_WRITE_PTR</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_FIFO_READ_PTR</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_SM_1</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_SM_2</span><span class="p">));</span>

	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RX_STATE[%08x:%08x:%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CFG</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_STATUS</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">));</span>

	<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;HP_STATE[%08x:%08x:%08x:%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_STATE_MACHINE</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_STATUS0</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_STATUS1</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_HP_STATUS2</span><span class="p">));</span>

<span class="cp">#if 1</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">,</span> <span class="n">CAS_RESET_ALL</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cas_intme</span><span class="p">(</span><span class="kt">int</span> <span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Algorithm: IRQ every 1/2 of descriptors. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">entry</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">TX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_write_txd</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span>
			  <span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ctrl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas_tx_desc</span> <span class="o">*</span><span class="n">txd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_txds</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">+</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">TX_DESC_BUFLEN</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cas_intme</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">))</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">TX_DESC_INTME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">TX_DESC_EOF</span><span class="p">;</span>
	<span class="n">txd</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">txd</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">tx_tiny_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_bufs</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">+</span> <span class="n">TX_TINY_BUF_LEN</span><span class="o">*</span><span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">dma_addr_t</span> <span class="nf">tx_tiny_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">tentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">tentry</span><span class="p">].</span><span class="n">nbufs</span><span class="o">++</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">].</span><span class="n">used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_dvma</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">+</span> <span class="n">TX_TINY_BUF_LEN</span><span class="o">*</span><span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cas_xmit_tx_ringN</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">entry</span><span class="p">,</span> <span class="n">nr_frags</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span> <span class="n">tabort</span><span class="p">,</span> <span class="n">tentry</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">mapping</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* This is a hard error, log it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TX_BUFFS_AVAIL</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span> <span class="o">&lt;=</span>
	    <span class="n">CAS_TABORT</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BUG! Tx Ring full when queue awake!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="n">csum_start_off</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">const</span> <span class="n">u64</span> <span class="n">csum_stuff_off</span> <span class="o">=</span> <span class="n">csum_start_off</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>

		<span class="n">ctrl</span> <span class="o">=</span>  <span class="n">TX_DESC_CSUM_EN</span> <span class="o">|</span>
			<span class="n">CAS_BASE</span><span class="p">(</span><span class="n">TX_DESC_CSUM_START</span><span class="p">,</span> <span class="n">csum_start_off</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">CAS_BASE</span><span class="p">(</span><span class="n">TX_DESC_CSUM_STUFF</span><span class="p">,</span> <span class="n">csum_stuff_off</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_new</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_skbs</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">nr_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="n">pci_map_page</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
			       <span class="n">offset_in_page</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span>
			       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

	<span class="n">tentry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">tabort</span> <span class="o">=</span> <span class="n">cas_calc_tabort</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tabort</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* NOTE: len is always &gt;  tabort */</span>
		<span class="n">cas_write_txd</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">tabort</span><span class="p">,</span>
			      <span class="n">ctrl</span> <span class="o">|</span> <span class="n">TX_DESC_SOF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">TX_DESC_NEXT</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

		<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">tabort</span><span class="p">,</span>
			      <span class="n">tx_tiny_buf</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">),</span> <span class="n">tabort</span><span class="p">);</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">tx_tiny_map</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">tentry</span><span class="p">);</span>
		<span class="n">cas_write_txd</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">tabort</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">nr_frags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cas_write_txd</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ctrl</span> <span class="o">|</span>
			      <span class="n">TX_DESC_SOF</span><span class="p">,</span> <span class="p">(</span><span class="n">nr_frags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">TX_DESC_NEXT</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">frag</span> <span class="o">&lt;</span> <span class="n">nr_frags</span><span class="p">;</span> <span class="n">frag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">fragp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">frag</span><span class="p">];</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">fragp</span><span class="p">);</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">fragp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					   <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

		<span class="n">tabort</span> <span class="o">=</span> <span class="n">cas_calc_tabort</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">fragp</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tabort</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

			<span class="cm">/* NOTE: len is always &gt; tabort */</span>
			<span class="n">cas_write_txd</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">tabort</span><span class="p">,</span>
				      <span class="n">ctrl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">TX_DESC_NEXT</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

			<span class="n">addr</span> <span class="o">=</span> <span class="n">cas_page_map</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">fragp</span><span class="p">));</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">tx_tiny_buf</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">),</span>
			       <span class="n">addr</span> <span class="o">+</span> <span class="n">fragp</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">tabort</span><span class="p">,</span>
			       <span class="n">tabort</span><span class="p">);</span>
			<span class="n">cas_page_unmap</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">mapping</span> <span class="o">=</span> <span class="n">tx_tiny_map</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">tentry</span><span class="p">);</span>
			<span class="n">len</span>     <span class="o">=</span> <span class="n">tabort</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cas_write_txd</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">frag</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">nr_frags</span><span class="p">));</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">TX_DESC_NEXT</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_new</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TX_BUFFS_AVAIL</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">CAS_TABORT</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">tx_queued</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span>
		     <span class="s">&quot;tx[%d] queued, slot %d, skblen %d, avail %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">ring</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">TX_BUFFS_AVAIL</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_KICKN</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">[</span><span class="n">ring</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">cas_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* this is only used as a load-balancing hint, so it doesn&#39;t</span>
<span class="cm">	 * need to be SMP safe</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_padto</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">min_frame_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>

	<span class="cm">/* XXX: we need some higher-level QoS hooks to steer packets to</span>
<span class="cm">	 *      individual queues.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cas_xmit_tx_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ring</span><span class="o">++</span> <span class="o">&amp;</span> <span class="n">N_TX_RINGS_MASK</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_init_tx_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">desc_dma</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">block_dvma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* set up tx completion writeback registers. must be 8-byte aligned */</span>
<span class="cp">#ifdef USE_TX_COMPWB</span>
	<span class="n">off</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas_init_block</span><span class="p">,</span> <span class="n">tx_compwb</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_COMPWB_DB_HI</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_COMPWB_DB_LOW</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* enable completion writebacks, enable paced mode,</span>
<span class="cm">	 * disable read pipe, and disable pre-interrupt compwbs</span>
<span class="cm">	 */</span>
	<span class="n">val</span> <span class="o">=</span>   <span class="n">TX_CFG_COMPWB_Q1</span> <span class="o">|</span> <span class="n">TX_CFG_COMPWB_Q2</span> <span class="o">|</span>
		<span class="n">TX_CFG_COMPWB_Q3</span> <span class="o">|</span> <span class="n">TX_CFG_COMPWB_Q4</span> <span class="o">|</span>
		<span class="n">TX_CFG_DMA_RDPIPE_DIS</span> <span class="o">|</span> <span class="n">TX_CFG_PACED_MODE</span> <span class="o">|</span>
		<span class="n">TX_CFG_INTR_COMPWB_DIS</span><span class="p">;</span>

	<span class="cm">/* write out tx ring info and tx desc bases */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_TX_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_txds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">|=</span> <span class="n">CAS_TX_RINGN_BASE</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_DBN_HI</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">desc_dma</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
		       <span class="n">REG_TX_DBN_LOW</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="cm">/* don&#39;t zero out the kick register here as the system</span>
<span class="cm">		 * will wedge</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_CFG</span><span class="p">);</span>

	<span class="cm">/* program max burst sizes. these numbers should be different</span>
<span class="cm">	 * if doing QoS.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef USE_QOS</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x800</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_MAXBURST_0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x1600</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_MAXBURST_1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x2400</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_MAXBURST_2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x4800</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_MAXBURST_3</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x800</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_MAXBURST_0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x800</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_MAXBURST_1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x800</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_MAXBURST_2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x800</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_MAXBURST_3</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_init_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_init_tx_dma</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_init_rx_dma</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_process_mc_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">hash_table</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">crc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">hash_table</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hash_table</span><span class="p">));</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">CAS_MC_EXACT_MATCH_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* use the alternate mac address registers for the</span>
<span class="cm">			 * first 15 multicast addresses</span>
<span class="cm">			 */</span>
			<span class="n">writel</span><span class="p">((</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
			       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">0</span><span class="p">));</span>
			<span class="n">writel</span><span class="p">((</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
			<span class="n">writel</span><span class="p">((</span><span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* use hw hash table for the next series of</span>
<span class="cm">			 * multicast addresses</span>
<span class="cm">			 */</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="n">ether_crc_le</span><span class="p">(</span><span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">crc</span> <span class="o">&gt;&gt;=</span> <span class="mi">24</span><span class="p">;</span>
			<span class="n">hash_table</span><span class="p">[</span><span class="n">crc</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">15</span> <span class="o">-</span> <span class="p">(</span><span class="n">crc</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">hash_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_HASH_TABLEN</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">cas_setup_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rxcfg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rxcfg</span> <span class="o">|=</span> <span class="n">MAC_RX_CFG_PROMISC_EN</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
	    	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFF</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_HASH_TABLEN</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
		<span class="n">rxcfg</span> <span class="o">|=</span> <span class="n">MAC_RX_CFG_HASH_FILTER_EN</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cas_process_mc_list</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">rxcfg</span> <span class="o">|=</span> <span class="n">MAC_RX_CFG_HASH_FILTER_EN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rxcfg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* must be invoked under cp-&gt;stat_lock[N_TX_RINGS] */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_clear_mac_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_NORMAL</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_FIRST</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_EXCESS</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_LATE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TIMER_DEFER</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ATTEMPTS_PEAK</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RECV_FRAME</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_LEN_ERR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ALIGN_ERR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_FCS_ERR</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CODE_ERR</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_mac_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* do both TX and RX reset */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_RESET</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_RESET</span><span class="p">);</span>

	<span class="cm">/* wait for TX */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">STOP_TRIES</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_RESET</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* wait for RX */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">STOP_TRIES</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_RESET</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_RESET</span><span class="p">)</span> <span class="o">|</span>
	    <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_RESET</span><span class="p">))</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mac tx[%d]/rx[%d] reset failed [%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_RESET</span><span class="p">),</span>
			   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_RESET</span><span class="p">),</span>
			   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_STATE_MACHINE</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_init_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">cas_mac_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="cm">/* setup core arbitration weight register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">CAWR_RR_DIS</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_CAWR</span><span class="p">);</span>

	<span class="cm">/* XXX Use pci_dma_burst_advice() */</span>
<span class="cp">#if !defined(CONFIG_SPARC64) &amp;&amp; !defined(CONFIG_ALPHA)</span>
	<span class="cm">/* set the infinite burst register for chips that don&#39;t have</span>
<span class="cm">	 * pci issues.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_TARGET_ABORT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">INF_BURST_EN</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_INF_BURST</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">writel</span><span class="p">(</span><span class="mh">0x1BF0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_SEND_PAUSE</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_IPG0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x08</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_IPG1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x04</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_IPG2</span><span class="p">);</span>

	<span class="cm">/* change later for 802.3z */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_SLOT_TIME</span><span class="p">);</span>

	<span class="cm">/* min frame + FCS */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">ETH_ZLEN</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_FRAMESIZE_MIN</span><span class="p">);</span>

	<span class="cm">/* Ethernet payload + header + FCS + optional VLAN tag. NOTE: we</span>
<span class="cm">	 * specify the maximum frame size to prevent RX tag errors on</span>
<span class="cm">	 * oversized frames.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">CAS_BASE</span><span class="p">(</span><span class="n">MAC_FRAMESIZE_MAX_BURST</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">)</span> <span class="o">|</span>
	       <span class="n">CAS_BASE</span><span class="p">(</span><span class="n">MAC_FRAMESIZE_MAX_FRAME</span><span class="p">,</span>
			<span class="p">(</span><span class="n">CAS_MAX_MTU</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)),</span>
	       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_FRAMESIZE_MAX</span><span class="p">);</span>

	<span class="cm">/* NOTE: crc_size is used as a surrogate for half-duplex.</span>
<span class="cm">	 * workaround saturn half-duplex issue by increasing preamble</span>
<span class="cm">	 * size to 65 bytes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_SATURN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x41</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_PA_SIZE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x07</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_PA_SIZE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x04</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_JAM_SIZE</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ATTEMPT_LIMIT</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x8808</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_CTRL_TYPE</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RANDOM_SEED</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDR_FILTER0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDR_FILTER1</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDR_FILTER2</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDR_FILTER2_1_MASK</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDR_FILTER0_MASK</span><span class="p">);</span>

	<span class="cm">/* setup mac address in perfect filter array */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">45</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="n">writel</span><span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>

	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0001</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xc200</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="mi">43</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0x0180</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ADDRN</span><span class="p">(</span><span class="mi">44</span><span class="p">));</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">mac_rx_cfg</span> <span class="o">=</span> <span class="n">cas_setup_multicast</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">]);</span>
	<span class="n">cas_clear_mac_err</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">]);</span>

	<span class="cm">/* Setup MAC interrupts.  We want to get all of the interesting</span>
<span class="cm">	 * counter expiration events, but we do not want to hear about</span>
<span class="cm">	 * normal rx/tx as the DMA engine tells us that.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">MAC_TX_FRAME_XMIT</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_MASK</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">MAC_RX_FRAME_RECV</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_MASK</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t enable even the PAUSE interrupts for now, we</span>
<span class="cm">	 * make no use of those events other than to record them.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_CTRL_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_init_pause_thresholds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Calculate pause thresholds.  Setting the OFF threshold to the</span>
<span class="cm">	 * full RX fifo size effectively disables PAUSE generation</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_fifo_size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_off</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_on</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_fifo_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">max_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">63</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_fifo_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_off</span> <span class="o">=</span> <span class="mi">7104</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_on</span>  <span class="o">=</span> <span class="mi">960</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_fifo_size</span> <span class="o">-</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>
			<span class="kt">int</span> <span class="n">on</span> <span class="o">=</span> <span class="n">off</span> <span class="o">-</span> <span class="n">max_frame</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_off</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_on</span> <span class="o">=</span> <span class="n">on</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_vpd_match</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* get the mac address by reading the vpd information in the rom.</span>
<span class="cm"> * also get the phy type and determine if there&#39;s an entropy generator.</span>
<span class="cm"> * NOTE: this is a bit convoluted for the following reasons:</span>
<span class="cm"> *  1) vpd info has order-dependent mac addresses for multinic cards</span>
<span class="cm"> *  2) the only way to determine the nic order is to use the slot</span>
<span class="cm"> *     number.</span>
<span class="cm"> *  3) fiber cards don&#39;t have bridges, so their slot numbers don&#39;t</span>
<span class="cm"> *     mean anything.</span>
<span class="cm"> *  4) we don&#39;t actually know we have a fiber card until after</span>
<span class="cm"> *     the mac addresses are parsed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_get_vpd_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_addr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_EXPANSION_ROM_RUN_START</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">kstart</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#define VPD_FOUND_MAC        0x01</span>
<span class="cp">#define VPD_FOUND_PHY        0x02</span>

	<span class="kt">int</span> <span class="n">phy_type</span> <span class="o">=</span> <span class="n">CAS_PHY_MII_MDIO0</span><span class="p">;</span> <span class="cm">/* default phy type */</span>
	<span class="kt">int</span> <span class="n">mac_off</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_SPARC)</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* give us access to the PROM */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BIM_LOCAL_DEV_PROM</span> <span class="o">|</span> <span class="n">BIM_LOCAL_DEV_PAD</span><span class="p">,</span>
	       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_BIM_LOCAL_DEV_EN</span><span class="p">);</span>

	<span class="cm">/* check for an expansion rom */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x55</span> <span class="o">||</span> <span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0xaa</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">use_random_mac_addr</span><span class="p">;</span>

	<span class="cm">/* search for beginning of vpd */</span>
	<span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXPANSION_ROM_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check for PCIR */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x50</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x43</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x49</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x52</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">base</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				    <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span> <span class="o">||</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x82</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">use_random_mac_addr</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXPANSION_ROM_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x90</span><span class="p">)</span> <span class="cm">/* no vpd found */</span>
			<span class="k">goto</span> <span class="n">use_random_mac_addr</span><span class="p">;</span>

		<span class="cm">/* found a vpd field */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

		<span class="cm">/* extract keywords */</span>
		<span class="n">kstart</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">kstart</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="n">kstart</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">klen</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
			<span class="kt">char</span> <span class="n">type</span><span class="p">;</span>

			<span class="n">p</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>

			<span class="cm">/* look for the following things:</span>
<span class="cm">			 * -- correct length == 29</span>
<span class="cm">			 * 3 (type) + 2 (size) +</span>
<span class="cm">			 * 18 (strlen(&quot;local-mac-address&quot;) + 1) +</span>
<span class="cm">			 * 6 (mac addr)</span>
<span class="cm">			 * -- VPD Instance &#39;I&#39;</span>
<span class="cm">			 * -- VPD Type Bytes &#39;B&#39;</span>
<span class="cm">			 * -- VPD data length == 6</span>
<span class="cm">			 * -- property string == local-mac-address</span>
<span class="cm">			 *</span>
<span class="cm">			 * -- correct length == 24</span>
<span class="cm">			 * 3 (type) + 2 (size) +</span>
<span class="cm">			 * 12 (strlen(&quot;entropy-dev&quot;) + 1) +</span>
<span class="cm">			 * 7 (strlen(&quot;vms110&quot;) + 1)</span>
<span class="cm">			 * -- VPD Instance &#39;I&#39;</span>
<span class="cm">			 * -- VPD Type String &#39;B&#39;</span>
<span class="cm">			 * -- VPD data length == 7</span>
<span class="cm">			 * -- property string == entropy-dev</span>
<span class="cm">			 *</span>
<span class="cm">			 * -- correct length == 18</span>
<span class="cm">			 * 3 (type) + 2 (size) +</span>
<span class="cm">			 * 9 (strlen(&quot;phy-type&quot;) + 1) +</span>
<span class="cm">			 * 4 (strlen(&quot;pcs&quot;) + 1)</span>
<span class="cm">			 * -- VPD Instance &#39;I&#39;</span>
<span class="cm">			 * -- VPD Type String &#39;S&#39;</span>
<span class="cm">			 * -- VPD data length == 4</span>
<span class="cm">			 * -- property string == phy-type</span>
<span class="cm">			 *</span>
<span class="cm">			 * -- correct length == 23</span>
<span class="cm">			 * 3 (type) + 2 (size) +</span>
<span class="cm">			 * 14 (strlen(&quot;phy-interface&quot;) + 1) +</span>
<span class="cm">			 * 4 (strlen(&quot;pcs&quot;) + 1)</span>
<span class="cm">			 * -- VPD Instance &#39;I&#39;</span>
<span class="cm">			 * -- VPD Type String &#39;S&#39;</span>
<span class="cm">			 * -- VPD data length == 4</span>
<span class="cm">			 * -- property string == phy-interface</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">&#39;I&#39;</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

			<span class="cm">/* finally, check string and length */</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">klen</span> <span class="o">==</span> <span class="mi">29</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span>
				    <span class="n">cas_vpd_match</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span>
						  <span class="s">&quot;local-mac-address&quot;</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">mac_off</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

					<span class="cm">/* set mac address */</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
						<span class="n">dev_addr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span>
							<span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">23</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">found_mac</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="sc">&#39;S&#39;</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

<span class="cp">#ifdef USE_ENTROPY_DEV</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">klen</span> <span class="o">==</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">cas_vpd_match</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&quot;entropy-dev&quot;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">cas_vpd_match</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">17</span><span class="p">,</span> <span class="s">&quot;vms110&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_ENTROPY_DEV</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&amp;</span> <span class="n">VPD_FOUND_PHY</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">klen</span> <span class="o">==</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span>
			    <span class="n">cas_vpd_match</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&quot;phy-type&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cas_vpd_match</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">14</span><span class="p">,</span> <span class="s">&quot;pcs&quot;</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">phy_type</span> <span class="o">=</span> <span class="n">CAS_PHY_SERDES</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">found_phy</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">klen</span> <span class="o">==</span> <span class="mi">23</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">readb</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span>
			    <span class="n">cas_vpd_match</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&quot;phy-interface&quot;</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cas_vpd_match</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">19</span><span class="p">,</span> <span class="s">&quot;pcs&quot;</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">phy_type</span> <span class="o">=</span> <span class="n">CAS_PHY_SERDES</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">found_phy</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
<span class="nl">found_mac:</span>
			<span class="n">found</span> <span class="o">|=</span> <span class="n">VPD_FOUND_MAC</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

<span class="nl">found_phy:</span>
			<span class="n">found</span> <span class="o">|=</span> <span class="n">VPD_FOUND_PHY</span><span class="p">;</span>

<span class="nl">next:</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">klen</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">use_random_mac_addr:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&amp;</span> <span class="n">VPD_FOUND_MAC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_SPARC)</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">of_node</span><span class="p">,</span> <span class="s">&quot;local-mac-address&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* Sun MAC prefix then 3 random bytes. */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;MAC address not found in ROM VPD</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="n">dev_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">dev_addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="n">dev_addr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_BIM_LOCAL_DEV_EN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">phy_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* check pci invariants */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_check_pci_invariants</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_SUN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_SUN_CASSINI</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="n">CAS_ID_REVPLUS</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="n">CAS_ID_REVPLUS02u</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_TARGET_ABORT</span><span class="p">;</span>

		<span class="cm">/* Original Cassini supports HW CSUM, but it&#39;s not</span>
<span class="cm">		 * enabled by default as it can trigger TX hangs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="n">CAS_ID_REV2</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_NO_HW_CSUM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Only sun has original cassini chips.  */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">;</span>

		<span class="cm">/* We use a flag because the same phy might be externally</span>
<span class="cm">		 * connected.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_NS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NS_SATURN</span><span class="p">))</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_SATURN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_check_invariants</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* get page size for rx buffers. */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef USE_PAGE_ORDER</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">&lt;</span> <span class="n">CAS_JUMBO_PAGE_SHIFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* see if we can allocate larger pages */</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">,</span>
						<span class="n">CAS_JUMBO_PAGE_SHIFT</span> <span class="o">-</span>
						<span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">CAS_JUMBO_PAGE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_order</span> <span class="o">=</span> <span class="n">CAS_JUMBO_PAGE_SHIFT</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;MTU limited to %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CAS_MAX_MTU</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">);</span>

	<span class="cm">/* Fetch the FIFO configurations. */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_fifo_size</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_FIFO_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_fifo_size</span> <span class="o">=</span> <span class="n">RX_FIFO_SIZE</span><span class="p">;</span>

	<span class="cm">/* finish phy determination. MDIO1 takes precedence over MDIO0 if</span>
<span class="cm">	 * they&#39;re both connected.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">cas_get_vpd_info</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
					<span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">&amp;</span> <span class="n">CAS_PHY_SERDES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_1000MB_CAP</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* no more checking needed */</span>
	<span class="p">}</span>

	<span class="cm">/* MII */</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_CFG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">MIF_CFG_MDIO_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">CAS_PHY_MII_MDIO1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">MIF_CFG_MDIO_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">CAS_PHY_MII_MDIO0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">PCS_DATAPATH_MODE_MII</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_DATAPATH_MODE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">phy_id</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">phy_id</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_PHYSID1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">phy_id</span> <span class="o">|=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_PHYSID2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phy_id</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phy_id</span> <span class="o">!=</span> <span class="mh">0xFFFFFFFF</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">phy_id</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;MII phy did not respond [%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_STATE_MACHINE</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="cm">/* see if we can do gigabit */</span>
	<span class="n">cfg</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cfg</span> <span class="o">&amp;</span> <span class="n">CAS_BMSR_1000_EXTEND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">CAS_MII_1000_EXTEND</span><span class="p">))</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">|=</span> <span class="n">CAS_FLAG_1000MB_CAP</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_start_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txfailed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* enable dma */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_CFG</span><span class="p">)</span> <span class="o">|</span> <span class="n">TX_CFG_DMA_EN</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_CFG</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CFG</span><span class="p">)</span> <span class="o">|</span> <span class="n">RX_CFG_DMA_EN</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CFG</span><span class="p">);</span>

	<span class="cm">/* enable the mac */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_CFG</span><span class="p">)</span> <span class="o">|</span> <span class="n">MAC_TX_CFG_EN</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_CFG</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">)</span> <span class="o">|</span> <span class="n">MAC_RX_CFG_EN</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">STOP_TRIES</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_CFG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MAC_TX_CFG_EN</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">txfailed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">STOP_TRIES</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">MAC_RX_CFG_EN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">txfailed</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">netdev_err</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					   <span class="s">&quot;enabling mac failed [tx:%08x:%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_STATE_MACHINE</span><span class="p">),</span>
					   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_STATE_MACHINE</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">enable_rx_done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netdev_err</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;enabling mac failed [%s:%08x:%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">txfailed</span> <span class="o">?</span> <span class="s">&quot;tx,rx&quot;</span> <span class="o">:</span> <span class="s">&quot;rx&quot;</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_STATE_MACHINE</span><span class="p">),</span>
		   <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_STATE_MACHINE</span><span class="p">));</span>

<span class="nl">enable_rx_done:</span>
	<span class="n">cas_unmask_intr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span> <span class="cm">/* enable interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_KICK</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_COMP_TAIL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">N_RX_DESC_RINGS</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
			       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_RX_KICK1</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PLUS_RX_COMPN_TAIL</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_read_pcs_link_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="o">*</span><span class="n">pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_LPA</span><span class="p">);</span>
	<span class="o">*</span><span class="n">fd</span>     <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PCS_MII_LPA_FD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pause</span>  <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PCS_MII_LPA_SYM_PAUSE</span><span class="p">)</span> <span class="o">?</span> <span class="mh">0x01</span> <span class="o">:</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PCS_MII_LPA_ASYM_PAUSE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pause</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span>
	<span class="o">*</span><span class="n">spd</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_read_mii_link_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="o">*</span><span class="n">pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="o">*</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">spd</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pause</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* use GMII registers */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_LPA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">CAS_LPA_PAUSE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pause</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">CAS_LPA_ASYM_PAUSE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">pause</span> <span class="o">|=</span> <span class="mh">0x10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">LPA_DUPLEX</span><span class="p">)</span>
		<span class="o">*</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">LPA_100</span><span class="p">)</span>
		<span class="o">*</span><span class="n">spd</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_1000MB_CAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">CAS_MII_1000_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CAS_LPA_1000FULL</span> <span class="o">|</span> <span class="n">CAS_LPA_1000HALF</span><span class="p">))</span>
			<span class="o">*</span><span class="n">spd</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">CAS_LPA_1000FULL</span><span class="p">)</span>
			<span class="o">*</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* A link-up condition has occurred, initialize and enable the</span>
<span class="cm"> * rest of the chip.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be invoked under cp-&gt;lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_set_link_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">full_duplex</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">pause</span><span class="p">;</span>

	<span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">speed</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">pause</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CAS_PHY_MII</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cas_read_mii_link_mode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">full_duplex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">pause</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">BMCR_FULLDPLX</span><span class="p">)</span>
				<span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">BMCR_SPEED100</span><span class="p">)</span>
				<span class="n">speed</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">CAS_BMCR_SPEED1000</span><span class="p">)</span>
				<span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_1000MB_CAP</span><span class="p">)</span> <span class="o">?</span>
					<span class="mi">1000</span> <span class="o">:</span> <span class="mi">100</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_CTRL</span><span class="p">);</span>
		<span class="n">cas_read_pcs_link_mode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">full_duplex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pause</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PCS_MII_AUTONEG_EN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PCS_MII_CTRL_DUPLEX</span><span class="p">)</span>
				<span class="n">full_duplex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netif_info</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Link up at %d Mbps, %s-duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">speed</span><span class="p">,</span> <span class="n">full_duplex</span> <span class="o">?</span> <span class="s">&quot;full&quot;</span> <span class="o">:</span> <span class="s">&quot;half&quot;</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">MAC_XIF_TX_MII_OUTPUT_EN</span> <span class="o">|</span> <span class="n">MAC_XIF_LINK_LED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CAS_PHY_MII</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_XIF_MII_BUFFER_OUTPUT_EN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">full_duplex</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_XIF_DISABLE_ECHO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_duplex</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_XIF_FDPLX_LED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_XIF_GMII_MODE</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_XIF_CFG</span><span class="p">);</span>

	<span class="cm">/* deal with carrier and collision detect. */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">MAC_TX_CFG_IPG_EN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_duplex</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_TX_CFG_IGNORE_CARRIER</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_TX_CFG_IGNORE_COLL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifndef USE_CSMA_CD_PROTO</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_TX_CFG_NEVER_GIVE_UP_EN</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_TX_CFG_NEVER_GIVE_UP_LIM</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="cm">/* val now set up for REG_MAC_TX_CFG */</span>

	<span class="cm">/* If gigabit and half-duplex, enable carrier extension</span>
<span class="cm">	 * mode.  increase slot time to 512 bytes as well.</span>
<span class="cm">	 * else, disable it and make sure slot time is 64 bytes.</span>
<span class="cm">	 * also activate checksum bug workaround</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">full_duplex</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">|</span> <span class="n">MAC_TX_CFG_CARRIER_EXTEND</span><span class="p">,</span>
		       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_CFG</span><span class="p">);</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MAC_RX_CFG_STRIP_FCS</span><span class="p">;</span> <span class="cm">/* checksum workaround */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">|</span> <span class="n">MAC_RX_CFG_CARRIER_EXTEND</span><span class="p">,</span>
		       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>

		<span class="n">writel</span><span class="p">(</span><span class="mh">0x200</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_SLOT_TIME</span><span class="p">);</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* minimum size gigabit frame at half duplex */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">min_frame_size</span> <span class="o">=</span> <span class="n">CAS_1000MB_MIN_FRAME</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_CFG</span><span class="p">);</span>

		<span class="cm">/* checksum bug workaround. don&#39;t strip FCS when in</span>
<span class="cm">		 * half-duplex mode</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">full_duplex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_RX_CFG_STRIP_FCS</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">min_frame_size</span> <span class="o">=</span> <span class="n">CAS_MIN_MTU</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MAC_RX_CFG_STRIP_FCS</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">crc_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">min_frame_size</span> <span class="o">=</span> <span class="n">CAS_MIN_FRAME</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAC_RX_CFG_CARRIER_EXTEND</span><span class="p">,</span>
		       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_SLOT_TIME</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_link</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pause</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pause is enabled (rxfifo: %d off: %d on: %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_fifo_size</span><span class="p">,</span>
				    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_off</span><span class="p">,</span>
				    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pause_on</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pause</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX pause enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">netdev_info</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Pause is disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_CTRL_CFG</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MAC_CTRL_CFG_SEND_PAUSE_EN</span> <span class="o">|</span> <span class="n">MAC_CTRL_CFG_RECV_PAUSE_EN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pause</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* symmetric or asymmetric pause */</span>
		<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_CTRL_CFG_SEND_PAUSE_EN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pause</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* symmetric pause */</span>
			<span class="n">val</span> <span class="o">|=</span> <span class="n">MAC_CTRL_CFG_RECV_PAUSE_EN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_CTRL_CFG</span><span class="p">);</span>
	<span class="n">cas_start_dma</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">restart_link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">restart_link</span><span class="p">)</span>
		<span class="n">cas_phy_init</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="n">cas_init_pause_thresholds</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_init_mac</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_init_dma</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">restart_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Default aneg parameters */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cas_begin_auto_negotiation</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">==</span> <span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_set_link_modes</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. on earlier cassini boards,</span>
<span class="cm"> * SOFT_0 is tied to PCI reset. we use this to force a pci reset,</span>
<span class="cm"> * let it settle out, and then restore pci state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_hard_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BIM_LOCAL_DEV_SOFT_0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_BIM_LOCAL_DEV_EN</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_global_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blkflag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>

	<span class="cm">/* issue a global reset. don&#39;t use RSTOUT. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blkflag</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">CAS_PHY_MII</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* For PCS, when the blkflag is set, we should set the</span>
<span class="cm">		 * SW_REST_BLOCK_PCS_SLINK bit to prevent the results of</span>
<span class="cm">		 * the last autonegotiation from being cleared.  We&#39;ll</span>
<span class="cm">		 * need some special handling if the chip is set into a</span>
<span class="cm">		 * loopback mode.</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">SW_RESET_TX</span> <span class="o">|</span> <span class="n">SW_RESET_RX</span> <span class="o">|</span> <span class="n">SW_RESET_BLOCK_PCS_SLINK</span><span class="p">),</span>
		       <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_SW_RESET</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">SW_RESET_TX</span> <span class="o">|</span> <span class="n">SW_RESET_RX</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_SW_RESET</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* need to wait at least 3ms before polling register */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">STOP_TRIES</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">limit</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_SW_RESET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SW_RESET_TX</span> <span class="o">|</span> <span class="n">SW_RESET_RX</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">netdev_err</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;sw reset failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="cm">/* enable various BIM interrupts */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">BIM_CFG_DPAR_INTR_ENABLE</span> <span class="o">|</span> <span class="n">BIM_CFG_RMA_INTR_ENABLE</span> <span class="o">|</span>
	       <span class="n">BIM_CFG_RTA_INTR_ENABLE</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_BIM_CFG</span><span class="p">);</span>

	<span class="cm">/* clear out pci error status mask for handled errors.</span>
<span class="cm">	 * we don&#39;t deal with DMA counter overflows as they happen</span>
<span class="cm">	 * all the time.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xFFFFFFFFU</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PCI_ERR_BADACK</span> <span class="o">|</span> <span class="n">PCI_ERR_DTRTO</span> <span class="o">|</span>
			       <span class="n">PCI_ERR_OTHER</span> <span class="o">|</span> <span class="n">PCI_ERR_BIM_DMA_WRITE</span> <span class="o">|</span>
			       <span class="n">PCI_ERR_BIM_DMA_READ</span><span class="p">),</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span>
	       <span class="n">REG_PCI_ERR_STATUS_MASK</span><span class="p">);</span>

	<span class="cm">/* set up for MII by default to address mac rx reset timeout</span>
<span class="cm">	 * issue</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">PCS_DATAPATH_MODE_MII</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_DATAPATH_MODE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blkflag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">cas_mask_intr</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_global_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">blkflag</span><span class="p">);</span>
	<span class="n">cas_mac_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_entropy_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="cm">/* disable dma engines. */</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_CFG</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TX_CFG_DMA_EN</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_CFG</span><span class="p">);</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CFG</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RX_CFG_DMA_EN</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_RX_CFG</span><span class="p">);</span>

	<span class="cm">/* program header parser */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_TARGET_ABORT</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">CAS_HP_ALT_FIRMWARE</span> <span class="o">==</span> <span class="n">cas_prog_null</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cas_load_firmware</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">CAS_HP_FIRMWARE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cas_load_firmware</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">CAS_HP_ALT_FIRMWARE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* clear out error registers */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">]);</span>
	<span class="n">cas_clear_mac_err</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Shut down the chip, must be called with pm_mutex held.  */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Make us not-running to avoid timers respawning */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">);</span>

	<span class="cm">/* Stop the reset task */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	while (atomic_read(&amp;cp-&gt;reset_task_pending_mtu) ||</span>
<span class="c">	       atomic_read(&amp;cp-&gt;reset_task_pending_spare) ||</span>
<span class="c">	       atomic_read(&amp;cp-&gt;reset_task_pending_all))</span>
<span class="c">		schedule();</span>

<span class="cp">#else</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">))</span>
		<span class="n">schedule</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="cm">/* Actually stop the chip */</span>
	<span class="n">cas_lock_all_save</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cas_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_SATURN</span><span class="p">)</span>
		<span class="n">cas_phy_powerdown</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_unlock_all_restore</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="n">CAS_MIN_MTU</span> <span class="o">||</span> <span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">CAS_MAX_MTU</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* let the reset task handle it */</span>
<span class="cp">#if 1</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">&amp;</span> <span class="n">CAS_PHY_SERDES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_mtu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">,</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">&amp;</span> <span class="n">CAS_PHY_SERDES</span><span class="p">)</span> <span class="o">?</span>
		   <span class="n">CAS_RESET_ALL</span> <span class="o">:</span> <span class="n">CAS_RESET_MTU</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;reset called in cas_change_mtu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">flush_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_clean_txd</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas_tx_desc</span> <span class="o">*</span><span class="n">txd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_txds</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">**</span><span class="n">skbs</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_skbs</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">dlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">TX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">frag</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">skbs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">skbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">frag</span> <span class="o">&lt;=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>  <span class="n">frag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ent</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* first buffer is never a tiny buffer and so</span>
<span class="cm">			 * needs to be unmapped.</span>
<span class="cm">			 */</span>
			<span class="n">daddr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">txd</span><span class="p">[</span><span class="n">ent</span><span class="p">].</span><span class="n">buffer</span><span class="p">);</span>
			<span class="n">dlen</span>  <span class="o">=</span>  <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">TX_DESC_BUFLEN</span><span class="p">,</span>
					 <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">txd</span><span class="p">[</span><span class="n">ent</span><span class="p">].</span><span class="n">control</span><span class="p">));</span>
			<span class="n">pci_unmap_page</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">dlen</span><span class="p">,</span>
				       <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">!=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>

				<span class="cm">/* next buffer might by a tiny buffer.</span>
<span class="cm">				 * skip past it.</span>
<span class="cm">				 */</span>
				<span class="n">ent</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">][</span><span class="n">ent</span><span class="p">].</span><span class="n">used</span><span class="p">)</span>
					<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* zero out tiny buf usage */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_use</span><span class="p">[</span><span class="n">ring</span><span class="p">]));</span>
<span class="p">}</span>

<span class="cm">/* freed on close */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cas_free_rx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_page_t</span> <span class="o">**</span><span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">cas_page_free</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_free_rxds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_DESC_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cas_free_rx_desc</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Must be invoked under cp-&gt;lock. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_clean_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* need to clean all tx rings */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_old</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_old</span><span class="p">)</span><span class="o">*</span><span class="n">N_TX_RINGS</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_new</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_new</span><span class="p">)</span><span class="o">*</span><span class="n">N_TX_RINGS</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cas_clean_txd</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/* zero out init block */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas_init_block</span><span class="p">));</span>
	<span class="n">cas_clean_rxds</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_clean_rxcs</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* allocated on open */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cas_alloc_rx_desc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cas_page_t</span> <span class="o">**</span><span class="n">page</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_pages</span><span class="p">[</span><span class="n">ring</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">RX_DESC_RINGN_SIZE</span><span class="p">(</span><span class="n">ring</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cas_page_alloc</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_alloc_rxds</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_DESC_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cas_alloc_rx_desc</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cas_free_rxds</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cas</span><span class="p">,</span> <span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	int pending = atomic_read(&amp;cp-&gt;reset_task_pending);</span>
<span class="cp">#else</span>
	<span class="kt">int</span> <span class="n">pending_all</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pending_spare</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_spare</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pending_mtu</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_mtu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pending_all</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pending_spare</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pending_mtu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We can have more tasks scheduled than actually</span>
<span class="cm">		 * needed.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* The link went down, we reset the ring, but keep</span>
<span class="cm">	 * DMA stopped. Use this function for reset</span>
<span class="cm">	 * on error as well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/* Make sure we don&#39;t get interrupts or tx packets */</span>
		<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">cas_lock_all_save</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We call cas_spare_recover when we call cas_open.</span>
<span class="cm">			 * but we do not initialize the lists cas_spare_recover</span>
<span class="cm">			 * uses until cas_open is called.</span>
<span class="cm">			 */</span>
			<span class="n">cas_spare_recover</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#if 1</span>
		<span class="cm">/* test =&gt; only pending_spare set */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pending_all</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pending_mtu</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="n">CAS_RESET_SPARE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="cm">/* when pending == CAS_RESET_ALL, the following</span>
<span class="cm">		 * call to cas_init_hw will restart auto negotiation.</span>
<span class="cm">		 * Setting the second argument of cas_reset to</span>
<span class="cm">		 * !(pending == CAS_RESET_ALL) will set this argument</span>
<span class="cm">		 * to 1 (avoiding reinitializing the PHY for the normal</span>
<span class="cm">		 * PCS case) when auto negotiation is not restarted.</span>
<span class="cm">		 */</span>
<span class="cp">#if 1</span>
		<span class="n">cas_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">pending_all</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span>
			<span class="n">cas_clean_rings</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">cas_init_hw</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="p">(</span><span class="n">pending_all</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span>
<span class="cp">#else</span>
		<span class="n">cas_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="n">CAS_RESET_ALL</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span>
			<span class="n">cas_clean_rings</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">cas_init_hw</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">pending</span> <span class="o">==</span> <span class="n">CAS_RESET_ALL</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="nl">done:</span>
		<span class="n">cas_unlock_all_restore</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if 1</span>
	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">pending_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">);</span>
	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">pending_spare</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_spare</span><span class="p">);</span>
	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">pending_mtu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_mtu</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_link_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_transition_timeout</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies_valid</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies</span><span class="p">)</span> <span class="o">&gt;</span>
	      <span class="p">(</span><span class="n">link_transition_timeout</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* One-second counter so link-down workaround doesn&#39;t</span>
<span class="cm">		 * cause resets to occur so fast as to fool the switch</span>
<span class="cm">		 * into thinking the link is down.</span>
<span class="cm">		 */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cas_lock_tx</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_entropy_gather</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="cm">/* If the link task is still pending, we just</span>
<span class="cm">	 * reschedule the link timer</span>
<span class="cm">	 */</span>
<span class="cp">#if 1</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_spare</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_mtu</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* check for rx cleaning */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_RXD_POST_MASK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rmask</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_RX_DESC_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rmask</span> <span class="o">=</span> <span class="n">CAS_FLAG_RXD_POST</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">rmask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* post_rxds will do a mod_timer */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cas_post_rxds_ringN</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_last</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pending</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">rmask</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CAS_PHY_MII</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">bmsr</span><span class="p">;</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bmsr</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>
		<span class="cm">/* WTZ: Solaris driver reads this twice, but that</span>
<span class="cm">		 * may be due to the PCS case and the use of a</span>
<span class="cm">		 * common implementation. Read it twice here to be</span>
<span class="cm">		 * safe.</span>
<span class="cm">		 */</span>
		<span class="n">bmsr</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMSR</span><span class="p">);</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MIF_STATUS</span><span class="p">);</span> <span class="cm">/* avoid dups */</span>
		<span class="n">reset</span> <span class="o">=</span> <span class="n">cas_mii_link_check</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">bmsr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">reset</span> <span class="o">=</span> <span class="n">cas_pcs_link_check</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* check for tx state machine confusion */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_TX_STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MAC_TX_FRAME_XMIT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_STATE_MACHINE</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">wptr</span><span class="p">,</span> <span class="n">rptr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">tlm</span>  <span class="o">=</span> <span class="n">CAS_VAL</span><span class="p">(</span><span class="n">MAC_SM_TLM</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">tlm</span> <span class="o">==</span> <span class="mh">0x5</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tlm</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">CAS_VAL</span><span class="p">(</span><span class="n">MAC_SM_ENCAP_SM</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;tx err: MAC_STATE[%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="n">reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">val</span>  <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_FIFO_PKT_CNT</span><span class="p">);</span>
		<span class="n">wptr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_FIFO_WRITE_PTR</span><span class="p">);</span>
		<span class="n">rptr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_TX_FIFO_READ_PTR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">wptr</span> <span class="o">!=</span> <span class="n">rptr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netif_printk</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">tx_err</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				     <span class="s">&quot;tx err: TX_FIFO[%08x:%08x:%08x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">val</span><span class="p">,</span> <span class="n">wptr</span><span class="p">,</span> <span class="n">rptr</span><span class="p">);</span>
			<span class="n">reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
			<span class="n">cas_hard_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if 1</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">,</span> <span class="n">CAS_RESET_ALL</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;reset called in cas_link_timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pending</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">CAS_LINK_TIMEOUT</span><span class="p">);</span>
	<span class="n">cas_unlock_tx</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* tiny buffers are used to avoid target abort issues with</span>
<span class="cm"> * older cassini&#39;s</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_tx_tiny_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">TX_TINY_BUF_BLOCK</span><span class="p">,</span>
				    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_dvma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_tx_tiny_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">TX_TINY_BUF_BLOCK</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_dvma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_tiny_bufs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">cas_tx_tiny_free</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">hw_was_up</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>

	<span class="n">hw_was_up</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">;</span>

	<span class="cm">/* The power-management mutex protects the hw_running</span>
<span class="cm">	 * etc. state so it is safe to do this bit without cp-&gt;lock</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Reset the chip */</span>
		<span class="n">cas_lock_all_save</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* We set the second arg to cas_reset to zero</span>
<span class="cm">		 * because cas_init_hw below will have its second</span>
<span class="cm">		 * argument set to non-zero, which will force</span>
<span class="cm">		 * autonegotiation to start.</span>
<span class="cm">		 */</span>
		<span class="n">cas_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cas_unlock_all_restore</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cas_tx_tiny_alloc</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_unlock</span><span class="p">;</span>

	<span class="cm">/* alloc rx descriptors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cas_alloc_rxds</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_tx_tiny</span><span class="p">;</span>

	<span class="cm">/* allocate spares */</span>
	<span class="n">cas_spare_init</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_spare_recover</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/* We can now request the interrupt as we know it&#39;s masked</span>
<span class="cm">	 * on the controller. cassini+ has up to 4 interrupts</span>
<span class="cm">	 * that can be used, but you need to do explicit pci interrupt</span>
<span class="cm">	 * mapping to expose them</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">cas_interrupt</span><span class="p">,</span>
			<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to request irq !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_spare</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef USE_NAPI</span>
	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* init hw */</span>
	<span class="n">cas_lock_all_save</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cas_clean_rings</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_init_hw</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">!</span><span class="n">hw_was_up</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cas_unlock_all_restore</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_spare:</span>
	<span class="n">cas_spare_free</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_free_rxds</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
<span class="nl">err_tx_tiny:</span>
	<span class="n">cas_tx_tiny_free</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
<span class="nl">err_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef USE_NAPI</span>
	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/* Make sure we don&#39;t get distracted by suspend/resume */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Stop traffic, mark us closed */</span>
	<span class="n">cas_lock_all_save</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cas_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cas_phy_init</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_begin_auto_negotiation</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cas_clean_rings</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_unlock_all_restore</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">cas_spare_free</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_free_rxds</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_tx_tiny_free</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">ETH_GSTRING_LEN</span><span class="p">];</span>
<span class="p">}</span> <span class="n">ethtool_cassini_statnames</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;collisions&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_bytes&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_crc_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_dropped&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_fifo_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_frame_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_length_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_over_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;rx_packets&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;tx_aborted_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;tx_bytes&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;tx_dropped&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;tx_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;tx_fifo_errors&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;tx_packets&quot;</span><span class="p">}</span>
<span class="p">};</span>
<span class="cp">#define CAS_NUM_STAT_KEYS ARRAY_SIZE(ethtool_cassini_statnames)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">offsets</span><span class="p">;</span>	<span class="cm">/* neg. values for 2nd arg to cas_read_phy */</span>
<span class="p">}</span> <span class="n">ethtool_register_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="o">-</span><span class="n">MII_BMSR</span><span class="p">},</span>
	<span class="p">{</span><span class="o">-</span><span class="n">MII_BMCR</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_CAWR</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_INF_BURST</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_BIM_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_RX_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_HP_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_MAC_TX_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_MAC_RX_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_MAC_CTRL_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_MAC_XIF_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_MIF_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_PCS_CFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_SATURN_PCFG</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_PCS_MII_STATUS</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_PCS_STATE_MACHINE</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_MAC_COLL_EXCESS</span><span class="p">},</span>
	<span class="p">{</span><span class="n">REG_MAC_COLL_LATE</span><span class="p">}</span>
<span class="p">};</span>
<span class="cp">#define CAS_REG_LEN 	ARRAY_SIZE(ethtool_register_table)</span>
<span class="cp">#define CAS_MAX_REGS 	(sizeof (u32)*CAS_REG_LEN)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_read_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">hval</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ethtool_register_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offsets</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hval</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span>
				    <span class="o">-</span><span class="n">ethtool_register_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offsets</span><span class="p">);</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">hval</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">val</span><span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="o">+</span><span class="n">ethtool_register_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">offsets</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">cas_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">net_stats</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* we collate all of the stats into net_stats[N_TX_RING] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">stats</span> <span class="o">+</span> <span class="n">N_TX_RINGS</span><span class="p">;</span>

	<span class="cm">/* collect outstanding stats */</span>
	<span class="cm">/* WTZ: the Cassini spec gives these as 16 bit counters but</span>
<span class="cm">	 * stored in 32-bit words.  Added a mask of 0xffff to be safe,</span>
<span class="cm">	 * in case the chip somehow puts any garbage in the other bits.</span>
<span class="cm">	 * Also, counter usage didn&#39;t seem to mach what Adrian did</span>
<span class="cm">	 * in the parts of the code that set these quantities. Made</span>
<span class="cm">	 * that consistent.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_crc_errors</span> <span class="o">+=</span>
	  <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_FCS_ERR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_frame_errors</span> <span class="o">+=</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_ALIGN_ERR</span><span class="p">)</span> <span class="o">&amp;</span><span class="mh">0xffff</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_length_errors</span> <span class="o">+=</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_LEN_ERR</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="cp">#if 1</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_EXCESS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_LATE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">tx_aborted_errors</span> <span class="o">+=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">collisions</span> <span class="o">+=</span>
	  <span class="n">tmp</span> <span class="o">+</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_NORMAL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">tx_aborted_errors</span> <span class="o">+=</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_EXCESS</span><span class="p">);</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">collisions</span> <span class="o">+=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_EXCESS</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_COLL_LATE</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">cas_clear_mac_err</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="cm">/* saved bits that are unique to ring 0 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">collisions</span>        <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">collisions</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_over_errors</span>    <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_over_errors</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_frame_errors</span>   <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_frame_errors</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_fifo_errors</span>    <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rx_fifo_errors</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">tx_aborted_errors</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_aborted_errors</span><span class="p">;</span>
	<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">tx_fifo_errors</span>    <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tx_fifo_errors</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_length_errors</span> <span class="o">+=</span>
			<span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_length_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_crc_errors</span> <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_crc_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_packets</span>    <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_packets</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">tx_packets</span>    <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_packets</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_bytes</span>      <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_bytes</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">tx_bytes</span>      <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_bytes</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_errors</span>     <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">tx_errors</span>     <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_errors</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">rx_dropped</span>    <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_dropped</span><span class="p">;</span>
		<span class="n">stats</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">].</span><span class="n">tx_dropped</span>    <span class="o">+=</span> <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tx_dropped</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">stats</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device_stats</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">],</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">stats</span> <span class="o">+</span> <span class="n">N_TX_RINGS</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_set_multicast</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">rxcfg</span><span class="p">,</span> <span class="n">rxcfg_new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">STOP_TRIES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">rxcfg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>

	<span class="cm">/* disable RX MAC and wait for completion */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rxcfg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAC_RX_CFG_EN</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MAC_RX_CFG_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">limit</span><span class="o">--</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* disable hash filter and wait for completion */</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">STOP_TRIES</span><span class="p">;</span>
	<span class="n">rxcfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MAC_RX_CFG_PROMISC_EN</span> <span class="o">|</span> <span class="n">MAC_RX_CFG_HASH_FILTER_EN</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rxcfg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAC_RX_CFG_EN</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MAC_RX_CFG_HASH_FILTER_EN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">limit</span><span class="o">--</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* program hash filters */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">mac_rx_cfg</span> <span class="o">=</span> <span class="n">rxcfg_new</span> <span class="o">=</span> <span class="n">cas_setup_multicast</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">rxcfg</span> <span class="o">|=</span> <span class="n">rxcfg_new</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">rxcfg</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_MAC_RX_CFG</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_get_drvinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_drvinfo</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">,</span> <span class="n">DRV_MODULE_NAME</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">DRV_MODULE_VERSION</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bus_info</span><span class="p">));</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">regdump_len</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">casreg_len</span> <span class="o">&lt;</span> <span class="n">CAS_MAX_REGS</span> <span class="o">?</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">casreg_len</span> <span class="o">:</span> <span class="n">CAS_MAX_REGS</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">n_stats</span> <span class="o">=</span> <span class="n">CAS_NUM_STAT_KEYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_get_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">bmcr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">full_duplex</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">pause</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">link_state</span> <span class="n">linkstate</span> <span class="o">=</span> <span class="n">link_up</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">=</span> <span class="n">SUPPORTED_Autoneg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_1000MB_CAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">|=</span> <span class="n">SUPPORTED_1000baseT_Full</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_1000baseT_Full</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Record PHY settings if HW is on. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bmcr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">linkstate</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CAS_PHY_MII</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">PORT_MII</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_SATURN</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">XCVR_INTERNAL</span> <span class="o">:</span> <span class="n">XCVR_EXTERNAL</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">phy_address</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_TP</span> <span class="o">|</span> <span class="n">ADVERTISED_MII</span> <span class="o">|</span>
			<span class="n">ADVERTISED_10baseT_Half</span> <span class="o">|</span>
			<span class="n">ADVERTISED_10baseT_Full</span> <span class="o">|</span>
			<span class="n">ADVERTISED_100baseT_Half</span> <span class="o">|</span>
			<span class="n">ADVERTISED_100baseT_Full</span><span class="p">;</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">supported</span> <span class="o">|=</span>
			<span class="p">(</span><span class="n">SUPPORTED_10baseT_Half</span> <span class="o">|</span>
			 <span class="n">SUPPORTED_10baseT_Full</span> <span class="o">|</span>
			 <span class="n">SUPPORTED_100baseT_Half</span> <span class="o">|</span>
			 <span class="n">SUPPORTED_100baseT_Full</span> <span class="o">|</span>
			 <span class="n">SUPPORTED_TP</span> <span class="o">|</span> <span class="n">SUPPORTED_MII</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bmcr</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">MII_BMCR</span><span class="p">);</span>
			<span class="n">cas_read_mii_link_mode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">full_duplex</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pause</span><span class="p">);</span>
			<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">PORT_FIBRE</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transceiver</span> <span class="o">=</span> <span class="n">XCVR_INTERNAL</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">phy_address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">supported</span>   <span class="o">|=</span> <span class="n">SUPPORTED_FIBRE</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_FIBRE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* pcs uses the same bits as mii */</span>
			<span class="n">bmcr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_PCS_MII_CTRL</span><span class="p">);</span>
			<span class="n">cas_read_pcs_link_mode</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">full_duplex</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pause</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmcr</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">advertising</span> <span class="o">|=</span> <span class="n">ADVERTISED_Autoneg</span><span class="p">;</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">AUTONEG_ENABLE</span><span class="p">;</span>
		<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="p">((</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="o">?</span>
					    <span class="n">SPEED_10</span> <span class="o">:</span>
					    <span class="p">((</span><span class="n">speed</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">?</span>
					     <span class="n">SPEED_1000</span> <span class="o">:</span> <span class="n">SPEED_100</span><span class="p">)));</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">full_duplex</span> <span class="o">?</span> <span class="n">DUPLEX_FULL</span> <span class="o">:</span> <span class="n">DUPLEX_HALF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="n">AUTONEG_DISABLE</span><span class="p">;</span>
		<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="p">((</span><span class="n">bmcr</span> <span class="o">&amp;</span> <span class="n">CAS_BMCR_SPEED1000</span><span class="p">)</span> <span class="o">?</span>
					    <span class="n">SPEED_1000</span> <span class="o">:</span>
					    <span class="p">((</span><span class="n">bmcr</span> <span class="o">&amp;</span> <span class="n">BMCR_SPEED100</span><span class="p">)</span> <span class="o">?</span>
					     <span class="n">SPEED_100</span> <span class="o">:</span> <span class="n">SPEED_10</span><span class="p">)));</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">bmcr</span> <span class="o">&amp;</span> <span class="n">BMCR_FULLDPLX</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">DUPLEX_FULL</span> <span class="o">:</span> <span class="n">DUPLEX_HALF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">linkstate</span> <span class="o">!=</span> <span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Force these to &quot;unknown&quot; if the link is not up and</span>
<span class="cm">		 * autonogotiation in enabled. We can set the link</span>
<span class="cm">		 * speed to 0, but not cmd-&gt;duplex,</span>
<span class="cm">		 * because its legal values are 0 and 1.  Ethtool will</span>
<span class="cm">		 * print the value reported in parentheses after the</span>
<span class="cm">		 * word &quot;Unknown&quot; for unrecognized values.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If in forced mode, we report the speed and duplex</span>
<span class="cm">		 * settings that we configured.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SPEED_10</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">&amp;</span> <span class="n">BMCR_SPEED100</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SPEED_100</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">&amp;</span> <span class="n">CAS_BMCR_SPEED1000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ethtool_cmd_speed_set</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">SPEED_1000</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">&amp;</span> <span class="n">BMCR_FULLDPLX</span><span class="p">)</span><span class="o">?</span>
				<span class="n">DUPLEX_FULL</span> <span class="o">:</span> <span class="n">DUPLEX_HALF</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_set_settings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_cmd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">ethtool_cmd_speed</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="cm">/* Verify the settings we care about. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">!=</span> <span class="n">AUTONEG_ENABLE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">!=</span> <span class="n">AUTONEG_DISABLE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="n">AUTONEG_DISABLE</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">SPEED_1000</span> <span class="o">&amp;&amp;</span>
	      <span class="n">speed</span> <span class="o">!=</span> <span class="n">SPEED_100</span> <span class="o">&amp;&amp;</span>
	      <span class="n">speed</span> <span class="o">!=</span> <span class="n">SPEED_10</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">!=</span> <span class="n">DUPLEX_HALF</span> <span class="o">&amp;&amp;</span>
	      <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">duplex</span> <span class="o">!=</span> <span class="n">DUPLEX_FULL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Apply settings and restart link process. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cas_begin_auto_negotiation</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_nway_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">&amp;</span> <span class="n">BMCR_ANENABLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Restart link process. */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">cas_begin_auto_negotiation</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">cas_get_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">==</span> <span class="n">link_up</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">cas_get_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">msg_enable</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_set_msglevel</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_get_regs_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">casreg_len</span> <span class="o">&lt;</span> <span class="n">CAS_MAX_REGS</span> <span class="o">?</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">casreg_len</span><span class="o">:</span> <span class="n">CAS_MAX_REGS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_get_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ethtool_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">regs</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* cas_read_regs handles locks (cp-&gt;lock).  */</span>
	<span class="n">cas_read_regs</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_get_sset_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sset</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ETH_SS_STATS</span>:
		<span class="k">return</span> <span class="n">CAS_NUM_STAT_KEYS</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_get_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">stringset</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	 <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ethtool_cassini_statnames</span><span class="p">,</span>
					 <span class="n">CAS_NUM_STAT_KEYS</span> <span class="o">*</span> <span class="n">ETH_GSTRING_LEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cas_get_ethtool_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ethtool_stats</span> <span class="o">*</span><span class="n">estats</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="n">cas_get_stats</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">collisions</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_fifo_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_over_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_aborted_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_dropped</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_fifo_errors</span><span class="p">;</span>
	<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">CAS_NUM_STAT_KEYS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="n">cas_ethtool_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_drvinfo</span>		<span class="o">=</span> <span class="n">cas_get_drvinfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_settings</span>		<span class="o">=</span> <span class="n">cas_get_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_settings</span>		<span class="o">=</span> <span class="n">cas_set_settings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nway_reset</span>		<span class="o">=</span> <span class="n">cas_nway_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link</span>		<span class="o">=</span> <span class="n">cas_get_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_msglevel</span>		<span class="o">=</span> <span class="n">cas_get_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_msglevel</span>		<span class="o">=</span> <span class="n">cas_set_msglevel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs_len</span>		<span class="o">=</span> <span class="n">cas_get_regs_len</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_regs</span>		<span class="o">=</span> <span class="n">cas_get_regs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_sset_count</span>		<span class="o">=</span> <span class="n">cas_get_sset_count</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_strings</span>		<span class="o">=</span> <span class="n">cas_get_strings</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_ethtool_stats</span>	<span class="o">=</span> <span class="n">cas_get_ethtool_stats</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* Hold the PM mutex while doing ioctl&#39;s or we may collide</span>
<span class="cm">	 * with open/close and power management and oops.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:		<span class="cm">/* Get address of MII PHY in use. */</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">;</span>
		<span class="cm">/* Fallthrough... */</span>

	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:		<span class="cm">/* Read MII PHY register. */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">cas_phy_read</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:		<span class="cm">/* Write MII PHY register. */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cas_phy_write</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">val_in</span><span class="p">);</span>
		<span class="n">cas_mif_poll</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* When this chip sits underneath an Intel 31154 bridge, it is the</span>
<span class="cm"> * only subordinate device and we can tweak the bridge settings to</span>
<span class="cm"> * reflect that fact.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">cas_program_bridge</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">cas_pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">cas_pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">!=</span> <span class="mh">0x8086</span> <span class="o">||</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">!=</span> <span class="mh">0x537c</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Clear bit 10 (Bus Parking Control) in the Secondary</span>
<span class="cm">	 * Arbiter Control/Status Register which lives at offset</span>
<span class="cm">	 * 0x41.  Using a 32-bit word read/modify/write at 0x40</span>
<span class="cm">	 * is much simpler so that&#39;s how we do this.</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x00040000</span><span class="p">;</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="cm">/* Max out the Multi-Transaction Timer settings since</span>
<span class="cm">	 * Cassini is the only device present.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The register is 16-bit and lives at 0x50.  When the</span>
<span class="cm">	 * settings are enabled, it extends the GRANT# signal</span>
<span class="cm">	 * for a requestor after a transaction is complete.  This</span>
<span class="cm">	 * allows the next request to run without first needing</span>
<span class="cm">	 * to negotiate the GRANT# signal back.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Bits 12:10 define the grant duration:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	1	--	16 clocks</span>
<span class="cm">	 *	2	--	32 clocks</span>
<span class="cm">	 *	3	--	64 clocks</span>
<span class="cm">	 *	4	--	128 clocks</span>
<span class="cm">	 *	5	--	256 clocks</span>
<span class="cm">	 *</span>
<span class="cm">	 * All other values are illegal.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Bits 09:00 define which REQ/GNT signal pairs get the</span>
<span class="cm">	 * GRANT# signal treatment.  We set them all.</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x3ff</span><span class="p">);</span>

	<span class="cm">/* The Read Prefecth Policy register is 16-bit and sits at</span>
<span class="cm">	 * offset 0x52.  It enables a &quot;smart&quot; pre-fetch policy.  We</span>
<span class="cm">	 * enable it and max out all of the settings since only one</span>
<span class="cm">	 * device is sitting underneath and thus bandwidth sharing is</span>
<span class="cm">	 * not an issue.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The register has several 3 bit fields, which indicates a</span>
<span class="cm">	 * multiplier applied to the base amount of prefetching the</span>
<span class="cm">	 * chip would do.  These fields are at:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	15:13	---	ReRead Primary Bus</span>
<span class="cm">	 *	12:10	---	FirstRead Primary Bus</span>
<span class="cm">	 *	09:07	---	ReRead Secondary Bus</span>
<span class="cm">	 *	06:04	---	FirstRead Secondary Bus</span>
<span class="cm">	 *</span>
<span class="cm">	 * Bits 03:00 control which REQ/GNT pairs the prefetch settings</span>
<span class="cm">	 * get enabled on.  Bit 3 is a grouped enabler which controls</span>
<span class="cm">	 * all of the REQ/GNT pairs from [8:3].  Bits 2 to 0 control</span>
<span class="cm">	 * the individual REQ/GNT pairs [2:0].</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x52</span><span class="p">,</span>
			      <span class="p">(</span><span class="mh">0x7</span> <span class="o">&lt;&lt;</span> <span class="mi">13</span><span class="p">)</span> <span class="o">|</span>
			      <span class="p">(</span><span class="mh">0x7</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span>
			      <span class="p">(</span><span class="mh">0x7</span> <span class="o">&lt;&lt;</span>  <span class="mi">7</span><span class="p">)</span> <span class="o">|</span>
			      <span class="p">(</span><span class="mh">0x7</span> <span class="o">&lt;&lt;</span>  <span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
			      <span class="p">(</span><span class="mh">0xf</span> <span class="o">&lt;&lt;</span>  <span class="mi">0</span><span class="p">));</span>

	<span class="cm">/* Force cacheline size to 0x8 */</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">);</span>

	<span class="cm">/* Force latency timer to maximum setting so Cassini can</span>
<span class="cm">	 * sit on the bus as long as it likes.</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">cas_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">cas_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">cas_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">cas_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span> 		<span class="o">=</span> <span class="n">cas_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">cas_set_multicast</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">cas_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">cas_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">cas_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">cas_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">cas_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">cas_version_printed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">casreg_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">pci_using_dac</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">orig_cacheline_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cas_cacheline_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cas_version_printed</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot enable PCI device, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot find proper PCI device &quot;</span>
		       <span class="s">&quot;base address, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_disable_pdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out_disable_pdev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot obtain PCI resources, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_free_netdev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* we must always turn on parity response or else parity</span>
<span class="cm">	 * doesn&#39;t get generated properly. disable SERR/PERR as well.</span>
<span class="cm">	 * in addition, we want to turn MWI on.</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_cmd</span><span class="p">);</span>
	<span class="n">pci_cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PCI_COMMAND_SERR</span><span class="p">;</span>
	<span class="n">pci_cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_PARITY</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">pci_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_try_set_mwi</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Could not enable MWI for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>

	<span class="n">cas_program_bridge</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * On some architectures, the default cache line size set</span>
<span class="cm">	 * by pci_try_set_mwi reduces perforamnce.  We have to increase</span>
<span class="cm">	 * it for this case.  To start, we&#39;ll print some configuration</span>
<span class="cm">	 * data.</span>
<span class="cm">	 */</span>
<span class="cp">#if 1</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">orig_cacheline_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_cacheline_size</span> <span class="o">&lt;</span> <span class="n">CAS_PREF_CACHELINE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cas_cacheline_size</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">CAS_PREF_CACHELINE_SIZE</span> <span class="o">&lt;</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">CAS_PREF_CACHELINE_SIZE</span> <span class="o">:</span> <span class="n">SMP_CACHE_BYTES</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
					  <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span>
					  <span class="n">cas_cacheline_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Could not set PCI cache &quot;</span>
			       <span class="s">&quot;line size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_write_cacheline</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>


	<span class="cm">/* Configure DMA attributes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						  <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to obtain 64-bit DMA &quot;</span>
			       <span class="s">&quot;for consistent allocations</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No usable DMA configuration, &quot;</span>
			       <span class="s">&quot;aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">casreg_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
<span class="cp">#if 1</span>
	<span class="cm">/* A value of 0 indicates we never explicitly set it */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">orig_cacheline_size</span> <span class="o">=</span> <span class="n">cas_cacheline_size</span> <span class="o">?</span> <span class="n">orig_cacheline_size</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="p">(</span><span class="n">cassini_debug</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">CAS_DEF_MSG_ENABLE</span> <span class="o">:</span>
	  <span class="n">cassini_debug</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_SPARC)</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">of_node</span> <span class="o">=</span> <span class="n">pci_device_to_OF_node</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_UNKNOWN</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition_jiffies_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_inuse_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_spare_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tx_lock</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">[</span><span class="n">N_TX_RINGS</span><span class="p">]);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">cas_link_timer</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">cp</span><span class="p">;</span>

<span class="cp">#if 1</span>
	<span class="cm">/* Just in case the implementation of atomic operations</span>
<span class="cm">	 * change so that an explicit initialization is necessary.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_all</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_spare</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task_pending_mtu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">,</span> <span class="n">cas_reset_task</span><span class="p">);</span>

	<span class="cm">/* Default link parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">link_mode</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">link_mode</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">=</span> <span class="n">link_modes</span><span class="p">[</span><span class="n">link_mode</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_cntl</span> <span class="o">=</span> <span class="n">BMCR_ANENABLE</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lstate</span> <span class="o">=</span> <span class="n">link_down</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_transition</span> <span class="o">=</span> <span class="n">LINK_TRANSITION_LINK_DOWN</span><span class="p">;</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">timer_ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* give us access to cassini registers */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">casreg_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot map device registers, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_free_res</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">casreg_len</span> <span class="o">=</span> <span class="n">casreg_len</span><span class="p">;</span>

	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">cas_check_pci_invariants</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_hard_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cas_check_invariants</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_out_iounmap</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_SATURN</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cas_saturn_firmware_init</span><span class="p">(</span><span class="n">cp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_out_iounmap</span><span class="p">;</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cas_init_block</span> <span class="o">*</span><span class="p">)</span>
		<span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas_init_block</span><span class="p">),</span>
				     <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">block_dvma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot allocate init block, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_TX_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_txds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">txds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_DESC_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">rxds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_COMP_RINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_rxcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="o">-&gt;</span><span class="n">rxcs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_RX_FLOWS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">rx_flows</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cas_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cas_ethtool_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="n">CAS_TX_TIMEOUT</span><span class="p">;</span>

<span class="cp">#ifdef USE_NAPI</span>
	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">cas_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Cassini features. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_NO_HW_CSUM</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_SG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_using_dac</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Cannot register net device, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out_free_consistent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span> <span class="o">+</span> <span class="n">REG_BIM_CFG</span><span class="p">);</span>
	<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Sun Cassini%s (%sbit/%sMHz PCI/%s) Ethernet[%d] %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cas_flags</span> <span class="o">&amp;</span> <span class="n">CAS_FLAG_REG_PLUS</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;+&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		    <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">BIM_CFG_32BIT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;32&quot;</span> <span class="o">:</span> <span class="s">&quot;64&quot;</span><span class="p">,</span>
		    <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">BIM_CFG_66MHZ</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;66&quot;</span> <span class="o">:</span> <span class="s">&quot;33&quot;</span><span class="p">,</span>
		    <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">CAS_PHY_SERDES</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Fi&quot;</span> <span class="o">:</span> <span class="s">&quot;Cu&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">cas_entropy_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_phy_init</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">cas_begin_auto_negotiation</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out_free_consistent:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas_init_block</span><span class="p">),</span>
			    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">block_dvma</span><span class="p">);</span>

<span class="nl">err_out_iounmap:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span>
		<span class="n">cas_shutdown</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>

	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>


<span class="nl">err_out_free_res:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">err_write_cacheline:</span>
	<span class="cm">/* Try to restore it in case the error occurred after we</span>
<span class="cm">	 * set it.</span>
<span class="cm">	 */</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="n">orig_cacheline_size</span><span class="p">);</span>

<span class="nl">err_out_free_netdev:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="nl">err_out_disable_pdev:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">cas_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_data</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">fw_data</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span>
		<span class="n">cas_shutdown</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>

<span class="cp">#if 1</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">orig_cacheline_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Restore the cache line size if we had modified</span>
<span class="cm">		 * it.</span>
<span class="cm">		 */</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span>
				      <span class="n">cp</span><span class="o">-&gt;</span><span class="n">orig_cacheline_size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cas_init_block</span><span class="p">),</span>
			    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">init_block</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">block_dvma</span><span class="p">);</span>
	<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>

	<span class="cm">/* If the driver is opened, we stop the DMA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">cas_lock_all_save</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* We can set the second arg of cas_reset to 0</span>
<span class="cm">		 * because on resume, we&#39;ll call cas_init_hw with</span>
<span class="cm">		 * its second arg set so that autonegotiation is</span>
<span class="cm">		 * restarted.</span>
<span class="cm">		 */</span>
		<span class="n">cas_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cas_clean_rings</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">cas_unlock_all_restore</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span><span class="p">)</span>
		<span class="n">cas_shutdown</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cas_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cas</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netdev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;resuming</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="n">cas_hard_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">opened</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">cas_lock_all_save</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">cas_reset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">hw_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cas_clean_rings</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
		<span class="n">cas_init_hw</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">cas_unlock_all_restore</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">pm_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">cas_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRV_MODULE_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">cas_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">cas_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">cas_remove_one</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">cas_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">cas_resume</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">cas_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">linkdown_timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">link_transition_timeout</span> <span class="o">=</span> <span class="n">linkdown_timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">link_transition_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cas_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">cas_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cas_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">cas_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cas_cleanup</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
