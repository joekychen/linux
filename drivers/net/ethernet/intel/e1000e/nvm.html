<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › e1000e › nvm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>nvm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel PRO/1000 Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#include &quot;e1000.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_raise_eec_clk - Raise EEPROM clock</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @eecd: pointer to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Enable/Raise the EEPROM clock bit.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_raise_eec_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eecd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">eecd</span> <span class="o">=</span> <span class="o">*</span><span class="n">eecd</span> <span class="o">|</span> <span class="n">E1000_EECD_SK</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="o">*</span><span class="n">eecd</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">delay_usec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_lower_eec_clk - Lower EEPROM clock</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @eecd: pointer to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Clear/Lower the EEPROM clock bit.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_lower_eec_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eecd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">eecd</span> <span class="o">=</span> <span class="o">*</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_EECD_SK</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="o">*</span><span class="n">eecd</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">delay_usec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_shift_out_eec_bits - Shift data bits our to the EEPROM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @data: data to send to the EEPROM</span>
<span class="cm"> *  @count: number of bits to shift out</span>
<span class="cm"> *</span>
<span class="cm"> *  We need to shift &#39;count&#39; bits out to the EEPROM.  So, the value in the</span>
<span class="cm"> *  &quot;data&quot; parameter will be shifted out to the EEPROM one bit at a time.</span>
<span class="cm"> *  In order to do this, &quot;data&quot; must be broken down into bits.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_shift_out_eec_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_nvm_eeprom_spi</span><span class="p">)</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_DO</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_DI</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_DI</span><span class="p">;</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">e1e_flush</span><span class="p">();</span>

		<span class="n">udelay</span><span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>

		<span class="n">e1000_raise_eec_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>
		<span class="n">e1000_lower_eec_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>

		<span class="n">mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_DI</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_shift_in_eec_bits - Shift data bits in from the EEPROM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @count: number of bits to shift in</span>
<span class="cm"> *</span>
<span class="cm"> *  In order to read a register from the EEPROM, we need to shift &#39;count&#39; bits</span>
<span class="cm"> *  in from the EEPROM.  Bits are &quot;shifted in&quot; by raising the clock input to</span>
<span class="cm"> *  the EEPROM (setting the SK bit), and then reading the value of the data out</span>
<span class="cm"> *  &quot;DO&quot; bit.  During this &quot;shifting in&quot; process the data in &quot;DI&quot; bit should</span>
<span class="cm"> *  always be clear.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">e1000_shift_in_eec_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

	<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_DO</span> <span class="o">|</span> <span class="n">E1000_EECD_DI</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">e1000_raise_eec_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>

		<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_DI</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_DO</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">e1000_lower_eec_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_poll_eerd_eewr_done - Poll for EEPROM read/write completion</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @ee_reg: EEPROM flag for polling</span>
<span class="cm"> *</span>
<span class="cm"> *  Polls the EEPROM status bit for either read or write completion based</span>
<span class="cm"> *  upon the value of &#39;ee_reg&#39;.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_poll_eerd_eewr_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ee_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">attempts</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">attempts</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ee_reg</span> <span class="o">==</span> <span class="n">E1000_NVM_POLL_READ</span><span class="p">)</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EERD</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EEWR</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">E1000_NVM_RW_REG_DONE</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_acquire_nvm - Generic request for access to EEPROM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Set the EEPROM access request bit and wait for EEPROM access grant bit.</span>
<span class="cm"> *  Return successful if access grant bit set, else clear the request for</span>
<span class="cm"> *  EEPROM access and return -E1000_ERR_NVM (-1).</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_acquire_nvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="n">s32</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">E1000_NVM_GRANT_ATTEMPTS</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span> <span class="o">|</span> <span class="n">E1000_EECD_REQ</span><span class="p">);</span>
	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_GNT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
		<span class="n">timeout</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_REQ</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not acquire NVM grant</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_standby_nvm - Return EEPROM to standby state</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Return the EEPROM to a standby state.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_standby_nvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_nvm_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Toggle CS to flush commands */</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_CS</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">e1e_flush</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_CS</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">e1e_flush</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_stop_nvm - Terminate EEPROM command</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Terminates the current command by inverting the EEPROM&#39;s chip select pin.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_stop_nvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>

	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_nvm_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Pull CS high */</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_CS</span><span class="p">;</span>
		<span class="n">e1000_lower_eec_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_release_nvm - Release exclusive access to EEPROM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Stop any current commands to the EEPROM and clear the EEPROM request bit.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_release_nvm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>

	<span class="n">e1000_stop_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_REQ</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_ready_nvm_eeprom - Prepares EEPROM for read/write</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Setups the EEPROM for reading and writing.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_ready_nvm_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">spi_stat_reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_nvm_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">NVM_MAX_RETRY_SPI</span><span class="p">;</span>

		<span class="cm">/* Clear SK and CS */</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_CS</span> <span class="o">|</span> <span class="n">E1000_EECD_SK</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">e1e_flush</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Read &quot;Status Register&quot; repeatedly until the LSB is cleared.</span>
<span class="cm">		 * The EEPROM will signal that the command has been completed</span>
<span class="cm">		 * by clearing bit 0 of the internal status register.  If it&#39;s</span>
<span class="cm">		 * not cleared within &#39;timeout&#39;, then error out.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e1000_shift_out_eec_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_RDSR_OPCODE_SPI</span><span class="p">,</span>
						 <span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">opcode_bits</span><span class="p">);</span>
			<span class="n">spi_stat_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">e1000_shift_in_eec_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spi_stat_reg</span> <span class="o">&amp;</span> <span class="n">NVM_STATUS_RDY_SPI</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
			<span class="n">e1000_standby_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">timeout</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;SPI NVM Status error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_nvm_eerd - Reads EEPROM using EERD register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: offset of word in the EEPROM to read</span>
<span class="cm"> *  @words: number of words to read</span>
<span class="cm"> *  @data: word read from the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads a 16 bit word from the EEPROM using the EERD register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_nvm_eerd</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">eerd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A check for invalid values:  offset too large, too many words,</span>
<span class="cm">	 * too many words for the offset, and not enough words.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">words</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;nvm parameter(s) out of bounds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eerd</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_NVM_RW_ADDR_SHIFT</span><span class="p">)</span> <span class="o">+</span>
		    <span class="n">E1000_NVM_RW_REG_START</span><span class="p">;</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">EERD</span><span class="p">,</span> <span class="n">eerd</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_poll_eerd_eewr_done</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_NVM_POLL_READ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">EERD</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">E1000_NVM_RW_REG_DATA</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_nvm_spi - Write to EEPROM using SPI</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be written to</span>
<span class="cm"> *  @words: number of words to write</span>
<span class="cm"> *  @data: 16 bit word(s) to be written to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  Writes data to EEPROM at offset using SPI interface.</span>
<span class="cm"> *</span>
<span class="cm"> *  If e1000e_update_nvm_checksum is not called after this function , the</span>
<span class="cm"> *  EEPROM will most likely contain an invalid checksum.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_nvm_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">widx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A check for invalid values:  offset too large, too many words,</span>
<span class="cm">	 * and not enough words.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">words</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;nvm parameter(s) out of bounds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">nvm</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">widx</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">write_opcode</span> <span class="o">=</span> <span class="n">NVM_WRITE_OPCODE_SPI</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_ready_nvm_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>

		<span class="n">e1000_standby_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Send the WRITE ENABLE command (8 bit opcode) */</span>
		<span class="n">e1000_shift_out_eec_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_WREN_OPCODE_SPI</span><span class="p">,</span>
					 <span class="n">nvm</span><span class="o">-&gt;</span><span class="n">opcode_bits</span><span class="p">);</span>

		<span class="n">e1000_standby_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Some SPI eeproms use the 8th address bit embedded in the</span>
<span class="cm">		 * opcode</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">))</span>
			<span class="n">write_opcode</span> <span class="o">|=</span> <span class="n">NVM_A8_OPCODE_SPI</span><span class="p">;</span>

		<span class="cm">/* Send the Write command (8-bit opcode + addr) */</span>
		<span class="n">e1000_shift_out_eec_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">write_opcode</span><span class="p">,</span> <span class="n">nvm</span><span class="o">-&gt;</span><span class="n">opcode_bits</span><span class="p">);</span>
		<span class="n">e1000_shift_out_eec_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">widx</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
					 <span class="n">nvm</span><span class="o">-&gt;</span><span class="n">address_bits</span><span class="p">);</span>

		<span class="cm">/* Loop to allow for up to whole page write of eeprom */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">widx</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">word_out</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">widx</span><span class="p">];</span>
			<span class="n">word_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">word_out</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">word_out</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">e1000_shift_out_eec_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">word_out</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">widx</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">widx</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">nvm</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e1000_standby_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>
<span class="nl">release:</span>
	<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_pba_string_generic - Read device part number</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @pba_num: pointer to device part number</span>
<span class="cm"> *  @pba_num_size: size of part number buffer</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the product board assembly (PBA) number from the EEPROM and stores</span>
<span class="cm"> *  the value in pba_num.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_read_pba_string_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">pba_num</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">pba_num_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nvm_data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pba_ptr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pba_num</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PBA string buffer was null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_INVALID_ARGUMENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_PBA_OFFSET_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvm_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_PBA_OFFSET_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pba_ptr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if nvm_data is not ptr guard the PBA must be in legacy format which</span>
<span class="cm">	 * means pba_ptr is actually our second data word for the PBA number</span>
<span class="cm">	 * and we can decode it into an ascii string</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nvm_data</span> <span class="o">!=</span> <span class="n">NVM_PBA_PTR_GUARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM PBA number is not stored as string</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* we will need 11 characters to store the PBA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pba_num_size</span> <span class="o">&lt;</span> <span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PBA string buffer too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">E1000_ERR_NO_SPACE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* extract hex string from data and pba_ptr */</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nvm_data</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nvm_data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nvm_data</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">nvm_data</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pba_ptr</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pba_ptr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pba_ptr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">pba_ptr</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">;</span>

		<span class="cm">/* put a null character on the end of our string */</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

		<span class="cm">/* switch all the data but the &#39;-&#39; to hex char */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0xA</span><span class="p">)</span>
				<span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mh">0x10</span><span class="p">)</span>
				<span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">+=</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="mh">0xA</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pba_ptr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="mh">0xFFFF</span> <span class="o">||</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM PBA number section invalid length</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM_PBA_SECTION</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* check if pba_num buffer is big enough */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pba_num_size</span> <span class="o">&lt;</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">length</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PBA string buffer too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NO_SPACE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* trim pba length from start of string */</span>
	<span class="n">pba_ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">length</span><span class="o">--</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pba_ptr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvm_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">nvm_data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">pba_num</span><span class="p">[(</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">nvm_data</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pba_num</span><span class="p">[</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_mac_addr_generic - Read device MAC address</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the device MAC address from the EEPROM and stores the value.</span>
<span class="cm"> *  Since devices with two ports use the same EEPROM, we increment the</span>
<span class="cm"> *  last bit in the MAC address for the second port.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_read_mac_addr_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rar_high</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_low</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rar_high</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RAH</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">rar_low</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RAL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_RAL_MAC_ADDR_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">perm_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">rar_low</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_RAH_MAC_ADDR_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">perm_addr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">rar_high</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ETH_ALEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">perm_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_validate_nvm_checksum_generic - Validate EEPROM checksum</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Calculates the EEPROM checksum by reading/adding each word of the EEPROM</span>
<span class="cm"> *  and then verifies that the sum of the EEPROM is equal to 0xBABA.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_validate_nvm_checksum_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">nvm_data</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">NVM_CHECKSUM_REG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvm_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">checksum</span> <span class="o">+=</span> <span class="n">nvm_data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">NVM_SUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Checksum Invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_update_nvm_checksum_generic - Update EEPROM checksum</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Updates the EEPROM checksum by reading/adding each word of the EEPROM</span>
<span class="cm"> *  up to the checksum.  Then calculates the EEPROM checksum and writes the</span>
<span class="cm"> *  value to the EEPROM.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_update_nvm_checksum_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">nvm_data</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NVM_CHECKSUM_REG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvm_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Read Error while updating checksum.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">checksum</span> <span class="o">+=</span> <span class="n">nvm_data</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">NVM_SUM</span> <span class="o">-</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_CHECKSUM_REG</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">checksum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Write Error while updating checksum.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_reload_nvm_generic - Reloads EEPROM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reloads the EEPROM by setting the &quot;Reinitialize from EEPROM&quot; bit in the</span>
<span class="cm"> *  extended control register.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_reload_nvm_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
	<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_EE_RST</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
