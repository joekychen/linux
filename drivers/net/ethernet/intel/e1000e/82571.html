<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › e1000e › 82571.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>82571.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel PRO/1000 Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * 82571EB Gigabit Ethernet Controller</span>
<span class="cm"> * 82571EB Gigabit Ethernet Controller (Copper)</span>
<span class="cm"> * 82571EB Gigabit Ethernet Controller (Fiber)</span>
<span class="cm"> * 82571EB Dual Port Gigabit Mezzanine Adapter</span>
<span class="cm"> * 82571EB Quad Port Gigabit Mezzanine Adapter</span>
<span class="cm"> * 82571PT Gigabit PT Quad Port Server ExpressModule</span>
<span class="cm"> * 82572EI Gigabit Ethernet Controller (Copper)</span>
<span class="cm"> * 82572EI Gigabit Ethernet Controller (Fiber)</span>
<span class="cm"> * 82572EI Gigabit Ethernet Controller</span>
<span class="cm"> * 82573V Gigabit Ethernet Controller (Copper)</span>
<span class="cm"> * 82573E Gigabit Ethernet Controller (Copper)</span>
<span class="cm"> * 82573L Gigabit Ethernet Controller</span>
<span class="cm"> * 82574L Gigabit Network Connection</span>
<span class="cm"> * 82583V Gigabit Network Connection</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;e1000.h&quot;</span>

<span class="cp">#define ID_LED_RESERVED_F746 0xF746</span>
<span class="cp">#define ID_LED_DEFAULT_82573 ((ID_LED_DEF1_DEF2 &lt;&lt; 12) | \</span>
<span class="cp">			      (ID_LED_OFF1_ON2  &lt;&lt;  8) | \</span>
<span class="cp">			      (ID_LED_DEF1_DEF2 &lt;&lt;  4) | \</span>
<span class="cp">			      (ID_LED_DEF1_DEF2))</span>

<span class="cp">#define E1000_GCR_L1_ACT_WITHOUT_L0S_RX 0x08000000</span>
<span class="cp">#define AN_RETRY_COUNT          5 </span><span class="cm">/* Autoneg Retry Count value */</span><span class="cp"></span>
<span class="cp">#define E1000_BASE1000T_STATUS          10</span>
<span class="cp">#define E1000_IDLE_ERROR_COUNT_MASK     0xFF</span>
<span class="cp">#define E1000_RECEIVE_ERROR_COUNTER     21</span>
<span class="cp">#define E1000_RECEIVE_ERROR_MAX         0xFFFF</span>

<span class="cp">#define E1000_NVM_INIT_CTRL2_MNGM 0x6000 </span><span class="cm">/* Manageability Operation Mode mask */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_get_phy_id_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_setup_copper_link_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_setup_fiber_serdes_link_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_check_for_serdes_link_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_write_nvm_eewr_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_fix_nvm_checksum_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_initialize_hw_bits_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_setup_link_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clear_hw_cntrs_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clear_vfta_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">e1000_check_mng_mode_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_led_on_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_put_hw_semaphore_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_power_down_phy_copper_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_put_hw_semaphore_82573</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_get_hw_semaphore_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_put_hw_semaphore_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_set_d0_lplu_state_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_set_d3_lplu_state_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_init_phy_params_82571 - Init PHY func ptrs.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_init_phy_params_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e1000_phy_none</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">addr</span>			 <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_mask</span>		 <span class="o">=</span> <span class="n">AUTONEG_ADVERTISE_SPEED_DEFAULT</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">reset_delay_us</span>		 <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">power_up</span>		 <span class="o">=</span> <span class="n">e1000_power_up_phy_copper</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">power_down</span>		 <span class="o">=</span> <span class="n">e1000_power_down_phy_copper_82571</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span>		 <span class="o">=</span> <span class="n">e1000_phy_igp_2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span>		 <span class="o">=</span> <span class="n">e1000_phy_m88</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span>		 <span class="o">=</span> <span class="n">e1000_phy_bm</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span> <span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82574</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">e1000_put_hw_semaphore_82574</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">set_d0_lplu_state</span> <span class="o">=</span> <span class="n">e1000_set_d0_lplu_state_82574</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">set_d3_lplu_state</span> <span class="o">=</span> <span class="n">e1000_set_d3_lplu_state_82574</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This can only be done after all function pointers are setup. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_phy_id_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error getting PHY ID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Verify phy id */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">IGP01E1000_I_PHY_ID</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">M88E1111_I_PHY_ID</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">BME1000_E_PHY_ID_R2</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PHY ID unknown: type = 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_init_nvm_params_82571 - Init NVM func ptrs.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_init_nvm_params_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">opcode_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">delay_usec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">override</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_nvm_override_spi_large</span>:
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_nvm_override_spi_small</span>:
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_ADDR_BITS</span> <span class="o">?</span> <span class="mi">32</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_ADDR_BITS</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="k">if</span> <span class="p">(((</span><span class="n">eecd</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e1000_nvm_flash_hw</span><span class="p">;</span>
			<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Autonomous Flash update bit must be cleared due</span>
<span class="cm">			 * to Flash update issue.</span>
<span class="cm">			 */</span>
			<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_AUPDEN</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Fall Through */</span>
	<span class="nl">default:</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e1000_nvm_eeprom_spi</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_SIZE_EX_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				  <span class="n">E1000_EECD_SIZE_EX_SHIFT</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Added to a constant, &quot;size&quot; becomes the left-shift value</span>
<span class="cm">		 * for setting word_size.</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">NVM_WORD_SIZE_BASE_SHIFT</span><span class="p">;</span>

		<span class="cm">/* EEPROM access above 16k is unsupported */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Function Pointers */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span> <span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82574</span><span class="p">;</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">e1000_put_hw_semaphore_82574</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_init_mac_params_82571 - Init MAC func ptrs.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_init_mac_params_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swsm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swsm2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">force_clear_smbi</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Set media type and media-dependent function pointers */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571EB_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82572EI_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571EB_QUAD_FIBER</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_fiber</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_physical_interface</span> <span class="o">=</span>
		    <span class="n">e1000_setup_fiber_serdes_link_82571</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span> <span class="o">=</span> <span class="n">e1000e_check_for_fiber_link</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_link_up_info</span> <span class="o">=</span>
		    <span class="n">e1000e_get_speed_and_duplex_fiber_serdes</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571EB_SERDES</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571EB_SERDES_DUAL</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571EB_SERDES_QUAD</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82572EI_SERDES</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_physical_interface</span> <span class="o">=</span>
		    <span class="n">e1000_setup_fiber_serdes_link_82571</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span> <span class="o">=</span> <span class="n">e1000_check_for_serdes_link_82571</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_link_up_info</span> <span class="o">=</span>
		    <span class="n">e1000e_get_speed_and_duplex_fiber_serdes</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_copper</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_physical_interface</span> <span class="o">=</span>
		    <span class="n">e1000_setup_copper_link_82571</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span> <span class="o">=</span> <span class="n">e1000e_check_for_copper_link</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_link_up_info</span> <span class="o">=</span> <span class="n">e1000e_get_speed_and_duplex_copper</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set mta register count */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">mta_reg_count</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="cm">/* Set rar entry count */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">rar_entry_count</span> <span class="o">=</span> <span class="n">E1000_RAR_ENTRIES</span><span class="p">;</span>
	<span class="cm">/* Adaptive IFS supported */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">adaptive_ifs</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* MAC-specific function pointers */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">set_lan_id</span> <span class="o">=</span> <span class="n">e1000_set_lan_id_single_port</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_mng_mode</span> <span class="o">=</span> <span class="n">e1000e_check_mng_mode_generic</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">led_on</span> <span class="o">=</span> <span class="n">e1000e_led_on_generic</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">blink_led</span> <span class="o">=</span> <span class="n">e1000e_blink_led_generic</span><span class="p">;</span>

		<span class="cm">/* FWSM register */</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">has_fwsm</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * ARC supported; valid only if manageability features are</span>
<span class="cm">		 * enabled.</span>
<span class="cm">		 */</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">arc_subsystem_valid</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">FWSM</span><span class="p">)</span> <span class="o">&amp;</span>
					      <span class="n">E1000_FWSM_MODE_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">set_lan_id</span> <span class="o">=</span> <span class="n">e1000_set_lan_id_single_port</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_mng_mode</span> <span class="o">=</span> <span class="n">e1000_check_mng_mode_82574</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">led_on</span> <span class="o">=</span> <span class="n">e1000_led_on_82574</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_mng_mode</span> <span class="o">=</span> <span class="n">e1000e_check_mng_mode_generic</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">led_on</span> <span class="o">=</span> <span class="n">e1000e_led_on_generic</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">blink_led</span> <span class="o">=</span> <span class="n">e1000e_blink_led_generic</span><span class="p">;</span>

		<span class="cm">/* FWSM register */</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">has_fwsm</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that the inter-port SWSM.SMBI lock bit is clear before</span>
<span class="cm">	 * first NVM or PHY access. This should be done for single-port</span>
<span class="cm">	 * devices, and for one port only on dual-port devices so that</span>
<span class="cm">	 * for those devices we can still use the SMBI lock to synchronize</span>
<span class="cm">	 * inter-port accesses to the PHY &amp; NVM.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="n">swsm2</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SWSM2</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">swsm2</span> <span class="o">&amp;</span> <span class="n">E1000_SWSM2_LOCK</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Only do this for the first interface on this card */</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">SWSM2</span><span class="p">,</span> <span class="n">swsm2</span> <span class="o">|</span> <span class="n">E1000_SWSM2_LOCK</span><span class="p">);</span>
			<span class="n">force_clear_smbi</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">force_clear_smbi</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">force_clear_smbi</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">force_clear_smbi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure SWSM.SMBI is clear */</span>
		<span class="n">swsm</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swsm</span> <span class="o">&amp;</span> <span class="n">E1000_SWSM_SMBI</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This bit should not be set on a first interface, and</span>
<span class="cm">			 * indicates that the bootagent or EFI code has</span>
<span class="cm">			 * improperly left this bit enabled</span>
<span class="cm">			 */</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Please update your 82571 Bootagent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">,</span> <span class="n">swsm</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_SWSM_SMBI</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize device specific counter of SMBI acquisition</span>
<span class="cm">	 * timeouts.</span>
<span class="cm">	 */</span>
	 <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e82571</span><span class="p">.</span><span class="n">smb_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_variants_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">global_quad_port_a</span><span class="p">;</span> <span class="cm">/* global port a indication */</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_port_b</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_FUNC_1</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">e1000_init_mac_params_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">e1000_init_nvm_params_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">e1000_init_phy_params_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* tag quad port adapters first, it&#39;s used below */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571EB_QUAD_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571EB_QUAD_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571EB_QUAD_COPPER_LP</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82571PT_QUAD_COPPER</span>:
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_IS_QUAD_PORT</span><span class="p">;</span>
		<span class="cm">/* mark the first port */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global_quad_port_a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_IS_QUAD_PORT_A</span><span class="p">;</span>
		<span class="cm">/* Reset for multiple quad port adapters */</span>
		<span class="n">global_quad_port_a</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global_quad_port_a</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">global_quad_port_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
		<span class="cm">/* these dual ports don&#39;t have WoL on port B at all */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">E1000_DEV_ID_82571EB_FIBER</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">E1000_DEV_ID_82571EB_SERDES</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">E1000_DEV_ID_82571EB_COPPER</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">is_port_b</span><span class="p">))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_HAS_WOL</span><span class="p">;</span>
		<span class="cm">/* quad ports only support WoL on port A */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_IS_QUAD_PORT</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_IS_QUAD_PORT_A</span><span class="p">)))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_HAS_WOL</span><span class="p">;</span>
		<span class="cm">/* Does not support WoL on any port */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">E1000_DEV_ID_82571EB_SERDES_QUAD</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_HAS_WOL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">E1000_DEV_ID_82573L</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_HAS_JUMBO_FRAMES</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_hw_frame_size</span> <span class="o">=</span> <span class="n">DEFAULT_JUMBO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_phy_id_82571 - Retrieve the PHY ID and revision</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the PHY registers and stores the PHY ID and possibly the PHY</span>
<span class="cm"> *  revision in the hardware structure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_phy_id_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="cm">/*</span>
<span class="cm">		 * The 82571 firmware may still be configuring the PHY.</span>
<span class="cm">		 * In this case, we cannot access the PHY until the</span>
<span class="cm">		 * configuration is done.  So we explicitly set the</span>
<span class="cm">		 * PHY ID.</span>
<span class="cm">		 */</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">IGP01E1000_I_PHY_ID</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
		<span class="k">return</span> <span class="n">e1000e_get_phy_id</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_ID1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">phy_id</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_ID2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">phy_id</span><span class="p">);</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PHY_REVISION_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_hw_semaphore_82571 - Acquire hardware semaphore</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquire the HW semaphore to access the PHY or NVM</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_hw_semaphore_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">swsm</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">sw_timeout</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">fw_timeout</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">word_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have timedout 3 times on trying to acquire</span>
<span class="cm">	 * the inter-port SMBI semaphore, there is old code</span>
<span class="cm">	 * operating on the other port, and it is not</span>
<span class="cm">	 * releasing SMBI. Modify the number of times that</span>
<span class="cm">	 * we try for the semaphore to interwork with this</span>
<span class="cm">	 * older code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e82571</span><span class="p">.</span><span class="n">smb_counter</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">sw_timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Get the SW semaphore */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">sw_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swsm</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">swsm</span> <span class="o">&amp;</span> <span class="n">E1000_SWSM_SMBI</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">sw_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Driver can&#39;t access device - SMBI bit is set.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e82571</span><span class="p">.</span><span class="n">smb_counter</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Get the FW semaphore. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fw_timeout</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swsm</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">,</span> <span class="n">swsm</span> <span class="o">|</span> <span class="n">E1000_SWSM_SWESMBI</span><span class="p">);</span>

		<span class="cm">/* Semaphore acquired if bit latched */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_SWSM_SWESMBI</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">fw_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Release semaphores */</span>
		<span class="n">e1000_put_hw_semaphore_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Driver can&#39;t access the NVM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_put_hw_semaphore_82571 - Release hardware semaphore</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Release hardware semaphore used to access the PHY or NVM</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_put_hw_semaphore_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">swsm</span><span class="p">;</span>

	<span class="n">swsm</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">);</span>
	<span class="n">swsm</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_SWSM_SMBI</span> <span class="o">|</span> <span class="n">E1000_SWSM_SWESMBI</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">,</span> <span class="n">swsm</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> *  e1000_get_hw_semaphore_82573 - Acquire hardware semaphore</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquire the HW semaphore during reset.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_hw_semaphore_82573</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">extcnf_ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">extcnf_ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EXTCNF_CTRL</span><span class="p">);</span>
	<span class="n">extcnf_ctrl</span> <span class="o">|=</span> <span class="n">E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EXTCNF_CTRL</span><span class="p">,</span> <span class="n">extcnf_ctrl</span><span class="p">);</span>
		<span class="n">extcnf_ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EXTCNF_CTRL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">extcnf_ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">extcnf_ctrl</span> <span class="o">|=</span> <span class="n">E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP</span><span class="p">;</span>

		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MDIO_OWNERSHIP_TIMEOUT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MDIO_OWNERSHIP_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Release semaphores */</span>
		<span class="n">e1000_put_hw_semaphore_82573</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Driver can&#39;t access the PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_put_hw_semaphore_82573 - Release hardware semaphore</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Release hardware semaphore used during reset.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_put_hw_semaphore_82573</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">extcnf_ctrl</span><span class="p">;</span>

	<span class="n">extcnf_ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EXTCNF_CTRL</span><span class="p">);</span>
	<span class="n">extcnf_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EXTCNF_CTRL</span><span class="p">,</span> <span class="n">extcnf_ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">swflag_mutex</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_hw_semaphore_82574 - Acquire hardware semaphore</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquire the HW semaphore to access the PHY or NVM.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_hw_semaphore_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swflag_mutex</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82573</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swflag_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_put_hw_semaphore_82574 - Release hardware semaphore</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Release hardware semaphore used to access the PHY or NVM</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_put_hw_semaphore_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e1000_put_hw_semaphore_82573</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swflag_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_set_d0_lplu_state_82574 - Set Low Power Linkup D0 state</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @active: true to enable LPLU, false to disable</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets the LPLU D0 state according to the active flag.</span>
<span class="cm"> *  LPLU will not be activated unless the</span>
<span class="cm"> *  device autonegotiation advertisement meets standards of</span>
<span class="cm"> *  either 10 or 10/100 or 10/100/1000 at all duplexes.</span>
<span class="cm"> *  This is a function pointer entry point only called by</span>
<span class="cm"> *  PHY setup routines.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_d0_lplu_state_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">POEMB</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">E1000_PHY_CTRL_D0A_LPLU</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_PHY_CTRL_D0A_LPLU</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">POEMB</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_set_d3_lplu_state_82574 - Sets low power link up state for D3</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @active: boolean used to enable/disable lplu</span>
<span class="cm"> *</span>
<span class="cm"> *  The low power link up (lplu) state is set to the power management level D3</span>
<span class="cm"> *  when active is true, else clear lplu for D3. LPLU</span>
<span class="cm"> *  is used during Dx states where the power conservation is most important.</span>
<span class="cm"> *  During driver activity, SmartSpeed should be enabled so performance is</span>
<span class="cm"> *  maintained.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_d3_lplu_state_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">POEMB</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_PHY_CTRL_NOND0A_LPLU</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">E1000_ALL_SPEED_DUPLEX</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">E1000_ALL_NOT_GIG</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">E1000_ALL_10_SPEED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">E1000_PHY_CTRL_NOND0A_LPLU</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">POEMB</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_acquire_nvm_82571 - Request for access to the EEPROM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  To gain access to the EEPROM, first we must obtain a hardware semaphore.</span>
<span class="cm"> *  Then for non-82573 hardware, set the EEPROM access request bit and wait</span>
<span class="cm"> *  for EEPROM access grant bit.  If the access grant bit is not set, release</span>
<span class="cm"> *  hardware semaphore.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_acquire_nvm_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_acquire_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e1000_put_hw_semaphore_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_release_nvm_82571 - Release exclusive access to EEPROM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Stop any current commands to the EEPROM and clear the EEPROM request bit.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_release_nvm_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e1000e_release_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">e1000_put_hw_semaphore_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_write_nvm_82571 - Write to EEPROM using appropriate interface</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be written to</span>
<span class="cm"> *  @words: number of words to write</span>
<span class="cm"> *  @data: 16 bit word(s) to be written to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  For non-82573 silicon, write data to EEPROM at offset using SPI interface.</span>
<span class="cm"> *</span>
<span class="cm"> *  If e1000e_update_nvm_checksum is not called after this function, the</span>
<span class="cm"> *  EEPROM will most likely contain an invalid checksum.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_write_nvm_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span>
				 <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_nvm_eewr_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_nvm_spi</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_update_nvm_checksum_82571 - Update EEPROM checksum</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Updates the EEPROM checksum by reading/adding each word of the EEPROM</span>
<span class="cm"> *  up to the checksum.  Then calculates the EEPROM checksum and writes the</span>
<span class="cm"> *  value to the EEPROM.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_update_nvm_checksum_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_update_nvm_checksum_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If our nvm is an EEPROM, then we&#39;re done</span>
<span class="cm">	 * otherwise, commit the checksum to the flash NVM.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_nvm_flash_hw</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check for pending operations. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_FLASH_UPDATES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_FLUPD</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">E1000_FLASH_UPDATES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>

	<span class="cm">/* Reset the firmware if using STM opcode. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">er32</span><span class="p">(</span><span class="n">FLOP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF00</span><span class="p">)</span> <span class="o">==</span> <span class="n">E1000_STM_OPCODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The enabling of and the actual reset must be done</span>
<span class="cm">		 * in two write cycles.</span>
<span class="cm">		 */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">HICR</span><span class="p">,</span> <span class="n">E1000_HICR_FW_RESET_ENABLE</span><span class="p">);</span>
		<span class="n">e1e_flush</span><span class="p">();</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">HICR</span><span class="p">,</span> <span class="n">E1000_HICR_FW_RESET</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Commit the write to flash */</span>
	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">)</span> <span class="o">|</span> <span class="n">E1000_EECD_FLUPD</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_FLASH_UPDATES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_FLUPD</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">E1000_FLASH_UPDATES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_validate_nvm_checksum_82571 - Validate EEPROM checksum</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Calculates the EEPROM checksum by reading/adding each word of the EEPROM</span>
<span class="cm"> *  and then verifies that the sum of the EEPROM is equal to 0xBABA.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_validate_nvm_checksum_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_nvm_flash_hw</span><span class="p">)</span>
		<span class="n">e1000_fix_nvm_checksum_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">e1000e_validate_nvm_checksum_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_write_nvm_eewr_82571 - Write to EEPROM for 82573 silicon</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: offset within the EEPROM to be written to</span>
<span class="cm"> *  @words: number of words to write</span>
<span class="cm"> *  @data: 16 bit word(s) to be written to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> *  After checking for invalid values, poll the EEPROM to ensure the previous</span>
<span class="cm"> *  command has completed before trying to write the next word.  After write</span>
<span class="cm"> *  poll for completion.</span>
<span class="cm"> *</span>
<span class="cm"> *  If e1000e_update_nvm_checksum is not called after this function, the</span>
<span class="cm"> *  EEPROM will most likely contain an invalid checksum.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_write_nvm_eewr_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">eewr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A check for invalid values:  offset too large, too many words,</span>
<span class="cm">	 * and not enough words.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">words</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;nvm parameter(s) out of bounds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_NVM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eewr</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_NVM_RW_REG_DATA</span><span class="p">)</span> <span class="o">|</span>
		       <span class="p">((</span><span class="n">offset</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_NVM_RW_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		       <span class="n">E1000_NVM_RW_REG_START</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_poll_eerd_eewr_done</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_NVM_POLL_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">EEWR</span><span class="p">,</span> <span class="n">eewr</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_poll_eerd_eewr_done</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_NVM_POLL_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_cfg_done_82571 - Poll for configuration done</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the management control register for the config done bit to be set.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_cfg_done_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">PHY_CFG_TIMEOUT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">EEMNGCTL</span><span class="p">)</span> <span class="o">&amp;</span>
		    <span class="n">E1000_NVM_CFG_DONE_PORT_0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
		<span class="n">timeout</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MNG configuration cycle has not completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_RESET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_set_d0_lplu_state_82571 - Set Low Power Linkup D0 state</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @active: true to enable LPLU, false to disable</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets the LPLU D0 state according to the active flag.  When activating LPLU</span>
<span class="cm"> *  this function also disables smart speed and vice versa.  LPLU will not be</span>
<span class="cm"> *  activated unless the device autonegotiation advertisement meets standards</span>
<span class="cm"> *  of either 10 or 10/100 or 10/100/1000 at all duplexes.  This is a function</span>
<span class="cm"> *  pointer entry point only called by PHY setup routines.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_d0_lplu_state_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP02E1000_PHY_POWER_MGMT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">IGP02E1000_PM_D0_LPLU</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP02E1000_PHY_POWER_MGMT</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* When LPLU is enabled, we should disable SmartSpeed */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP02E1000_PM_D0_LPLU</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP02E1000_PHY_POWER_MGMT</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * LPLU and SmartSpeed are mutually exclusive.  LPLU is used</span>
<span class="cm">		 * during Dx states where the power conservation is most</span>
<span class="cm">		 * important.  During driver activity we should enable</span>
<span class="cm">		 * SmartSpeed, so performance is maintained.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">smart_speed</span> <span class="o">==</span> <span class="n">e1000_smart_speed_on</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">data</span> <span class="o">|=</span> <span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">smart_speed</span> <span class="o">==</span> <span class="n">e1000_smart_speed_off</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_reset_hw_82571 - Reset hardware</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  This resets the hardware into a known state.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_reset_hw_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">,</span> <span class="n">eecd</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent the PCI-E bus from sticking if there is no TLP connection</span>
<span class="cm">	 * on the last TLP read/write transaction when MAC is reset.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_disable_pcie_master</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PCI-E Master disable polling has failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Masking off all interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">E1000_TCTL_PSP</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must acquire the MDIO ownership before MAC reset.</span>
<span class="cm">	 * Ownership defaults to firmware after a reset.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82573</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82574</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Cannot acquire MDIO ownership</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Issuing a global reset to MAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_RST</span><span class="p">);</span>

	<span class="cm">/* Must release MDIO ownership and mutex after MAC reset. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">e1000_put_hw_semaphore_82574</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_nvm_flash_hw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
		<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_EE_RST</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
		<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_get_auto_rd_done</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="cm">/* We don&#39;t want to continue accessing MAC registers. */</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Phy configuration from NVM just starts after EECD_AUTO_RD is set.</span>
<span class="cm">	 * Need to wait for Phy configuration completion before accessing</span>
<span class="cm">	 * NVM and Phy.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="cm">/*</span>
<span class="cm">		 * REQ and GNT bits need to be cleared when using AUTO_RD</span>
<span class="cm">		 * to access the EEPROM.</span>
<span class="cm">		 */</span>
		<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_REQ</span> <span class="o">|</span> <span class="n">E1000_EECD_GNT</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">msleep</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear any pending interrupt events. */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82571</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Install any alternate MAC address into RAR0 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_alt_mac_addr_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">e1000e_set_laa_state_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reinitialize the 82571 serdes link state machine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">serdes_link_state</span> <span class="o">=</span> <span class="n">e1000_serdes_link_down</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_init_hw_82571 - Initialize hardware</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  This inits the hardware readying it for operation.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_init_hw_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_data</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">rar_count</span> <span class="o">=</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">rar_entry_count</span><span class="p">;</span>

	<span class="n">e1000_initialize_hw_bits_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Initialize identification LED */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">id_led_init</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error initializing identification LED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* This is not fatal and we should not stop init due to this */</span>

	<span class="cm">/* Disabling VLAN filtering */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Initializing the IEEE VLAN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">clear_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Setup the receive address. */</span>
	<span class="cm">/*</span>
<span class="cm">	 * If, however, a locally administered address was assigned to the</span>
<span class="cm">	 * 82571, we must reserve a RAR for it to work around an issue where</span>
<span class="cm">	 * resetting one port will reload the MAC on the other port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000e_get_laa_state_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">rar_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">e1000e_init_rx_addrs</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">rar_count</span><span class="p">);</span>

	<span class="cm">/* Zero out the Multicast HASH table */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Zeroing the MTA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">mta_reg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_MTA</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Setup link and flow control */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Set the transmit descriptor write-back policy */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXDCTL_WTHRESH</span><span class="p">)</span> <span class="o">|</span>
		   <span class="n">E1000_TXDCTL_FULL_TX_DESC_WB</span> <span class="o">|</span>
		   <span class="n">E1000_TXDCTL_COUNT_DESC</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="cm">/* ...for both queues. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
		<span class="n">e1000e_enable_tx_pkt_filtering</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">reg_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GCR</span><span class="p">);</span>
		<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">E1000_GCR_L1_ACT_WITHOUT_L0S_RX</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">GCR</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">reg_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">reg_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXDCTL_WTHRESH</span><span class="p">)</span> <span class="o">|</span>
			   <span class="n">E1000_TXDCTL_FULL_TX_DESC_WB</span> <span class="o">|</span>
			   <span class="n">E1000_TXDCTL_COUNT_DESC</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reg_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear all of the statistics registers (clear on read).  It is</span>
<span class="cm">	 * important that we do this after we have tried to establish link</span>
<span class="cm">	 * because the symbol error count will increment wildly if there</span>
<span class="cm">	 * is no link.</span>
<span class="cm">	 */</span>
	<span class="n">e1000_clear_hw_cntrs_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_initialize_hw_bits_82571 - Initialize hardware-dependent bits</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Initializes required hardware-dependent bits needed for normal operation.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_initialize_hw_bits_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Transmit Descriptor Control 0 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Transmit Descriptor Control 1 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Transmit Arbitration Control 0 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xF</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span> <span class="cm">/* 30:27 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Transmit Arbitration Control 1 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">));</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_TCTL_MULR</span><span class="p">)</span>
			<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Device Control */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Extended Device Control */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82571</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PBA_ECC</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="n">E1000_PBA_ECC_CORR_EN</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">PBA_ECC</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Workaround for hardware errata.</span>
<span class="cm">	 * Ensure that DMA Dynamic Clock gating is disabled on 82571 and 82572</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82571</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82572</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_EXT_DMA_DYN_CLK_EN</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable IPv6 extension header parsing because some malformed</span>
<span class="cm">	 * IPv6 headers can hang the Rx.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;=</span> <span class="n">e1000_82573</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RFCTL</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_RFCTL_IPV6_EX_DIS</span> <span class="o">|</span> <span class="n">E1000_RFCTL_NEW_IPV6_EXT_DIS</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RFCTL</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* PCI-Ex Control Registers */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GCR</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">GCR</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Workaround for hardware errata.</span>
<span class="cm">		 * apply workaround for hardware errata documented in errata</span>
<span class="cm">		 * docs Fixes issue where some error prone or unreliable PCIe</span>
<span class="cm">		 * completions are occurring, particularly with ASPM enabled.</span>
<span class="cm">		 * Without fix, issue can cause Tx timeouts.</span>
<span class="cm">		 */</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GCR2</span><span class="p">);</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">GCR2</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_clear_vfta_82571 - Clear VLAN filter table</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Clears the register array which contains the VLAN filter table by</span>
<span class="cm"> *  setting all the values to 0.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clear_vfta_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta_bit_in_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">vlan_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The VFTA is a 4096b bit-field, each identifying</span>
<span class="cm">			 * a single VLAN ID.  The following operations</span>
<span class="cm">			 * determine which 32b entry (i.e. offset) into the</span>
<span class="cm">			 * array we want to set the VLAN ID (i.e. bit) of</span>
<span class="cm">			 * the manageability unit.</span>
<span class="cm">			 */</span>
			<span class="n">vfta_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">vlan_id</span> <span class="o">&gt;&gt;</span>
				       <span class="n">E1000_VFTA_ENTRY_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
				      <span class="n">E1000_VFTA_ENTRY_MASK</span><span class="p">;</span>
			<span class="n">vfta_bit_in_reg</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">vlan_id</span> <span class="o">&amp;</span>
					       <span class="n">E1000_VFTA_ENTRY_BIT_SHIFT_MASK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">E1000_VLAN_FILTER_TBL_SIZE</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the offset we want to clear is the same offset of the</span>
<span class="cm">		 * manageability VLAN ID, then clear all bits except that of</span>
<span class="cm">		 * the manageability unit.</span>
<span class="cm">		 */</span>
		<span class="n">vfta_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">vfta_offset</span><span class="p">)</span> <span class="o">?</span> <span class="n">vfta_bit_in_reg</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_VFTA</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vfta_value</span><span class="p">);</span>
		<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_check_mng_mode_82574 - Check manageability is enabled</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the NVM Initialization Control Word 2 and returns true</span>
<span class="cm"> *  (&gt;0) if any manageability is enabled, else false (0).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_check_mng_mode_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_INIT_CONTROL2_REG</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">E1000_NVM_INIT_CTRL2_MNGM</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_led_on_82574 - Turn LED on</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Turn LED on.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_led_on_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ledctl_mode2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">E1000_STATUS_LU</span> <span class="o">&amp;</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If no link, then turn LED on by setting the invert bit</span>
<span class="cm">		 * for each LED that&#39;s &quot;on&quot; (0x0E) in ledctl_mode2.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ledctl_mode2</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">==</span>
			    <span class="n">E1000_LEDCTL_MODE_LED_ON</span><span class="p">)</span>
				<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_LEDCTL_LED0_IVRT</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_check_phy_82574 - check 82574 phy hung state</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns whether phy is hung or not</span>
<span class="cm"> **/</span>
<span class="n">bool</span> <span class="nf">e1000_check_phy_82574</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status_1kbt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">receive_errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read PHY Receive Error counter first, if its is max - all F&#39;s then</span>
<span class="cm">	 * read the Base1000T status register If both are max then PHY is hung.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_RECEIVE_ERROR_COUNTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">receive_errors</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">receive_errors</span> <span class="o">==</span> <span class="n">E1000_RECEIVE_ERROR_MAX</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_BASE1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status_1kbt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status_1kbt</span> <span class="o">&amp;</span> <span class="n">E1000_IDLE_ERROR_COUNT_MASK</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">E1000_IDLE_ERROR_COUNT_MASK</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_setup_link_82571 - Setup flow control and link settings</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Determines which flow control settings to use, then configures flow</span>
<span class="cm"> *  control.  Calls the appropriate media-specific link configuration</span>
<span class="cm"> *  function.  Assuming the adapter has a valid link partner, a valid link</span>
<span class="cm"> *  should be established.  Assumes the hardware has previously been reset</span>
<span class="cm"> *  and the transmitter and receiver are not enabled.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_setup_link_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * 82573 does not have a word in the NVM to determine</span>
<span class="cm">	 * the default flow control setting, so we explicitly</span>
<span class="cm">	 * set it to full.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span> <span class="o">==</span> <span class="n">e1000_fc_default</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span> <span class="o">=</span> <span class="n">e1000_fc_full</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">e1000e_setup_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_setup_copper_link_82571 - Configure copper link settings</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Configures the link for auto-neg or forced speed and duplex.  Then we check</span>
<span class="cm"> *  for link, once link is established calls to configure collision distance</span>
<span class="cm"> *  and flow control are called.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_setup_copper_link_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SLU</span><span class="p">;</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_FRCSPD</span> <span class="o">|</span> <span class="n">E1000_CTRL_FRCDPX</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_phy_m88</span>:
	<span class="k">case</span> <span class="n">e1000_phy_bm</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_copper_link_setup_m88</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_phy_igp_2</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_copper_link_setup_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1000e_setup_copper_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_setup_fiber_serdes_link_82571 - Setup link for fiber/serdes</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Configures collision distance and flow control for fiber and serdes links.</span>
<span class="cm"> *  Upon successful setup, poll for link.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_setup_fiber_serdes_link_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82571</span>:
	<span class="k">case</span> <span class="n">e1000_82572</span>:
		<span class="cm">/*</span>
<span class="cm">		 * If SerDes loopback mode is entered, there is no form</span>
<span class="cm">		 * of reset to take the adapter out of that mode.  So we</span>
<span class="cm">		 * have to explicitly take the adapter out of loopback</span>
<span class="cm">		 * mode.  This prevents drivers from twiddling their thumbs</span>
<span class="cm">		 * if another tool failed to take it out of loopback mode.</span>
<span class="cm">		 */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">SCTL</span><span class="p">,</span> <span class="n">E1000_SCTL_DISABLE_SERDES_LOOPBACK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">e1000e_setup_fiber_serdes_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_check_for_serdes_link_82571 - Check for link (Serdes)</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reports the link state as up or down.</span>
<span class="cm"> *</span>
<span class="cm"> *  If autonegotiation is supported by the link partner, the link state is</span>
<span class="cm"> *  determined by the result of autonegotiation. This is the most likely case.</span>
<span class="cm"> *  If autonegotiation is not supported by the link partner, and the link</span>
<span class="cm"> *  has a valid signal, force the link up.</span>
<span class="cm"> *</span>
<span class="cm"> *  The link state is represented internally here by 4 states:</span>
<span class="cm"> *</span>
<span class="cm"> *  1) down</span>
<span class="cm"> *  2) autoneg_progress</span>
<span class="cm"> *  3) autoneg_complete (the link successfully autonegotiated)</span>
<span class="cm"> *  4) forced_up (the link has been forced up, it did not autonegotiate)</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_check_for_serdes_link_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rxcw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txcw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
	<span class="n">rxcw</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCW</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_SYNCH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_IV</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Receiver is synchronized with no invalid bits.  */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">e1000_serdes_link_autoneg_complete</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We have lost link, retry autoneg before</span>
<span class="cm">				 * reporting link failure</span>
<span class="cm">				 */</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span>
				    <span class="n">e1000_serdes_link_autoneg_progress</span><span class="p">;</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;AN_UP     -&gt; AN_PROG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">e1000_serdes_link_forced_up</span>:
			<span class="cm">/*</span>
<span class="cm">			 * If we are receiving /C/ ordered sets, re-enable</span>
<span class="cm">			 * auto-negotiation in the TXCW register and disable</span>
<span class="cm">			 * forced link in the Device Control register in an</span>
<span class="cm">			 * attempt to auto-negotiate with our link partner.</span>
<span class="cm">			 * If the partner code word is null, stop forcing</span>
<span class="cm">			 * and restart auto negotiation.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_C</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_CW</span><span class="p">))</span>  <span class="p">{</span>
				<span class="cm">/* Enable autoneg, and unforce link up */</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">,</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">txcw</span><span class="p">);</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_CTRL_SLU</span><span class="p">));</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span>
				    <span class="n">e1000_serdes_link_autoneg_progress</span><span class="p">;</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;FORCED_UP -&gt; AN_PROG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">e1000_serdes_link_autoneg_progress</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_C</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We received /C/ ordered sets, meaning the</span>
<span class="cm">				 * link partner has autonegotiated, and we can</span>
<span class="cm">				 * trust the Link Up (LU) status bit.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span>
					    <span class="n">e1000_serdes_link_autoneg_complete</span><span class="p">;</span>
					<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;AN_PROG   -&gt; AN_UP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Autoneg completed, but failed. */</span>
					<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span>
					    <span class="n">e1000_serdes_link_down</span><span class="p">;</span>
					<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;AN_PROG   -&gt; DOWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The link partner did not autoneg.</span>
<span class="cm">				 * Force link up and full duplex, and change</span>
<span class="cm">				 * state to forced.</span>
<span class="cm">				 */</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">,</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">txcw</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXCW_ANE</span><span class="p">));</span>
				<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_CTRL_SLU</span> <span class="o">|</span> <span class="n">E1000_CTRL_FD</span><span class="p">);</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

				<span class="cm">/* Configure Flow Control after link up. */</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_config_fc_after_link_up</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error config flow control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span>
				    <span class="n">e1000_serdes_link_forced_up</span><span class="p">;</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;AN_PROG   -&gt; FORCED_UP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">e1000_serdes_link_down</span>:
		<span class="nl">default:</span>
			<span class="cm">/*</span>
<span class="cm">			 * The link was down but the receiver has now gained</span>
<span class="cm">			 * valid sync, so lets see if we can bring the link</span>
<span class="cm">			 * up.</span>
<span class="cm">			 */</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">,</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">txcw</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_CTRL_SLU</span><span class="p">));</span>
			<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span>
			    <span class="n">e1000_serdes_link_autoneg_progress</span><span class="p">;</span>
			<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;DOWN      -&gt; AN_PROG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_SYNCH</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span> <span class="n">e1000_serdes_link_down</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;ANYSTATE  -&gt; DOWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check several times, if Sync and Config</span>
<span class="cm">			 * both are consistently 1 then simply ignore</span>
<span class="cm">			 * the Invalid bit and restart Autoneg</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AN_RETRY_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
				<span class="n">rxcw</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCW</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_IV</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="p">((</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_SYNCH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				      <span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_C</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
					<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span>
					    <span class="n">e1000_serdes_link_down</span><span class="p">;</span>
					<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;ANYSTATE  -&gt; DOWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">AN_RETRY_COUNT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">txcw</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">);</span>
				<span class="n">txcw</span> <span class="o">|=</span> <span class="n">E1000_TXCW_ANE</span><span class="p">;</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">,</span> <span class="n">txcw</span><span class="p">);</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_link_state</span> <span class="o">=</span>
				    <span class="n">e1000_serdes_link_autoneg_progress</span><span class="p">;</span>
				<span class="n">mac</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;ANYSTATE  -&gt; AN_PROG</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_valid_led_default_82571 - Verify a valid default LED config</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @data: pointer to the NVM (EEPROM)</span>
<span class="cm"> *</span>
<span class="cm"> *  Read the EEPROM for the current default LED configuration.  If the</span>
<span class="cm"> *  LED configuration is not valid, set to a valid LED configuration.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_valid_led_default_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_ID_LED_SETTINGS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NVM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82573</span>:
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">data</span> <span class="o">==</span> <span class="n">ID_LED_RESERVED_F746</span><span class="p">)</span>
			<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">ID_LED_DEFAULT_82573</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">data</span> <span class="o">==</span> <span class="n">ID_LED_RESERVED_0000</span> <span class="o">||</span>
		    <span class="o">*</span><span class="n">data</span> <span class="o">==</span> <span class="n">ID_LED_RESERVED_FFFF</span><span class="p">)</span>
			<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">ID_LED_DEFAULT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_get_laa_state_82571 - Get locally administered address state</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Retrieve and return the current locally administered address state.</span>
<span class="cm"> **/</span>
<span class="n">bool</span> <span class="nf">e1000e_get_laa_state_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_82571</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e82571</span><span class="p">.</span><span class="n">laa_is_present</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_set_laa_state_82571 - Set locally administered address state</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @state: enable/disable locally administered address</span>
<span class="cm"> *</span>
<span class="cm"> *  Enable/Disable the current locally administered address state.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_set_laa_state_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_82571</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e82571</span><span class="p">.</span><span class="n">laa_is_present</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/* If workaround is activated... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Hold a copy of the LAA in RAR[14] This is done so that</span>
<span class="cm">		 * between the time RAR[0] gets clobbered and the time it</span>
<span class="cm">		 * gets fixed, the actual LAA is in one of the RARs and no</span>
<span class="cm">		 * incoming packets directed to this port are dropped.</span>
<span class="cm">		 * Eventually the LAA will be in RAR[0] and RAR[14].</span>
<span class="cm">		 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
				    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">rar_entry_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_fix_nvm_checksum_82571 - Fix EEPROM checksum</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Verifies that the EEPROM has completed the update.  After updating the</span>
<span class="cm"> *  EEPROM, we need to check bit 15 in work 0x23 for the checksum fix.  If</span>
<span class="cm"> *  the checksum fix is not implemented, we need to set the bit and update</span>
<span class="cm"> *  the checksum.  Otherwise, if bit 15 is set and the checksum is incorrect,</span>
<span class="cm"> *  we need to return bad checksum.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_fix_nvm_checksum_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_nvm_flash_hw</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check bit 4 of word 10h.  If it is 0, firmware is done updating</span>
<span class="cm">	 * 10h-12h.  Checksum may need to be fixed.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Read 0x23 and check bit 15.  This bit is a 1</span>
<span class="cm">		 * when the checksum has already been fixed.  If</span>
<span class="cm">		 * the checksum is still wrong and this bit is a</span>
<span class="cm">		 * 1, we need to return bad checksum.  Otherwise,</span>
<span class="cm">		 * we need to set this bit to a 1 and update the</span>
<span class="cm">		 * checksum.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="mh">0x8000</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_update_nvm_checksum</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_mac_addr_82571 - Read device MAC address</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_read_mac_addr_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82571</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there&#39;s an alternate MAC address place it in RAR0</span>
<span class="cm">		 * so that it will override the Si installed default perm</span>
<span class="cm">		 * address.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_alt_mac_addr_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">e1000_read_mac_addr_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_power_down_phy_copper_82571 - Remove link during PHY power down</span>
<span class="cm"> * @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of a PHY power down to save power, or to turn off link during a</span>
<span class="cm"> * driver unload, or wake on lan is not enabled, remove the link.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_power_down_phy_copper_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If the management interface is not enabled, then power down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_mng_mode</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">||</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span><span class="p">(</span><span class="n">hw</span><span class="p">)))</span>
		<span class="n">e1000_power_down_phy_copper</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_clear_hw_cntrs_82571 - Clear device specific hardware counters</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Clears the hardware counters by reading the counter registers.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clear_hw_cntrs_82571</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e1000e_clear_hw_cntrs_base</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">PRC64</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC127</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC255</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC511</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC1023</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC1522</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC64</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC127</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC255</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC511</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC1023</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC1522</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">ALGNERRC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">RXERRC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">TNCRS</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">CEXTERR</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">TSCTC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">TSCTFC</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">MGTPRC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">MGTPDC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">MGTPTC</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">IAC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICRXOC</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">ICRXPTC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICRXATC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICTXPTC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICTXATC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICTXQEC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICTXQMTC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICRXDMTC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_mac_operations</span> <span class="n">e82571_mac_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* .check_mng_mode: mac type dependent */</span>
	<span class="cm">/* .check_for_link: media type dependent */</span>
	<span class="p">.</span><span class="n">id_led_init</span>		<span class="o">=</span> <span class="n">e1000e_id_led_init_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cleanup_led</span>		<span class="o">=</span> <span class="n">e1000e_cleanup_led_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_hw_cntrs</span>		<span class="o">=</span> <span class="n">e1000_clear_hw_cntrs_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_bus_info</span>		<span class="o">=</span> <span class="n">e1000e_get_bus_info_pcie</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_lan_id</span>		<span class="o">=</span> <span class="n">e1000_set_lan_id_multi_port_pcie</span><span class="p">,</span>
	<span class="cm">/* .get_link_up_info: media type dependent */</span>
	<span class="cm">/* .led_on: mac type dependent */</span>
	<span class="p">.</span><span class="n">led_off</span>		<span class="o">=</span> <span class="n">e1000e_led_off_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_mc_addr_list</span>	<span class="o">=</span> <span class="n">e1000e_update_mc_addr_list_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_vfta</span>		<span class="o">=</span> <span class="n">e1000_write_vfta_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_vfta</span>		<span class="o">=</span> <span class="n">e1000_clear_vfta_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_hw</span>		<span class="o">=</span> <span class="n">e1000_reset_hw_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_hw</span>		<span class="o">=</span> <span class="n">e1000_init_hw_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_link</span>		<span class="o">=</span> <span class="n">e1000_setup_link_82571</span><span class="p">,</span>
	<span class="cm">/* .setup_physical_interface: media type dependent */</span>
	<span class="p">.</span><span class="n">setup_led</span>		<span class="o">=</span> <span class="n">e1000e_setup_led_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">config_collision_dist</span>	<span class="o">=</span> <span class="n">e1000e_config_collision_dist_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_mac_addr</span>		<span class="o">=</span> <span class="n">e1000_read_mac_addr_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rar_set</span>		<span class="o">=</span> <span class="n">e1000e_rar_set_generic</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_phy_operations</span> <span class="n">e82_phy_ops_igp</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">acquire</span>		<span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_polarity</span>		<span class="o">=</span> <span class="n">e1000_check_polarity_igp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_reset_block</span>	<span class="o">=</span> <span class="n">e1000e_check_reset_block_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">commit</span>			<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">force_speed_duplex</span>	<span class="o">=</span> <span class="n">e1000e_phy_force_speed_duplex_igp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cfg_done</span>		<span class="o">=</span> <span class="n">e1000_get_cfg_done_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cable_length</span>	<span class="o">=</span> <span class="n">e1000e_get_cable_length_igp_2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_info</span>		<span class="o">=</span> <span class="n">e1000e_get_phy_info_igp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_reg</span>		<span class="o">=</span> <span class="n">e1000e_read_phy_reg_igp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">e1000_put_hw_semaphore_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span>			<span class="o">=</span> <span class="n">e1000e_phy_hw_reset_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_d0_lplu_state</span>	<span class="o">=</span> <span class="n">e1000_set_d0_lplu_state_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_d3_lplu_state</span>	<span class="o">=</span> <span class="n">e1000e_set_d3_lplu_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_reg</span>		<span class="o">=</span> <span class="n">e1000e_write_phy_reg_igp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cfg_on_link_up</span>      	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_phy_operations</span> <span class="n">e82_phy_ops_m88</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">acquire</span>		<span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_polarity</span>		<span class="o">=</span> <span class="n">e1000_check_polarity_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_reset_block</span>	<span class="o">=</span> <span class="n">e1000e_check_reset_block_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">commit</span>			<span class="o">=</span> <span class="n">e1000e_phy_sw_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">force_speed_duplex</span>	<span class="o">=</span> <span class="n">e1000e_phy_force_speed_duplex_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cfg_done</span>		<span class="o">=</span> <span class="n">e1000e_get_cfg_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cable_length</span>	<span class="o">=</span> <span class="n">e1000e_get_cable_length_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_info</span>		<span class="o">=</span> <span class="n">e1000e_get_phy_info_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_reg</span>		<span class="o">=</span> <span class="n">e1000e_read_phy_reg_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">e1000_put_hw_semaphore_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span>			<span class="o">=</span> <span class="n">e1000e_phy_hw_reset_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_d0_lplu_state</span>	<span class="o">=</span> <span class="n">e1000_set_d0_lplu_state_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_d3_lplu_state</span>	<span class="o">=</span> <span class="n">e1000e_set_d3_lplu_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_reg</span>		<span class="o">=</span> <span class="n">e1000e_write_phy_reg_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cfg_on_link_up</span>      	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_phy_operations</span> <span class="n">e82_phy_ops_bm</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">acquire</span>		<span class="o">=</span> <span class="n">e1000_get_hw_semaphore_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_polarity</span>		<span class="o">=</span> <span class="n">e1000_check_polarity_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_reset_block</span>	<span class="o">=</span> <span class="n">e1000e_check_reset_block_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">commit</span>			<span class="o">=</span> <span class="n">e1000e_phy_sw_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">force_speed_duplex</span>	<span class="o">=</span> <span class="n">e1000e_phy_force_speed_duplex_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cfg_done</span>		<span class="o">=</span> <span class="n">e1000e_get_cfg_done</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cable_length</span>	<span class="o">=</span> <span class="n">e1000e_get_cable_length_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_info</span>		<span class="o">=</span> <span class="n">e1000e_get_phy_info_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_reg</span>		<span class="o">=</span> <span class="n">e1000e_read_phy_reg_bm2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">e1000_put_hw_semaphore_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span>			<span class="o">=</span> <span class="n">e1000e_phy_hw_reset_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_d0_lplu_state</span>	<span class="o">=</span> <span class="n">e1000_set_d0_lplu_state_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_d3_lplu_state</span>	<span class="o">=</span> <span class="n">e1000e_set_d3_lplu_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_reg</span>		<span class="o">=</span> <span class="n">e1000e_write_phy_reg_bm2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cfg_on_link_up</span>      	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_nvm_operations</span> <span class="n">e82571_nvm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">acquire</span>		<span class="o">=</span> <span class="n">e1000_acquire_nvm_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="n">e1000e_read_nvm_eerd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">e1000_release_nvm_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reload</span>			<span class="o">=</span> <span class="n">e1000e_reload_nvm_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update</span>			<span class="o">=</span> <span class="n">e1000_update_nvm_checksum_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">valid_led_default</span>	<span class="o">=</span> <span class="n">e1000_valid_led_default_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">validate</span>		<span class="o">=</span> <span class="n">e1000_validate_nvm_checksum_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>			<span class="o">=</span> <span class="n">e1000_write_nvm_82571</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="n">e1000_82571_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>			<span class="o">=</span> <span class="n">e1000_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_JUMBO_FRAMES</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_WOL</span>
				  <span class="o">|</span> <span class="n">FLAG_APME_IN_CTRL3</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_CTRLEXT_ON_LOAD</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_SMART_POWER_DOWN</span>
				  <span class="o">|</span> <span class="n">FLAG_RESET_OVERWRITES_LAA</span> <span class="cm">/* errata */</span>
				  <span class="o">|</span> <span class="n">FLAG_TARC_SPEED_MODE_BIT</span> <span class="cm">/* errata */</span>
				  <span class="o">|</span> <span class="n">FLAG_APME_CHECK_PORT_B</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags2</span>			<span class="o">=</span> <span class="n">FLAG2_DISABLE_ASPM_L1</span> <span class="cm">/* errata 13 */</span>
				  <span class="o">|</span> <span class="n">FLAG2_DMA_BURST</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pba</span>			<span class="o">=</span> <span class="mi">38</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_hw_frame_size</span>	<span class="o">=</span> <span class="n">DEFAULT_JUMBO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_variants</span>		<span class="o">=</span> <span class="n">e1000_get_variants_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mac_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_mac_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phy_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82_phy_ops_igp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nvm_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_nvm_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="n">e1000_82572_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>			<span class="o">=</span> <span class="n">e1000_82572</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_JUMBO_FRAMES</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_WOL</span>
				  <span class="o">|</span> <span class="n">FLAG_APME_IN_CTRL3</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_CTRLEXT_ON_LOAD</span>
				  <span class="o">|</span> <span class="n">FLAG_TARC_SPEED_MODE_BIT</span><span class="p">,</span> <span class="cm">/* errata */</span>
	<span class="p">.</span><span class="n">flags2</span>			<span class="o">=</span> <span class="n">FLAG2_DISABLE_ASPM_L1</span> <span class="cm">/* errata 13 */</span>
				  <span class="o">|</span> <span class="n">FLAG2_DMA_BURST</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pba</span>			<span class="o">=</span> <span class="mi">38</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_hw_frame_size</span>	<span class="o">=</span> <span class="n">DEFAULT_JUMBO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_variants</span>		<span class="o">=</span> <span class="n">e1000_get_variants_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mac_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_mac_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phy_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82_phy_ops_igp</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nvm_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_nvm_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="n">e1000_82573_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>			<span class="o">=</span> <span class="n">e1000_82573</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_WOL</span>
				  <span class="o">|</span> <span class="n">FLAG_APME_IN_CTRL3</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_SMART_POWER_DOWN</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_AMT</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_SWSM_ON_LOAD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags2</span>			<span class="o">=</span> <span class="n">FLAG2_DISABLE_ASPM_L1</span>
				  <span class="o">|</span> <span class="n">FLAG2_DISABLE_ASPM_L0S</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pba</span>			<span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_hw_frame_size</span>	<span class="o">=</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_variants</span>		<span class="o">=</span> <span class="n">e1000_get_variants_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mac_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_mac_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phy_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82_phy_ops_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nvm_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_nvm_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="n">e1000_82574_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>			<span class="o">=</span> <span class="n">e1000_82574</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_MSIX</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_JUMBO_FRAMES</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_WOL</span>
				  <span class="o">|</span> <span class="n">FLAG_APME_IN_CTRL3</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_SMART_POWER_DOWN</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_AMT</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_CTRLEXT_ON_LOAD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags2</span>			 <span class="o">=</span> <span class="n">FLAG2_CHECK_PHY_HANG</span>
				  <span class="o">|</span> <span class="n">FLAG2_DISABLE_ASPM_L0S</span>
				  <span class="o">|</span> <span class="n">FLAG2_DISABLE_ASPM_L1</span>
				  <span class="o">|</span> <span class="n">FLAG2_NO_DISABLE_RX</span>
				  <span class="o">|</span> <span class="n">FLAG2_DMA_BURST</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pba</span>			<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_hw_frame_size</span>	<span class="o">=</span> <span class="n">DEFAULT_JUMBO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_variants</span>		<span class="o">=</span> <span class="n">e1000_get_variants_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mac_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_mac_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phy_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82_phy_ops_bm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nvm_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_nvm_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="n">e1000_82583_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>			<span class="o">=</span> <span class="n">e1000_82583</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_WOL</span>
				  <span class="o">|</span> <span class="n">FLAG_APME_IN_CTRL3</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_SMART_POWER_DOWN</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_AMT</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_JUMBO_FRAMES</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_CTRLEXT_ON_LOAD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags2</span>			<span class="o">=</span> <span class="n">FLAG2_DISABLE_ASPM_L0S</span>
				  <span class="o">|</span> <span class="n">FLAG2_NO_DISABLE_RX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pba</span>			<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_hw_frame_size</span>	<span class="o">=</span> <span class="n">DEFAULT_JUMBO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_variants</span>		<span class="o">=</span> <span class="n">e1000_get_variants_82571</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mac_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_mac_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phy_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82_phy_ops_bm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nvm_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e82571_nvm_ops</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
