<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › e1000e › phy.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>phy.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel PRO/1000 Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#include &quot;e1000.h&quot;</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_get_phy_cfg_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_phy_force_speed_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_set_d0_lplu_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_wait_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">e1000_get_phy_addr_for_bm_page</span><span class="p">(</span><span class="n">u32</span> <span class="n">page</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_access_phy_wakeup_reg_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bool</span> <span class="n">read</span><span class="p">,</span> <span class="n">bool</span> <span class="n">page_set</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">e1000_get_phy_addr_for_hv_page</span><span class="p">(</span><span class="n">u32</span> <span class="n">page</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_access_phy_debug_regs_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
                                          <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bool</span> <span class="n">read</span><span class="p">);</span>

<span class="cm">/* Cable length tables */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">e1000_m88_cable_length_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">140</span><span class="p">,</span> <span class="mi">140</span><span class="p">,</span> <span class="n">E1000_CABLE_LENGTH_UNDEFINED</span> <span class="p">};</span>
<span class="cp">#define M88E1000_CABLE_LENGTH_TABLE_SIZE \</span>
<span class="cp">		ARRAY_SIZE(e1000_m88_cable_length_table)</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">e1000_igp_2_cable_length_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
	<span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>
	<span class="mi">26</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span>
	<span class="mi">44</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span>
	<span class="mi">66</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">87</span><span class="p">,</span> <span class="mi">91</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span>
	<span class="mi">87</span><span class="p">,</span> <span class="mi">92</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">121</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span>
	<span class="mi">100</span><span class="p">,</span> <span class="mi">105</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">113</span><span class="p">,</span> <span class="mi">116</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="mi">122</span><span class="p">,</span> <span class="mi">124</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">118</span><span class="p">,</span> <span class="mi">121</span><span class="p">,</span>
	<span class="mi">124</span><span class="p">};</span>
<span class="cp">#define IGP02E1000_CABLE_LENGTH_TABLE_SIZE \</span>
<span class="cp">		ARRAY_SIZE(e1000_igp_2_cable_length_table)</span>

<span class="cp">#define BM_PHY_REG_PAGE(offset) \</span>
<span class="cp">	((u16)(((offset) &gt;&gt; PHY_PAGE_SHIFT) &amp; 0xFFFF))</span>
<span class="cp">#define BM_PHY_REG_NUM(offset) \</span>
<span class="cp">	((u16)(((offset) &amp; MAX_PHY_REG_ADDRESS) |\</span>
<span class="cp">	 (((offset) &gt;&gt; (PHY_UPPER_SHIFT - PHY_PAGE_SHIFT)) &amp;\</span>
<span class="cp">		~MAX_PHY_REG_ADDRESS)))</span>

<span class="cp">#define HV_INTC_FC_PAGE_START             768</span>
<span class="cp">#define I82578_ADDR_REG                   29</span>
<span class="cp">#define I82577_ADDR_REG                   16</span>
<span class="cp">#define I82577_CFG_REG                    22</span>
<span class="cp">#define I82577_CFG_ASSERT_CRS_ON_TX       (1 &lt;&lt; 15)</span>
<span class="cp">#define I82577_CFG_ENABLE_DOWNSHIFT       (3 &lt;&lt; 10) </span><span class="cm">/* auto downshift 100/10 */</span><span class="cp"></span>
<span class="cp">#define I82577_CTRL_REG                   23</span>

<span class="cm">/* 82577 specific PHY registers */</span>
<span class="cp">#define I82577_PHY_CTRL_2            18</span>
<span class="cp">#define I82577_PHY_STATUS_2          26</span>
<span class="cp">#define I82577_PHY_DIAG_STATUS       31</span>

<span class="cm">/* I82577 PHY Status 2 */</span>
<span class="cp">#define I82577_PHY_STATUS2_REV_POLARITY   0x0400</span>
<span class="cp">#define I82577_PHY_STATUS2_MDIX           0x0800</span>
<span class="cp">#define I82577_PHY_STATUS2_SPEED_MASK     0x0300</span>
<span class="cp">#define I82577_PHY_STATUS2_SPEED_1000MBPS 0x0200</span>

<span class="cm">/* I82577 PHY Control 2 */</span>
<span class="cp">#define I82577_PHY_CTRL2_AUTO_MDIX        0x0400</span>
<span class="cp">#define I82577_PHY_CTRL2_FORCE_MDI_MDIX   0x0200</span>

<span class="cm">/* I82577 PHY Diagnostics Status */</span>
<span class="cp">#define I82577_DSTATUS_CABLE_LENGTH       0x03FC</span>
<span class="cp">#define I82577_DSTATUS_CABLE_LENGTH_SHIFT 2</span>

<span class="cm">/* BM PHY Copper Specific Control 1 */</span>
<span class="cp">#define BM_CS_CTRL1                       16</span>

<span class="cp">#define HV_MUX_DATA_CTRL               PHY_REG(776, 16)</span>
<span class="cp">#define HV_MUX_DATA_CTRL_GEN_TO_MAC    0x0400</span>
<span class="cp">#define HV_MUX_DATA_CTRL_FORCE_SPEED   0x0004</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_check_reset_block_generic - Check if PHY reset is blocked</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Read the PHY management control register and check whether a PHY reset</span>
<span class="cm"> *  is blocked.  If a reset is not blocked return 0, otherwise</span>
<span class="cm"> *  return E1000_BLK_PHY_RESET (12).</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_check_reset_block_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">manc</span><span class="p">;</span>

	<span class="n">manc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MANC</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">manc</span> <span class="o">&amp;</span> <span class="n">E1000_MANC_BLK_PHY_RST_ON_IDE</span><span class="p">)</span> <span class="o">?</span>
	       <span class="n">E1000_BLK_PHY_RESET</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_get_phy_id - Retrieve the PHY ID and revision</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the PHY registers and stores the PHY ID and possibly the PHY</span>
<span class="cm"> *  revision in the hardware structure.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_get_phy_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">retry_count</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_ID1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">phy_id</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_ID2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="n">PHY_REVISION_MASK</span><span class="p">);</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">phy_id</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PHY_REVISION_MASK</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">PHY_REVISION_MASK</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">retry_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_phy_reset_dsp - Reset PHY DSP</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reset the digital signal processor.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_phy_reset_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_phy_reg_mdic - Read MDI control register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the MDI control register in the PHY at offset and stores the</span>
<span class="cm"> *  information read to data.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">mdic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_REG_ADDRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PHY Address %d is out of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PARAM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up Op-code, Phy Address, and register offset in the MDI</span>
<span class="cm">	 * Control register.  The MAC will take care of interfacing with the</span>
<span class="cm">	 * PHY to retrieve the desired data.</span>
<span class="cm">	 */</span>
	<span class="n">mdic</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_REG_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_PHY_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">E1000_MDIC_OP_READ</span><span class="p">));</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">MDIC</span><span class="p">,</span> <span class="n">mdic</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Poll the ready bit to see if the MDI read completed</span>
<span class="cm">	 * Increasing the time out as testing showed failures with</span>
<span class="cm">	 * the lower time out</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">E1000_GEN_POLL_TIMEOUT</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">mdic</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MDIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_READY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_READY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Read did not complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">mdic</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow some time after each MDIC transaction to avoid</span>
<span class="cm">	 * reading duplicate data in the next MDIC transaction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_pch2lan</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_phy_reg_mdic - Write MDI control register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write to register at offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Writes data to MDI control register in the PHY at offset.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">mdic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_REG_ADDRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PHY Address %d is out of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PARAM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up Op-code, Phy Address, and register offset in the MDI</span>
<span class="cm">	 * Control register.  The MAC will take care of interfacing with the</span>
<span class="cm">	 * PHY to retrieve the desired data.</span>
<span class="cm">	 */</span>
	<span class="n">mdic</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">data</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_REG_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_PHY_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">E1000_MDIC_OP_WRITE</span><span class="p">));</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">MDIC</span><span class="p">,</span> <span class="n">mdic</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Poll the ready bit to see if the MDI read completed</span>
<span class="cm">	 * Increasing the time out as testing showed failures with</span>
<span class="cm">	 * the lower time out</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">E1000_GEN_POLL_TIMEOUT</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="n">mdic</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MDIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_READY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_READY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Write did not complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow some time after each MDIC transaction to avoid</span>
<span class="cm">	 * reading duplicate data in the next MDIC transaction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_pch2lan</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_phy_reg_m88 - Read m88 PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then reads the PHY register at offset</span>
<span class="cm"> *  and storing the retrieved information in data.  Release any acquired</span>
<span class="cm"> *  semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_phy_reg_m88</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
					   <span class="n">data</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_phy_reg_m88 - Write m88 PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then writes the data to PHY register</span>
<span class="cm"> *  at the offset.  Release any acquired semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_phy_reg_m88</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
					    <span class="n">data</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_set_page_igp - Set page as on IGP-like PHY(s)</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @page: page to set (shifted left when necessary)</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets PHY page required for PHY register access.  Assumes semaphore is</span>
<span class="cm"> *  already acquired.  Note, this function sets phy.addr to 1 so the caller</span>
<span class="cm"> *  must set it appropriately (if necessary) after this function returns.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_set_page_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Setting page 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  __e1000e_read_phy_reg_igp - Read igp PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *  @locked: semaphore has already been acquired or not</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then reads the PHY register at offset</span>
<span class="cm"> *  and stores the retrieved information in data.  Release any acquired</span>
<span class="cm"> *  semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">__e1000e_read_phy_reg_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                                    <span class="n">bool</span> <span class="n">locked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						    <span class="n">IGP01E1000_PHY_PAGE_SELECT</span><span class="p">,</span>
						    <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						   <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
						   <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_phy_reg_igp - Read igp PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore then reads the PHY register at offset and stores the</span>
<span class="cm"> *  retrieved information in data.</span>
<span class="cm"> *  Release the acquired semaphore before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_phy_reg_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000e_read_phy_reg_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_phy_reg_igp_locked - Read igp PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the PHY register at offset and stores the retrieved information</span>
<span class="cm"> *  in data.  Assumes semaphore already acquired.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_phy_reg_igp_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000e_read_phy_reg_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_phy_reg_igp - Write igp PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *  @locked: semaphore has already been acquired or not</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then writes the data to PHY register</span>
<span class="cm"> *  at the offset.  Release any acquired semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">__e1000e_write_phy_reg_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">,</span>
                                     <span class="n">bool</span> <span class="n">locked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						    <span class="n">IGP01E1000_PHY_PAGE_SELECT</span><span class="p">,</span>
						    <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span>
							<span class="n">offset</span><span class="p">,</span>
						    <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_phy_reg_igp - Write igp PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore then writes the data to PHY register</span>
<span class="cm"> *  at the offset.  Release any acquired semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_phy_reg_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000e_write_phy_reg_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_phy_reg_igp_locked - Write igp PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Writes the data to PHY register at the offset.</span>
<span class="cm"> *  Assumes semaphore already acquired.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_phy_reg_igp_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000e_write_phy_reg_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  __e1000_read_kmrn_reg - Read kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *  @locked: semaphore has already been acquired or not</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary.  Then reads the PHY register at offset</span>
<span class="cm"> *  using the kumeran interface.  The information retrieved is stored in data.</span>
<span class="cm"> *  Release any acquired semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">__e1000_read_kmrn_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                                 <span class="n">bool</span> <span class="n">locked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">kmrnctrlsta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kmrnctrlsta</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_KMRNCTRLSTA_OFFSET_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		       <span class="n">E1000_KMRNCTRLSTA_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="n">E1000_KMRNCTRLSTA_REN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">KMRNCTRLSTA</span><span class="p">,</span> <span class="n">kmrnctrlsta</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">kmrnctrlsta</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">KMRNCTRLSTA</span><span class="p">);</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">kmrnctrlsta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_kmrn_reg -  Read kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore then reads the PHY register at offset using the</span>
<span class="cm"> *  kumeran interface.  The information retrieved is stored in data.</span>
<span class="cm"> *  Release the acquired semaphore before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_kmrn_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_read_kmrn_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_kmrn_reg_locked -  Read kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the PHY register at offset using the kumeran interface.  The</span>
<span class="cm"> *  information retrieved is stored in data.</span>
<span class="cm"> *  Assumes semaphore already acquired.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_kmrn_reg_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_read_kmrn_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  __e1000_write_kmrn_reg - Write kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *  @locked: semaphore has already been acquired or not</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary.  Then write the data to PHY register</span>
<span class="cm"> *  at the offset using the kumeran interface.  Release any acquired semaphores</span>
<span class="cm"> *  before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">__e1000_write_kmrn_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">,</span>
                                  <span class="n">bool</span> <span class="n">locked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">kmrnctrlsta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kmrnctrlsta</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_KMRNCTRLSTA_OFFSET_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
		       <span class="n">E1000_KMRNCTRLSTA_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">KMRNCTRLSTA</span><span class="p">,</span> <span class="n">kmrnctrlsta</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_kmrn_reg -  Write kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore then writes the data to the PHY register at the offset</span>
<span class="cm"> *  using the kumeran interface.  Release the acquired semaphore before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_kmrn_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_write_kmrn_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_kmrn_reg_locked -  Write kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Write the data to PHY register at the offset using the kumeran interface.</span>
<span class="cm"> *  Assumes semaphore already acquired.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_kmrn_reg_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_write_kmrn_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_set_master_slave_mode - Setup PHY for Master/slave mode</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets up Master/slave mode</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_master_slave_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Resolve Master/Slave mode */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* load defaults for future use */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">original_ms_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">CR_1000T_MS_ENABLE</span><span class="p">)</span> <span class="o">?</span>
	    <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">CR_1000T_MS_VALUE</span><span class="p">)</span> <span class="o">?</span>
	     <span class="n">e1000_ms_force_master</span> <span class="o">:</span> <span class="n">e1000_ms_force_slave</span><span class="p">)</span> <span class="o">:</span> <span class="n">e1000_ms_auto</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ms_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_ms_force_master</span>:
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CR_1000T_MS_ENABLE</span> <span class="o">|</span> <span class="n">CR_1000T_MS_VALUE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_ms_force_slave</span>:
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">CR_1000T_MS_ENABLE</span><span class="p">;</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CR_1000T_MS_VALUE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_ms_auto</span>:
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CR_1000T_MS_ENABLE</span><span class="p">;</span>
		<span class="cm">/* fall-through */</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_copper_link_setup_82577 - Setup 82577 PHY for copper link</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets up Carrier-sense on Transmit and downshift values.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_copper_link_setup_82577</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Enable CRS on Tx. This must be set for half-duplex operation. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">I82577_CFG_REG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">I82577_CFG_ASSERT_CRS_ON_TX</span><span class="p">;</span>

	<span class="cm">/* Enable downshift */</span>
	<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">I82577_CFG_ENABLE_DOWNSHIFT</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">I82577_CFG_REG</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1000_set_master_slave_mode</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_copper_link_setup_m88 - Setup m88 PHY&#39;s for copper link</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets up MDI/MDI-X and polarity for m88 PHY&#39;s.  If necessary, transmit clock</span>
<span class="cm"> *  and downshift values are set also.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_copper_link_setup_m88</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Enable CRS on Tx. This must be set for half-duplex operation. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* For BM PHY this bit is downshift enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_phy_bm</span><span class="p">)</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_ASSERT_CRS_ON_TX</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Options:</span>
<span class="cm">	 *   MDI/MDI-X = 0 (default)</span>
<span class="cm">	 *   0 - Auto for all speeds</span>
<span class="cm">	 *   1 - MDI mode</span>
<span class="cm">	 *   2 - MDI-X mode</span>
<span class="cm">	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)</span>
<span class="cm">	 */</span>
	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M88E1000_PSCR_AUTO_X_MODE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">mdix</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_MDI_MANUAL_MODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_MDIX_MANUAL_MODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_AUTO_X_1000T</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="nl">default:</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_AUTO_X_MODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Options:</span>
<span class="cm">	 *   disable_polarity_correction = 0 (default)</span>
<span class="cm">	 *       Automatic Correction for Reversed Cable Polarity</span>
<span class="cm">	 *   0 - Disabled</span>
<span class="cm">	 *   1 - Enabled</span>
<span class="cm">	 */</span>
	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M88E1000_PSCR_POLARITY_REVERSAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">disable_polarity_correction</span><span class="p">)</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_POLARITY_REVERSAL</span><span class="p">;</span>

	<span class="cm">/* Enable downshift on BM (disabled by default) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_bm</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For 82574/82583, first disable then enable downshift */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">BME1000_E_PHY_ID_R2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BME1000_PSCR_ENABLE_DOWNSHIFT</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span>
					   <span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="cm">/* Commit the changes. */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_commit_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error committing the PHY changes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">BME1000_PSCR_ENABLE_DOWNSHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="n">E1000_REVISION_4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">BME1000_E_PHY_ID_R2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Force TX_CLK in the Extended PHY Specific Control Register</span>
<span class="cm">		 * to 25MHz clock.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_EPSCR_TX_CLK_25</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">M88E1111_I_PHY_ID</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* 82573L PHY - set the downshift counter to 5x. */</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK</span><span class="p">;</span>
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Configure Master and Slave downshift values */</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK</span> <span class="o">|</span>
				      <span class="n">M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK</span><span class="p">);</span>
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">M88E1000_EPSCR_MASTER_DOWNSHIFT_1X</span> <span class="o">|</span>
				     <span class="n">M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_bm</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">BME1000_E_PHY_ID_R2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Set PHY page 0, register 29 to 0x0003 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* Set PHY page 0, register 30 to 0x0000 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Commit the changes. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_commit_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error committing the PHY changes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_82578</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* 82578 PHY - set the downshift count to 1x. */</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">I82578_EPSCR_DOWNSHIFT_ENABLE</span><span class="p">;</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I82578_EPSCR_DOWNSHIFT_COUNTER_MASK</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_copper_link_setup_igp - Setup igp PHY&#39;s for copper link</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Sets up LPLU, MDI/MDI-X, polarity, Smartspeed and Master/Slave config for</span>
<span class="cm"> *  igp PHY&#39;s.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_copper_link_setup_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_hw_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error resetting the PHY.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait 100ms for MAC to configure PHY from NVM settings, to avoid</span>
<span class="cm">	 * timeout issues when LFS is enabled.</span>
<span class="cm">	 */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="cm">/* disable lplu d0 during driver init */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_d0_lplu_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Disabling LPLU D0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Configure mdi-mdix settings */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCR_AUTO_MDIX</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">mdix</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCR_FORCE_MDI_MDIX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">data</span> <span class="o">|=</span> <span class="n">IGP01E1000_PSCR_FORCE_MDI_MDIX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="nl">default:</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">IGP01E1000_PSCR_AUTO_MDIX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* set auto-master slave resolution settings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">autoneg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * when autonegotiation advertisement is only 1000Mbps then we</span>
<span class="cm">		 * should disable SmartSpeed and enable Auto MasterSlave</span>
<span class="cm">		 * resolution as hardware default.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Disable SmartSpeed */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="cm">/* Set auto Master/Slave resolution process */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CR_1000T_MS_ENABLE</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_master_slave_mode</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_phy_setup_autoneg - Configure PHY for auto-negotiation</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the MII auto-neg advertisement register and/or the 1000T control</span>
<span class="cm"> *  register and if the PHY is already setup for auto-negotiation, then</span>
<span class="cm"> *  return successful.  Otherwise, setup advertisement and flow control to</span>
<span class="cm"> *  the appropriate values for the wanted auto-negotiation.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_phy_setup_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_1000t_ctrl_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_mask</span><span class="p">;</span>

	<span class="cm">/* Read the MII Auto-Neg Advertisement Register (Address 4). */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_ADV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_autoneg_adv_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_mask</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the MII 1000Base-T Control Register (Address 9). */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_1000t_ctrl_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to parse both autoneg_advertised and fc and set up</span>
<span class="cm">	 * the appropriate PHY registers.  First we will parse for</span>
<span class="cm">	 * autoneg_advertised software override.  Since we can advertise</span>
<span class="cm">	 * a plethora of combinations, we need to check each bit</span>
<span class="cm">	 * individually.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * First we clear all the 10/100 mb speed bits in the Auto-Neg</span>
<span class="cm">	 * Advertisement Register (Address 4) and the 1000 mb speed bits in</span>
<span class="cm">	 * the  1000Base-T Control Register (Address 9).</span>
<span class="cm">	 */</span>
	<span class="n">mii_autoneg_adv_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NWAY_AR_100TX_FD_CAPS</span> <span class="o">|</span>
				 <span class="n">NWAY_AR_100TX_HD_CAPS</span> <span class="o">|</span>
				 <span class="n">NWAY_AR_10T_FD_CAPS</span>   <span class="o">|</span>
				 <span class="n">NWAY_AR_10T_HD_CAPS</span><span class="p">);</span>
	<span class="n">mii_1000t_ctrl_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CR_1000T_HD_CAPS</span> <span class="o">|</span> <span class="n">CR_1000T_FD_CAPS</span><span class="p">);</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;autoneg_advertised %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span><span class="p">);</span>

	<span class="cm">/* Do we want to advertise 10 Mb Half Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_10_HALF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 10mb Half duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_10T_HD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we want to advertise 10 Mb Full Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_10_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 10mb Full duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_10T_FD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we want to advertise 100 Mb Half Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_100_HALF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 100mb Half duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_100TX_HD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we want to advertise 100 Mb Full Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_100_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 100mb Full duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_100TX_FD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We do not allow the Phy to advertise 1000 Mb Half Duplex */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_1000_HALF</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 1000mb Half duplex request denied!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Do we want to advertise 1000 Mb Full Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 1000mb Full duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_1000t_ctrl_reg</span> <span class="o">|=</span> <span class="n">CR_1000T_FD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for a software override of the flow control settings, and</span>
<span class="cm">	 * setup the PHY advertisement registers accordingly.  If</span>
<span class="cm">	 * auto-negotiation is enabled, then software will have to set the</span>
<span class="cm">	 * &quot;PAUSE&quot; bits to the correct value in the Auto-Negotiation</span>
<span class="cm">	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-</span>
<span class="cm">	 * negotiation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The possible values of the &quot;fc&quot; parameter are:</span>
<span class="cm">	 *      0:  Flow control is completely disabled</span>
<span class="cm">	 *      1:  Rx flow control is enabled (we can receive pause frames</span>
<span class="cm">	 *          but not send pause frames).</span>
<span class="cm">	 *      2:  Tx flow control is enabled (we can send pause frames</span>
<span class="cm">	 *          but we do not support receiving pause frames).</span>
<span class="cm">	 *      3:  Both Rx and Tx flow control (symmetric) are enabled.</span>
<span class="cm">	 *  other:  No software override.  The flow control configuration</span>
<span class="cm">	 *          in the EEPROM is used.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_fc_none</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Flow control (Rx &amp; Tx) is completely disabled by a</span>
<span class="cm">		 * software over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NWAY_AR_ASM_DIR</span> <span class="o">|</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_fc_rx_pause</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Rx Flow control is enabled, and Tx Flow control is</span>
<span class="cm">		 * disabled, by a software over-ride.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Since there really isn&#39;t a way to advertise that we are</span>
<span class="cm">		 * capable of Rx Pause ONLY, we will advertise that we</span>
<span class="cm">		 * support both symmetric and asymmetric Rx PAUSE.  Later</span>
<span class="cm">		 * (in e1000e_config_fc_after_link_up) we will disable the</span>
<span class="cm">		 * hw&#39;s ability to send PAUSE frames.</span>
<span class="cm">		 */</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NWAY_AR_ASM_DIR</span> <span class="o">|</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_fc_tx_pause</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Tx Flow control is enabled, and Rx Flow control is</span>
<span class="cm">		 * disabled, by a software over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_ASM_DIR</span><span class="p">;</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NWAY_AR_PAUSE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_fc_full</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Flow control (both Rx and Tx) is enabled by a software</span>
<span class="cm">		 * over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NWAY_AR_ASM_DIR</span> <span class="o">|</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Flow control param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_ADV</span><span class="p">,</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Auto-Neg Advertising %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_mask</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="n">mii_1000t_ctrl_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_copper_link_autoneg - Setup/Enable autoneg for copper link</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Performs initial bounds checking on autoneg advertisement parameter, then</span>
<span class="cm"> *  configure to advertise the full capability.  Setup the PHY to autoneg</span>
<span class="cm"> *  and restart the negotiation process between the link partner.  If</span>
<span class="cm"> *  autoneg_wait_to_complete, then wait for autoneg to complete before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_copper_link_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_ctrl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perform some bounds checking on the autoneg advertisement</span>
<span class="cm">	 * parameter.</span>
<span class="cm">	 */</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If autoneg_advertised is zero, we assume it was not defaulted</span>
<span class="cm">	 * by the calling code so we set to advertise full capability.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span><span class="p">)</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_mask</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Reconfiguring auto-neg advertisement params</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_setup_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Setting up Auto-Negotiation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Restarting Auto-Neg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restart auto-negotiation by setting the Auto Neg Enable bit and</span>
<span class="cm">	 * the Auto Neg Restart bit in the PHY control register.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MII_CR_AUTO_NEG_EN</span> <span class="o">|</span> <span class="n">MII_CR_RESTART_AUTO_NEG</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">phy_ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Does the user want to wait for Auto-Neg to complete here, or</span>
<span class="cm">	 * check at a later time (for example, callback routine).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_wait_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error while waiting for autoneg to complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_setup_copper_link - Configure copper link settings</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Calls the appropriate function to configure the link for auto-neg or forced</span>
<span class="cm"> *  speed and duplex.  Then we check for link, once link is established calls</span>
<span class="cm"> *  to configure collision distance and flow control are called.  If link is</span>
<span class="cm"> *  not established, we return -E1000_ERR_PHY (-2).</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_setup_copper_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">autoneg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Setup autoneg and flow control advertisement and perform</span>
<span class="cm">		 * autonegotiation.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * PHY will be set to 10H, 10F, 100H or 100F</span>
<span class="cm">		 * depending on user settings.</span>
<span class="cm">		 */</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Forcing Speed and Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_force_speed_duplex</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Forcing Speed and Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check link status. Wait up to 100 microseconds for link to become</span>
<span class="cm">	 * valid.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">COPPER_LINK_UP_LIMIT</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Valid link established!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_config_fc_after_link_up</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Unable to establish link!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_phy_force_speed_duplex_igp - Force speed/duplex for igp PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Calls the PHY setup function to force speed and duplex.  Clears the</span>
<span class="cm"> *  auto-crossover to force MDI manually.  Waits for link and returns</span>
<span class="cm"> *  successful if link up is successful, else -E1000_ERR_PHY (-2).</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_phy_force_speed_duplex_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e1000e_phy_force_speed_duplex_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear Auto-Crossover to force MDI manually.  IGP requires MDI</span>
<span class="cm">	 * forced whenever speed and duplex are forced.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCR_AUTO_MDIX</span><span class="p">;</span>
	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCR_FORCE_MDI_MDIX</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;IGP PSCR: %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Waiting for forced speed/duplex link on IGP phy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						      <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Link taking longer than expected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Try once more */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						      <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_phy_force_speed_duplex_m88 - Force speed/duplex for m88 PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Calls the PHY setup function to force speed and duplex.  Clears the</span>
<span class="cm"> *  auto-crossover to force MDI manually.  Resets the PHY to commit the</span>
<span class="cm"> *  changes.  If time expires while waiting for link up, we reset the DSP.</span>
<span class="cm"> *  After reset, TX_CLK and CRS on Tx must be set.  Return successful upon</span>
<span class="cm"> *  successful completion, else return corresponding error code.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_phy_force_speed_duplex_m88</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear Auto-Crossover to force MDI manually.  M88E1000 requires MDI</span>
<span class="cm">	 * forced whenever speed and duplex are forced.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M88E1000_PSCR_AUTO_X_MODE</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;M88E1000 PSCR: %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e1000e_phy_force_speed_duplex_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Reset the phy to commit changes. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_commit_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Waiting for forced speed/duplex link on M88 phy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						     <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Link taking longer than expected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We didn&#39;t get link.</span>
<span class="cm">				 * Reset the DSP and cross our fingers.</span>
<span class="cm">				 */</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span>
						   <span class="mh">0x001d</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
				<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_reset_dsp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Try once more */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						     <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_phy_m88</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Resetting the phy means we need to re-force TX_CLK in the</span>
<span class="cm">	 * Extended PHY Specific Control Register to 25MHz clock from</span>
<span class="cm">	 * the reset value of 2.5MHz.</span>
<span class="cm">	 */</span>
	<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_EPSCR_TX_CLK_25</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In addition, we must re-enable CRS on Tx for both half and full</span>
<span class="cm">	 * duplex.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_ASSERT_CRS_ON_TX</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_phy_force_speed_duplex_ife - Force PHY speed &amp; duplex</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Forces the speed and duplex settings of the PHY.</span>
<span class="cm"> *  This is a function pointer entry point only called by</span>
<span class="cm"> *  PHY setup routines.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_phy_force_speed_duplex_ife</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e1000e_phy_force_speed_duplex_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Disable MDI-X support for 10/100 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IFE_PHY_MDIX_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFE_PMC_AUTO_MDIX</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFE_PMC_FORCE_MDIX</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IFE_PHY_MDIX_CONTROL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;IFE PMC: %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Waiting for forced speed/duplex link on IFE phy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						      <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Link taking longer than expected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Try once more */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						      <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_phy_force_speed_duplex_setup - Configure forced PHY speed/duplex</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @phy_ctrl: pointer to current value of PHY_CONTROL</span>
<span class="cm"> *</span>
<span class="cm"> *  Forces speed and duplex on the PHY by doing the following: disable flow</span>
<span class="cm"> *  control, force speed/duplex on the MAC, disable auto speed detection,</span>
<span class="cm"> *  disable auto-negotiation, configure duplex, configure speed, configure</span>
<span class="cm"> *  the collision distance, write configuration to CTRL register.  The</span>
<span class="cm"> *  caller must write to the PHY_CONTROL register for these settings to</span>
<span class="cm"> *  take affect.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_phy_force_speed_duplex_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">phy_ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="cm">/* Turn off flow control when forcing speed/duplex */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">e1000_fc_none</span><span class="p">;</span>

	<span class="cm">/* Force speed/duplex on the mac */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_CTRL_FRCSPD</span> <span class="o">|</span> <span class="n">E1000_CTRL_FRCDPX</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_SPD_SEL</span><span class="p">;</span>

	<span class="cm">/* Disable Auto Speed Detection */</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_ASDE</span><span class="p">;</span>

	<span class="cm">/* Disable autoneg on the phy */</span>
	<span class="o">*</span><span class="n">phy_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MII_CR_AUTO_NEG_EN</span><span class="p">;</span>

	<span class="cm">/* Forcing Full or Half Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">&amp;</span> <span class="n">E1000_ALL_HALF_DUPLEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_FD</span><span class="p">;</span>
		<span class="o">*</span><span class="n">phy_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MII_CR_FULL_DUPLEX</span><span class="p">;</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Half Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_FD</span><span class="p">;</span>
		<span class="o">*</span><span class="n">phy_ctrl</span> <span class="o">|=</span> <span class="n">MII_CR_FULL_DUPLEX</span><span class="p">;</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Full Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Forcing 10mb or 100mb? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">&amp;</span> <span class="n">E1000_ALL_100_SPEED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SPD_100</span><span class="p">;</span>
		<span class="o">*</span><span class="n">phy_ctrl</span> <span class="o">|=</span> <span class="n">MII_CR_SPEED_100</span><span class="p">;</span>
		<span class="o">*</span><span class="n">phy_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MII_CR_SPEED_1000</span> <span class="o">|</span> <span class="n">MII_CR_SPEED_10</span><span class="p">);</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Forcing 100mb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_SPD_1000</span> <span class="o">|</span> <span class="n">E1000_CTRL_SPD_100</span><span class="p">);</span>
		<span class="o">*</span><span class="n">phy_ctrl</span> <span class="o">|=</span> <span class="n">MII_CR_SPEED_10</span><span class="p">;</span>
		<span class="o">*</span><span class="n">phy_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MII_CR_SPEED_1000</span> <span class="o">|</span> <span class="n">MII_CR_SPEED_100</span><span class="p">);</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Forcing 10mb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_set_d3_lplu_state - Sets low power link up state for D3</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @active: boolean used to enable/disable lplu</span>
<span class="cm"> *</span>
<span class="cm"> *  Success returns 0, Failure returns 1</span>
<span class="cm"> *</span>
<span class="cm"> *  The low power link up (lplu) state is set to the power management level D3</span>
<span class="cm"> *  and SmartSpeed is disabled when active is true, else clear lplu for D3</span>
<span class="cm"> *  and enable Smartspeed.  LPLU and Smartspeed are mutually exclusive.  LPLU</span>
<span class="cm"> *  is used during Dx states where the power conservation is most important.</span>
<span class="cm"> *  During driver activity, SmartSpeed should be enabled so performance is</span>
<span class="cm"> *  maintained.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_set_d3_lplu_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP02E1000_PHY_POWER_MGMT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP02E1000_PM_D3_LPLU</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP02E1000_PHY_POWER_MGMT</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * LPLU and SmartSpeed are mutually exclusive.  LPLU is used</span>
<span class="cm">		 * during Dx states where the power conservation is most</span>
<span class="cm">		 * important.  During driver activity we should enable</span>
<span class="cm">		 * SmartSpeed, so performance is maintained.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">smart_speed</span> <span class="o">==</span> <span class="n">e1000_smart_speed_on</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">data</span> <span class="o">|=</span> <span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">smart_speed</span> <span class="o">==</span> <span class="n">e1000_smart_speed_off</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					   <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">E1000_ALL_SPEED_DUPLEX</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">E1000_ALL_NOT_GIG</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">E1000_ALL_10_SPEED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">IGP02E1000_PM_D3_LPLU</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP02E1000_PHY_POWER_MGMT</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* When LPLU is enabled, we should disable SmartSpeed */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_check_downshift - Checks whether a downshift in speed occurred</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Success returns 0, Failure returns 1</span>
<span class="cm"> *</span>
<span class="cm"> *  A downshift is detected by querying the PHY link health.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_check_downshift</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_phy_m88</span>:
	<span class="k">case</span> <span class="n">e1000_phy_gg82563</span>:
	<span class="k">case</span> <span class="n">e1000_phy_bm</span>:
	<span class="k">case</span> <span class="n">e1000_phy_82578</span>:
		<span class="n">offset</span>	<span class="o">=</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">;</span>
		<span class="n">mask</span>	<span class="o">=</span> <span class="n">M88E1000_PSSR_DOWNSHIFT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_phy_igp_2</span>:
	<span class="k">case</span> <span class="n">e1000_phy_igp_3</span>:
		<span class="n">offset</span>	<span class="o">=</span> <span class="n">IGP01E1000_PHY_LINK_HEALTH</span><span class="p">;</span>
		<span class="n">mask</span>	<span class="o">=</span> <span class="n">IGP01E1000_PLHR_SS_DOWNGRADE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* speed downshift not supported */</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">speed_downgraded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">speed_downgraded</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_check_polarity_m88 - Checks the polarity.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)</span>
<span class="cm"> *</span>
<span class="cm"> *  Polarity is determined based on the PHY specific status register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_check_polarity_m88</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_polarity</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_REV_POLARITY</span><span class="p">)</span>
				      <span class="o">?</span> <span class="n">e1000_rev_polarity_reversed</span>
				      <span class="o">:</span> <span class="n">e1000_rev_polarity_normal</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_check_polarity_igp - Checks the polarity.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)</span>
<span class="cm"> *</span>
<span class="cm"> *  Polarity is determined based on the PHY port status register, and the</span>
<span class="cm"> *  current speed (since there is no polarity at 100Mbps).</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_check_polarity_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Polarity is determined based on the speed of</span>
<span class="cm">	 * our connection.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PSSR_SPEED_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IGP01E1000_PSSR_SPEED_1000MBPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span>	<span class="o">=</span> <span class="n">IGP01E1000_PHY_PCS_INIT_REG</span><span class="p">;</span>
		<span class="n">mask</span>	<span class="o">=</span> <span class="n">IGP01E1000_PHY_POLARITY_MASK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This really only applies to 10Mbps since</span>
<span class="cm">		 * there is no polarity for 100Mbps (always 0).</span>
<span class="cm">		 */</span>
		<span class="n">offset</span>	<span class="o">=</span> <span class="n">IGP01E1000_PHY_PORT_STATUS</span><span class="p">;</span>
		<span class="n">mask</span>	<span class="o">=</span> <span class="n">IGP01E1000_PSSR_POLARITY_REVERSED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_polarity</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
				      <span class="o">?</span> <span class="n">e1000_rev_polarity_reversed</span>
				      <span class="o">:</span> <span class="n">e1000_rev_polarity_normal</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_check_polarity_ife - Check cable polarity for IFE PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Polarity is determined on the polarity reversal feature being enabled.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_check_polarity_ife</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Polarity is determined based on the reversal feature being enabled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">polarity_correction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">IFE_PHY_EXTENDED_STATUS_CONTROL</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">IFE_PESC_POLARITY_REVERSED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">IFE_PHY_SPECIAL_CONTROL</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">IFE_PSC_FORCE_POLARITY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_polarity</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
		                       <span class="o">?</span> <span class="n">e1000_rev_polarity_reversed</span>
		                       <span class="o">:</span> <span class="n">e1000_rev_polarity_normal</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_wait_autoneg - Wait for auto-neg completion</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Waits for auto-negotiation to complete or for the auto-negotiation time</span>
<span class="cm"> *  limit to expire, which ever happens first.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_wait_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">phy_status</span><span class="p">;</span>

	<span class="cm">/* Break after autoneg completes or PHY_AUTO_NEG_LIMIT expires. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PHY_AUTO_NEG_LIMIT</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_status</span> <span class="o">&amp;</span> <span class="n">MII_SR_AUTONEG_COMPLETE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * PHY_AUTO_NEG_TIME expiration doesn&#39;t guarantee auto-negotiation</span>
<span class="cm">	 * has completed.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_phy_has_link_generic - Polls PHY for link</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @iterations: number of times to poll for link</span>
<span class="cm"> *  @usec_interval: delay between polling attempts</span>
<span class="cm"> *  @success: pointer to whether polling was successful or not</span>
<span class="cm"> *</span>
<span class="cm"> *  Polls the PHY status register for link, &#39;iterations&#39; number of times.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">iterations</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">usec_interval</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">success</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">phy_status</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some PHYs require the PHY_STATUS register to be read</span>
<span class="cm">		 * twice due to the link bit being sticky.  No harm doing</span>
<span class="cm">		 * it across the board.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the first read fails, another entity may have</span>
<span class="cm">			 * ownership of the resources, wait and try again to</span>
<span class="cm">			 * see if they have relinquished the resources yet.</span>
<span class="cm">			 */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">usec_interval</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_status</span> <span class="o">&amp;</span> <span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usec_interval</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="n">usec_interval</span><span class="o">/</span><span class="mi">1000</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">usec_interval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">success</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_get_cable_length_m88 - Determine cable length for m88 PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the PHY specific status register to retrieve the cable length</span>
<span class="cm"> *  information.  The cable length is determined by averaging the minimum and</span>
<span class="cm"> *  maximum values to get the &quot;average&quot; cable length.  The m88 PHY has four</span>
<span class="cm"> *  possible cable length values, which are:</span>
<span class="cm"> *	Register Value		Cable Length</span>
<span class="cm"> *	0			&lt; 50 meters</span>
<span class="cm"> *	1			50 - 80 meters</span>
<span class="cm"> *	2			80 - 110 meters</span>
<span class="cm"> *	3			110 - 140 meters</span>
<span class="cm"> *	4			&gt; 140 meters</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_get_cable_length_m88</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_CABLE_LENGTH</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
	        <span class="n">M88E1000_PSSR_CABLE_LENGTH_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">M88E1000_CABLE_LENGTH_TABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">min_cable_length</span> <span class="o">=</span> <span class="n">e1000_m88_cable_length_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">max_cable_length</span> <span class="o">=</span> <span class="n">e1000_m88_cable_length_table</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">min_cable_length</span> <span class="o">+</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">max_cable_length</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_get_cable_length_igp_2 - Determine cable length for igp2 PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  The automatic gain control (agc) normalizes the amplitude of the</span>
<span class="cm"> *  received signal, adjusting for the attenuation produced by the</span>
<span class="cm"> *  cable.  By reading the AGC registers, which represent the</span>
<span class="cm"> *  combination of coarse and fine gain value, the value can be put</span>
<span class="cm"> *  into a lookup table to obtain the approximate cable length</span>
<span class="cm"> *  for each channel.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_get_cable_length_igp_2</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">agc_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cur_agc_index</span><span class="p">,</span> <span class="n">max_agc_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">min_agc_index</span> <span class="o">=</span> <span class="n">IGP02E1000_CABLE_LENGTH_TABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">agc_reg_array</span><span class="p">[</span><span class="n">IGP02E1000_PHY_CHANNEL_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	       <span class="n">IGP02E1000_PHY_AGC_A</span><span class="p">,</span>
	       <span class="n">IGP02E1000_PHY_AGC_B</span><span class="p">,</span>
	       <span class="n">IGP02E1000_PHY_AGC_C</span><span class="p">,</span>
	       <span class="n">IGP02E1000_PHY_AGC_D</span>
	<span class="p">};</span>

	<span class="cm">/* Read the AGC registers for all channels */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IGP02E1000_PHY_CHANNEL_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">agc_reg_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Getting bits 15:9, which represent the combination of</span>
<span class="cm">		 * coarse and fine gain values.  The result is a number</span>
<span class="cm">		 * that can be put into the lookup table to obtain the</span>
<span class="cm">		 * approximate cable length.</span>
<span class="cm">		 */</span>
		<span class="n">cur_agc_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&gt;&gt;</span> <span class="n">IGP02E1000_AGC_LENGTH_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">IGP02E1000_AGC_LENGTH_MASK</span><span class="p">;</span>

		<span class="cm">/* Array index bound check. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cur_agc_index</span> <span class="o">&gt;=</span> <span class="n">IGP02E1000_CABLE_LENGTH_TABLE_SIZE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">cur_agc_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>

		<span class="cm">/* Remove min &amp; max AGC values from calculation. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_igp_2_cable_length_table</span><span class="p">[</span><span class="n">min_agc_index</span><span class="p">]</span> <span class="o">&gt;</span>
		    <span class="n">e1000_igp_2_cable_length_table</span><span class="p">[</span><span class="n">cur_agc_index</span><span class="p">])</span>
			<span class="n">min_agc_index</span> <span class="o">=</span> <span class="n">cur_agc_index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_igp_2_cable_length_table</span><span class="p">[</span><span class="n">max_agc_index</span><span class="p">]</span> <span class="o">&lt;</span>
		    <span class="n">e1000_igp_2_cable_length_table</span><span class="p">[</span><span class="n">cur_agc_index</span><span class="p">])</span>
			<span class="n">max_agc_index</span> <span class="o">=</span> <span class="n">cur_agc_index</span><span class="p">;</span>

		<span class="n">agc_value</span> <span class="o">+=</span> <span class="n">e1000_igp_2_cable_length_table</span><span class="p">[</span><span class="n">cur_agc_index</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">agc_value</span> <span class="o">-=</span> <span class="p">(</span><span class="n">e1000_igp_2_cable_length_table</span><span class="p">[</span><span class="n">min_agc_index</span><span class="p">]</span> <span class="o">+</span>
		      <span class="n">e1000_igp_2_cable_length_table</span><span class="p">[</span><span class="n">max_agc_index</span><span class="p">]);</span>
	<span class="n">agc_value</span> <span class="o">/=</span> <span class="p">(</span><span class="n">IGP02E1000_PHY_CHANNEL_NUM</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Calculate cable length with the error range of +/- 10 meters. */</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">min_cable_length</span> <span class="o">=</span> <span class="p">((</span><span class="n">agc_value</span> <span class="o">-</span> <span class="n">IGP02E1000_AGC_RANGE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
				 <span class="p">(</span><span class="n">agc_value</span> <span class="o">-</span> <span class="n">IGP02E1000_AGC_RANGE</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">max_cable_length</span> <span class="o">=</span> <span class="n">agc_value</span> <span class="o">+</span> <span class="n">IGP02E1000_AGC_RANGE</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">min_cable_length</span> <span class="o">+</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">max_cable_length</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_get_phy_info_m88 - Retrieve PHY information</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Valid for only copper links.  Read the PHY status register (sticky read)</span>
<span class="cm"> *  to verify that link is up.  Read the PHY special control register to</span>
<span class="cm"> *  determine the polarity and 10base-T extended distance.  Read the PHY</span>
<span class="cm"> *  special status register to determine MDI/MDIx and current speed.  If</span>
<span class="cm"> *  speed is 1000, then determine cable length, local and remote receiver.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_get_phy_info_m88</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span>  <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Phy info is only valid for copper media</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Phy info is only valid if link is up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">polarity_correction</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span>
				      <span class="n">M88E1000_PSCR_POLARITY_REVERSAL</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_polarity_m88</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">is_mdix</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_MDIX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_SPEED</span><span class="p">)</span> <span class="o">==</span> <span class="n">M88E1000_PSSR_1000MBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_cable_length</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_LOCAL_RX_STATUS</span><span class="p">)</span>
				<span class="o">?</span> <span class="n">e1000_1000t_rx_status_ok</span>
				<span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_REMOTE_RX_STATUS</span><span class="p">)</span>
				 <span class="o">?</span> <span class="n">e1000_1000t_rx_status_ok</span>
				 <span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Set values to &quot;undefined&quot; */</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">E1000_CABLE_LENGTH_UNDEFINED</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_get_phy_info_igp - Retrieve igp PHY information</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Read PHY status to determine if link is up.  If link is up, then</span>
<span class="cm"> *  set/determine 10base-T extended distance and polarity correction.  Read</span>
<span class="cm"> *  PHY port status to determine MDI/MDIx and speed.  Based on the speed,</span>
<span class="cm"> *  determine on the cable length, local and remote receiver.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_get_phy_info_igp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Phy info is only valid if link is up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">polarity_correction</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_polarity_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">is_mdix</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PSSR_MDIX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PSSR_SPEED_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IGP01E1000_PSSR_SPEED_1000MBPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_cable_length</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_LOCAL_RX_STATUS</span><span class="p">)</span>
				<span class="o">?</span> <span class="n">e1000_1000t_rx_status_ok</span>
				<span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_REMOTE_RX_STATUS</span><span class="p">)</span>
				 <span class="o">?</span> <span class="n">e1000_1000t_rx_status_ok</span>
				 <span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">E1000_CABLE_LENGTH_UNDEFINED</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_phy_info_ife - Retrieves various IFE PHY states</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Populates &quot;phy&quot; structure with various feature states.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_get_phy_info_ife</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Phy info is only valid if link is up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IFE_PHY_SPECIAL_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">polarity_correction</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">IFE_PSC_AUTO_POLARITY_DISABLE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">polarity_correction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_polarity_ife</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Polarity is forced */</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_polarity</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">IFE_PSC_FORCE_POLARITY</span><span class="p">)</span>
		                      <span class="o">?</span> <span class="n">e1000_rev_polarity_reversed</span>
		                      <span class="o">:</span> <span class="n">e1000_rev_polarity_normal</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IFE_PHY_MDIX_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">is_mdix</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">IFE_PMC_MDIX_STATUS</span><span class="p">);</span>

	<span class="cm">/* The following parameters are undefined for 10/100 operation. */</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">E1000_CABLE_LENGTH_UNDEFINED</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_phy_sw_reset - PHY software reset</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Does a software reset of the PHY by reading the PHY control register and</span>
<span class="cm"> *  setting/write the control register reset bit to the PHY.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_phy_sw_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_ctrl</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_ctrl</span> <span class="o">|=</span> <span class="n">MII_CR_RESET</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">phy_ctrl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_phy_hw_reset_generic - PHY hardware reset</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Verify the reset block is not blocking us from resetting.  Acquire</span>
<span class="cm"> *  semaphore (if necessary) and read/set/write the device control reset</span>
<span class="cm"> *  bit in the PHY.  Wait the appropriate delay time for the device to</span>
<span class="cm"> *  reset and release the semaphore (if necessary).</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_phy_hw_reset_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_PHY_RST</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="n">udelay</span><span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">reset_delay_us</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">150</span><span class="p">);</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">e1000_get_phy_cfg_done</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_get_cfg_done - Generic configuration done</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Generic function to wait 10 milli-seconds for configuration to complete</span>
<span class="cm"> *  and return success.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_get_cfg_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_phy_init_script_igp3 - Inits the IGP3 PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Initializes a Intel Gigabit PHY3 when an EEPROM is not present.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_phy_init_script_igp3</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Running IGP 3 PHY init script</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* PHY init IGP 3 */</span>
	<span class="cm">/* Enable rise/fall, 10-mode work in class-A */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="mh">0x9018</span><span class="p">);</span>
	<span class="cm">/* Remove all caps from Replica path filter */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F52</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="cm">/* Bias trimming for ADC, AFE and Driver (Default) */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2FB1</span><span class="p">,</span> <span class="mh">0x8B24</span><span class="p">);</span>
	<span class="cm">/* Increase Hybrid poly bias */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2FB2</span><span class="p">,</span> <span class="mh">0xF8F0</span><span class="p">);</span>
	<span class="cm">/* Add 4% to Tx amplitude in Gig mode */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2010</span><span class="p">,</span> <span class="mh">0x10B0</span><span class="p">);</span>
	<span class="cm">/* Disable trimming (TTT) */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2011</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="cm">/* Poly DC correction to 94.6% + 2% for all channels */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x20DD</span><span class="p">,</span> <span class="mh">0x249A</span><span class="p">);</span>
	<span class="cm">/* ABS DC correction to 95.9% */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x20DE</span><span class="p">,</span> <span class="mh">0x00D3</span><span class="p">);</span>
	<span class="cm">/* BG temp curve trim */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x28B4</span><span class="p">,</span> <span class="mh">0x04CE</span><span class="p">);</span>
	<span class="cm">/* Increasing ADC OPAMP stage 1 currents to max */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F70</span><span class="p">,</span> <span class="mh">0x29E4</span><span class="p">);</span>
	<span class="cm">/* Force 1000 ( required for enabling PHY regs configuration) */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x0140</span><span class="p">);</span>
	<span class="cm">/* Set upd_freq to 6 */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F30</span><span class="p">,</span> <span class="mh">0x1606</span><span class="p">);</span>
	<span class="cm">/* Disable NPDFE */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F31</span><span class="p">,</span> <span class="mh">0xB814</span><span class="p">);</span>
	<span class="cm">/* Disable adaptive fixed FFE (Default) */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F35</span><span class="p">,</span> <span class="mh">0x002A</span><span class="p">);</span>
	<span class="cm">/* Enable FFE hysteresis */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F3E</span><span class="p">,</span> <span class="mh">0x0067</span><span class="p">);</span>
	<span class="cm">/* Fixed FFE for short cable lengths */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F54</span><span class="p">,</span> <span class="mh">0x0065</span><span class="p">);</span>
	<span class="cm">/* Fixed FFE for medium cable lengths */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F55</span><span class="p">,</span> <span class="mh">0x002A</span><span class="p">);</span>
	<span class="cm">/* Fixed FFE for long cable lengths */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F56</span><span class="p">,</span> <span class="mh">0x002A</span><span class="p">);</span>
	<span class="cm">/* Enable Adaptive Clip Threshold */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F72</span><span class="p">,</span> <span class="mh">0x3FB0</span><span class="p">);</span>
	<span class="cm">/* AHT reset limit to 1 */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F76</span><span class="p">,</span> <span class="mh">0xC0FF</span><span class="p">);</span>
	<span class="cm">/* Set AHT master delay to 127 msec */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F77</span><span class="p">,</span> <span class="mh">0x1DEC</span><span class="p">);</span>
	<span class="cm">/* Set scan bits for AHT */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F78</span><span class="p">,</span> <span class="mh">0xF9EF</span><span class="p">);</span>
	<span class="cm">/* Set AHT Preset bits */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F79</span><span class="p">,</span> <span class="mh">0x0210</span><span class="p">);</span>
	<span class="cm">/* Change integ_factor of channel A to 3 */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1895</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">);</span>
	<span class="cm">/* Change prop_factor of channels BCD to 8 */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1796</span><span class="p">,</span> <span class="mh">0x0008</span><span class="p">);</span>
	<span class="cm">/* Change cg_icount + enable integbp for channels BCD */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1798</span><span class="p">,</span> <span class="mh">0xD008</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Change cg_icount + enable integbp + change prop_factor_master</span>
<span class="cm">	 * to 8 for channel A</span>
<span class="cm">	 */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1898</span><span class="p">,</span> <span class="mh">0xD918</span><span class="p">);</span>
	<span class="cm">/* Disable AHT in Slave mode on channel A */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x187A</span><span class="p">,</span> <span class="mh">0x0800</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable LPLU and disable AN to 1000 in non-D0a states,</span>
<span class="cm">	 * Enable SPD+B2B</span>
<span class="cm">	 */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0019</span><span class="p">,</span> <span class="mh">0x008D</span><span class="p">);</span>
	<span class="cm">/* Enable restart AN on an1000_dis change */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x001B</span><span class="p">,</span> <span class="mh">0x2080</span><span class="p">);</span>
	<span class="cm">/* Enable wh_fifo read clock in 10/100 modes */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0014</span><span class="p">,</span> <span class="mh">0x0045</span><span class="p">);</span>
	<span class="cm">/* Restart AN, Speed selection is 1000 */</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x1340</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Internal function pointers */</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_phy_cfg_done - Generic PHY configuration done</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Return success if silicon family did not implement a family specific</span>
<span class="cm"> *  get_cfg_done function.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_phy_cfg_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_cfg_done</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_cfg_done</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_phy_force_speed_duplex - Generic force PHY speed/duplex</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  When the silicon family has not implemented a forced speed/duplex</span>
<span class="cm"> *  function for the PHY, simply return 0.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_phy_force_speed_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">force_speed_duplex</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">force_speed_duplex</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_get_phy_type_from_id - Get PHY type from id</span>
<span class="cm"> *  @phy_id: phy_id read from the phy</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns the phy type from the id.</span>
<span class="cm"> **/</span>
<span class="k">enum</span> <span class="n">e1000_phy_type</span> <span class="nf">e1000e_get_phy_type_from_id</span><span class="p">(</span><span class="n">u32</span> <span class="n">phy_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">e1000_phy_type</span> <span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_unknown</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phy_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">M88E1000_I_PHY_ID</span>:
	<span class="k">case</span> <span class="n">M88E1000_E_PHY_ID</span>:
	<span class="k">case</span> <span class="n">M88E1111_I_PHY_ID</span>:
	<span class="k">case</span> <span class="n">M88E1011_I_PHY_ID</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_m88</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IGP01E1000_I_PHY_ID</span>: <span class="cm">/* IGP 1 &amp; 2 share this */</span>
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_igp_2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">GG82563_E_PHY_ID</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_gg82563</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IGP03E1000_E_PHY_ID</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_igp_3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IFE_E_PHY_ID</span>:
	<span class="k">case</span> <span class="n">IFE_PLUS_E_PHY_ID</span>:
	<span class="k">case</span> <span class="n">IFE_C_E_PHY_ID</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_ife</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BME1000_E_PHY_ID</span>:
	<span class="k">case</span> <span class="n">BME1000_E_PHY_ID_R2</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_bm</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I82578_E_PHY_ID</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_82578</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I82577_E_PHY_ID</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_82577</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I82579_E_PHY_ID</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_82579</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">I217_E_PHY_ID</span>:
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_i217</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_unknown</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">phy_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_determine_phy_address - Determines PHY address.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  This uses a trial and error method to loop through possible PHY</span>
<span class="cm"> *  addresses. It tests each by reading the PHY ID registers and</span>
<span class="cm"> *  checking for a match.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_determine_phy_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">e1000_phy_type</span> <span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_unknown</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">phy_type</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">phy_addr</span> <span class="o">&lt;</span> <span class="n">E1000_MAX_PHY_ADDR</span><span class="p">;</span> <span class="n">phy_addr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">phy_addr</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">e1000e_get_phy_id</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000e_get_phy_type_from_id</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If phy_type is valid, break - we found our</span>
<span class="cm">			 * PHY address</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phy_type</span>  <span class="o">!=</span> <span class="n">e1000_phy_unknown</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY_TYPE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_phy_addr_for_bm_page - Retrieve PHY page address</span>
<span class="cm"> *  @page: page to access</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns the phy address for the page requested.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">e1000_get_phy_addr_for_bm_page</span><span class="p">(</span><span class="n">u32</span> <span class="n">page</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">page</span> <span class="o">&gt;=</span> <span class="mi">768</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">reg</span> <span class="o">==</span> <span class="mi">25</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">reg</span> <span class="o">==</span> <span class="mi">31</span><span class="p">))</span>
		<span class="n">phy_addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phy_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_phy_reg_bm - Write BM PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then writes the data to PHY register</span>
<span class="cm"> *  at the offset.  Release any acquired semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_phy_reg_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Page 800 works differently than the rest so it has its own func */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">BM_WUC_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_wakeup_reg_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
							 <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">e1000_get_phy_addr_for_bm_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">page_shift</span><span class="p">,</span> <span class="n">page_select</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Page select is register 31 for phy address 1 and 22 for</span>
<span class="cm">		 * phy address 2 and 3. Page select is shifted only for</span>
<span class="cm">		 * phy address 1.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_shift</span> <span class="o">=</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">page_select</span> <span class="o">=</span> <span class="n">IGP01E1000_PHY_PAGE_SELECT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">page_shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">page_select</span> <span class="o">=</span> <span class="n">BM_PHY_PAGE_SELECT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Page is shifted left, PHY expects (page x 32) */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">page_select</span><span class="p">,</span>
		                                    <span class="p">(</span><span class="n">page</span> <span class="o">&lt;&lt;</span> <span class="n">page_shift</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
	                                    <span class="n">data</span><span class="p">);</span>

<span class="nl">release:</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_phy_reg_bm - Read BM PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then reads the PHY register at offset</span>
<span class="cm"> *  and storing the retrieved information in data.  Release any acquired</span>
<span class="cm"> *  semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_phy_reg_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Page 800 works differently than the rest so it has its own func */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">BM_WUC_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_wakeup_reg_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
							 <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">e1000_get_phy_addr_for_bm_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">page_shift</span><span class="p">,</span> <span class="n">page_select</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Page select is register 31 for phy address 1 and 22 for</span>
<span class="cm">		 * phy address 2 and 3. Page select is shifted only for</span>
<span class="cm">		 * phy address 1.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_shift</span> <span class="o">=</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">page_select</span> <span class="o">=</span> <span class="n">IGP01E1000_PHY_PAGE_SELECT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">page_shift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">page_select</span> <span class="o">=</span> <span class="n">BM_PHY_PAGE_SELECT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Page is shifted left, PHY expects (page x 32) */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">page_select</span><span class="p">,</span>
		                                    <span class="p">(</span><span class="n">page</span> <span class="o">&lt;&lt;</span> <span class="n">page_shift</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
	                                   <span class="n">data</span><span class="p">);</span>
<span class="nl">release:</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_read_phy_reg_bm2 - Read BM PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then reads the PHY register at offset</span>
<span class="cm"> *  and storing the retrieved information in data.  Release any acquired</span>
<span class="cm"> *  semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_read_phy_reg_bm2</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Page 800 works differently than the rest so it has its own func */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">BM_WUC_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_wakeup_reg_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
							 <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Page is shifted left, PHY expects (page x 32) */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_PHY_PAGE_SELECT</span><span class="p">,</span>
						    <span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
					   <span class="n">data</span><span class="p">);</span>
<span class="nl">release:</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_write_phy_reg_bm2 - Write BM PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then writes the data to PHY register</span>
<span class="cm"> *  at the offset.  Release any acquired semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_write_phy_reg_bm2</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Page 800 works differently than the rest so it has its own func */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">BM_WUC_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_wakeup_reg_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
							 <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Page is shifted left, PHY expects (page x 32) */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_PHY_PAGE_SELECT</span><span class="p">,</span>
						    <span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
					    <span class="n">data</span><span class="p">);</span>

<span class="nl">release:</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_enable_phy_wakeup_reg_access_bm - enable access to BM wakeup registers</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @phy_reg: pointer to store original contents of BM_WUC_ENABLE_REG</span>
<span class="cm"> *</span>
<span class="cm"> *  Assumes semaphore already acquired and phy_reg points to a valid memory</span>
<span class="cm"> *  address to store contents of the BM_WUC_ENABLE_REG register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_enable_phy_wakeup_reg_access_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">phy_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">temp</span><span class="p">;</span>

	<span class="cm">/* All page select, port ctrl and wakeup registers use phy address 1 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Select Port Control Registers page */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_page_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">BM_PORT_CTRL_PAGE</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not set Port Control page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUC_ENABLE_REG</span><span class="p">,</span> <span class="n">phy_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not read PHY register %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">BM_PORT_CTRL_PAGE</span><span class="p">,</span> <span class="n">BM_WUC_ENABLE_REG</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable both PHY wakeup mode and Wakeup register page writes.</span>
<span class="cm">	 * Prevent a power state change by disabling ME and Host PHY wakeup.</span>
<span class="cm">	 */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">phy_reg</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">|=</span> <span class="n">BM_WUC_ENABLE_BIT</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BM_WUC_ME_WU_BIT</span> <span class="o">|</span> <span class="n">BM_WUC_HOST_WU_BIT</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUC_ENABLE_REG</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not write PHY register %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">BM_PORT_CTRL_PAGE</span><span class="p">,</span> <span class="n">BM_WUC_ENABLE_REG</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Select Host Wakeup Registers page - caller now able to write</span>
<span class="cm">	 * registers on the Wakeup registers page</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">e1000_set_page_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">BM_WUC_PAGE</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_disable_phy_wakeup_reg_access_bm - disable access to BM wakeup regs</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @phy_reg: pointer to original contents of BM_WUC_ENABLE_REG</span>
<span class="cm"> *</span>
<span class="cm"> *  Restore BM_WUC_ENABLE_REG to its original value.</span>
<span class="cm"> *</span>
<span class="cm"> *  Assumes semaphore already acquired and *phy_reg is the contents of the</span>
<span class="cm"> *  BM_WUC_ENABLE_REG before register(s) on BM_WUC_PAGE were accessed by</span>
<span class="cm"> *  caller.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_disable_phy_wakeup_reg_access_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">phy_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Select Port Control Registers page */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_page_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">BM_PORT_CTRL_PAGE</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not set Port Control page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Restore 769.17 to its original value */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUC_ENABLE_REG</span><span class="p">,</span> <span class="o">*</span><span class="n">phy_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not restore PHY register %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">BM_PORT_CTRL_PAGE</span><span class="p">,</span> <span class="n">BM_WUC_ENABLE_REG</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_access_phy_wakeup_reg_bm - Read/write BM PHY wakeup register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read or written</span>
<span class="cm"> *  @data: pointer to the data to read or write</span>
<span class="cm"> *  @read: determines if operation is read or write</span>
<span class="cm"> *  @page_set: BM_WUC_PAGE already set and access enabled</span>
<span class="cm"> *</span>
<span class="cm"> *  Read the PHY register at offset and store the retrieved information in</span>
<span class="cm"> *  data, or write data to PHY register at offset.  Note the procedure to</span>
<span class="cm"> *  access the PHY wakeup registers is different than reading the other PHY</span>
<span class="cm"> *  registers. It works as such:</span>
<span class="cm"> *  1) Set 769.17.2 (page 769, register 17, bit 2) = 1</span>
<span class="cm"> *  2) Set page to 800 for host (801 if we were manageability)</span>
<span class="cm"> *  3) Write the address using the address opcode (0x11)</span>
<span class="cm"> *  4) Read or write the data using the data opcode (0x12)</span>
<span class="cm"> *  5) Restore 769.17.2 to its original value</span>
<span class="cm"> *</span>
<span class="cm"> *  Steps 1 and 2 are done by e1000_enable_phy_wakeup_reg_access_bm() and</span>
<span class="cm"> *  step 5 is done by e1000_disable_phy_wakeup_reg_access_bm().</span>
<span class="cm"> *</span>
<span class="cm"> *  Assumes semaphore is already acquired.  When page_set==true, assumes</span>
<span class="cm"> *  the PHY page is set to BM_WUC_PAGE (i.e. a function in the call stack</span>
<span class="cm"> *  is responsible for calls to e1000_[enable|disable]_phy_wakeup_reg_bm()).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_access_phy_wakeup_reg_bm</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
					  <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bool</span> <span class="n">read</span><span class="p">,</span> <span class="n">bool</span> <span class="n">page_set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">BM_PHY_REG_NUM</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">page</span> <span class="o">=</span> <span class="n">BM_PHY_REG_PAGE</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">phy_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Gig must be disabled for MDIO accesses to Host Wakeup reg page */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_pchlan</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">PHY_CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_PHY_CTRL_GBE_DISABLE</span><span class="p">)))</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Attempting to access page %d while gig enabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_set</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable access to PHY wakeup registers */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_enable_phy_wakeup_reg_access_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not enable PHY wakeup reg access</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Accessing PHY page %d reg 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Write the Wakeup register page offset value using opcode 0x11 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUC_ADDRESS_OPCODE</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not write address opcode to page %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the Wakeup register page value using opcode 0x12 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUC_DATA_OPCODE</span><span class="p">,</span>
		                                   <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Write the Wakeup register page value using opcode 0x12 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUC_DATA_OPCODE</span><span class="p">,</span>
						    <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not access PHY reg %d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_set</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_disable_phy_wakeup_reg_access_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_reg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_power_up_phy_copper - Restore copper link in case of PHY power down</span>
<span class="cm"> * @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of a PHY power down to save power, or to turn off link during a</span>
<span class="cm"> * driver unload, or wake on lan is not enabled, restore the link to previous</span>
<span class="cm"> * settings.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000_power_up_phy_copper</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">mii_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The PHY will retain its settings across a power down/up cycle */</span>
	<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_reg</span><span class="p">);</span>
	<span class="n">mii_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MII_CR_POWER_DOWN</span><span class="p">;</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">mii_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_power_down_phy_copper - Restore copper link in case of PHY power down</span>
<span class="cm"> * @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of a PHY power down to save power, or to turn off link during a</span>
<span class="cm"> * driver unload, or wake on lan is not enabled, restore the link to previous</span>
<span class="cm"> * settings.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000_power_down_phy_copper</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">mii_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The PHY will retain its settings across a power down/up cycle */</span>
	<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_reg</span><span class="p">);</span>
	<span class="n">mii_reg</span> <span class="o">|=</span> <span class="n">MII_CR_POWER_DOWN</span><span class="p">;</span>
	<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">mii_reg</span><span class="p">);</span>
	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000e_commit_phy - Soft PHY reset</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Performs a soft PHY reset on those that apply. This is a function pointer</span>
<span class="cm"> *  entry point called by drivers.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000e_commit_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">commit</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">commit</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_set_d0_lplu_state - Sets low power link up state for D0</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @active: boolean used to enable/disable lplu</span>
<span class="cm"> *</span>
<span class="cm"> *  Success returns 0, Failure returns 1</span>
<span class="cm"> *</span>
<span class="cm"> *  The low power link up (lplu) state is set to the power management level D0</span>
<span class="cm"> *  and SmartSpeed is disabled when active is true, else clear lplu for D0</span>
<span class="cm"> *  and enable Smartspeed.  LPLU and Smartspeed are mutually exclusive.  LPLU</span>
<span class="cm"> *  is used during Dx states where the power conservation is most important.</span>
<span class="cm"> *  During driver activity, SmartSpeed should be enabled so performance is</span>
<span class="cm"> *  maintained.  This is a function pointer entry point called by drivers.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_d0_lplu_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_d0_lplu_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_d0_lplu_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">active</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  __e1000_read_phy_reg_hv -  Read HV PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *  @locked: semaphore has already been acquired or not</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then reads the PHY register at offset</span>
<span class="cm"> *  and stores the retrieved information in data.  Release any acquired</span>
<span class="cm"> *  semaphore before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">__e1000_read_phy_reg_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="n">locked</span><span class="p">,</span> <span class="n">bool</span> <span class="n">page_set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">page</span> <span class="o">=</span> <span class="n">BM_PHY_REG_PAGE</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">BM_PHY_REG_NUM</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">e1000_get_phy_addr_for_hv_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Page 800 works differently than the rest so it has its own func */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">BM_WUC_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_wakeup_reg_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
							 <span class="nb">true</span><span class="p">,</span> <span class="n">page_set</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">page</span> <span class="o">&lt;</span> <span class="n">HV_INTC_FC_PAGE_START</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_debug_regs_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
		                                         <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_set</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">HV_INTC_FC_PAGE_START</span><span class="p">)</span>
			<span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Page is shifted left, PHY expects (page x 32) */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_page_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						     <span class="p">(</span><span class="n">page</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">));</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">phy_addr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;reading PHY page %d (or 0x%x shifted) reg 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
	      <span class="n">page</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">reg</span><span class="p">,</span>
	                                  <span class="n">data</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_phy_reg_hv -  Read HV PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore then reads the PHY register at offset and stores</span>
<span class="cm"> *  the retrieved information in data.  Release the acquired semaphore</span>
<span class="cm"> *  before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_read_phy_reg_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_read_phy_reg_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_phy_reg_hv_locked -  Read HV PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the PHY register at offset and stores the retrieved information</span>
<span class="cm"> *  in data.  Assumes semaphore already acquired.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_read_phy_reg_hv_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_read_phy_reg_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_phy_reg_page_hv - Read HV PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the PHY register at offset and stores the retrieved information</span>
<span class="cm"> *  in data.  Assumes semaphore already acquired and page already set.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_read_phy_reg_page_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_read_phy_reg_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  __e1000_write_phy_reg_hv - Write HV PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *  @locked: semaphore has already been acquired or not</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore, if necessary, then writes the data to PHY register</span>
<span class="cm"> *  at the offset.  Release any acquired semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">__e1000_write_phy_reg_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">,</span>
				    <span class="n">bool</span> <span class="n">locked</span><span class="p">,</span> <span class="n">bool</span> <span class="n">page_set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">page</span> <span class="o">=</span> <span class="n">BM_PHY_REG_PAGE</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">reg</span> <span class="o">=</span> <span class="n">BM_PHY_REG_NUM</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">e1000_get_phy_addr_for_hv_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Page 800 works differently than the rest so it has its own func */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">BM_WUC_PAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_wakeup_reg_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
							 <span class="nb">false</span><span class="p">,</span> <span class="n">page_set</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">page</span> <span class="o">&lt;</span> <span class="n">HV_INTC_FC_PAGE_START</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_debug_regs_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
		                                         <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_set</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">HV_INTC_FC_PAGE_START</span><span class="p">)</span>
			<span class="n">page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Workaround MDIO accesses being disabled after entering IEEE</span>
<span class="cm">		 * Power Down (when bit 11 of the PHY Control register is set)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_82578</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">reg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">data2</span> <span class="o">=</span> <span class="mh">0x7EFF</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_access_phy_debug_regs_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
								 <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x3</span><span class="p">,</span>
								 <span class="o">&amp;</span><span class="n">data2</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Page is shifted left, PHY expects (page x 32) */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_page_igp</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						     <span class="p">(</span><span class="n">page</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">));</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">phy_addr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;writing PHY page %d (or 0x%x shifted) reg 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
	      <span class="n">page</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">reg</span><span class="p">,</span>
	                                  <span class="n">data</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_write_phy_reg_hv - Write HV PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquires semaphore then writes the data to PHY register at the offset.</span>
<span class="cm"> *  Release the acquired semaphores before exiting.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_write_phy_reg_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_write_phy_reg_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_write_phy_reg_hv_locked - Write HV PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Writes the data to PHY register at the offset.  Assumes semaphore</span>
<span class="cm"> *  already acquired.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_write_phy_reg_hv_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_write_phy_reg_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_write_phy_reg_page_hv - Write HV PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Writes the data to PHY register at the offset.  Assumes semaphore</span>
<span class="cm"> *  already acquired and page already set.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_write_phy_reg_page_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__e1000_write_phy_reg_hv</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_phy_addr_for_hv_page - Get PHY address based on page</span>
<span class="cm"> *  @page: page to be accessed</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">e1000_get_phy_addr_for_hv_page</span><span class="p">(</span><span class="n">u32</span> <span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&gt;=</span> <span class="n">HV_INTC_FC_PAGE_START</span><span class="p">)</span>
		<span class="n">phy_addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phy_addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_access_phy_debug_regs_hv - Read HV PHY vendor specific high registers</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read or written</span>
<span class="cm"> *  @data: pointer to the data to be read or written</span>
<span class="cm"> *  @read: determines if operation is read or write</span>
<span class="cm"> *</span>
<span class="cm"> *  Reads the PHY register at offset and stores the retreived information</span>
<span class="cm"> *  in data.  Assumes semaphore already acquired.  Note that the procedure</span>
<span class="cm"> *  to access these regs uses the address port and data port to read/write.</span>
<span class="cm"> *  These accesses done with PHY address 2 and without using pages.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_access_phy_debug_regs_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
                                          <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">bool</span> <span class="n">read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">addr_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This takes care of the difference with desktop vs mobile phy */</span>
	<span class="n">addr_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_82578</span><span class="p">)</span> <span class="o">?</span>
	           <span class="n">I82578_ADDR_REG</span> <span class="o">:</span> <span class="n">I82577_ADDR_REG</span><span class="p">;</span>
	<span class="n">data_reg</span> <span class="o">=</span> <span class="n">addr_reg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* All operations in this function are phy address 2 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* masking with 0x3F to remove the page from offset */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">addr_reg</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not write the Address Offset port register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read or write the data value next */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">data_reg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">data_reg</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not access the Data port register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_link_stall_workaround_hv - Si workaround</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  This function works around a Si bug where the link partner can get</span>
<span class="cm"> *  a link up indication before the PHY does.  If small packets are sent</span>
<span class="cm"> *  by the link partner they can be placed in the packet buffer without</span>
<span class="cm"> *  being properly accounted for by the PHY and will stall preventing</span>
<span class="cm"> *  further packets from being received.  The workaround is to clear the</span>
<span class="cm"> *  packet buffer after the PHY detects link up.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_link_stall_workaround_hv</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_phy_82578</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Do not apply workaround if in PHY loopback bit 14 set */</span>
	<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">PHY_CONTROL_LB</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* check if link is up and at 1Gbps */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_CS_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="n">BM_CS_STATUS_LINK_UP</span> <span class="o">|</span> <span class="n">BM_CS_STATUS_RESOLVED</span> <span class="o">|</span>
		<span class="n">BM_CS_STATUS_SPEED_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="p">(</span><span class="n">BM_CS_STATUS_LINK_UP</span> <span class="o">|</span> <span class="n">BM_CS_STATUS_RESOLVED</span> <span class="o">|</span>
		     <span class="n">BM_CS_STATUS_SPEED_1000</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

	<span class="cm">/* flush the packets in the fifo buffer */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_MUX_DATA_CTRL</span><span class="p">,</span> <span class="n">HV_MUX_DATA_CTRL_GEN_TO_MAC</span> <span class="o">|</span>
			   <span class="n">HV_MUX_DATA_CTRL_FORCE_SPEED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_MUX_DATA_CTRL</span><span class="p">,</span> <span class="n">HV_MUX_DATA_CTRL_GEN_TO_MAC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_check_polarity_82577 - Checks the polarity.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)</span>
<span class="cm"> *</span>
<span class="cm"> *  Polarity is determined based on the PHY specific status register.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_check_polarity_82577</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">I82577_PHY_STATUS_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_polarity</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">I82577_PHY_STATUS2_REV_POLARITY</span><span class="p">)</span>
		                      <span class="o">?</span> <span class="n">e1000_rev_polarity_reversed</span>
		                      <span class="o">:</span> <span class="n">e1000_rev_polarity_normal</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_phy_force_speed_duplex_82577 - Force speed/duplex for I82577 PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Calls the PHY setup function to force speed and duplex.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_phy_force_speed_duplex_82577</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e1000e_phy_force_speed_duplex_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Waiting for forced speed/duplex link on 82577 phy</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						      <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Link taking longer than expected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Try once more */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						      <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_phy_info_82577 - Retrieve I82577 PHY information</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Read PHY status to determine if link is up.  If link is up, then</span>
<span class="cm"> *  set/determine 10base-T extended distance and polarity correction.  Read</span>
<span class="cm"> *  PHY port status to determine MDI/MDIx and speed.  Based on the speed,</span>
<span class="cm"> *  determine on the cable length, local and remote receiver.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_get_phy_info_82577</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Phy info is only valid if link is up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">polarity_correction</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_polarity_82577</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">I82577_PHY_STATUS_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">is_mdix</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">I82577_PHY_STATUS2_MDIX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">I82577_PHY_STATUS2_SPEED_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">I82577_PHY_STATUS2_SPEED_1000MBPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_cable_length</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_LOCAL_RX_STATUS</span><span class="p">)</span>
		                <span class="o">?</span> <span class="n">e1000_1000t_rx_status_ok</span>
		                <span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>

		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_REMOTE_RX_STATUS</span><span class="p">)</span>
		                 <span class="o">?</span> <span class="n">e1000_1000t_rx_status_ok</span>
		                 <span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">E1000_CABLE_LENGTH_UNDEFINED</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_cable_length_82577 - Determine cable length for 82577 PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> * Reads the diagnostic status register and verifies result is valid before</span>
<span class="cm"> * placing it in the phy_cable_length field.</span>
<span class="cm"> **/</span>
<span class="n">s32</span> <span class="nf">e1000_get_cable_length_82577</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">I82577_PHY_DIAG_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">I82577_DSTATUS_CABLE_LENGTH</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
	         <span class="n">I82577_DSTATUS_CABLE_LENGTH_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="n">E1000_CABLE_LENGTH_UNDEFINED</span><span class="p">)</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
