<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › e1000e › 80003es2lan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>80003es2lan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel PRO/1000 Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * 80003ES2LAN Gigabit Ethernet Controller (Copper)</span>
<span class="cm"> * 80003ES2LAN Gigabit Ethernet Controller (Serdes)</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;e1000.h&quot;</span>

<span class="cp">#define E1000_KMRNCTRLSTA_OFFSET_FIFO_CTRL	 0x00</span>
<span class="cp">#define E1000_KMRNCTRLSTA_OFFSET_INB_CTRL	 0x02</span>
<span class="cp">#define E1000_KMRNCTRLSTA_OFFSET_HD_CTRL	 0x10</span>
<span class="cp">#define E1000_KMRNCTRLSTA_OFFSET_MAC2PHY_OPMODE	 0x1F</span>

<span class="cp">#define E1000_KMRNCTRLSTA_FIFO_CTRL_RX_BYPASS	 0x0008</span>
<span class="cp">#define E1000_KMRNCTRLSTA_FIFO_CTRL_TX_BYPASS	 0x0800</span>
<span class="cp">#define E1000_KMRNCTRLSTA_INB_CTRL_DIS_PADDING	 0x0010</span>

<span class="cp">#define E1000_KMRNCTRLSTA_HD_CTRL_10_100_DEFAULT 0x0004</span>
<span class="cp">#define E1000_KMRNCTRLSTA_HD_CTRL_1000_DEFAULT	 0x0000</span>
<span class="cp">#define E1000_KMRNCTRLSTA_OPMODE_E_IDLE		 0x2000</span>

<span class="cp">#define E1000_KMRNCTRLSTA_OPMODE_MASK		 0x000C</span>
<span class="cp">#define E1000_KMRNCTRLSTA_OPMODE_INBAND_MDIO	 0x0004</span>

<span class="cp">#define E1000_TCTL_EXT_GCEX_MASK 0x000FFC00 </span><span class="cm">/* Gigabit Carry Extend Padding */</span><span class="cp"></span>
<span class="cp">#define DEFAULT_TCTL_EXT_GCEX_80003ES2LAN	 0x00010000</span>

<span class="cp">#define DEFAULT_TIPG_IPGT_1000_80003ES2LAN	 0x8</span>
<span class="cp">#define DEFAULT_TIPG_IPGT_10_100_80003ES2LAN	 0x9</span>

<span class="cm">/* GG82563 PHY Specific Status Register (Page 0, Register 16 */</span>
<span class="cp">#define GG82563_PSCR_POLARITY_REVERSAL_DISABLE	 0x0002 </span><span class="cm">/* 1=Reversal Disab. */</span><span class="cp"></span>
<span class="cp">#define GG82563_PSCR_CROSSOVER_MODE_MASK	 0x0060</span>
<span class="cp">#define GG82563_PSCR_CROSSOVER_MODE_MDI		 0x0000 </span><span class="cm">/* 00=Manual MDI */</span><span class="cp"></span>
<span class="cp">#define GG82563_PSCR_CROSSOVER_MODE_MDIX	 0x0020 </span><span class="cm">/* 01=Manual MDIX */</span><span class="cp"></span>
<span class="cp">#define GG82563_PSCR_CROSSOVER_MODE_AUTO	 0x0060 </span><span class="cm">/* 11=Auto crossover */</span><span class="cp"></span>

<span class="cm">/* PHY Specific Control Register 2 (Page 0, Register 26) */</span>
<span class="cp">#define GG82563_PSCR2_REVERSE_AUTO_NEG		 0x2000</span>
						<span class="cm">/* 1=Reverse Auto-Negotiation */</span>

<span class="cm">/* MAC Specific Control Register (Page 2, Register 21) */</span>
<span class="cm">/* Tx clock speed for Link Down and 1000BASE-T for the following speeds */</span>
<span class="cp">#define GG82563_MSCR_TX_CLK_MASK		 0x0007</span>
<span class="cp">#define GG82563_MSCR_TX_CLK_10MBPS_2_5		 0x0004</span>
<span class="cp">#define GG82563_MSCR_TX_CLK_100MBPS_25		 0x0005</span>
<span class="cp">#define GG82563_MSCR_TX_CLK_1000MBPS_25		 0x0007</span>

<span class="cp">#define GG82563_MSCR_ASSERT_CRS_ON_TX		 0x0010 </span><span class="cm">/* 1=Assert */</span><span class="cp"></span>

<span class="cm">/* DSP Distance Register (Page 5, Register 26) */</span>
<span class="cp">#define GG82563_DSPD_CABLE_LENGTH		 0x0007 </span><span class="cm">/* 0 = &lt;50M</span>
<span class="cm">							   1 = 50-80M</span>
<span class="cm">							   2 = 80-110M</span>
<span class="cm">							   3 = 110-140M</span>
<span class="cm">							   4 = &gt;140M */</span><span class="cp"></span>

<span class="cm">/* Kumeran Mode Control Register (Page 193, Register 16) */</span>
<span class="cp">#define GG82563_KMCR_PASS_FALSE_CARRIER		 0x0800</span>

<span class="cm">/* Max number of times Kumeran read/write should be validated */</span>
<span class="cp">#define GG82563_MAX_KMRN_RETRY  0x5</span>

<span class="cm">/* Power Management Control Register (Page 193, Register 20) */</span>
<span class="cp">#define GG82563_PMCR_ENABLE_ELECTRICAL_IDLE	 0x0001</span>
					   <span class="cm">/* 1=Enable SERDES Electrical Idle */</span>

<span class="cm">/* In-Band Control Register (Page 194, Register 18) */</span>
<span class="cp">#define GG82563_ICR_DIS_PADDING			 0x0010 </span><span class="cm">/* Disable Padding */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * A table for the GG82563 cable length where the range is defined</span>
<span class="cm"> * with a lower bound at &quot;index&quot; and the upper bound at</span>
<span class="cm"> * &quot;index + 5&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">e1000_gg82563_cable_length_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	 <span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mh">0xFF</span> <span class="p">};</span>
<span class="cp">#define GG82563_CABLE_LENGTH_TABLE_SIZE \</span>
<span class="cp">		ARRAY_SIZE(e1000_gg82563_cable_length_table)</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_setup_copper_link_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_acquire_swfw_sync_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_release_swfw_sync_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_initialize_hw_bits_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clear_hw_cntrs_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_cfg_kmrn_1000_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_cfg_kmrn_10_100_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">duplex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_cfg_on_link_up_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span>  <span class="n">e1000_read_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
                                            <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span>  <span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
                                             <span class="n">u16</span> <span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_power_down_phy_copper_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_init_phy_params_80003es2lan - Init ESB2 PHY func ptrs.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_init_phy_params_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span>	<span class="o">=</span> <span class="n">e1000_phy_none</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">power_up</span> <span class="o">=</span> <span class="n">e1000_power_up_phy_copper</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">power_down</span> <span class="o">=</span> <span class="n">e1000_power_down_phy_copper_80003es2lan</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">addr</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">autoneg_mask</span>	<span class="o">=</span> <span class="n">AUTONEG_ADVERTISE_SPEED_DEFAULT</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">reset_delay_us</span>      <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">type</span>		<span class="o">=</span> <span class="n">e1000_phy_gg82563</span><span class="p">;</span>

	<span class="cm">/* This can only be done after all function pointers are setup. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_get_phy_id</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Verify phy id */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">GG82563_E_PHY_ID</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_init_nvm_params_80003es2lan - Init ESB2 NVM func ptrs.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_init_nvm_params_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_nvm_info</span> <span class="o">*</span><span class="n">nvm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">opcode_bits</span>	<span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">delay_usec</span>	 <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">nvm</span><span class="o">-&gt;</span><span class="n">override</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_nvm_override_spi_large</span>:
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">page_size</span>    <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_nvm_override_spi_small</span>:
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">page_size</span>    <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">page_size</span>    <span class="o">=</span> <span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_ADDR_BITS</span> <span class="o">?</span> <span class="mi">32</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_ADDR_BITS</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e1000_nvm_eeprom_spi</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_SIZE_EX_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			  <span class="n">E1000_EECD_SIZE_EX_SHIFT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Added to a constant, &quot;size&quot; becomes the left-shift value</span>
<span class="cm">	 * for setting word_size.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">NVM_WORD_SIZE_BASE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* EEPROM access above 16k is unsupported */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">nvm</span><span class="o">-&gt;</span><span class="n">word_size</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_init_mac_params_80003es2lan - Init ESB2 MAC func ptrs.</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_init_mac_params_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>

	<span class="cm">/* Set media type and media-dependent function pointers */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_80003ES2LAN_SERDES_DPT</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span> <span class="o">=</span> <span class="n">e1000e_check_for_serdes_link</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_physical_interface</span> <span class="o">=</span>
		    <span class="n">e1000e_setup_fiber_serdes_link</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_copper</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span> <span class="o">=</span> <span class="n">e1000e_check_for_copper_link</span><span class="p">;</span>
		<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_physical_interface</span> <span class="o">=</span>
		    <span class="n">e1000_setup_copper_link_80003es2lan</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set mta register count */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">mta_reg_count</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="cm">/* Set rar entry count */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">rar_entry_count</span> <span class="o">=</span> <span class="n">E1000_RAR_ENTRIES</span><span class="p">;</span>
	<span class="cm">/* FWSM register */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">has_fwsm</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/* ARC supported; valid only if manageability features are enabled. */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">arc_subsystem_valid</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">FWSM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_FWSM_MODE_MASK</span><span class="p">);</span>
	<span class="cm">/* Adaptive IFS not supported */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">adaptive_ifs</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* set lan id for port to determine which phy lock to use */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_lan_id</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_variants_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">e1000_init_mac_params_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">e1000_init_nvm_params_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">e1000_init_phy_params_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_acquire_phy_80003es2lan - Acquire rights to access PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  A wrapper to acquire access rights to the correct PHY.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_acquire_phy_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span> <span class="o">?</span> <span class="n">E1000_SWFW_PHY1_SM</span> <span class="o">:</span> <span class="n">E1000_SWFW_PHY0_SM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">e1000_acquire_swfw_sync_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_release_phy_80003es2lan - Release rights to access PHY</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  A wrapper to release access rights to the correct PHY.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_release_phy_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span> <span class="o">?</span> <span class="n">E1000_SWFW_PHY1_SM</span> <span class="o">:</span> <span class="n">E1000_SWFW_PHY0_SM</span><span class="p">;</span>
	<span class="n">e1000_release_swfw_sync_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_acquire_mac_csr_80003es2lan - Acquire right to access Kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquire the semaphore to access the Kumeran interface.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_acquire_mac_csr_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">E1000_SWFW_CSR_SM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1000_acquire_swfw_sync_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_release_mac_csr_80003es2lan - Release right to access Kumeran Register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Release the semaphore used to access the Kumeran interface</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_release_mac_csr_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">E1000_SWFW_CSR_SM</span><span class="p">;</span>

	<span class="n">e1000_release_swfw_sync_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_acquire_nvm_80003es2lan - Acquire rights to access NVM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquire the semaphore to access the EEPROM.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_acquire_nvm_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_acquire_swfw_sync_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_SWFW_EEP_SM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_acquire_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e1000_release_swfw_sync_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_SWFW_EEP_SM</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_release_nvm_80003es2lan - Relinquish rights to access NVM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Release the semaphore used to access the EEPROM.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_release_nvm_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e1000e_release_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">e1000_release_swfw_sync_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_SWFW_EEP_SM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_acquire_swfw_sync_80003es2lan - Acquire SW/FW semaphore</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @mask: specifies which semaphore to acquire</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask</span>
<span class="cm"> *  will also specify which port we&#39;re acquiring the lock for.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_acquire_swfw_sync_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">swfw_sync</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swmask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">fwmask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000e_get_hw_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_SWFW_SYNC</span><span class="p">;</span>

		<span class="n">swfw_sync</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SW_FW_SYNC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">swfw_sync</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fwmask</span> <span class="o">|</span> <span class="n">swmask</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Firmware currently using resource (fwmask)</span>
<span class="cm">		 * or other software thread using resource (swmask)</span>
<span class="cm">		 */</span>
		<span class="n">e1000e_put_hw_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Driver can&#39;t access resource, SW_FW_SYNC timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_SWFW_SYNC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">swfw_sync</span> <span class="o">|=</span> <span class="n">swmask</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">SW_FW_SYNC</span><span class="p">,</span> <span class="n">swfw_sync</span><span class="p">);</span>

	<span class="n">e1000e_put_hw_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_release_swfw_sync_80003es2lan - Release SW/FW semaphore</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @mask: specifies which semaphore to acquire</span>
<span class="cm"> *</span>
<span class="cm"> *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask</span>
<span class="cm"> *  will also specify which port we&#39;re releasing the lock for.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_release_swfw_sync_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">swfw_sync</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">e1000e_get_hw_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span> <span class="cm">/* Empty */</span>

	<span class="n">swfw_sync</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SW_FW_SYNC</span><span class="p">);</span>
	<span class="n">swfw_sync</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">SW_FW_SYNC</span><span class="p">,</span> <span class="n">swfw_sync</span><span class="p">);</span>

	<span class="n">e1000e_put_hw_semaphore</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_phy_reg_gg82563_80003es2lan - Read GG82563 PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: offset of the register to read</span>
<span class="cm"> *  @data: pointer to the data returned from the operation</span>
<span class="cm"> *</span>
<span class="cm"> *  Read the GG82563 PHY register.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_read_phy_reg_gg82563_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
						  <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_select</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_acquire_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Select Configuration Page */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">MAX_PHY_REG_ADDRESS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">GG82563_MIN_ALT_REG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_select</span> <span class="o">=</span> <span class="n">GG82563_PHY_PAGE_SELECT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Use Alternative Page Select register to access</span>
<span class="cm">		 * registers 30 and 31</span>
<span class="cm">		 */</span>
		<span class="n">page_select</span> <span class="o">=</span> <span class="n">GG82563_PHY_PAGE_SELECT_ALT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">GG82563_PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">page_select</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e1000_release_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e80003es2lan</span><span class="p">.</span><span class="n">mdic_wa_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The &quot;ready&quot; bit in the MDIC register may be incorrectly set</span>
<span class="cm">		 * before the device has completed the &quot;Page Select&quot; MDI</span>
<span class="cm">		 * transaction.  So we wait 200us after each MDI command...</span>
<span class="cm">		 */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

		<span class="cm">/* ...and verify the command was successful. */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">page_select</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">GG82563_PAGE_SHIFT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e1000_release_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		                                  <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
		                                  <span class="n">data</span><span class="p">);</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		                                  <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
		                                  <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e1000_release_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_write_phy_reg_gg82563_80003es2lan - Write GG82563 PHY register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: offset of the register to read</span>
<span class="cm"> *  @data: value to write to the register</span>
<span class="cm"> *</span>
<span class="cm"> *  Write to the GG82563 PHY register.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_write_phy_reg_gg82563_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
						   <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">page_select</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_acquire_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Select Configuration Page */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">MAX_PHY_REG_ADDRESS</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">GG82563_MIN_ALT_REG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_select</span> <span class="o">=</span> <span class="n">GG82563_PHY_PAGE_SELECT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Use Alternative Page Select register to access</span>
<span class="cm">		 * registers 30 and 31</span>
<span class="cm">		 */</span>
		<span class="n">page_select</span> <span class="o">=</span> <span class="n">GG82563_PHY_PAGE_SELECT_ALT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">GG82563_PAGE_SHIFT</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">page_select</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e1000_release_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e80003es2lan</span><span class="p">.</span><span class="n">mdic_wa_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The &quot;ready&quot; bit in the MDIC register may be incorrectly set</span>
<span class="cm">		 * before the device has completed the &quot;Page Select&quot; MDI</span>
<span class="cm">		 * transaction.  So we wait 200us after each MDI command...</span>
<span class="cm">		 */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

		<span class="cm">/* ...and verify the command was successful. */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">page_select</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">GG82563_PAGE_SHIFT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e1000_release_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		                                  <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
		                                  <span class="n">data</span><span class="p">);</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_write_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
		                                  <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">offset</span><span class="p">,</span>
		                                  <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e1000_release_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_write_nvm_80003es2lan - Write to ESB2 NVM</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: offset of the register to read</span>
<span class="cm"> *  @words: number of words to write</span>
<span class="cm"> *  @data: buffer of data to write to the NVM</span>
<span class="cm"> *</span>
<span class="cm"> *  Write &quot;words&quot; of data to the ESB2 NVM.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_write_nvm_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
				       <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">e1000e_write_nvm_spi</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_cfg_done_80003es2lan - Wait for configuration to complete</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Wait a specific amount of time for manageability processes to complete.</span>
<span class="cm"> *  This is a function pointer entry point called by the phy module.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_cfg_done_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">PHY_CFG_TIMEOUT</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">E1000_NVM_CFG_DONE_PORT_0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">E1000_NVM_CFG_DONE_PORT_1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">EEMNGCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
		<span class="n">timeout</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MNG configuration cycle has not completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_RESET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_phy_force_speed_duplex_80003es2lan - Force PHY speed and duplex</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Force the speed and duplex settings onto the PHY.  This is a</span>
<span class="cm"> *  function pointer entry point called by the phy module.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_phy_force_speed_duplex_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear Auto-Crossover to force MDI manually.  M88E1000 requires MDI</span>
<span class="cm">	 * forced whenever speed and duplex are forced.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GG82563_PSCR_CROSSOVER_MODE_AUTO</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;GG82563 PSCR: %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e1000e_phy_force_speed_duplex_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>

	<span class="cm">/* Reset the phy to commit changes. */</span>
	<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">MII_CR_RESET</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_wait_to_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Waiting for forced speed/duplex link on GG82563 phy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						     <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We didn&#39;t get link.</span>
<span class="cm">			 * Reset the DSP and cross our fingers.</span>
<span class="cm">			 */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_reset_dsp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Try once more */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_phy_has_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_FORCE_LIMIT</span><span class="p">,</span>
						     <span class="mi">100000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">link</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_MAC_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Resetting the phy means we need to verify the TX_CLK corresponds</span>
<span class="cm">	 * to the link speed.  10Mbps -&gt; 2.5MHz, else 25MHz.</span>
<span class="cm">	 */</span>
	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GG82563_MSCR_TX_CLK_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">forced_speed_duplex</span> <span class="o">&amp;</span> <span class="n">E1000_ALL_10_SPEED</span><span class="p">)</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">GG82563_MSCR_TX_CLK_10MBPS_2_5</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">GG82563_MSCR_TX_CLK_100MBPS_25</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In addition, we must re-enable CRS on Tx for both half and full</span>
<span class="cm">	 * duplex.</span>
<span class="cm">	 */</span>
	<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">GG82563_MSCR_ASSERT_CRS_ON_TX</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_MAC_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_cable_length_80003es2lan - Set approximate cable length</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Find the approximate cable length as measured by the GG82563 PHY.</span>
<span class="cm"> *  This is a function pointer entry point called by the phy module.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_cable_length_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_DSP_DISTANCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">GG82563_DSPD_CABLE_LENGTH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">GG82563_CABLE_LENGTH_TABLE_SIZE</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">min_cable_length</span> <span class="o">=</span> <span class="n">e1000_gg82563_cable_length_table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">max_cable_length</span> <span class="o">=</span> <span class="n">e1000_gg82563_cable_length_table</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">5</span><span class="p">];</span>

	<span class="n">phy</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">min_cable_length</span> <span class="o">+</span> <span class="n">phy</span><span class="o">-&gt;</span><span class="n">max_cable_length</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_get_link_up_info_80003es2lan - Report speed and duplex</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @speed: pointer to speed buffer</span>
<span class="cm"> *  @duplex: pointer to duplex buffer</span>
<span class="cm"> *</span>
<span class="cm"> *  Retrieve the current speed and duplex configuration.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_link_up_info_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">speed</span><span class="p">,</span>
					      <span class="n">u16</span> <span class="o">*</span><span class="n">duplex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_get_speed_and_duplex_copper</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
								    <span class="n">speed</span><span class="p">,</span>
								    <span class="n">duplex</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">cfg_on_link_up</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_get_speed_and_duplex_fiber_serdes</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
								  <span class="n">speed</span><span class="p">,</span>
								  <span class="n">duplex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_reset_hw_80003es2lan - Reset the ESB2 controller</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Perform a global reset to the ESB2 controller.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_reset_hw_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">kum_reg_data</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent the PCI-E bus from sticking if there is no TLP connection</span>
<span class="cm">	 * on the last TLP read/write transaction when MAC is reset.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_disable_pcie_master</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PCI-E Master disable polling has failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Masking off all interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">E1000_TCTL_PSP</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_acquire_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Issuing a global reset to MAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_RST</span><span class="p">);</span>
	<span class="n">e1000_release_phy_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Disable IBIST slave mode (far-end loopback) */</span>
	<span class="n">e1000_read_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_KMRNCTRLSTA_INBAND_PARAM</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">kum_reg_data</span><span class="p">);</span>
	<span class="n">kum_reg_data</span> <span class="o">|=</span> <span class="n">E1000_KMRNCTRLSTA_IBIST_DISABLE</span><span class="p">;</span>
	<span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_KMRNCTRLSTA_INBAND_PARAM</span><span class="p">,</span>
					 <span class="n">kum_reg_data</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_get_auto_rd_done</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="cm">/* We don&#39;t want to continue accessing MAC registers. */</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Clear any pending interrupt events. */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">e1000_check_alt_mac_addr_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_init_hw_80003es2lan - Initialize the ESB2 controller</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Initialize the hw bits, LED, VFTA, MTA, link and hw counters.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_init_hw_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg_data</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">kum_reg_data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">e1000_initialize_hw_bits_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Initialize identification LED */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">id_led_init</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error initializing identification LED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* This is not fatal and we should not stop init due to this */</span>

	<span class="cm">/* Disabling VLAN filtering */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Initializing the IEEE VLAN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">clear_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Setup the receive address. */</span>
	<span class="n">e1000e_init_rx_addrs</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">rar_entry_count</span><span class="p">);</span>

	<span class="cm">/* Zero out the Multicast HASH table */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Zeroing the MTA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">mta_reg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_MTA</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Setup link and flow control */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Disable IBIST slave mode (far-end loopback) */</span>
	<span class="n">e1000_read_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_KMRNCTRLSTA_INBAND_PARAM</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">kum_reg_data</span><span class="p">);</span>
	<span class="n">kum_reg_data</span> <span class="o">|=</span> <span class="n">E1000_KMRNCTRLSTA_IBIST_DISABLE</span><span class="p">;</span>
	<span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_KMRNCTRLSTA_INBAND_PARAM</span><span class="p">,</span>
					 <span class="n">kum_reg_data</span><span class="p">);</span>

	<span class="cm">/* Set the transmit descriptor write-back policy */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXDCTL_WTHRESH</span><span class="p">)</span> <span class="o">|</span>
		   <span class="n">E1000_TXDCTL_FULL_TX_DESC_WB</span> <span class="o">|</span> <span class="n">E1000_TXDCTL_COUNT_DESC</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="cm">/* ...for both queues. */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg_data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXDCTL_WTHRESH</span><span class="p">)</span> <span class="o">|</span>
		   <span class="n">E1000_TXDCTL_FULL_TX_DESC_WB</span> <span class="o">|</span> <span class="n">E1000_TXDCTL_COUNT_DESC</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="cm">/* Enable retransmit on late collisions */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
	<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">E1000_TCTL_RTLC</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="cm">/* Configure Gigabit Carry Extend Padding */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL_EXT</span><span class="p">);</span>
	<span class="n">reg_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TCTL_EXT_GCEX_MASK</span><span class="p">;</span>
	<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">DEFAULT_TCTL_EXT_GCEX_80003ES2LAN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL_EXT</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="cm">/* Configure Transmit Inter-Packet Gap */</span>
	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TIPG</span><span class="p">);</span>
	<span class="n">reg_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TIPG_IPGT_MASK</span><span class="p">;</span>
	<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">DEFAULT_TIPG_IPGT_1000_80003ES2LAN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TIPG</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">E1000_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_FFLT</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">);</span>
	<span class="n">reg_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x00100000</span><span class="p">;</span>
	<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_FFLT</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>

	<span class="cm">/* default to true to enable the MDIC W/A */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e80003es2lan</span><span class="p">.</span><span class="n">mdic_wa_enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
	                              <span class="n">E1000_KMRNCTRLSTA_OFFSET</span> <span class="o">&gt;&gt;</span>
	                              <span class="n">E1000_KMRNCTRLSTA_OFFSET_SHIFT</span><span class="p">,</span>
	                              <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">&amp;</span> <span class="n">E1000_KMRNCTRLSTA_OPMODE_MASK</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">E1000_KMRNCTRLSTA_OPMODE_INBAND_MDIO</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dev_spec</span><span class="p">.</span><span class="n">e80003es2lan</span><span class="p">.</span><span class="n">mdic_wa_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear all of the statistics registers (clear on read).  It is</span>
<span class="cm">	 * important that we do this after we have tried to establish link</span>
<span class="cm">	 * because the symbol error count will increment wildly if there</span>
<span class="cm">	 * is no link.</span>
<span class="cm">	 */</span>
	<span class="n">e1000_clear_hw_cntrs_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_initialize_hw_bits_80003es2lan - Init hw bits of ESB2</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Initializes required hardware-dependent bits needed for normal operation.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_initialize_hw_bits_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* Transmit Descriptor Control 0 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Transmit Descriptor Control 1 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Transmit Arbitration Control 0 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xF</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span> <span class="cm">/* 30:27 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/* Transmit Arbitration Control 1 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_TCTL_MULR</span><span class="p">)</span>
		<span class="n">reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable IPv6 extension header parsing because some malformed</span>
<span class="cm">	 * IPv6 headers can hang the Rx.</span>
<span class="cm">	 */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RFCTL</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_RFCTL_IPV6_EX_DIS</span> <span class="o">|</span> <span class="n">E1000_RFCTL_NEW_IPV6_EXT_DIS</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RFCTL</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_copper_link_setup_gg82563_80003es2lan - Configure GG82563 Link</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Setup some GG82563 PHY registers for obtaining link</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_copper_link_setup_gg82563_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_MAC_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">|=</span> <span class="n">GG82563_MSCR_ASSERT_CRS_ON_TX</span><span class="p">;</span>
	<span class="cm">/* Use 25MHz for both link down and 1000Base-T for Tx clock. */</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">GG82563_MSCR_TX_CLK_1000MBPS_25</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_MAC_SPEC_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Options:</span>
<span class="cm">	 *   MDI/MDI-X = 0 (default)</span>
<span class="cm">	 *   0 - Auto for all speeds</span>
<span class="cm">	 *   1 - MDI mode</span>
<span class="cm">	 *   2 - MDI-X mode</span>
<span class="cm">	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GG82563_PSCR_CROSSOVER_MODE_MASK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">mdix</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">data</span> <span class="o">|=</span> <span class="n">GG82563_PSCR_CROSSOVER_MODE_MDI</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">data</span> <span class="o">|=</span> <span class="n">GG82563_PSCR_CROSSOVER_MODE_MDIX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="nl">default:</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">GG82563_PSCR_CROSSOVER_MODE_AUTO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Options:</span>
<span class="cm">	 *   disable_polarity_correction = 0 (default)</span>
<span class="cm">	 *       Automatic Correction for Reversed Cable Polarity</span>
<span class="cm">	 *   0 - Disabled</span>
<span class="cm">	 *   1 - Enabled</span>
<span class="cm">	 */</span>
	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GG82563_PSCR_POLARITY_REVERSAL_DISABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">disable_polarity_correction</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">GG82563_PSCR_POLARITY_REVERSAL_DISABLE</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* SW Reset the PHY so all changes take effect */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_commit_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Resetting the PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Bypass Rx and Tx FIFO&#39;s */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					<span class="n">E1000_KMRNCTRLSTA_OFFSET_FIFO_CTRL</span><span class="p">,</span>
					<span class="n">E1000_KMRNCTRLSTA_FIFO_CTRL_RX_BYPASS</span> <span class="o">|</span>
					<span class="n">E1000_KMRNCTRLSTA_FIFO_CTRL_TX_BYPASS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
				       <span class="n">E1000_KMRNCTRLSTA_OFFSET_MAC2PHY_OPMODE</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">E1000_KMRNCTRLSTA_OPMODE_E_IDLE</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					<span class="n">E1000_KMRNCTRLSTA_OFFSET_MAC2PHY_OPMODE</span><span class="p">,</span>
					<span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_SPEC_CTRL_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GG82563_PSCR2_REVERSE_AUTO_NEG</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_SPEC_CTRL_2</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
	<span class="n">ctrl_ext</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_EXT_LINK_MODE_MASK</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_PWR_MGMT_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do not init these registers when the HW is in IAMT mode, since the</span>
<span class="cm">	 * firmware will have already initialized them.  We only initialize</span>
<span class="cm">	 * them if the HW is not in IAMT mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_mng_mode</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Enable Electrical Idle on the PHY */</span>
		<span class="n">data</span> <span class="o">|=</span> <span class="n">GG82563_PMCR_ENABLE_ELECTRICAL_IDLE</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_PWR_MGMT_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_KMRN_MODE_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GG82563_KMCR_PASS_FALSE_CARRIER</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_KMRN_MODE_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Workaround: Disable padding in Kumeran interface in the MAC</span>
<span class="cm">	 * and in the PHY to avoid CRC errors.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_INBAND_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">|=</span> <span class="n">GG82563_ICR_DIS_PADDING</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_INBAND_CTRL</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_setup_copper_link_80003es2lan - Setup Copper Link for ESB2</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Essentially a wrapper for setting up all things &quot;copper&quot; related.</span>
<span class="cm"> *  This is a function pointer entry point called by the mac module.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_setup_copper_link_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reg_data</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SLU</span><span class="p">;</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_FRCSPD</span> <span class="o">|</span> <span class="n">E1000_CTRL_FRCDPX</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the mac to wait the maximum time between each</span>
<span class="cm">	 * iteration and increase the max iterations when</span>
<span class="cm">	 * polling the phy; this fixes erroneous timeouts at 10Mbps.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_REG</span><span class="p">(</span><span class="mh">0x34</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
	                                           <span class="mh">0xFFFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_REG</span><span class="p">(</span><span class="mh">0x34</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
	                                          <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">reg_data</span> <span class="o">|=</span> <span class="mh">0x3F</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_REG</span><span class="p">(</span><span class="mh">0x34</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
	                                           <span class="n">reg_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
				      <span class="n">E1000_KMRNCTRLSTA_OFFSET_INB_CTRL</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">E1000_KMRNCTRLSTA_INB_CTRL_DIS_PADDING</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					<span class="n">E1000_KMRNCTRLSTA_OFFSET_INB_CTRL</span><span class="p">,</span>
					<span class="n">reg_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_setup_gg82563_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1000e_setup_copper_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_cfg_on_link_up_80003es2lan - es2 link configuration after link-up</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @duplex: current duplex setting</span>
<span class="cm"> *</span>
<span class="cm"> *  Configure the KMRN interface by applying last minute quirks for</span>
<span class="cm"> *  10/100 operation.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_cfg_on_link_up_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">duplex</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_get_speed_and_duplex_copper</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span>
		                                             <span class="o">&amp;</span><span class="n">duplex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_cfg_kmrn_1000_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_cfg_kmrn_10_100_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">duplex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_cfg_kmrn_10_100_80003es2lan - Apply &quot;quirks&quot; for 10/100 operation</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @duplex: current duplex setting</span>
<span class="cm"> *</span>
<span class="cm"> *  Configure the KMRN interface by applying last minute quirks for</span>
<span class="cm"> *  10/100 operation.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_cfg_kmrn_10_100_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">duplex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tipg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reg_data</span><span class="p">,</span> <span class="n">reg_data2</span><span class="p">;</span>

	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">E1000_KMRNCTRLSTA_HD_CTRL_10_100_DEFAULT</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
	                               <span class="n">E1000_KMRNCTRLSTA_OFFSET_HD_CTRL</span><span class="p">,</span>
	                               <span class="n">reg_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Configure Transmit Inter-Packet Gap */</span>
	<span class="n">tipg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TIPG</span><span class="p">);</span>
	<span class="n">tipg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TIPG_IPGT_MASK</span><span class="p">;</span>
	<span class="n">tipg</span> <span class="o">|=</span> <span class="n">DEFAULT_TIPG_IPGT_10_100_80003ES2LAN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TIPG</span><span class="p">,</span> <span class="n">tipg</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_KMRN_MODE_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_KMRN_MODE_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">reg_data</span> <span class="o">!=</span> <span class="n">reg_data2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">GG82563_MAX_KMRN_RETRY</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">HALF_DUPLEX</span><span class="p">)</span>
		<span class="n">reg_data</span> <span class="o">|=</span> <span class="n">GG82563_KMCR_PASS_FALSE_CARRIER</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">reg_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GG82563_KMCR_PASS_FALSE_CARRIER</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_KMRN_MODE_CTRL</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_cfg_kmrn_1000_80003es2lan - Apply &quot;quirks&quot; for gigabit operation</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Configure the KMRN interface by applying last minute quirks for</span>
<span class="cm"> *  gigabit operation.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_cfg_kmrn_1000_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reg_data</span><span class="p">,</span> <span class="n">reg_data2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tipg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">reg_data</span> <span class="o">=</span> <span class="n">E1000_KMRNCTRLSTA_HD_CTRL_1000_DEFAULT</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
	                               <span class="n">E1000_KMRNCTRLSTA_OFFSET_HD_CTRL</span><span class="p">,</span>
	                               <span class="n">reg_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Configure Transmit Inter-Packet Gap */</span>
	<span class="n">tipg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TIPG</span><span class="p">);</span>
	<span class="n">tipg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TIPG_IPGT_MASK</span><span class="p">;</span>
	<span class="n">tipg</span> <span class="o">|=</span> <span class="n">DEFAULT_TIPG_IPGT_1000_80003ES2LAN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TIPG</span><span class="p">,</span> <span class="n">tipg</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_KMRN_MODE_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_KMRN_MODE_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg_data2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">reg_data</span> <span class="o">!=</span> <span class="n">reg_data2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">GG82563_MAX_KMRN_RETRY</span><span class="p">));</span>

	<span class="n">reg_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GG82563_KMCR_PASS_FALSE_CARRIER</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GG82563_PHY_KMRN_MODE_CTRL</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_kmrn_reg_80003es2lan - Read kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to be read</span>
<span class="cm"> *  @data: pointer to the read data</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquire semaphore, then read the PHY register at offset</span>
<span class="cm"> *  using the kumeran interface.  The information retrieved is stored in data.</span>
<span class="cm"> *  Release the semaphore before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_read_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
					   <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">kmrnctrlsta</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_acquire_mac_csr_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">kmrnctrlsta</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_KMRNCTRLSTA_OFFSET_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
	               <span class="n">E1000_KMRNCTRLSTA_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="n">E1000_KMRNCTRLSTA_REN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">KMRNCTRLSTA</span><span class="p">,</span> <span class="n">kmrnctrlsta</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">kmrnctrlsta</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">KMRNCTRLSTA</span><span class="p">);</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">kmrnctrlsta</span><span class="p">;</span>

	<span class="n">e1000_release_mac_csr_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_write_kmrn_reg_80003es2lan - Write kumeran register</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *  @offset: register offset to write to</span>
<span class="cm"> *  @data: data to write at register offset</span>
<span class="cm"> *</span>
<span class="cm"> *  Acquire semaphore, then write the data to PHY register</span>
<span class="cm"> *  at the offset using the kumeran interface.  Release semaphore</span>
<span class="cm"> *  before exiting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_write_kmrn_reg_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
					    <span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">kmrnctrlsta</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_acquire_mac_csr_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">kmrnctrlsta</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_KMRNCTRLSTA_OFFSET_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
	               <span class="n">E1000_KMRNCTRLSTA_OFFSET</span><span class="p">)</span> <span class="o">|</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">KMRNCTRLSTA</span><span class="p">,</span> <span class="n">kmrnctrlsta</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="n">e1000_release_mac_csr_80003es2lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_read_mac_addr_80003es2lan - Read device MAC address</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_read_mac_addr_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there&#39;s an alternate MAC address place it in RAR0</span>
<span class="cm">	 * so that it will override the Si installed default perm</span>
<span class="cm">	 * address.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_alt_mac_addr_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">e1000_read_mac_addr_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_power_down_phy_copper_80003es2lan - Remove link during PHY power down</span>
<span class="cm"> * @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> * In the case of a PHY power down to save power, or to turn off link during a</span>
<span class="cm"> * driver unload, or wake on lan is not enabled, remove the link.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_power_down_phy_copper_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If the management interface is not enabled, then power down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_mng_mode</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span><span class="p">(</span><span class="n">hw</span><span class="p">)))</span>
		<span class="n">e1000_power_down_phy_copper</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  e1000_clear_hw_cntrs_80003es2lan - Clear device specific hardware counters</span>
<span class="cm"> *  @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> *  Clears the hardware counters by reading the counter registers.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clear_hw_cntrs_80003es2lan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e1000e_clear_hw_cntrs_base</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">PRC64</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC127</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC255</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC511</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC1023</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PRC1522</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC64</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC127</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC255</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC511</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC1023</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">PTC1522</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">ALGNERRC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">RXERRC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">TNCRS</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">CEXTERR</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">TSCTC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">TSCTFC</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">MGTPRC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">MGTPDC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">MGTPTC</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">IAC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICRXOC</span><span class="p">);</span>

	<span class="n">er32</span><span class="p">(</span><span class="n">ICRXPTC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICRXATC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICTXPTC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICTXATC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICTXQEC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICTXQMTC</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICRXDMTC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_mac_operations</span> <span class="n">es2_mac_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read_mac_addr</span>		<span class="o">=</span> <span class="n">e1000_read_mac_addr_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_led_init</span>		<span class="o">=</span> <span class="n">e1000e_id_led_init_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">blink_led</span>		<span class="o">=</span> <span class="n">e1000e_blink_led_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_mng_mode</span>		<span class="o">=</span> <span class="n">e1000e_check_mng_mode_generic</span><span class="p">,</span>
	<span class="cm">/* check_for_link dependent on media type */</span>
	<span class="p">.</span><span class="n">cleanup_led</span>		<span class="o">=</span> <span class="n">e1000e_cleanup_led_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_hw_cntrs</span>		<span class="o">=</span> <span class="n">e1000_clear_hw_cntrs_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_bus_info</span>		<span class="o">=</span> <span class="n">e1000e_get_bus_info_pcie</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_lan_id</span>		<span class="o">=</span> <span class="n">e1000_set_lan_id_multi_port_pcie</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_link_up_info</span>	<span class="o">=</span> <span class="n">e1000_get_link_up_info_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">led_on</span>			<span class="o">=</span> <span class="n">e1000e_led_on_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">led_off</span>		<span class="o">=</span> <span class="n">e1000e_led_off_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_mc_addr_list</span>	<span class="o">=</span> <span class="n">e1000e_update_mc_addr_list_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_vfta</span>		<span class="o">=</span> <span class="n">e1000_write_vfta_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_vfta</span>		<span class="o">=</span> <span class="n">e1000_clear_vfta_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_hw</span>		<span class="o">=</span> <span class="n">e1000_reset_hw_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_hw</span>		<span class="o">=</span> <span class="n">e1000_init_hw_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_link</span>		<span class="o">=</span> <span class="n">e1000e_setup_link_generic</span><span class="p">,</span>
	<span class="cm">/* setup_physical_interface dependent on media type */</span>
	<span class="p">.</span><span class="n">setup_led</span>		<span class="o">=</span> <span class="n">e1000e_setup_led_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">config_collision_dist</span>	<span class="o">=</span> <span class="n">e1000e_config_collision_dist_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rar_set</span>		<span class="o">=</span> <span class="n">e1000e_rar_set_generic</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_phy_operations</span> <span class="n">es2_phy_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">acquire</span>		<span class="o">=</span> <span class="n">e1000_acquire_phy_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_polarity</span>		<span class="o">=</span> <span class="n">e1000_check_polarity_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_reset_block</span>	<span class="o">=</span> <span class="n">e1000e_check_reset_block_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">commit</span>		 	<span class="o">=</span> <span class="n">e1000e_phy_sw_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">force_speed_duplex</span> 	<span class="o">=</span> <span class="n">e1000_phy_force_speed_duplex_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cfg_done</span>       	<span class="o">=</span> <span class="n">e1000_get_cfg_done_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_cable_length</span>   	<span class="o">=</span> <span class="n">e1000_get_cable_length_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_info</span>       	<span class="o">=</span> <span class="n">e1000e_get_phy_info_m88</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_reg</span>       	<span class="o">=</span> <span class="n">e1000_read_phy_reg_gg82563_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">e1000_release_phy_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span>		  	<span class="o">=</span> <span class="n">e1000e_phy_hw_reset_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_d0_lplu_state</span>  	<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_d3_lplu_state</span>  	<span class="o">=</span> <span class="n">e1000e_set_d3_lplu_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_reg</span>      	<span class="o">=</span> <span class="n">e1000_write_phy_reg_gg82563_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cfg_on_link_up</span>      	<span class="o">=</span> <span class="n">e1000_cfg_on_link_up_80003es2lan</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_nvm_operations</span> <span class="n">es2_nvm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">acquire</span>		<span class="o">=</span> <span class="n">e1000_acquire_nvm_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>			<span class="o">=</span> <span class="n">e1000e_read_nvm_eerd</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">e1000_release_nvm_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reload</span>			<span class="o">=</span> <span class="n">e1000e_reload_nvm_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update</span>			<span class="o">=</span> <span class="n">e1000e_update_nvm_checksum_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">valid_led_default</span>	<span class="o">=</span> <span class="n">e1000e_valid_led_default</span><span class="p">,</span>
	<span class="p">.</span><span class="n">validate</span>		<span class="o">=</span> <span class="n">e1000e_validate_nvm_checksum_generic</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>			<span class="o">=</span> <span class="n">e1000_write_nvm_80003es2lan</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="n">e1000_es2_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mac</span>			<span class="o">=</span> <span class="n">e1000_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flags</span>			<span class="o">=</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_JUMBO_FRAMES</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_WOL</span>
				  <span class="o">|</span> <span class="n">FLAG_APME_IN_CTRL3</span>
				  <span class="o">|</span> <span class="n">FLAG_HAS_CTRLEXT_ON_LOAD</span>
				  <span class="o">|</span> <span class="n">FLAG_RX_NEEDS_RESTART</span> <span class="cm">/* errata */</span>
				  <span class="o">|</span> <span class="n">FLAG_TARC_SET_BIT_ZERO</span> <span class="cm">/* errata */</span>
				  <span class="o">|</span> <span class="n">FLAG_APME_CHECK_PORT_B</span>
				  <span class="o">|</span> <span class="n">FLAG_DISABLE_FC_PAUSE_TIME</span><span class="p">,</span> <span class="cm">/* errata */</span>
	<span class="p">.</span><span class="n">flags2</span>			<span class="o">=</span> <span class="n">FLAG2_DMA_BURST</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pba</span>			<span class="o">=</span> <span class="mi">38</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_hw_frame_size</span>	<span class="o">=</span> <span class="n">DEFAULT_JUMBO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_variants</span>		<span class="o">=</span> <span class="n">e1000_get_variants_80003es2lan</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mac_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">es2_mac_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">phy_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">es2_phy_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nvm_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">es2_nvm_ops</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
