<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › e1000e › netdev.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>netdev.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel PRO/1000 Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;net/ip6_checksum.h&gt;</span>
<span class="cp">#include &lt;linux/mii.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/pm_qos.h&gt;</span>
<span class="cp">#include &lt;linux/pm_runtime.h&gt;</span>
<span class="cp">#include &lt;linux/aer.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &quot;e1000.h&quot;</span>

<span class="cp">#define DRV_EXTRAVERSION &quot;-k&quot;</span>

<span class="cp">#define DRV_VERSION &quot;2.0.0&quot; DRV_EXTRAVERSION</span>
<span class="kt">char</span> <span class="n">e1000e_driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;e1000e&quot;</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">e1000e_driver_version</span><span class="p">[]</span> <span class="o">=</span> <span class="n">DRV_VERSION</span><span class="p">;</span>

<span class="cp">#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Debug level (0=none,...,16=all)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000e_disable_aspm</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">state</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="o">*</span><span class="n">e1000_info_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">board_82571</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_82571_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_82572</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_82572_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_82573</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_82573_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_82574</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_82574_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_82583</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_82583_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_80003es2lan</span><span class="p">]</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_es2_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_ich8lan</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_ich8_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_ich9lan</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_ich9_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_ich10lan</span><span class="p">]</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_ich10_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_pchlan</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_pch_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_pch2lan</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_pch2_info</span><span class="p">,</span>
	<span class="p">[</span><span class="n">board_pch_lpt</span><span class="p">]</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_pch_lpt_info</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">e1000_reg_info</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define E1000_RDFH	0x02410	</span><span class="cm">/* Rx Data FIFO Head - RW */</span><span class="cp"></span>
<span class="cp">#define E1000_RDFT	0x02418	</span><span class="cm">/* Rx Data FIFO Tail - RW */</span><span class="cp"></span>
<span class="cp">#define E1000_RDFHS	0x02420	</span><span class="cm">/* Rx Data FIFO Head Saved - RW */</span><span class="cp"></span>
<span class="cp">#define E1000_RDFTS	0x02428	</span><span class="cm">/* Rx Data FIFO Tail Saved - RW */</span><span class="cp"></span>
<span class="cp">#define E1000_RDFPC	0x02430	</span><span class="cm">/* Rx Data FIFO Packet Count - RW */</span><span class="cp"></span>

<span class="cp">#define E1000_TDFH	0x03410	</span><span class="cm">/* Tx Data FIFO Head - RW */</span><span class="cp"></span>
<span class="cp">#define E1000_TDFT	0x03418	</span><span class="cm">/* Tx Data FIFO Tail - RW */</span><span class="cp"></span>
<span class="cp">#define E1000_TDFHS	0x03420	</span><span class="cm">/* Tx Data FIFO Head Saved - RW */</span><span class="cp"></span>
<span class="cp">#define E1000_TDFTS	0x03428	</span><span class="cm">/* Tx Data FIFO Tail Saved - RW */</span><span class="cp"></span>
<span class="cp">#define E1000_TDFPC	0x03430	</span><span class="cm">/* Tx Data FIFO Packet Count - RW */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_reg_info</span> <span class="n">e1000_reg_info_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>

	<span class="cm">/* General Registers */</span>
	<span class="p">{</span><span class="n">E1000_CTRL</span><span class="p">,</span> <span class="s">&quot;CTRL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_STATUS</span><span class="p">,</span> <span class="s">&quot;STATUS&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_CTRL_EXT</span><span class="p">,</span> <span class="s">&quot;CTRL_EXT&quot;</span><span class="p">},</span>

	<span class="cm">/* Interrupt Registers */</span>
	<span class="p">{</span><span class="n">E1000_ICR</span><span class="p">,</span> <span class="s">&quot;ICR&quot;</span><span class="p">},</span>

	<span class="cm">/* Rx Registers */</span>
	<span class="p">{</span><span class="n">E1000_RCTL</span><span class="p">,</span> <span class="s">&quot;RCTL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDLEN&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDT&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDTR</span><span class="p">,</span> <span class="s">&quot;RDTR&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RXDCTL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_ERT</span><span class="p">,</span> <span class="s">&quot;ERT&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDBAL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;RDBAH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDFH</span><span class="p">,</span> <span class="s">&quot;RDFH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDFT</span><span class="p">,</span> <span class="s">&quot;RDFT&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDFHS</span><span class="p">,</span> <span class="s">&quot;RDFHS&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDFTS</span><span class="p">,</span> <span class="s">&quot;RDFTS&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_RDFPC</span><span class="p">,</span> <span class="s">&quot;RDFPC&quot;</span><span class="p">},</span>

	<span class="cm">/* Tx Registers */</span>
	<span class="p">{</span><span class="n">E1000_TCTL</span><span class="p">,</span> <span class="s">&quot;TCTL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDBAL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDBAH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDLEN&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TDT&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TIDV</span><span class="p">,</span> <span class="s">&quot;TIDV&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TXDCTL&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TADV</span><span class="p">,</span> <span class="s">&quot;TADV&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s">&quot;TARC&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFH</span><span class="p">,</span> <span class="s">&quot;TDFH&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFT</span><span class="p">,</span> <span class="s">&quot;TDFT&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFHS</span><span class="p">,</span> <span class="s">&quot;TDFHS&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFTS</span><span class="p">,</span> <span class="s">&quot;TDFTS&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">E1000_TDFPC</span><span class="p">,</span> <span class="s">&quot;TDFPC&quot;</span><span class="p">},</span>

	<span class="cm">/* List Terminator */</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * e1000_regdump - register printout routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_regdump</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">e1000_reg_info</span> <span class="o">*</span><span class="n">reginfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">rname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">regs</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">__er32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_RXDCTL</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">__er32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_TXDCTL</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>:
		<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
			<span class="n">regs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">__er32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_TARC</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%-15s %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__er32</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">rname</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;%s%s&quot;</span><span class="p">,</span> <span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;[0-1]&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%-15s %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rname</span><span class="p">,</span> <span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">regs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * e1000e_dump - Print registers, Tx-ring and Rx-ring</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_reg_info</span> <span class="o">*</span><span class="n">reginfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">my_u0</span> <span class="p">{</span>
		<span class="n">__le64</span> <span class="n">a</span><span class="p">;</span>
		<span class="n">__le64</span> <span class="n">b</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">u0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_rx_desc_packet_split</span> <span class="o">*</span><span class="n">rx_desc_ps</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_rx_desc_extended</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">my_u1</span> <span class="p">{</span>
		<span class="n">__le64</span> <span class="n">a</span><span class="p">;</span>
		<span class="n">__le64</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">__le64</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">__le64</span> <span class="n">d</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">u1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">staterr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Print netdevice Info */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Net device Info</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Device Name     state            trans_start      last_rx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%-15s %016lX %016lX %016lX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">trans_start</span><span class="p">,</span>
			<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">last_rx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print Registers */</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Register Dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; Register Name   Value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">reginfo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">e1000_reg_info</span> <span class="o">*</span><span class="p">)</span><span class="n">e1000_reg_info_tbl</span><span class="p">;</span>
	     <span class="n">reginfo</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span> <span class="n">reginfo</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e1000_regdump</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">reginfo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print Tx Ring Summary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span> <span class="o">||</span> <span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx Ring Summary</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Queue [NTU] [NTC] [bi(ntc)-&gt;dma  ] leng ntw timestamp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">];</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %5d %5X %5X %016llX %04X %3X %016llX</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">);</span>

	<span class="cm">/* Print Tx Ring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_tx_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rx_ring_summary</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx Ring Dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Transmit Descriptor Formats - DEXT[29] is 0 (Legacy) or 1 (Extended)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Legacy Transmit Descriptor</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 * 0 |         Buffer Address [63:0] (Reserved on Write Back)       |</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 * 8 | Special  |    CSS     | Status |  CMD    |  CSO   |  Length  |</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 *   63       48 47        36 35    32 31     24 23    16 15        0</span>
<span class="cm">	 *</span>
<span class="cm">	 * Extended Context Descriptor (DTYP=0x0) for TSO or checksum offload</span>
<span class="cm">	 *   63      48 47    40 39       32 31             16 15    8 7      0</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 * 0 |  TUCSE  | TUCS0  |   TUCSS   |     IPCSE       | IPCS0 | IPCSS |</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 * 8 |   MSS   | HDRLEN | RSV | STA | TUCMD | DTYP |      PAYLEN      |</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 *   63      48 47    40 39 36 35 32 31   24 23  20 19                0</span>
<span class="cm">	 *</span>
<span class="cm">	 * Extended Data Descriptor (DTYP=0x1)</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 * 0 |                     Buffer Address [63:0]                      |</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 * 8 | VLAN tag |  POPTS  | Rsvd | Status | Command | DTYP |  DTALEN  |</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 *   63       48 47     40 39  36 35    32 31     24 23  20 19        0</span>
<span class="cm">	 */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tl[desc]     [address 63:0  ] [SpeCssSCmCsLen] [bi-&gt;dma       ] leng  ntw timestamp        bi-&gt;skb &lt;-- Legacy format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tc[desc]     [Ce CoCsIpceCoS] [MssHlRSCm0Plen] [bi-&gt;dma       ] leng  ntw timestamp        bi-&gt;skb &lt;-- Ext Context format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen] [bi-&gt;dma       ] leng  ntw timestamp        bi-&gt;skb &lt;-- Ext Data format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">next_desc</span><span class="p">;</span>
		<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">u0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_u0</span> <span class="o">*</span><span class="p">)</span><span class="n">tx_desc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
			<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTC/U&quot;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
			<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTU&quot;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
			<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTC&quot;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;T%c[0x%03X]    %016llX %016llX %016llX %04X  %3X %016llX %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;l&#39;</span> <span class="o">:</span>
			 <span class="p">((</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;d&#39;</span> <span class="o">:</span> <span class="sc">&#39;c&#39;</span><span class="p">)),</span>
			<span class="n">i</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u0</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">,</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_desc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_pktdata</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span>
				       <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">),</span>
				       <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Print Rx Ring Summary */</span>
<span class="nl">rx_ring_summary:</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Rx Ring Summary</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Queue [NTU] [NTC]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot; %5d %5X %5X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">);</span>

	<span class="cm">/* Print Rx Ring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_rx_status</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Rx Ring Dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_pages</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="k">case</span> <span class="mi">2</span>:
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="cm">/* [Extended] Packet Split Receive Descriptor Format</span>
<span class="cm">		 *</span>
<span class="cm">		 *    +-----------------------------------------------------+</span>
<span class="cm">		 *  0 |                Buffer Address 0 [63:0]              |</span>
<span class="cm">		 *    +-----------------------------------------------------+</span>
<span class="cm">		 *  8 |                Buffer Address 1 [63:0]              |</span>
<span class="cm">		 *    +-----------------------------------------------------+</span>
<span class="cm">		 * 16 |                Buffer Address 2 [63:0]              |</span>
<span class="cm">		 *    +-----------------------------------------------------+</span>
<span class="cm">		 * 24 |                Buffer Address 3 [63:0]              |</span>
<span class="cm">		 *    +-----------------------------------------------------+</span>
<span class="cm">		 */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;R  [desc]      [buffer 0 63:0 ] [buffer 1 63:0 ] [buffer 2 63:0 ] [buffer 3 63:0 ] [bi-&gt;dma       ] [bi-&gt;skb] &lt;-- Ext Pkt Split format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* [Extended] Receive Descriptor (Write-Back) Format</span>
<span class="cm">		 *</span>
<span class="cm">		 *   63       48 47    32 31     13 12    8 7    4 3        0</span>
<span class="cm">		 *   +------------------------------------------------------+</span>
<span class="cm">		 * 0 | Packet   | IP     |  Rsvd   | MRQ   | Rsvd | MRQ RSS |</span>
<span class="cm">		 *   | Checksum | Ident  |         | Queue |      |  Type   |</span>
<span class="cm">		 *   +------------------------------------------------------+</span>
<span class="cm">		 * 8 | VLAN Tag | Length | Extended Error | Extended Status |</span>
<span class="cm">		 *   +------------------------------------------------------+</span>
<span class="cm">		 *   63       48 47    32 31            20 19               0</span>
<span class="cm">		 */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;RWB[desc]      [ck ipid mrqhsh] [vl   l0 ee  es] [ l3  l2  l1 hs] [reserved      ] ---------------- [bi-&gt;skb] &lt;-- Ext Rx Write-Back format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">next_desc</span><span class="p">;</span>
			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">rx_desc_ps</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_PS</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">u1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_u1</span> <span class="o">*</span><span class="p">)</span><span class="n">rx_desc_ps</span><span class="p">;</span>
			<span class="n">staterr</span> <span class="o">=</span>
			    <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc_ps</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">middle</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTU&quot;</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTC&quot;</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Descriptor Done */</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s[0x%03X]     %016llX %016llX %016llX %016llX ---------------- %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="s">&quot;RWB&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">),</span>
					<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_desc</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s[0x%03X]     %016llX %016llX %016llX %016llX %016llX %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="s">&quot;R  &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_desc</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_pktdata</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
					<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
						<span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">phys_to_virt</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">),</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_bsize0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* Extended Receive Descriptor (Read) Format</span>
<span class="cm">		 *</span>
<span class="cm">		 *   +-----------------------------------------------------+</span>
<span class="cm">		 * 0 |                Buffer Address [63:0]                |</span>
<span class="cm">		 *   +-----------------------------------------------------+</span>
<span class="cm">		 * 8 |                      Reserved                       |</span>
<span class="cm">		 *   +-----------------------------------------------------+</span>
<span class="cm">		 */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;R  [desc]      [buf addr 63:0 ] [reserved 63:0 ] [bi-&gt;dma       ] [bi-&gt;skb] &lt;-- Ext (Read) format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* Extended Receive Descriptor (Write-Back) Format</span>
<span class="cm">		 *</span>
<span class="cm">		 *   63       48 47    32 31    24 23            4 3        0</span>
<span class="cm">		 *   +------------------------------------------------------+</span>
<span class="cm">		 *   |     RSS Hash      |        |               |         |</span>
<span class="cm">		 * 0 +-------------------+  Rsvd  |   Reserved    | MRQ RSS |</span>
<span class="cm">		 *   | Packet   | IP     |        |               |  Type   |</span>
<span class="cm">		 *   | Checksum | Ident  |        |               |         |</span>
<span class="cm">		 *   +------------------------------------------------------+</span>
<span class="cm">		 * 8 | VLAN Tag | Length | Extended Error | Extended Status |</span>
<span class="cm">		 *   +------------------------------------------------------+</span>
<span class="cm">		 *   63       48 47    32 31            20 19               0</span>
<span class="cm">		 */</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;RWB[desc]      [cs ipid    mrq] [vt   ln xe  xs] [bi-&gt;skb] &lt;-- Ext (Write-Back) format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">next_desc</span><span class="p">;</span>

			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_EXT</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">u1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_u1</span> <span class="o">*</span><span class="p">)</span><span class="n">rx_desc</span><span class="p">;</span>
			<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTU&quot;</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot; NTC&quot;</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">next_desc</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Descriptor Done */</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s[0x%03X]     %016llX %016llX ---------------- %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="s">&quot;RWB&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
					<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_desc</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s[0x%03X]     %016llX %016llX %016llX %p%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="s">&quot;R  &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u1</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_desc</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">netif_msg_pktdata</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
					<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
						       <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>
						       <span class="mi">1</span><span class="p">,</span>
						       <span class="n">phys_to_virt</span>
						       <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">),</span>
						       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span>
						       <span class="nb">true</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_desc_unused - calculate if we have unused descriptors</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_desc_unused</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">&gt;</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">-</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">-</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_receive_skb - helper function to handle Rx indications</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @status: descriptor status field as written by hardware</span>
<span class="cm"> * @vlan: descriptor vlan field as written by hardware (no le/be conversion)</span>
<span class="cm"> * @skb: pointer to sk_buff to be indicated to stack</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			      <span class="n">u8</span> <span class="n">status</span><span class="p">,</span> <span class="n">__le16</span> <span class="n">vlan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">vlan</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_VP</span><span class="p">)</span>
		<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

	<span class="n">napi_gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_rx_checksum - Receive Checksum Offload</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @status_err: receive descriptor status and error fields</span>
<span class="cm"> * @csum: receive descriptor csum field</span>
<span class="cm"> * @sk_buff: socket buffer with received data</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_rx_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status_err</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">status_err</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">errors</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">status_err</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>

	<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Rx checksum disabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Ignore Checksum bit is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_IXSM</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* TCP/UDP checksum error bit or IP checksum error bit is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_RXD_ERR_TCPE</span> <span class="o">|</span> <span class="n">E1000_RXD_ERR_IPE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* let the stack verify checksum errors */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_csum_err</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* TCP/UDP Checksum has not been calculated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_RXD_STAT_TCPCS</span> <span class="o">|</span> <span class="n">E1000_RXD_STAT_UDPCS</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* It must be a TCP or UDP packet with a valid checksum */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_csum_good</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_update_rdt_wa</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">__ew32_prepare</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ret_val</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">readl</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RCTL_EN</span><span class="p">);</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;ME firmware caused invalid RDT - resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_update_tdt_wa</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">__ew32_prepare</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ret_val</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">readl</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">tctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TCTL_EN</span><span class="p">);</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;ME firmware caused invalid TDT - resetting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_alloc_rx_buffers - Replace used receive buffers</span>
<span class="cm"> * @rx_ring: Rx descriptor ring</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_alloc_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">cleaned_count</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_rx_desc_extended</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsz</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">map_skb</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">__netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Better luck next round */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
<span class="nl">map_skb:</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span>
						  <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Rx DMA map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_dma_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_EXT</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_RX_BUFFER_WRITE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Force memory writes to complete before letting h/w</span>
<span class="cm">			 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">			 * applicable for weak-ordered memory model archs,</span>
<span class="cm">			 * such as IA-64).</span>
<span class="cm">			 */</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_PCIM2PCI_ARBITER_WA</span><span class="p">)</span>
				<span class="n">e1000e_update_rdt_wa</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_alloc_rx_buffers_ps - Replace used receive buffers; packet split</span>
<span class="cm"> * @rx_ring: Rx descriptor ring</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_alloc_rx_buffers_ps</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">cleaned_count</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_rx_desc_packet_split</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ps_page</span> <span class="o">*</span><span class="n">ps_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_PS</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">PS_PAGE_BUFFERS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ps_page</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">ps_pages</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* all unused desc entries get hw null ptr */</span>
				<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				    <span class="o">~</span><span class="n">cpu_to_le64</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">gfp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">no_buffers</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							    <span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
							    <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
							    <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						      <span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						<span class="s">&quot;Rx DMA page map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_dma_failed</span><span class="o">++</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">no_buffers</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * Refresh the desc even if buffer_addrs</span>
<span class="cm">			 * didn&#39;t change because each write-back</span>
<span class="cm">			 * erases this info.</span>
<span class="cm">			 */</span>
			<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
			    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">__netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span>
						  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_bsize0</span><span class="p">,</span>
						  <span class="n">gfp</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						  <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_bsize0</span><span class="p">,</span>
						  <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Rx DMA map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_dma_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="cm">/* cleanup skb */</span>
			<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_RX_BUFFER_WRITE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Force memory writes to complete before letting h/w</span>
<span class="cm">			 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">			 * applicable for weak-ordered memory model archs,</span>
<span class="cm">			 * such as IA-64).</span>
<span class="cm">			 */</span>
			<span class="n">wmb</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_PCIM2PCI_ARBITER_WA</span><span class="p">)</span>
				<span class="n">e1000e_update_rdt_wa</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

<span class="nl">no_buffers:</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_alloc_jumbo_rx_buffers - Replace used jumbo receive buffers</span>
<span class="cm"> * @rx_ring: Rx descriptor ring</span>
<span class="cm"> * @cleaned_count: number of buffers to allocate this pass</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_alloc_jumbo_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">cleaned_count</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_rx_desc_extended</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsz</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">-</span> <span class="mi">16</span> <span class="cm">/* for skb_reserve */</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">check_page</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">__netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Better luck next round */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
<span class="nl">check_page:</span>
		<span class="cm">/* allocate a new page if necessary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">gfp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			                                <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			                                <span class="n">PAGE_SIZE</span><span class="p">,</span>
							<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_EXT</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">.</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">!=</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Force memory writes to complete before letting h/w</span>
<span class="cm">		 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">		 * applicable for weak-ordered memory model archs,</span>
<span class="cm">		 * such as IA-64). */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_PCIM2PCI_ARBITER_WA</span><span class="p">)</span>
			<span class="n">e1000e_update_rdt_wa</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">e1000_rx_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">__le32</span> <span class="n">rss</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXHASH</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rss</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_rx_irq - Send received data up the network stack</span>
<span class="cm"> * @rx_ring: Rx descriptor ring</span>
<span class="cm"> *</span>
<span class="cm"> * the return value indicates whether actual cleaning was done, there</span>
<span class="cm"> * is no guarantee that everything was cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_clean_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_rx_desc_extended</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">next_rxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">,</span> <span class="o">*</span><span class="n">next_buffer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">,</span> <span class="n">staterr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_EXT</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">work_to_do</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">work_done</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>	<span class="cm">/* read descriptor and rx_buffer_info after status DD */</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">next_rxd</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_EXT</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">next_rxd</span><span class="p">);</span>

		<span class="n">next_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">cleaned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cleaned_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span>
				 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * !EOP means multiple descriptors were used to store a single</span>
<span class="cm">		 * packet, if that&#39;s the case we need to toss it.  In fact, we</span>
<span class="cm">		 * need to toss every packet with the EOP bit clear and the</span>
<span class="cm">		 * next frame that _does_ have the EOP bit set, as it is by</span>
<span class="cm">		 * definition only a frame fragment</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">)))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">|=</span> <span class="n">FLAG2_IS_DISCARDING</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_IS_DISCARDING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* All receives must fit into a single buffer */</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Receive packet consumed multiple buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* recycle */</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG2_IS_DISCARDING</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXDEXT_ERR_FRAME_ERR_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* recycle */</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* adjust length to remove Ethernet CRC */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_CRC_STRIPPING</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If configured to store CRC, don&#39;t subtract FCS,</span>
<span class="cm">			 * but keep the FCS bytes out of the total_rx_bytes</span>
<span class="cm">			 * counter</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXFCS</span><span class="p">)</span>
				<span class="n">total_rx_bytes</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">length</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">total_rx_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * code added for copybreak, this should improve</span>
<span class="cm">		 * performance for small packets with large amounts</span>
<span class="cm">		 * of reassembly being done in the stack</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">copybreak</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new_skb</span> <span class="o">=</span>
			    <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">new_skb</span><span class="p">,</span>
							       <span class="o">-</span><span class="n">NET_IP_ALIGN</span><span class="p">,</span>
							       <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span>
								<span class="n">NET_IP_ALIGN</span><span class="p">),</span>
							       <span class="p">(</span><span class="n">length</span> <span class="o">+</span>
								<span class="n">NET_IP_ALIGN</span><span class="p">));</span>
				<span class="cm">/* save the skb in buffer_info as good */</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">new_skb</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* else just continue with the old one */</span>
		<span class="p">}</span>
		<span class="cm">/* end copybreak code */</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

		<span class="cm">/* Receive Checksum Offload */</span>
		<span class="n">e1000_rx_checksum</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">staterr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">e1000_rx_hash</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">hi_dword</span><span class="p">.</span><span class="n">rss</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">e1000_receive_skb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">netdev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">staterr</span><span class="p">,</span>
				  <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">vlan</span><span class="p">);</span>

<span class="nl">next_desc:</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="mh">0xFF</span><span class="p">);</span>

		<span class="cm">/* return some buffers to hardware, one at a time is too slow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span> <span class="o">&gt;=</span> <span class="n">E1000_RX_BUFFER_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">,</span>
					      <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* use prefetched values */</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">next_rxd</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="p">;</span>

		<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cleaned_count</span> <span class="o">=</span> <span class="n">e1000_desc_unused</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">total_rx_bytes</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">+=</span> <span class="n">total_rx_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cleaned</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_put_txbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span><span class="p">)</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				       <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					 <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_print_hw_hang</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
	                                             <span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span>
	                                             <span class="n">print_hang_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eop</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_to_watch</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_tx_desc</span> <span class="o">*</span><span class="n">eop_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">eop</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_status</span><span class="p">,</span> <span class="n">phy_1000t_status</span><span class="p">,</span> <span class="n">phy_ext_status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_hang_recheck</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DMA_BURST</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * May be block on write-back, flush and detect again</span>
<span class="cm">		 * flush pending descriptor writebacks to memory</span>
<span class="cm">		 */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TIDV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span> <span class="o">|</span> <span class="n">E1000_TIDV_FPD</span><span class="p">);</span>
		<span class="cm">/* execute the writes immediately */</span>
		<span class="n">e1e_flush</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * Due to rare timing issues, write to TIDV again to ensure</span>
<span class="cm">		 * the write is successful</span>
<span class="cm">		 */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TIDV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span> <span class="o">|</span> <span class="n">E1000_TIDV_FPD</span><span class="p">);</span>
		<span class="cm">/* execute the writes immediately */</span>
		<span class="n">e1e_flush</span><span class="p">();</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_hang_recheck</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Real hang detected */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_hang_recheck</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_status</span><span class="p">);</span>
	<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_1000t_status</span><span class="p">);</span>
	<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_EXT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_ext_status</span><span class="p">);</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_status</span><span class="p">);</span>

	<span class="cm">/* detected Hardware unit hang */</span>
	<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Detected Hardware Unit Hang:</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;  TDH                  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;  TDT                  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;  next_to_use          &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;  next_to_clean        &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;buffer_info[next_to_clean]:</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;  time_stamp           &lt;%lx&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;  next_to_watch        &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;  jiffies              &lt;%lx&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;  next_to_watch.status &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;MAC Status             &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;PHY Status             &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;PHY 1000BASE-T Status  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;PHY Extended Status    &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
	      <span class="s">&quot;PCI Status             &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	      <span class="n">readl</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">),</span>
	      <span class="n">readl</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">),</span>
	      <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">,</span>
	      <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">,</span>
	      <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">eop</span><span class="p">].</span><span class="n">time_stamp</span><span class="p">,</span>
	      <span class="n">eop</span><span class="p">,</span>
	      <span class="n">jiffies</span><span class="p">,</span>
	      <span class="n">eop_desc</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">.</span><span class="n">fields</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
	      <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">),</span>
	      <span class="n">phy_status</span><span class="p">,</span>
	      <span class="n">phy_1000t_status</span><span class="p">,</span>
	      <span class="n">phy_ext_status</span><span class="p">,</span>
	      <span class="n">pci_status</span><span class="p">);</span>

	<span class="cm">/* Suggest workaround for known h/w issue */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_pchlan</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_TFCE</span><span class="p">))</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Try turning off Tx pause (flow control) via ethtool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_tx_irq - Reclaim resources after transmit completes</span>
<span class="cm"> * @tx_ring: Tx descriptor ring</span>
<span class="cm"> *</span>
<span class="cm"> * the return value indicates whether actual cleaning was done, there</span>
<span class="cm"> * is no guarantee that everything was cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_clean_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">eop_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">eop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_compl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pkts_compl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">eop</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_to_watch</span><span class="p">;</span>
	<span class="n">eop_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">eop</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">eop_desc</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_TXD_STAT_DD</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span> <span class="cm">/* read buffer_info after eop_desc */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="o">!</span><span class="n">cleaned</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">cleaned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">eop</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cleaned</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">total_tx_packets</span> <span class="o">+=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">;</span>
				<span class="n">total_tx_bytes</span> <span class="o">+=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">bytecount</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">bytes_compl</span> <span class="o">+=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
					<span class="n">pkts_compl</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">e1000_put_txbuf</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
			<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">eop</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_to_watch</span><span class="p">;</span>
		<span class="n">eop_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">eop</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">netdev_completed_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">pkts_compl</span><span class="p">,</span> <span class="n">bytes_compl</span><span class="p">);</span>

<span class="cp">#define TX_WAKE_THRESHOLD 32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">e1000_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TX_WAKE_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Make sure that anybody stopping the queue after this</span>
<span class="cm">		 * sees the new next_to_clean.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="o">++</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">restart_queue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">detect_tx_hung</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Detect a transmit hang in hardware, this serializes the</span>
<span class="cm">		 * check with the clearing of time_stamp and movement of i</span>
<span class="cm">		 */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">detect_tx_hung</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">time_stamp</span> <span class="o">&amp;&amp;</span>
		    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">time_stamp</span>
			       <span class="o">+</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_TXOFF</span><span class="p">))</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">print_hang_task</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_hang_recheck</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span> <span class="o">+=</span> <span class="n">total_tx_bytes</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span> <span class="o">+=</span> <span class="n">total_tx_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_rx_irq_ps - Send received data up the network stack; packet split</span>
<span class="cm"> * @rx_ring: Rx descriptor ring</span>
<span class="cm"> *</span>
<span class="cm"> * the return value indicates whether actual cleaning was done, there</span>
<span class="cm"> * is no guarantee that everything was cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_clean_rx_irq_ps</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_rx_desc_packet_split</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">next_rxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">,</span> <span class="o">*</span><span class="n">next_buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ps_page</span> <span class="o">*</span><span class="n">ps_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">,</span> <span class="n">staterr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_PS</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">middle</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">work_to_do</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">work_done</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>	<span class="cm">/* read descriptor and rx_buffer_info after status DD */</span>

		<span class="cm">/* in the packet split case this is header only */</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">next_rxd</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_PS</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">next_rxd</span><span class="p">);</span>

		<span class="n">next_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">cleaned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cleaned_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_bsize0</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* see !EOP comment in other Rx routine */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">|=</span> <span class="n">FLAG2_IS_DISCARDING</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_IS_DISCARDING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Packet Split buffers didn&#39;t pick up the full packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG2_IS_DISCARDING</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXDEXT_ERR_FRAME_ERR_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">middle</span><span class="p">.</span><span class="n">length0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Last part of the packet spanning multiple descriptors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Good Receive */</span>
		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

		<span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * this looks ugly, but it seems compiler issues make</span>
<span class="cm">			 * it more efficient than reusing j</span>
<span class="cm">			 */</span>
			<span class="kt">int</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

			<span class="cm">/*</span>
<span class="cm">			 * page alloc/put takes too long and effects small</span>
<span class="cm">			 * packet throughput, so unsplit small packets and</span>
<span class="cm">			 * save the alloc/put only valid in softirq (napi)</span>
<span class="cm">			 * context to call kmap_*</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">l1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">copybreak</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">((</span><span class="n">length</span> <span class="o">+</span> <span class="n">l1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_bsize0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

				<span class="n">ps_page</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">ps_pages</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

				<span class="cm">/*</span>
<span class="cm">				 * there is no documentation about how to call</span>
<span class="cm">				 * kmap_atomic, so we can&#39;t hold the mapping</span>
<span class="cm">				 * very long</span>
<span class="cm">				 */</span>
				<span class="n">dma_sync_single_for_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							<span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
							<span class="n">PAGE_SIZE</span><span class="p">,</span>
							<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
				<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">l1</span><span class="p">);</span>
				<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
				<span class="n">dma_sync_single_for_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							   <span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
							   <span class="n">PAGE_SIZE</span><span class="p">,</span>
							   <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>

				<span class="cm">/* remove the CRC */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_CRC_STRIPPING</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXFCS</span><span class="p">))</span>
						<span class="n">l1</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">l1</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">copydone</span><span class="p">;</span>
			<span class="p">}</span> <span class="cm">/* if */</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">PS_PAGE_BUFFERS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">ps_page</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">ps_pages</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* strip the ethernet crc, problem is we&#39;re using pages now so</span>
<span class="cm">		 * this whole operation can get a little cpu intensive</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_CRC_STRIPPING</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXFCS</span><span class="p">))</span>
				<span class="n">pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>
		<span class="p">}</span>

<span class="nl">copydone:</span>
		<span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">total_rx_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="n">e1000_rx_checksum</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">staterr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">e1000_rx_hash</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">hi_dword</span><span class="p">.</span><span class="n">rss</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">header_status</span> <span class="o">&amp;</span>
			   <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">E1000_RXDPS_HDRSTAT_HDRSP</span><span class="p">))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_hdr_split</span><span class="o">++</span><span class="p">;</span>

		<span class="n">e1000_receive_skb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">netdev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
				  <span class="n">staterr</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">middle</span><span class="p">.</span><span class="n">vlan</span><span class="p">);</span>

<span class="nl">next_desc:</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">middle</span><span class="p">.</span><span class="n">status_error</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="mh">0xFF</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* return some buffers to hardware, one at a time is too slow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span> <span class="o">&gt;=</span> <span class="n">E1000_RX_BUFFER_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">,</span>
					      <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* use prefetched values */</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">next_rxd</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="p">;</span>

		<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">middle</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cleaned_count</span> <span class="o">=</span> <span class="n">e1000_desc_unused</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">total_rx_bytes</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">+=</span> <span class="n">total_rx_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cleaned</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_consume_page - helper function</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_consume_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                               <span class="n">u16</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_jumbo_rx_irq - Send received data up the network stack; legacy</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * the return value indicates whether actual cleaning was done, there</span>
<span class="cm"> * is no guarantee that everything was cleaned</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_clean_jumbo_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">e1000_rx_desc_extended</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">next_rxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">,</span> <span class="o">*</span><span class="n">next_buffer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">,</span> <span class="n">staterr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_rx_bytes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_rx_packets</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_EXT</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">work_to_do</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">work_done</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>	<span class="cm">/* read descriptor and rx_buffer_info after status DD */</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">next_rxd</span> <span class="o">=</span> <span class="n">E1000_RX_DESC_EXT</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">next_rxd</span><span class="p">);</span>

		<span class="n">next_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">cleaned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cleaned_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
			       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

		<span class="cm">/* errors is only valid for DD + EOP descriptors */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="p">((</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXDEXT_ERR_FRAME_ERR_MASK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			      <span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">))))</span> <span class="p">{</span>
			<span class="cm">/* recycle both page and skb */</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="cm">/* an error means any chain goes out the window too */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span><span class="p">)</span>
				<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span><span class="p">);</span>
			<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

<span class="cp">#define rxtop (rx_ring-&gt;rx_skb_top)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">staterr</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* this descriptor is only the beginning (or middle) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxtop</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* this is the beginning of a chain */</span>
				<span class="n">rxtop</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">rxtop</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
				                   <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* this is the middle of a chain */</span>
				<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">rxtop</span><span class="p">,</span>
				    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">rxtop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
				    <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
				<span class="cm">/* re-use the skb, only consumed the page */</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">e1000_consume_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="p">,</span> <span class="n">rxtop</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rxtop</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* end of the chain */</span>
				<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">rxtop</span><span class="p">,</span>
				    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">rxtop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
				    <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
				<span class="cm">/* re-use the current skb, we only consumed the</span>
<span class="cm">				 * page */</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">rxtop</span><span class="p">;</span>
				<span class="n">rxtop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">e1000_consume_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* no chain, got EOP, this buf is the packet</span>
<span class="cm">				 * copybreak to save the put_page/alloc_page */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">copybreak</span> <span class="o">&amp;&amp;</span>
				    <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
					<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
					<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">,</span>
					       <span class="n">length</span><span class="p">);</span>
					<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
					<span class="cm">/* re-use the page, so don&#39;t erase</span>
<span class="cm">					 * buffer_info-&gt;page */</span>
					<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					                   <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				                           <span class="n">length</span><span class="p">);</span>
					<span class="n">e1000_consume_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
					                   <span class="n">length</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Receive Checksum Offload */</span>
		<span class="n">e1000_rx_checksum</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">staterr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">e1000_rx_hash</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">lower</span><span class="p">.</span><span class="n">hi_dword</span><span class="p">.</span><span class="n">rss</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* probably a little skewed due to removing CRC */</span>
		<span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">total_rx_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* eth type trans needs skb-&gt;data to point to something */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;pskb_may_pull failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">e1000_receive_skb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">netdev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">staterr</span><span class="p">,</span>
				  <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">vlan</span><span class="p">);</span>

<span class="nl">next_desc:</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span> <span class="o">&amp;=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">~</span><span class="mh">0xFF</span><span class="p">);</span>

		<span class="cm">/* return some buffers to hardware, one at a time is too slow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cleaned_count</span> <span class="o">&gt;=</span> <span class="n">E1000_RX_BUFFER_WRITE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">,</span>
					      <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* use prefetched values */</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">next_rxd</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="p">;</span>

		<span class="n">staterr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">upper</span><span class="p">.</span><span class="n">status_error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cleaned_count</span> <span class="o">=</span> <span class="n">e1000_desc_unused</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">total_rx_bytes</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">+=</span> <span class="n">total_rx_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cleaned</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_rx_ring - Free Rx Buffers per Queue</span>
<span class="cm"> * @rx_ring: Rx descriptor ring</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clean_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ps_page</span> <span class="o">*</span><span class="n">ps_page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="cm">/* Free all the Rx ring sk_buffs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">==</span> <span class="n">e1000_clean_rx_irq</span><span class="p">)</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
						 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span>
						 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">==</span> <span class="n">e1000_clean_jumbo_rx_irq</span><span class="p">)</span>
				<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				               <span class="n">PAGE_SIZE</span><span class="p">,</span>
					       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">==</span> <span class="n">e1000_clean_rx_irq_ps</span><span class="p">)</span>
				<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
						 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_bsize0</span><span class="p">,</span>
						 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">PS_PAGE_BUFFERS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ps_page</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">ps_pages</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">ps_page</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* there also may be some cached data from a chained receive */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span><span class="p">);</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Zero out the descriptor ring */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG2_IS_DISCARDING</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_PCIM2PCI_ARBITER_WA</span><span class="p">)</span>
		<span class="n">e1000e_update_rdt_wa</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_downshift_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span> <span class="n">downshift_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">e1000e_gig_downshift_workaround_ich8lan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_intr_msi - Interrupt Handler</span>
<span class="cm"> * @irq: interrupt number</span>
<span class="cm"> * @data: pointer to a network interface device structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">e1000_intr_msi</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * read ICR disables interrupts using IAM</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_LSC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * ICH8 workaround-- Call gig speed drop workaround on cable</span>
<span class="cm">		 * disconnect (LSC) before accessing any PHY registers</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_LSC_GIG_SPEED_DROP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)))</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">downshift_task</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * 80003ES2LAN workaround-- For packet buffer work-around on</span>
<span class="cm">		 * link down event; disable receives here in the ISR and reset</span>
<span class="cm">		 * adapter in watchdog</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RX_NEEDS_RESTART</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* disable receives */</span>
			<span class="n">u32</span> <span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RCTL_EN</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_RX_RESTART_NOW</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* guard against interrupt when we&#39;re going down */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_intr - Interrupt Handler</span>
<span class="cm"> * @irq: interrupt number</span>
<span class="cm"> * @data: pointer to a network interface device structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">e1000_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">icr</span> <span class="o">||</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>  <span class="cm">/* Not our interrupt */</span>

	<span class="cm">/*</span>
<span class="cm">	 * IMS will not auto-mask if INT_ASSERTED is not set, and if it is</span>
<span class="cm">	 * not set, then the adapter didn&#39;t send an interrupt</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_INT_ASSERTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Interrupt Auto-Mask...upon reading ICR,</span>
<span class="cm">	 * interrupts are masked.  No need for the</span>
<span class="cm">	 * IMC write</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_LSC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * ICH8 workaround-- Call gig speed drop workaround on cable</span>
<span class="cm">		 * disconnect (LSC) before accessing any PHY registers</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_LSC_GIG_SPEED_DROP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)))</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">downshift_task</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * 80003ES2LAN workaround--</span>
<span class="cm">		 * For packet buffer work-around on link down event;</span>
<span class="cm">		 * disable receives here in the ISR and</span>
<span class="cm">		 * reset adapter in watchdog</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RX_NEEDS_RESTART</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* disable receives */</span>
			<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RCTL_EN</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_RX_RESTART_NOW</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* guard against interrupt when we&#39;re going down */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">e1000_msix_other</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_INT_ASSERTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">IMS</span><span class="p">,</span> <span class="n">E1000_IMS_OTHER</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eiac_mask</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eiac_mask</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_OTHER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_LSC</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">no_link_interrupt</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* guard against interrupt when we&#39;re going down */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">no_link_interrupt:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">IMS</span><span class="p">,</span> <span class="n">E1000_IMS_LSC</span> <span class="o">|</span> <span class="n">E1000_IMS_OTHER</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">e1000_intr_msix_tx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>


	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_clean_tx_irq</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">))</span>
		<span class="cm">/* Ring was not completely cleaned, so fire another interrupt */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">e1000_intr_msix_rx</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="cm">/* Write the ITR value calculated at the end of the</span>
<span class="cm">	 * previous interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">*</span> <span class="mi">256</span><span class="p">),</span>
		       <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_configure_msix - Configure MSI-X hardware</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_configure_msix sets up the hardware to properly</span>
<span class="cm"> * generate MSI-X interrupts.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_configure_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">,</span> <span class="n">ivar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eiac_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Workaround issue with spurious interrupts on 82574 in MSI-X mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_82574</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">rfctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RFCTL</span><span class="p">);</span>
		<span class="n">rfctl</span> <span class="o">|=</span> <span class="n">E1000_RFCTL_ACK_DIS</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RFCTL</span><span class="p">,</span> <span class="n">rfctl</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#define E1000_IVAR_INT_ALLOC_VALID	0x8</span>
	<span class="cm">/* Configure Rx vector */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span> <span class="o">=</span> <span class="n">E1000_IMS_RXQ0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eiac_mask</span> <span class="o">|=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">*</span> <span class="mi">256</span><span class="p">),</span>
		       <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
	<span class="n">ivar</span> <span class="o">=</span> <span class="n">E1000_IVAR_INT_ALLOC_VALID</span> <span class="o">|</span> <span class="n">vector</span><span class="p">;</span>

	<span class="cm">/* Configure Tx vector */</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span> <span class="o">=</span> <span class="n">E1000_IMS_TXQ0</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">*</span> <span class="mi">256</span><span class="p">),</span>
		       <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eiac_mask</span> <span class="o">|=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span><span class="p">;</span>
	<span class="n">ivar</span> <span class="o">|=</span> <span class="p">((</span><span class="n">E1000_IVAR_INT_ALLOC_VALID</span> <span class="o">|</span> <span class="n">vector</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* set vector for Other Causes, e.g. link changes */</span>
	<span class="n">vector</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ivar</span> <span class="o">|=</span> <span class="p">((</span><span class="n">E1000_IVAR_INT_ALLOC_VALID</span> <span class="o">|</span> <span class="n">vector</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span><span class="p">)</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">*</span> <span class="mi">256</span><span class="p">),</span>
		       <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_EITR_82574</span><span class="p">(</span><span class="n">vector</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_EITR_82574</span><span class="p">(</span><span class="n">vector</span><span class="p">));</span>

	<span class="cm">/* Cause Tx interrupts on every write back */</span>
	<span class="n">ivar</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">IVAR</span><span class="p">,</span> <span class="n">ivar</span><span class="p">);</span>

	<span class="cm">/* enable MSI-X PBA support */</span>
	<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
	<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_PBA_CLR</span><span class="p">;</span>

	<span class="cm">/* Auto-Mask Other interrupts upon ICR read */</span>
<span class="cp">#define E1000_EIAC_MASK_82574   0x01F00000</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IAM</span><span class="p">,</span> <span class="o">~</span><span class="n">E1000_EIAC_MASK_82574</span> <span class="o">|</span> <span class="n">E1000_IMS_OTHER</span><span class="p">);</span>
	<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_EIAME</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000e_reset_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MSI_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_MSI_ENABLED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_set_interrupt_capability - set MSI or MSI-X if supported</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to configure interrupts using the best available</span>
<span class="cm"> * capabilities of the hardware and kernel.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_set_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000E_INT_MODE_MSIX</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_MSIX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vectors</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* RxQ0, TxQ0 and other */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vectors</span><span class="p">,</span>
						      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msix_entry</span><span class="p">),</span>
						      <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

				<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span>
						      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span>
						      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vectors</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* MSI-X failed, so fall through and try MSI */</span>
			<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Failed to initialize MSI-X interrupts.  Falling back to MSI interrupts.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">e1000e_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mode</span> <span class="o">=</span> <span class="n">E1000E_INT_MODE_MSI</span><span class="p">;</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">E1000E_INT_MODE_MSI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_MSI_ENABLED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mode</span> <span class="o">=</span> <span class="n">E1000E_INT_MODE_LEGACY</span><span class="p">;</span>
			<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Failed to initialize MSI interrupts.  Falling back to legacy interrupts.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">E1000E_INT_MODE_LEGACY</span>:
		<span class="cm">/* Don&#39;t do anything; this is the system default */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* store the number of vectors being used */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vectors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_request_msix - Initialize MSI-X interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_request_msix allocates MSI-X vectors and requests interrupts from the</span>
<span class="cm"> * kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_request_msix</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">IFNAMSIZ</span> <span class="o">-</span> <span class="mi">5</span><span class="p">))</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			 <span class="s">&quot;%s-rx-0&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			  <span class="n">e1000_intr_msix_rx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			  <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span>
	    <span class="n">E1000_EITR_82574</span><span class="p">(</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">IFNAMSIZ</span> <span class="o">-</span> <span class="mi">5</span><span class="p">))</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			 <span class="s">&quot;%s-tx-0&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			  <span class="n">e1000_intr_msix_tx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			  <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_register</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span>
	    <span class="n">E1000_EITR_82574</span><span class="p">(</span><span class="n">vector</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">++</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span>
			  <span class="n">e1000_msix_other</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">e1000_configure_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_request_irq - initialize interrupts</span>
<span class="cm"> *</span>
<span class="cm"> * Attempts to configure interrupts using the best available</span>
<span class="cm"> * capabilities of the hardware and kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_request_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="cm">/* fall back to MSI */</span>
		<span class="n">e1000e_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mode</span> <span class="o">=</span> <span class="n">E1000E_INT_MODE_MSI</span><span class="p">;</span>
		<span class="n">e1000e_set_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MSI_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">e1000_intr_msi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="cm">/* fall back to legacy interrupt */</span>
		<span class="n">e1000e_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mode</span> <span class="o">=</span> <span class="n">E1000E_INT_MODE_LEGACY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">e1000_intr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
			  <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate interrupt, Error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_free_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="n">vector</span><span class="o">++</span><span class="p">;</span>

		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="n">vector</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Other Causes interrupt vector */</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_irq_disable - Mask off interrupt generation on the NIC</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EIAC_82574</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vector</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_irq_enable - Enable default interrupt generation settings</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EIAC_82574</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eiac_mask</span> <span class="o">&amp;</span> <span class="n">E1000_EIAC_MASK_82574</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">IMS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eiac_mask</span> <span class="o">|</span> <span class="n">E1000_IMS_OTHER</span> <span class="o">|</span> <span class="n">E1000_IMS_LSC</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">IMS</span><span class="p">,</span> <span class="n">IMS_ENABLE_MASK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_get_hw_control - get control of the h/w from f/w</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * e1000e_get_hw_control sets {CTRL_EXT|SWSM}:DRV_LOAD bit.</span>
<span class="cm"> * For ASF and Pass Through versions of f/w this means that</span>
<span class="cm"> * the driver is loaded. For AMT version (only with 82573)</span>
<span class="cm"> * of the f/w this means that the network i/f is open.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_get_hw_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swsm</span><span class="p">;</span>

	<span class="cm">/* Let firmware know the driver has taken over */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_SWSM_ON_LOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swsm</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">,</span> <span class="n">swsm</span> <span class="o">|</span> <span class="n">E1000_SWSM_DRV_LOAD</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_CTRLEXT_ON_LOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span> <span class="o">|</span> <span class="n">E1000_CTRL_EXT_DRV_LOAD</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_release_hw_control - release control of the h/w to f/w</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * e1000e_release_hw_control resets {CTRL_EXT|SWSM}:DRV_LOAD bit.</span>
<span class="cm"> * For ASF and Pass Through versions of f/w this means that the</span>
<span class="cm"> * driver is no longer loaded. For AMT version (only with 82573) i</span>
<span class="cm"> * of the f/w this means that the network i/f is closed.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_release_hw_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">swsm</span><span class="p">;</span>

	<span class="cm">/* Let firmware taken over control of h/w */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_SWSM_ON_LOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swsm</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">SWSM</span><span class="p">,</span> <span class="n">swsm</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_SWSM_DRV_LOAD</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_CTRLEXT_ON_LOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_CTRL_EXT_DRV_LOAD</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * @e1000_alloc_ring - allocate memory for a ring structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_alloc_ring_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_setup_tx_resources - allocate Tx resources (Descriptors)</span>
<span class="cm"> * @tx_ring: Tx descriptor ring</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">e1000e_setup_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* round up to nearest 4K */</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_tx_desc</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_alloc_ring_dma</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate memory for the transmit descriptor ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_setup_rx_resources - allocate Rx resources (Descriptors)</span>
<span class="cm"> * @rx_ring: Rx descriptor ring</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">e1000e_setup_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">desc_len</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">ps_pages</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">PS_PAGE_BUFFERS</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ps_page</span><span class="p">),</span>
						<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">ps_pages</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_pages</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">desc_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_rx_desc_packet_split</span><span class="p">);</span>

	<span class="cm">/* Round up to nearest 4K */</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="n">desc_len</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_alloc_ring_dma</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pages</span><span class="p">;</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_pages:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">ps_pages</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">err:</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate memory for the receive descriptor ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_tx_ring - Free Tx Buffers</span>
<span class="cm"> * @tx_ring: Tx descriptor ring</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clean_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">e1000_put_txbuf</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">netdev_reset_queue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_PCIM2PCI_ARBITER_WA</span><span class="p">)</span>
		<span class="n">e1000e_update_tdt_wa</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_free_tx_resources - Free Tx Resources per Queue</span>
<span class="cm"> * @tx_ring: Tx descriptor ring</span>
<span class="cm"> *</span>
<span class="cm"> * Free all transmit software resources</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_free_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">e1000_clean_tx_ring</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span>
			  <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_free_rx_resources - Free Rx Resources</span>
<span class="cm"> * @rx_ring: Rx descriptor ring</span>
<span class="cm"> *</span>
<span class="cm"> * Free all receive software resources</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_free_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">e1000_clean_rx_ring</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ps_pages</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span>
			  <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_update_itr - update the dynamic ITR value based on statistics</span>
<span class="cm"> * @adapter: pointer to adapter</span>
<span class="cm"> * @itr_setting: current adapter-&gt;itr</span>
<span class="cm"> * @packets: the number of packets during this measurement interval</span>
<span class="cm"> * @bytes: the number of bytes during this measurement interval</span>
<span class="cm"> *</span>
<span class="cm"> *      Stores a new ITR value based on packets and byte</span>
<span class="cm"> *      counts during the last interrupt.  The advantage of per interrupt</span>
<span class="cm"> *      computation is faster updates and more accurate ITR for the current</span>
<span class="cm"> *      traffic pattern.  Constants in this function were computed</span>
<span class="cm"> *      based on theoretical maximum wire speed and thresholds were set based</span>
<span class="cm"> *      on testing data as well as attempting to minimize response time</span>
<span class="cm"> *      while increasing bulk throughput.  This functionality is controlled</span>
<span class="cm"> *      by the InterruptThrottleRate module parameter.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">e1000_update_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">itr_setting</span><span class="p">,</span> <span class="kt">int</span> <span class="n">packets</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">itr_setting</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">itr_setting</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">itr_setting</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">lowest_latency</span>:
		<span class="cm">/* handle TSO and jumbo frames */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">8000</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">low_latency</span>:  <span class="cm">/* 50 usec aka 20000 ints/s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this if handles the TSO accounting */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">8000</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1200</span><span class="p">))</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">))</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">lowest_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">lowest_latency</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">bulk_latency</span>: <span class="cm">/* 250 usec aka 4000 ints/s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">25000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">6000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_set_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">current_itr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_itr</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span><span class="p">;</span>

	<span class="cm">/* for non-gigabit speeds, just fix the interrupt rate at 4000 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">!=</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">set_itr_now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_AIM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">set_itr_now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span> <span class="o">=</span> <span class="n">e1000_update_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span><span class="p">);</span>
	<span class="cm">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span> <span class="o">==</span> <span class="n">lowest_latency</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span> <span class="o">=</span> <span class="n">e1000_update_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span><span class="p">);</span>
	<span class="cm">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span> <span class="o">==</span> <span class="n">lowest_latency</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>

	<span class="n">current_itr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">current_itr</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* counts and packets in update_itr are dependent on these numbers */</span>
	<span class="k">case</span> <span class="n">lowest_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">70000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">low_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span> <span class="cm">/* aka hwitr = ~200 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">bulk_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">set_itr_now:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * this attempts to bias the interrupt rate towards Bulk</span>
<span class="cm">		 * by adding intermediate steps when interrupt rate is</span>
<span class="cm">		 * increasing</span>
<span class="cm">		 */</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">new_itr</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">?</span>
			     <span class="n">min</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">new_itr</span><span class="p">)</span> <span class="o">:</span>
			     <span class="n">new_itr</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">=</span> <span class="n">new_itr</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">itr_val</span> <span class="o">=</span> <span class="n">new_itr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">set_itr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_itr</span><span class="p">)</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">*</span> <span class="mi">256</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_alloc_queues - Allocate memory for all rings</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">e1000_alloc_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring_count</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring_count</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate memory for queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_poll - NAPI Rx polling callback</span>
<span class="cm"> * @napi: struct associated with this polling callback</span>
<span class="cm"> * @weight: number of packets driver is allowed to process this poll</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000e_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span>
						     <span class="n">napi</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">poll_dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_cleaned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">poll_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span> <span class="o">&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span><span class="p">))</span>
		<span class="n">tx_cleaned</span> <span class="o">=</span> <span class="n">e1000_clean_tx_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_done</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_cleaned</span><span class="p">)</span>
		<span class="n">work_done</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>

	<span class="cm">/* If weight not fully consumed, exit the polling mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
			<span class="n">e1000_set_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">IMS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* don&#39;t update vlan cookie if already programmed */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
	     <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vid</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* add VID to filter table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">vid</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
		<span class="n">vfta</span> <span class="o">=</span> <span class="n">E1000_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_VFTA</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">vfta</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vid</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">));</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vfta</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
	     <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vid</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* release control to f/w */</span>
		<span class="n">e1000e_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remove VID from filter table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">vid</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
		<span class="n">vfta</span> <span class="o">=</span> <span class="n">E1000_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_VFTA</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">vfta</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vid</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">));</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vfta</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_vlan_filter_disable - helper to disable hw VLAN filtering</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_vlan_filter_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* disable VLAN receive filtering */</span>
		<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_RCTL_VFE</span> <span class="o">|</span> <span class="n">E1000_RCTL_CFIEN</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">E1000_MNG_VLAN_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e1000_vlan_rx_kill_vid</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">E1000_MNG_VLAN_NONE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_vlan_filter_enable - helper to enable HW VLAN filtering</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_vlan_filter_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable VLAN receive filtering */</span>
		<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_VFE</span><span class="p">;</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_CFIEN</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_vlan_strip_enable - helper to disable HW VLAN stripping</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_vlan_strip_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="cm">/* disable VLAN tag insert/strip */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_VME</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_vlan_strip_enable - helper to enable HW VLAN stripping</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_vlan_strip_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="cm">/* enable VLAN tag insert/strip */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_VME</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_update_mng_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vid</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">vlan_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">old_vid</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
	    <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e1000_vlan_rx_add_vid</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">vid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">old_vid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">E1000_MNG_VLAN_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vid</span> <span class="o">!=</span> <span class="n">old_vid</span><span class="p">))</span>
		<span class="n">e1000_vlan_rx_kill_vid</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">old_vid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_restore_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>

	<span class="n">e1000_vlan_rx_add_vid</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">,</span> <span class="n">VLAN_N_VID</span><span class="p">)</span>
		<span class="n">e1000_vlan_rx_add_vid</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_init_manageability_pt</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">manc</span><span class="p">,</span> <span class="n">manc2h</span><span class="p">,</span> <span class="n">mdef</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MNG_PT_ENABLED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">manc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MANC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * enable receiving management packets to the host. this will probably</span>
<span class="cm">	 * generate destination unreachable messages from the host OS, but</span>
<span class="cm">	 * the packets will be handled on SMBUS</span>
<span class="cm">	 */</span>
	<span class="n">manc</span> <span class="o">|=</span> <span class="n">E1000_MANC_EN_MNG2HOST</span><span class="p">;</span>
	<span class="n">manc2h</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MANC2H</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">manc2h</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_MANC2H_PORT_623</span> <span class="o">|</span> <span class="n">E1000_MANC2H_PORT_664</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82574</span>:
	<span class="k">case</span> <span class="n">e1000_82583</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Check if IPMI pass-through decision filter already exists;</span>
<span class="cm">		 * if so, enable it.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mdef</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MDEF</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

			<span class="cm">/* Ignore filters with anything other than IPMI ports */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mdef</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_MDEF_PORT_623</span> <span class="o">|</span> <span class="n">E1000_MDEF_PORT_664</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Enable this decision filter in MANC2H */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mdef</span><span class="p">)</span>
				<span class="n">manc2h</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>

			<span class="n">j</span> <span class="o">|=</span> <span class="n">mdef</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="p">(</span><span class="n">E1000_MDEF_PORT_623</span> <span class="o">|</span> <span class="n">E1000_MDEF_PORT_664</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Create new decision filter in an empty filter */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">MDEF</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">MDEF</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">E1000_MDEF_PORT_623</span> <span class="o">|</span>
					       <span class="n">E1000_MDEF_PORT_664</span><span class="p">));</span>
				<span class="n">manc2h</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">j</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="p">)</span>
			<span class="n">e_warn</span><span class="p">(</span><span class="s">&quot;Unable to create IPMI pass-through filter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">MANC2H</span><span class="p">,</span> <span class="n">manc2h</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">MANC</span><span class="p">,</span> <span class="n">manc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_configure_tx - Configure Transmit Unit after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Tx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_configure_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tdba</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tdlen</span><span class="p">,</span> <span class="n">tarc</span><span class="p">;</span>

	<span class="cm">/* Setup the HW Tx Head and Tail descriptor pointers */</span>
	<span class="n">tdba</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="n">tdlen</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_tx_desc</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">tdba</span> <span class="o">&amp;</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">tdba</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tdlen</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TDT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_TDH</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_TDT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Set the Tx Interrupt Delay register */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TIDV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span><span class="p">);</span>
	<span class="cm">/* Tx irq moderation */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TADV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_abs_int_delay</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DMA_BURST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">txdctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="n">txdctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_TXDCTL_PTHRESH</span> <span class="o">|</span> <span class="n">E1000_TXDCTL_HTHRESH</span> <span class="o">|</span>
			    <span class="n">E1000_TXDCTL_WTHRESH</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * set up some performance related parameters to encourage the</span>
<span class="cm">		 * hardware to use the bus more efficiently in bursts, depends</span>
<span class="cm">		 * on the tx_int_delay to be enabled,</span>
<span class="cm">		 * wthresh = 5 ==&gt; burst write a cacheline (64 bytes) at a time</span>
<span class="cm">		 * hthresh = 1 ==&gt; prefetch when one or more available</span>
<span class="cm">		 * pthresh = 0x1f ==&gt; prefetch if internal cache 31 or less</span>
<span class="cm">		 * BEWARE: this seems to work but should be considered first if</span>
<span class="cm">		 * there are Tx hangs or other Tx related bugs</span>
<span class="cm">		 */</span>
		<span class="n">txdctl</span> <span class="o">|=</span> <span class="n">E1000_TXDCTL_DMA_BURST_ENABLE</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">txdctl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* erratum work around: set txdctl the same for both queues */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_TARC_SPEED_MODE_BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tarc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * set the speed mode bit, we&#39;ll clear it if we&#39;re not at</span>
<span class="cm">		 * gigabit link later</span>
<span class="cm">		 */</span>
<span class="cp">#define SPEED_MODE_BIT (1 &lt;&lt; 21)</span>
		<span class="n">tarc</span> <span class="o">|=</span> <span class="n">SPEED_MODE_BIT</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tarc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* errata: program both queues to unweighted RR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_TARC_SET_BIT_ZERO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tarc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="n">tarc</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tarc</span><span class="p">);</span>
		<span class="n">tarc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
		<span class="n">tarc</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">tarc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup Transmit Descriptor Settings for eop descriptor */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_EOP</span> <span class="o">|</span> <span class="n">E1000_TXD_CMD_IFCS</span><span class="p">;</span>

	<span class="cm">/* only set IDE if we are delaying interrupts using the timers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_IDE</span><span class="p">;</span>

	<span class="cm">/* enable Report Status bit */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_RS</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_rctl - configure the receive control registers</span>
<span class="cm"> * @adapter: Board private structure</span>
<span class="cm"> **/</span>
<span class="cp">#define PAGE_USE_COUNT(S) (((S) &gt;&gt; PAGE_SHIFT) + \</span>
<span class="cp">			   (((S) &amp; (PAGE_SIZE - 1)) ? 1 : 0))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_setup_rctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">rfctl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Workaround Si errata on PCHx - configure jumbo frame flow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_pch2lan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_lv_jumbo_workaround_ich8lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_lv_jumbo_workaround_ich8lan</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;failed to enable jumbo frame workaround mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Program MC offset vector base */</span>
	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_RCTL_MO_SHIFT</span><span class="p">);</span>
	<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_EN</span> <span class="o">|</span> <span class="n">E1000_RCTL_BAM</span> <span class="o">|</span>
		<span class="n">E1000_RCTL_LBM_NO</span> <span class="o">|</span> <span class="n">E1000_RCTL_RDMTS_HALF</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">mc_filter_type</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_RCTL_MO_SHIFT</span><span class="p">);</span>

	<span class="cm">/* Do not Store bad packets */</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_SBP</span><span class="p">;</span>

	<span class="cm">/* Enable Long Packet receive */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&lt;=</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_LPE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_LPE</span><span class="p">;</span>

	<span class="cm">/* Some systems expect that the CRC is included in SMBUS traffic. The</span>
<span class="cm">	 * hardware strips the CRC before sending to both SMBUS (BMC) and to</span>
<span class="cm">	 * host memory when this is enabled</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_CRC_STRIPPING</span><span class="p">)</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SECRC</span><span class="p">;</span>

	<span class="cm">/* Workaround Si errata on 82577 PHY - configure IPG for jumbos */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_82577</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rctl</span> <span class="o">&amp;</span> <span class="n">E1000_RCTL_LPE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

		<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_REG</span><span class="p">(</span><span class="mi">770</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="mh">0xfff8</span><span class="p">;</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_REG</span><span class="p">(</span><span class="mi">770</span><span class="p">,</span> <span class="mi">26</span><span class="p">),</span> <span class="n">phy_data</span><span class="p">);</span>

		<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="mh">0x0fff</span><span class="p">;</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">);</span>
		<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x2823</span><span class="p">);</span>
		<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">);</span>
		<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup buffer sizes */</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_SZ_4096</span><span class="p">;</span>
	<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_BSEX</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2048</span>:
	<span class="nl">default:</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SZ_2048</span><span class="p">;</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_BSEX</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4096</span>:
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SZ_4096</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">8192</span>:
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SZ_8192</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">16384</span>:
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SZ_16384</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable Extended Status in all Receive Descriptors */</span>
	<span class="n">rfctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RFCTL</span><span class="p">);</span>
	<span class="n">rfctl</span> <span class="o">|=</span> <span class="n">E1000_RFCTL_EXTEN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RFCTL</span><span class="p">,</span> <span class="n">rfctl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * 82571 and greater support packet-split where the protocol</span>
<span class="cm">	 * header is placed in skb-&gt;data and the packet data is</span>
<span class="cm">	 * placed in pages hanging off of skb_shinfo(skb)-&gt;nr_frags.</span>
<span class="cm">	 * In the case of a non-split, skb-&gt;data is linearly filled,</span>
<span class="cm">	 * followed by the page buffers.  Therefore, skb-&gt;data is</span>
<span class="cm">	 * sized to hold the largest protocol header.</span>
<span class="cm">	 *</span>
<span class="cm">	 * allocations using alloc_page take too long for regular MTU</span>
<span class="cm">	 * so only enable packet split for jumbo frames</span>
<span class="cm">	 *</span>
<span class="cm">	 * Using pages when the page size is greater than 16k wastes</span>
<span class="cm">	 * a lot of memory, since we allocate 3 pages at all times</span>
<span class="cm">	 * per packet.</span>
<span class="cm">	 */</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">PAGE_USE_COUNT</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pages</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;=</span> <span class="mi">16384</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rctl</span> <span class="o">&amp;</span> <span class="n">E1000_RCTL_LPE</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">psrctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Enable Packet split descriptors */</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_DTYP_PS</span><span class="p">;</span>

		<span class="n">psrctl</span> <span class="o">|=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_bsize0</span> <span class="o">&gt;&gt;</span>
			<span class="n">E1000_PSRCTL_BSIZE0_SHIFT</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">psrctl</span> <span class="o">|=</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span>
				<span class="n">E1000_PSRCTL_BSIZE3_SHIFT</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">psrctl</span> <span class="o">|=</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span>
				<span class="n">E1000_PSRCTL_BSIZE2_SHIFT</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">psrctl</span> <span class="o">|=</span> <span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span>
				<span class="n">E1000_PSRCTL_BSIZE1_SHIFT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">PSRCTL</span><span class="p">,</span> <span class="n">psrctl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* This is useful for sniffing bad packets. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* UPE and MPE will be handled by normal PROMISC logic</span>
<span class="cm">		 * in e1000e_set_rx_mode */</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_RCTL_SBP</span> <span class="o">|</span> <span class="cm">/* Receive bad packets */</span>
			 <span class="n">E1000_RCTL_BAM</span> <span class="o">|</span> <span class="cm">/* RX All Bcast Pkts */</span>
			 <span class="n">E1000_RCTL_PMCF</span><span class="p">);</span> <span class="cm">/* RX All MAC Ctrl Pkts */</span>

		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_RCTL_VFE</span> <span class="o">|</span> <span class="cm">/* Disable VLAN filter */</span>
			  <span class="n">E1000_RCTL_DPF</span> <span class="o">|</span> <span class="cm">/* Allow filtered pause */</span>
			  <span class="n">E1000_RCTL_CFIEN</span><span class="p">);</span> <span class="cm">/* Dis VLAN CFIEN Filter */</span>
		<span class="cm">/* Do not mess with E1000_CTRL_VME, it affects transmit as well,</span>
<span class="cm">		 * and that breaks VLANs.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
	<span class="cm">/* just started the receive unit, no need to restart */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_RX_RESTART_NOW</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_configure_rx - Configure Receive Unit after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Rx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_configure_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rdba</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rdlen</span><span class="p">,</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">rxcsum</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this is a 32 byte descriptor */</span>
		<span class="n">rdlen</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_rx_desc_packet_split</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">=</span> <span class="n">e1000_clean_rx_irq_ps</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span> <span class="o">=</span> <span class="n">e1000_alloc_rx_buffers_ps</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdlen</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_rx_desc_extended</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">=</span> <span class="n">e1000_clean_jumbo_rx_irq</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span> <span class="o">=</span> <span class="n">e1000_alloc_jumbo_rx_buffers</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rdlen</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">e1000_rx_desc_extended</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">=</span> <span class="n">e1000_clean_rx_irq</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span> <span class="o">=</span> <span class="n">e1000_alloc_rx_buffers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* disable receives while setting up the descriptors */</span>
	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_NO_DISABLE_RX</span><span class="p">))</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RCTL_EN</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DMA_BURST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * set the writeback threshold (only takes effect if the RDTR</span>
<span class="cm">		 * is set). set GRAN=1 and write back up to 0x4 worth, and</span>
<span class="cm">		 * enable prefetching of 0x20 Rx descriptors</span>
<span class="cm">		 * granularity = 01</span>
<span class="cm">		 * wthresh = 04,</span>
<span class="cm">		 * hthresh = 04,</span>
<span class="cm">		 * pthresh = 0x20</span>
<span class="cm">		 */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">E1000_RXDCTL_DMA_BURST_ENABLE</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">E1000_RXDCTL_DMA_BURST_ENABLE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * override the delay timers for enabling bursting, only if</span>
<span class="cm">		 * the value was not set by the user via module options</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_int_delay</span> <span class="o">==</span> <span class="n">DEFAULT_RDTR</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_int_delay</span> <span class="o">=</span> <span class="n">BURST_RDTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_abs_int_delay</span> <span class="o">==</span> <span class="n">DEFAULT_RADV</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_abs_int_delay</span> <span class="o">=</span> <span class="n">BURST_RADV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set the Receive Delay Timer Register */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDTR</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_int_delay</span><span class="p">);</span>

	<span class="cm">/* irq moderation */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RADV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_abs_int_delay</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">*</span> <span class="mi">256</span><span class="p">));</span>

	<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
	<span class="cm">/* Auto-Mask interrupts upon ICR access */</span>
	<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_IAME</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IAM</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<span class="cm">	 * the Base and Length of the Rx Descriptor Ring</span>
<span class="cm">	 */</span>
	<span class="n">rdba</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDBAL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">rdba</span> <span class="o">&amp;</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDBAH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">rdba</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDLEN</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rdlen</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDH</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDT</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_RDH</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">E1000_RDT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Enable Receive Checksum Offload for TCP and UDP */</span>
	<span class="n">rxcsum</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCSUM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">)</span>
		<span class="n">rxcsum</span> <span class="o">|=</span> <span class="n">E1000_RXCSUM_TUOFL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rxcsum</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RXCSUM_TUOFL</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RXCSUM</span><span class="p">,</span> <span class="n">rxcsum</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_pch2lan</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * With jumbo frames, excessive C-state transition</span>
<span class="cm">		 * latencies result in dropped transactions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">rxdctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">RXDCTL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rxdctl</span> <span class="o">|</span> <span class="mh">0x3</span><span class="p">);</span>
			<span class="n">pm_qos_update_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">pm_qos_req</span><span class="p">,</span> <span class="mi">55</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pm_qos_update_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">pm_qos_req</span><span class="p">,</span>
					      <span class="n">PM_QOS_DEFAULT_VALUE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Enable Receives */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_write_mc_addr_list - write multicast addresses to MTA</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Writes multicast address list to the MTA hash table.</span>
<span class="cm"> * Returns: -ENOMEM on failure</span>
<span class="cm"> *                0 on no addresses written</span>
<span class="cm"> *                X on writing X addresses to MTA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000e_write_mc_addr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mta_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_mc_empty</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* nothing to program, so clear mc list */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">update_mc_addr_list</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mta_list</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mta_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* update_mc_addr_list expects a packed array of only addresses. */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">mta_list</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">*</span> <span class="n">ETH_ALEN</span><span class="p">),</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">ETH_ALEN</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">update_mc_addr_list</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mta_list</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mta_list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">netdev_mc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_write_uc_addr_list - write unicast addresses to RAR table</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Writes unicast address list to the RAR table.</span>
<span class="cm"> * Returns: -ENOMEM on failure/insufficient address space</span>
<span class="cm"> *                0 on no addresses written</span>
<span class="cm"> *                X on writing X addresses to the RAR table</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000e_write_uc_addr_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rar_entries</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">rar_entry_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* save a rar entry for our hardware address */</span>
	<span class="n">rar_entries</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* save a rar entry for the LAA workaround */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RESET_OVERWRITES_LAA</span><span class="p">)</span>
		<span class="n">rar_entries</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* return ENOMEM indicating insufficient memory for addresses */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_uc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rar_entries</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_uc_empty</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rar_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * write the addresses in reverse order to avoid write</span>
<span class="cm">		 * combining</span>
<span class="cm">		 */</span>
		<span class="n">netdev_for_each_uc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rar_entries</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">rar_entries</span><span class="o">--</span><span class="p">);</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* zero out the remaining RAR entries not used above */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">rar_entries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rar_entries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RAH</span><span class="p">(</span><span class="n">rar_entries</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RAL</span><span class="p">(</span><span class="n">rar_entries</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_set_rx_mode - secondary unicast, Multicast and Promiscuous mode set</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * The ndo_set_rx_mode entry point is called whenever the unicast or multicast</span>
<span class="cm"> * address list or the network interface flags are updated.  This routine is</span>
<span class="cm"> * responsible for configuring the hardware for proper unicast, multicast,</span>
<span class="cm"> * promiscuous mode, and all-multi behavior.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="cm">/* Check for Promiscuous and All Multicast modes */</span>
	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>

	<span class="cm">/* clear the affected bits */</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_RCTL_UPE</span> <span class="o">|</span> <span class="n">E1000_RCTL_MPE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_RCTL_UPE</span> <span class="o">|</span> <span class="n">E1000_RCTL_MPE</span><span class="p">);</span>
		<span class="cm">/* Do not hardware filter VLANs in promisc mode */</span>
		<span class="n">e1000e_vlan_filter_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_MPE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Write addresses to the MTA, if the attempt fails</span>
<span class="cm">			 * then we should just turn on promiscuous mode so</span>
<span class="cm">			 * that we can at least receive multicast traffic</span>
<span class="cm">			 */</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">e1000e_write_mc_addr_list</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_MPE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">e1000e_vlan_filter_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Write addresses to available RAR registers, if there is not</span>
<span class="cm">		 * sufficient space to store all the addresses then enable</span>
<span class="cm">		 * unicast promiscuous mode</span>
<span class="cm">		 */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">e1000e_write_uc_addr_list</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_UPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">e1000e_vlan_strip_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">e1000e_vlan_strip_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_setup_rss_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mrqc</span><span class="p">,</span> <span class="n">rxcsum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">rsskey</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0xda565a6d</span><span class="p">,</span> <span class="mh">0xc20e5b25</span><span class="p">,</span> <span class="mh">0x3d256741</span><span class="p">,</span> <span class="mh">0xb08fa343</span><span class="p">,</span> <span class="mh">0xcb2bcad0</span><span class="p">,</span>
		<span class="mh">0xb4307bae</span><span class="p">,</span> <span class="mh">0xa32dcb77</span><span class="p">,</span> <span class="mh">0x0cf23080</span><span class="p">,</span> <span class="mh">0x3bb7426a</span><span class="p">,</span> <span class="mh">0xfa01acbe</span>
	<span class="p">};</span>

	<span class="cm">/* Fill out hash function seed */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RSSRK</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">rsskey</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* Direct all traffic to queue 0 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RETA</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable raw packet checksumming so that RSS hash is placed in</span>
<span class="cm">	 * descriptor on writeback.</span>
<span class="cm">	 */</span>
	<span class="n">rxcsum</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCSUM</span><span class="p">);</span>
	<span class="n">rxcsum</span> <span class="o">|=</span> <span class="n">E1000_RXCSUM_PCSD</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">RXCSUM</span><span class="p">,</span> <span class="n">rxcsum</span><span class="p">);</span>

	<span class="n">mrqc</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1000_MRQC_RSS_FIELD_IPV4</span> <span class="o">|</span>
		<span class="n">E1000_MRQC_RSS_FIELD_IPV4_TCP</span> <span class="o">|</span>
		<span class="n">E1000_MRQC_RSS_FIELD_IPV6</span> <span class="o">|</span>
		<span class="n">E1000_MRQC_RSS_FIELD_IPV6_TCP</span> <span class="o">|</span>
		<span class="n">E1000_MRQC_RSS_FIELD_IPV6_TCP_EX</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">MRQC</span><span class="p">,</span> <span class="n">mrqc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_configure - configure the hardware for Rx and Tx</span>
<span class="cm"> * @adapter: private board structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>

	<span class="n">e1000e_set_rx_mode</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e1000_restore_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_init_manageability_pt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">e1000_configure_tx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXHASH</span><span class="p">)</span>
		<span class="n">e1000e_setup_rss_hash</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_setup_rctl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_configure_rx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">e1000_desc_unused</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_power_up_phy - restore link in case the phy was powered down</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * The phy may be powered down to save power and turn off link when the</span>
<span class="cm"> * driver is unloaded and wake on lan is not enabled (among others)</span>
<span class="cm"> * *** this routine MUST be followed by a call to e1000e_reset ***</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">e1000e_power_up_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">power_up</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">power_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">setup_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_power_down_phy - Power down the PHY</span>
<span class="cm"> *</span>
<span class="cm"> * Power down the PHY so no link is implied when interface is down.</span>
<span class="cm"> * The PHY cannot be powered down if management or WoL is active.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_power_down_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* WoL is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">power_down</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">power_down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_reset - bring the hardware into a known good state</span>
<span class="cm"> *</span>
<span class="cm"> * This function boots the hardware and enables some settings that</span>
<span class="cm"> * require a configuration cycle of the hardware - those cannot be</span>
<span class="cm"> * set/changed during runtime. After reset the device needs to be</span>
<span class="cm"> * properly configured for Rx, Tx etc.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000e_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_fc_info</span> <span class="o">*</span><span class="n">fc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tx_space</span><span class="p">,</span> <span class="n">min_tx_space</span><span class="p">,</span> <span class="n">min_rx_space</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pba</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pba</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hwm</span><span class="p">;</span>

	<span class="cm">/* reset Packet Buffer Allocation to default */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">PBA</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">&gt;</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * To maintain wire speed transmits, the Tx FIFO should be</span>
<span class="cm">		 * large enough to accommodate two full transmit packets,</span>
<span class="cm">		 * rounded up to the next 1KB and expressed in KB.  Likewise,</span>
<span class="cm">		 * the Rx FIFO should be large enough to accommodate at least</span>
<span class="cm">		 * one full receive packet and is similarly rounded up and</span>
<span class="cm">		 * expressed in KB.</span>
<span class="cm">		 */</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PBA</span><span class="p">);</span>
		<span class="cm">/* upper 16 bits has Tx packet buffer allocation size in KB */</span>
		<span class="n">tx_space</span> <span class="o">=</span> <span class="n">pba</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="cm">/* lower 16 bits has Rx packet buffer allocation size in KB */</span>
		<span class="n">pba</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * the Tx fifo also stores 16 bytes of information about the Tx</span>
<span class="cm">		 * but don&#39;t include ethernet FCS because hardware appends it</span>
<span class="cm">		 */</span>
		<span class="n">min_tx_space</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_tx_desc</span><span class="p">)</span> <span class="o">-</span>
				<span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">min_tx_space</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">min_tx_space</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="n">min_tx_space</span> <span class="o">&gt;&gt;=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* software strips receive CRC, so leave room for it */</span>
		<span class="n">min_rx_space</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">;</span>
		<span class="n">min_rx_space</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">min_rx_space</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="n">min_rx_space</span> <span class="o">&gt;&gt;=</span> <span class="mi">10</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If current Tx allocation is less than the min Tx FIFO size,</span>
<span class="cm">		 * and the min Tx FIFO size is less than the current Rx FIFO</span>
<span class="cm">		 * allocation, take space away from current Rx allocation</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tx_space</span> <span class="o">&lt;</span> <span class="n">min_tx_space</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">min_tx_space</span> <span class="o">-</span> <span class="n">tx_space</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pba</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pba</span> <span class="o">-=</span> <span class="n">min_tx_space</span> <span class="o">-</span> <span class="n">tx_space</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * if short on Rx space, Rx wins and must trump Tx</span>
<span class="cm">			 * adjustment or use Early Receive if available</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pba</span> <span class="o">&lt;</span> <span class="n">min_rx_space</span><span class="p">)</span>
				<span class="n">pba</span> <span class="o">=</span> <span class="n">min_rx_space</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">PBA</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * flow control settings</span>
<span class="cm">	 *</span>
<span class="cm">	 * The high water mark must be low enough to fit one full frame</span>
<span class="cm">	 * (or the size used for early receive) above it in the Rx FIFO.</span>
<span class="cm">	 * Set it to the lower of:</span>
<span class="cm">	 * - 90% of the Rx FIFO size, and</span>
<span class="cm">	 * - the full Rx FIFO size minus one full frame</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_DISABLE_FC_PAUSE_TIME</span><span class="p">)</span>
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">pause_time</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">pause_time</span> <span class="o">=</span> <span class="n">E1000_FC_PAUSE_TIME</span><span class="p">;</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">send_xon</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">fc</span><span class="o">-&gt;</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">requested_mode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_ich9lan</span>:
	<span class="k">case</span> <span class="n">e1000_ich10lan</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pba</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">PBA</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
			<span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">=</span> <span class="mh">0x2800</span><span class="p">;</span>
			<span class="n">fc</span><span class="o">-&gt;</span><span class="n">low_water</span> <span class="o">=</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fall-through */</span>
	<span class="nl">default:</span>
		<span class="n">hwm</span> <span class="o">=</span> <span class="n">min</span><span class="p">(((</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">10</span><span class="p">),</span>
			  <span class="p">((</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">));</span>

		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">=</span> <span class="n">hwm</span> <span class="o">&amp;</span> <span class="n">E1000_FCRTH_RTH</span><span class="p">;</span> <span class="cm">/* 8-byte granularity */</span>
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">low_water</span> <span class="o">=</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_pchlan</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Workaround PCH LOM adapter hangs with certain network</span>
<span class="cm">		 * loads.  If hangs persist, try disabling Tx flow control.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">=</span> <span class="mh">0x3500</span><span class="p">;</span>
			<span class="n">fc</span><span class="o">-&gt;</span><span class="n">low_water</span>  <span class="o">=</span> <span class="mh">0x1500</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">=</span> <span class="mh">0x5000</span><span class="p">;</span>
			<span class="n">fc</span><span class="o">-&gt;</span><span class="n">low_water</span>  <span class="o">=</span> <span class="mh">0x3000</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">refresh_time</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_pch2lan</span>:
	<span class="k">case</span> <span class="n">e1000_pch_lpt</span>:
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">high_water</span> <span class="o">=</span> <span class="mh">0x05C20</span><span class="p">;</span>
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">low_water</span> <span class="o">=</span> <span class="mh">0x05048</span><span class="p">;</span>
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">pause_time</span> <span class="o">=</span> <span class="mh">0x0650</span><span class="p">;</span>
		<span class="n">fc</span><span class="o">-&gt;</span><span class="n">refresh_time</span> <span class="o">=</span> <span class="mh">0x0400</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pba</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">PBA</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Disable Adaptive Interrupt Moderation if 2 full packets cannot</span>
<span class="cm">	 * fit in receive buffer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_AIM</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="s">&quot;Interrupt Throttle Rate turned off</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">|=</span> <span class="n">FLAG2_DISABLE_AIM</span><span class="p">;</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_AIM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				 <span class="s">&quot;Interrupt Throttle Rate turned on</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG2_DISABLE_AIM</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">*</span> <span class="mi">256</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Allow time for pending master requests to run */</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">reset_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * For parts with AMT enabled, let the firmware know</span>
<span class="cm">	 * that the network interface is in control</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_AMT</span><span class="p">)</span>
		<span class="n">e1000e_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">WUC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">init_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Hardware Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">e1000_update_mng_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Enable h/w to recognize an 802.1Q VLAN Ethernet packet */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">VET</span><span class="p">,</span> <span class="n">ETH_P_8021Q</span><span class="p">);</span>

	<span class="n">e1000e_reset_adaptive</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_TESTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e1000_power_down_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e1000_get_phy_info</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_SMART_POWER_DOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_SMART_POWER_DOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">phy_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * speed up time to link by disabling smart power down, ignore</span>
<span class="cm">		 * the return value of this function because there is nothing</span>
<span class="cm">		 * different we would do if it failed</span>
<span class="cm">		 */</span>
		<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP02E1000_PHY_POWER_MGMT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP02E1000_PM_SPD</span><span class="p">;</span>
		<span class="n">e1e_wphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP02E1000_PHY_POWER_MGMT</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">e1000e_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* hardware has been reset, we need to reload some things */</span>
	<span class="n">e1000_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">e1000_configure_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* fire a link change interrupt to start the watchdog */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_LSC</span> <span class="o">|</span> <span class="n">E1000_ICR_OTHER</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_LSC</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_flush_descriptors</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DMA_BURST</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* flush pending descriptor writebacks to memory */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TIDV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span> <span class="o">|</span> <span class="n">E1000_TIDV_FPD</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDTR</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_int_delay</span> <span class="o">|</span> <span class="n">E1000_RDTR_FPD</span><span class="p">);</span>

	<span class="cm">/* execute the writes immediately */</span>
	<span class="n">e1e_flush</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * due to rare timing issues, write to TIDV/RDTR again to ensure the</span>
<span class="cm">	 * write is successful</span>
<span class="cm">	 */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TIDV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span> <span class="o">|</span> <span class="n">E1000_TIDV_FPD</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDTR</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_int_delay</span> <span class="o">|</span> <span class="n">E1000_RDTR_FPD</span><span class="p">);</span>

	<span class="cm">/* execute the writes immediately */</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000e_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">e1000e_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tctl</span><span class="p">,</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * signal that we&#39;re down so the interrupt handler does not</span>
<span class="cm">	 * reschedule our watchdog timer</span>
<span class="cm">	 */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/* disable receives in the hardware */</span>
	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_NO_DISABLE_RX</span><span class="p">))</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RCTL_EN</span><span class="p">);</span>
	<span class="cm">/* flush and sleep below */</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* disable transmits in the hardware */</span>
	<span class="n">tctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
	<span class="n">tctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TCTL_EN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>

	<span class="cm">/* flush both disables and wait for them to finish */</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>

	<span class="n">e1000_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">);</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>
	<span class="n">e1000e_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>

	<span class="n">e1000e_flush_descriptors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_clean_tx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">e1000_clean_rx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">e1000e_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO: for power management, we could drop the link and</span>
<span class="cm">	 * pci_disable_device here.</span>
<span class="cm">	 */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000e_reinit_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
	<span class="n">e1000e_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000e_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_sw_init - Initialize general software structures (struct e1000_adapter)</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_sw_init initializes the Adapter private data structure.</span>
<span class="cm"> * Fields are initialized based on PCI device information and</span>
<span class="cm"> * OS network device settings (MTU size).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">e1000_sw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ps_bsize0</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">min_frame_size</span> <span class="o">=</span> <span class="n">ETH_ZLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring_count</span> <span class="o">=</span> <span class="n">E1000_DEFAULT_TXD</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring_count</span> <span class="o">=</span> <span class="n">E1000_DEFAULT_RXD</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>

	<span class="n">e1000e_set_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_alloc_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Explicitly disable IRQ since the NIC can be in any state. */</span>
	<span class="n">e1000_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_intr_msi_test - Interrupt Handler</span>
<span class="cm"> * @irq: interrupt number</span>
<span class="cm"> * @data: pointer to a network interface device structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">e1000_intr_msi_test</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;icr is %08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">icr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="n">E1000_ICR_RXSEQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_MSI_TEST_FAILED</span><span class="p">;</span>
		<span class="n">wmb</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_test_msi_interrupt - Returns 0 for successful test</span>
<span class="cm"> * @adapter: board private struct</span>
<span class="cm"> *</span>
<span class="cm"> * code flow taken from tg3.c</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_test_msi_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* poll_enable hasn&#39;t been called yet, so don&#39;t need disable */</span>
	<span class="cm">/* clear any pending events */</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="cm">/* free the real vector and request a test handler */</span>
	<span class="n">e1000_free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000e_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Assume that the test fails, if it succeeds then the test</span>
<span class="cm">	 * MSI irq handler will unset this flag */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_MSI_TEST_FAILED</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">msi_test_failed</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">e1000_intr_msi_test</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			  <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">msi_test_failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* fire an unusual interrupt on the test handler */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_RXSEQ</span><span class="p">);</span>
	<span class="n">e1e_flush</span><span class="p">();</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">e1000_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">rmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MSI_TEST_FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mode</span> <span class="o">=</span> <span class="n">E1000E_INT_MODE_LEGACY</span><span class="p">;</span>
		<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;MSI interrupt test failed, using legacy interrupt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MSI interrupt test succeeded!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

<span class="nl">msi_test_failed:</span>
	<span class="n">e1000e_set_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">e1000_request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_test_msi - Returns 0 if MSI test succeeds or INTx mode is restored</span>
<span class="cm"> * @adapter: board private struct</span>
<span class="cm"> *</span>
<span class="cm"> * code flow taken from tg3.c, called with e1000 interrupts disabled.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_test_msi</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">pci_cmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MSI_ENABLED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* disable SERR in case the MSI write causes a master abort */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_SERR</span><span class="p">)</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span>
				      <span class="n">pci_cmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_COMMAND_SERR</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_test_msi_interrupt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* re-enable SERR */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_cmd</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_SERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_cmd</span><span class="p">);</span>
		<span class="n">pci_cmd</span> <span class="o">|=</span> <span class="n">PCI_COMMAND_SERR</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">pci_cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_open - Called when a network interface is made active</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative value on failure</span>
<span class="cm"> *</span>
<span class="cm"> * The open entry point is called when a network interface is made</span>
<span class="cm"> * active by the system (IFF_UP).  At this point all resources needed</span>
<span class="cm"> * for transmit and receive operations are allocated, the interrupt</span>
<span class="cm"> * handler is registered with the OS, the watchdog timer is started,</span>
<span class="cm"> * and the stack is notified that the interface is ready.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* disallow open during test */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_TESTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* allocate transmit descriptors */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000e_setup_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup_tx</span><span class="p">;</span>

	<span class="cm">/* allocate receive descriptors */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000e_setup_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup_rx</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If AMT is enabled, let the firmware know that the network</span>
<span class="cm">	 * interface is now open and reset the part to a known state.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_AMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e1000e_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">e1000e_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e1000e_power_up_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">E1000_MNG_VLAN_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
	     <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN</span><span class="p">))</span>
		<span class="n">e1000_update_mng_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* DMA latency requirement to workaround jumbo issue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_pch2lan</span><span class="p">)</span>
		<span class="n">pm_qos_add_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">pm_qos_req</span><span class="p">,</span>
				   <span class="n">PM_QOS_CPU_DMA_LATENCY</span><span class="p">,</span>
				   <span class="n">PM_QOS_DEFAULT_VALUE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * before we allocate an interrupt, we must be ready to handle it.</span>
<span class="cm">	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt</span>
<span class="cm">	 * as soon as we call pci_request_irq, so we have to setup our</span>
<span class="cm">	 * clean_rx handler before we do so.</span>
<span class="cm">	 */</span>
	<span class="n">e1000_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_req_irq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Work around PCIe errata with MSI interrupts causing some chipsets to</span>
<span class="cm">	 * ignore e1000e MSI messages, which means we need to test our MSI</span>
<span class="cm">	 * interrupt now</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mode</span> <span class="o">!=</span> <span class="n">E1000E_INT_MODE_LEGACY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_test_msi</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Interrupt allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_req_irq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* From here on the code is the same as e1000e_up() */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_hang_recheck</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">idle_check</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">pm_runtime_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* fire a link status change interrupt to start the watchdog */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_LSC</span> <span class="o">|</span> <span class="n">E1000_ICR_OTHER</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_LSC</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_req_irq:</span>
	<span class="n">e1000e_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_power_down_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000e_free_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
<span class="nl">err_setup_rx:</span>
	<span class="n">e1000e_free_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
<span class="nl">err_setup_tx:</span>
	<span class="n">e1000e_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_close - Disables a network interface</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0, this is not allowed to fail</span>
<span class="cm"> *</span>
<span class="cm"> * The close entry point is called when an interface is de-activated</span>
<span class="cm"> * by the OS.  The hardware is still under the drivers control, but</span>
<span class="cm"> * needs to be disabled.  A global MAC reset is issued to stop the</span>
<span class="cm"> * hardware, and all transmit and receive resources are freed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">E1000_CHECK_RESET_COUNT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">--</span><span class="p">)</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>

	<span class="n">pm_runtime_get_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e1000e_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">e1000_free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">e1000_power_down_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">e1000e_free_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">e1000e_free_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * kill manageability vlan ID if supported, but not if a vlan with</span>
<span class="cm">	 * the same ID is registered on the host OS (let 8021q kill it)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
	    <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN</span><span class="p">)</span>
		<span class="n">e1000_vlan_rx_kill_vid</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If AMT is enabled, let the firmware know that the network</span>
<span class="cm">	 * interface is now closed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_AMT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_TESTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">e1000e_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_pch2lan</span><span class="p">)</span>
		<span class="n">pm_qos_remove_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">pm_qos_req</span><span class="p">);</span>

	<span class="n">pm_runtime_put_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * e1000_set_mac - Change the Ethernet Address of the NIC</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @p: pointer to an address structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_set_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">rar_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RESET_OVERWRITES_LAA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* activate the work around */</span>
		<span class="n">e1000e_set_laa_state_82571</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Hold a copy of the LAA in RAR[14] This is done so that</span>
<span class="cm">		 * between the time RAR[0] gets clobbered  and the time it</span>
<span class="cm">		 * gets fixed (in e1000_watchdog), the actual LAA is in one</span>
<span class="cm">		 * of the RARs and no incoming packets directed to this port</span>
<span class="cm">		 * are dropped. Eventually the LAA will be in RAR[0] and</span>
<span class="cm">		 * RAR[14]</span>
<span class="cm">		 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">rar_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">rar_entry_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_update_phy_task - work thread to update phy</span>
<span class="cm"> * @work: pointer to our work struct</span>
<span class="cm"> *</span>
<span class="cm"> * this worker thread exists because we must acquire a</span>
<span class="cm"> * semaphore to read the phy, which we could msleep while</span>
<span class="cm"> * waiting for it, and we can&#39;t msleep in a timer.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_update_phy_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span> <span class="n">update_phy_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">e1000_get_phy_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Need to wait a few seconds after link up to get diagnostic information from</span>
<span class="cm"> * the phy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_update_phy_info</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">update_phy_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_update_phy_stats - Update the PHY statistics counters</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Read/clear the upper 16-bit PHY registers and read/accumulate lower</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_update_phy_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * A page set is expensive so check if already on desired page.</span>
<span class="cm">	 * If not, set to the page with the PHY status registers.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000e_read_phy_reg_mdic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PAGE_SELECT</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">!=</span> <span class="p">(</span><span class="n">HV_STATS_PAGE</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">set_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					       <span class="n">HV_STATS_PAGE</span> <span class="o">&lt;&lt;</span> <span class="n">IGP_PAGE_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Single Collision Count */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_SCC_UPPER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_SCC_LOWER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">scc</span> <span class="o">+=</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Excessive Collision Count */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_ECOL_UPPER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_ECOL_LOWER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span> <span class="o">+=</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Multiple Collision Count */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_MCC_UPPER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_MCC_LOWER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mcc</span> <span class="o">+=</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Late Collision Count */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_LATECOL_UPPER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_LATECOL_LOWER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span> <span class="o">+=</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Collision Count - also used for adaptive IFS */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_COLC_UPPER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_COLC_LOWER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">collision_delta</span> <span class="o">=</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Defer Count */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_DC_UPPER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_DC_LOWER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">dc</span> <span class="o">+=</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="cm">/* Transmit with no CRS */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_TNCRS_UPPER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">HV_TNCRS_LOWER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span> <span class="o">+=</span> <span class="n">phy_data</span><span class="p">;</span>

<span class="nl">release:</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000e_update_stats - Update the board statistics counters</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent stats update while adapter is being reset, or if the pci</span>
<span class="cm">	 * connection is down.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CRCERRS</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gprc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GORCL</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">GORCH</span><span class="p">);</span> <span class="cm">/* Clear gorc */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">bprc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">BPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mprc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ROC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mpc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPC</span><span class="p">);</span>

	<span class="cm">/* Half-duplex statistics */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">==</span> <span class="n">HALF_DUPLEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_HAS_PHY_STATS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e1000e_update_phy_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">scc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SCC</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ECOL</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mcc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MCC</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">LATECOL</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">dc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">DC</span><span class="p">);</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">collision_delta</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">COLC</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_82574</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_82583</span><span class="p">))</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TNCRS</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span> <span class="o">+=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">collision_delta</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xonrxc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XONRXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xontxc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XONTXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xoffrxc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XOFFRXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xofftxc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XOFFTXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gptc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GOTCL</span><span class="p">);</span>
	<span class="n">er32</span><span class="p">(</span><span class="n">GOTCH</span><span class="p">);</span> <span class="cm">/* Clear gotc */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rnbc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RNBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RUC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mptc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">bptc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">BPTC</span><span class="p">);</span>

	<span class="cm">/* used for adaptive IFS */</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">tx_packet_delta</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TPT</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpt</span> <span class="o">+=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">tx_packet_delta</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ALGNERRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rxerrc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXERRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cexterr</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CEXTERR</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tsctc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TSCTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tsctfc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TSCTFC</span><span class="p">);</span>

	<span class="cm">/* Fill out the OS statistics structure */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mprc</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span><span class="p">;</span>

	<span class="cm">/* Rx Errors */</span>

	<span class="cm">/*</span>
<span class="cm">	 * RLEC on some newer hardware can be incorrect so build</span>
<span class="cm">	 * our own version based on RUC and ROC</span>
<span class="cm">	 */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rxerrc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cexterr</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+</span>
					      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mpc</span><span class="p">;</span>

	<span class="cm">/* Tx Errors */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span> <span class="o">+</span>
				       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span><span class="p">;</span>

	<span class="cm">/* Tx Dropped needs to be maintained elsewhere */</span>

	<span class="cm">/* Management Stats */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgptc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgprc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgpdc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPDC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_read_status - Update the PHY register status snapshot</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_phy_read_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_phy_regs</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span>  <span class="o">=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">bmcr</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">|=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">bmsr</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">|=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_ADV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">advertise</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">|=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_LP_ABILITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">lpa</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">|=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_EXP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">expansion</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">|=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">ctrl1000</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">|=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">stat1000</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">|=</span> <span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_EXT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">estatus</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="n">e_warn</span><span class="p">(</span><span class="s">&quot;Error reading PHY register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not read PHY registers if link is not up</span>
<span class="cm">		 * Set values to typical power-on defaults</span>
<span class="cm">		 */</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">bmcr</span> <span class="o">=</span> <span class="p">(</span><span class="n">BMCR_SPEED1000</span> <span class="o">|</span> <span class="n">BMCR_ANENABLE</span> <span class="o">|</span> <span class="n">BMCR_FULLDPLX</span><span class="p">);</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">bmsr</span> <span class="o">=</span> <span class="p">(</span><span class="n">BMSR_100FULL</span> <span class="o">|</span> <span class="n">BMSR_100HALF</span> <span class="o">|</span> <span class="n">BMSR_10FULL</span> <span class="o">|</span>
			     <span class="n">BMSR_10HALF</span> <span class="o">|</span> <span class="n">BMSR_ESTATEN</span> <span class="o">|</span> <span class="n">BMSR_ANEGCAPABLE</span> <span class="o">|</span>
			     <span class="n">BMSR_ERCAP</span><span class="p">);</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">advertise</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADVERTISE_PAUSE_ASYM</span> <span class="o">|</span> <span class="n">ADVERTISE_PAUSE_CAP</span> <span class="o">|</span>
				  <span class="n">ADVERTISE_ALL</span> <span class="o">|</span> <span class="n">ADVERTISE_CSMA</span><span class="p">);</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">lpa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">expansion</span> <span class="o">=</span> <span class="n">EXPANSION_ENABLENPAGE</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ctrl1000</span> <span class="o">=</span> <span class="n">ADVERTISE_1000FULL</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">stat1000</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phy</span><span class="o">-&gt;</span><span class="n">estatus</span> <span class="o">=</span> <span class="p">(</span><span class="n">ESTATUS_1000_TFULL</span> <span class="o">|</span> <span class="n">ESTATUS_1000_THALF</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_print_link_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="cm">/* Link status message must follow this format for user tools */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;e1000e: %s NIC Link is Up %d Mbps %s Duplex, Flow Control: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">==</span> <span class="n">FULL_DUPLEX</span> <span class="o">?</span> <span class="s">&quot;Full&quot;</span> <span class="o">:</span> <span class="s">&quot;Half&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_TFCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_RFCE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Rx/Tx&quot;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_RFCE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Rx&quot;</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_TFCE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Tx&quot;</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000e_has_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * get_link_status is set on LSC (link status) interrupt or</span>
<span class="cm">	 * Rx sequence error interrupt.  get_link_status will stay</span>
<span class="cm">	 * false until the check_for_link establishes link</span>
<span class="cm">	 * for copper adapters ONLY</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_media_type_copper</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">link_active</span> <span class="o">=</span> <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">get_link_status</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">link_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_media_type_fiber</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">link_active</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_media_type_internal_serdes</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">link_active</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">serdes_has_link</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
	<span class="k">case</span> <span class="n">e1000_media_type_unknown</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret_val</span> <span class="o">==</span> <span class="n">E1000_ERR_PHY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_igp_3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_PHY_CTRL_GBE_DISABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* See e1000_kmrn_lock_loss_workaround_ich8lan() */</span>
		<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;Gigabit has been disabled, downgrading speed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">link_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_enable_receives</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* make sure the receive unit is started */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RX_NEEDS_RESTART</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RX_RESTART_NOW</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">|</span> <span class="n">E1000_RCTL_EN</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_RX_RESTART_NOW</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_check_82574_phy_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * With 82574 controllers, PHY needs to be checked periodically</span>
<span class="cm">	 * for hung state and reset, if two calls return true</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_check_phy_82574</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_hang_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_hang_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_hang_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_hang_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_watchdog - Timer Call-back</span>
<span class="cm"> * @data: pointer to adapter cast into an unsigned long</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_watchdog</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* Do the rest outside of interrupt context */</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>

	<span class="cm">/* TODO: make this use queue_delayed_work() */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_watchdog_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span> <span class="n">watchdog_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_mac_info</span> <span class="o">*</span><span class="n">mac</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">link</span><span class="p">,</span> <span class="n">tctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">link</span> <span class="o">=</span> <span class="n">e1000e_has_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cancel scheduled suspend requests. */</span>
		<span class="n">pm_runtime_resume</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>

		<span class="n">e1000e_enable_receives</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">link_up</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">e1000e_enable_tx_pkt_filtering</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">vlan_id</span><span class="p">))</span>
		<span class="n">e1000_update_mng_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">txb2b</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

			<span class="cm">/* Cancel scheduled suspend requests. */</span>
			<span class="n">pm_runtime_resume</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>

			<span class="cm">/* update snapshot of PHY registers on LSC */</span>
			<span class="n">e1000_phy_read_status</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="n">mac</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">get_link_up_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span><span class="p">);</span>
			<span class="n">e1000_print_link_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * On supported PHYs, check for duplex mismatch only</span>
<span class="cm">			 * if link has autonegotiated at 10/100 half</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_igp_3</span> <span class="o">||</span>
			     <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_bm</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">autoneg</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">==</span> <span class="n">SPEED_10</span> <span class="o">||</span>
			     <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">==</span> <span class="n">SPEED_100</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">==</span> <span class="n">HALF_DUPLEX</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">u16</span> <span class="n">autoneg_exp</span><span class="p">;</span>

				<span class="n">e1e_rphy</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_EXP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">autoneg_exp</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">autoneg_exp</span> <span class="o">&amp;</span> <span class="n">NWAY_ER_LP_NWAY_CAPS</span><span class="p">))</span>
					<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;Autonegotiated half duplex but link partner cannot autoneg.  Try forcing full duplex if link gets many collisions.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* adjust timeout factor according to speed/duplex */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SPEED_10</span>:
				<span class="n">txb2b</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SPEED_100</span>:
				<span class="n">txb2b</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * workaround: re-program speed mode bit after</span>
<span class="cm">			 * link-up event</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_TARC_SPEED_MODE_BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">txb2b</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">tarc0</span><span class="p">;</span>
				<span class="n">tarc0</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
				<span class="n">tarc0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SPEED_MODE_BIT</span><span class="p">;</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">TARC</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">tarc0</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * disable TSO for pcie and 10/100 speeds, to avoid</span>
<span class="cm">			 * some hardware issues</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_TSO_FORCE</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">SPEED_10</span>:
				<span class="k">case</span> <span class="n">SPEED_100</span>:
					<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;10/100 speed: disabling TSO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_TSO</span><span class="p">;</span>
					<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_TSO6</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">SPEED_1000</span>:
					<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO</span><span class="p">;</span>
					<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO6</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="cm">/* oops */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * enable transmits in the hardware, need to do this</span>
<span class="cm">			 * after setting TARC(0)</span>
<span class="cm">			 */</span>
			<span class="n">tctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
			<span class="n">tctl</span> <span class="o">|=</span> <span class="n">E1000_TCTL_EN</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>

                        <span class="cm">/*</span>
<span class="cm">			 * Perform any post-link-up configuration before</span>
<span class="cm">			 * reporting link up.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">cfg_on_link_up</span><span class="p">)</span>
				<span class="n">phy</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">.</span><span class="n">cfg_on_link_up</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">,</span>
					  <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Link status message must follow this format */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;e1000e: %s NIC Link is Down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
				<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">,</span>
					  <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RX_NEEDS_RESTART</span><span class="p">)</span>
				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">pm_schedule_suspend</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span>
							<span class="n">LINK_TIMEOUT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">link_up:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>
	<span class="n">e1000e_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">tx_packet_delta</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpt</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tpt_old</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tpt_old</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpt</span><span class="p">;</span>
	<span class="n">mac</span><span class="o">-&gt;</span><span class="n">collision_delta</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">colc_old</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">colc_old</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorc</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorc</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorc_old</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorc_old</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorc</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotc</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotc</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotc_old</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotc_old</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotc</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>

	<span class="n">e1000e_update_adaptive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">e1000_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve lost link, so the controller stops DMA,</span>
<span class="cm">		 * but we&#39;ve got queued Tx work that&#39;s never going</span>
<span class="cm">		 * to get done, so reset controller to flush Tx.</span>
<span class="cm">		 * (Do the reset outside of interrupt context).</span>
<span class="cm">		 */</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
		<span class="cm">/* return immediately since reset is imminent */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Simple mode for Interrupt Throttle Rate (ITR) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Symmetric Tx/Rx gets a reduced ITR=2000;</span>
<span class="cm">		 * Total asymmetrical Tx or Rx gets ITR=8000;</span>
<span class="cm">		 * everyone else is between 2000-8000.</span>
<span class="cm">		 */</span>
		<span class="n">u32</span> <span class="n">goc</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotc</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorc</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">dif</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotc</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorc</span> <span class="o">?</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotc</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorc</span> <span class="o">:</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorc</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotc</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">goc</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">(</span><span class="n">dif</span> <span class="o">*</span> <span class="mi">6000</span> <span class="o">/</span> <span class="n">goc</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">)</span> <span class="o">:</span> <span class="mi">8000</span><span class="p">;</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">itr</span> <span class="o">*</span> <span class="mi">256</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Cause software interrupt to ensure Rx ring is cleaned */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">ims_val</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_RXDMT0</span><span class="p">);</span>

	<span class="cm">/* flush pending descriptors to memory before detecting Tx hang */</span>
	<span class="n">e1000e_flush_descriptors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Force detection of hung controller every watchdog period */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">detect_tx_hung</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * With 82571 controllers, LAA may be overwritten due to controller</span>
<span class="cm">	 * reset from the other port. Set the appropriate LAA in RAR[0]</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000e_get_laa_state_82571</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_CHECK_PHY_HANG</span><span class="p">)</span>
		<span class="n">e1000e_check_82574_phy_workaround</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Reset the timer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">,</span>
			  <span class="n">round_jiffies</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define E1000_TX_FLAGS_CSUM		0x00000001</span>
<span class="cp">#define E1000_TX_FLAGS_VLAN		0x00000002</span>
<span class="cp">#define E1000_TX_FLAGS_TSO		0x00000004</span>
<span class="cp">#define E1000_TX_FLAGS_IPV4		0x00000008</span>
<span class="cp">#define E1000_TX_FLAGS_NO_FCS		0x00000010</span>
<span class="cp">#define E1000_TX_FLAGS_VLAN_MASK	0xffff0000</span>
<span class="cp">#define E1000_TX_FLAGS_VLAN_SHIFT	16</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_context_desc</span> <span class="o">*</span><span class="n">context_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ipcse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tucse</span><span class="p">,</span> <span class="n">mss</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipcss</span><span class="p">,</span> <span class="n">ipcso</span><span class="p">,</span> <span class="n">tucss</span><span class="p">,</span> <span class="n">tucso</span><span class="p">,</span> <span class="n">hdr_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
		                                         <span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cmd_length</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_IP</span><span class="p">;</span>
		<span class="n">ipcse</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso_v6</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_ipv6_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
		                                       <span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
		                                       <span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ipcse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ipcss</span> <span class="o">=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ipcso</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">tucss</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">tucso</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">tucse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cmd_length</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_TXD_CMD_TSE</span> <span class="o">|</span>
	               <span class="n">E1000_TXD_CMD_TCP</span> <span class="o">|</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">hdr_len</span><span class="p">)));</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">context_desc</span> <span class="o">=</span> <span class="n">E1000_CONTEXT_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">lower_setup</span><span class="p">.</span><span class="n">ip_fields</span><span class="p">.</span><span class="n">ipcss</span>  <span class="o">=</span> <span class="n">ipcss</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">lower_setup</span><span class="p">.</span><span class="n">ip_fields</span><span class="p">.</span><span class="n">ipcso</span>  <span class="o">=</span> <span class="n">ipcso</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">lower_setup</span><span class="p">.</span><span class="n">ip_fields</span><span class="p">.</span><span class="n">ipcse</span>  <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ipcse</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucss</span> <span class="o">=</span> <span class="n">tucss</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucso</span> <span class="o">=</span> <span class="n">tucso</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucse</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">tucse</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">tcp_seg_setup</span><span class="p">.</span><span class="n">fields</span><span class="p">.</span><span class="n">mss</span>     <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">mss</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">tcp_seg_setup</span><span class="p">.</span><span class="n">fields</span><span class="p">.</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="n">hdr_len</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">cmd_and_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_length</span><span class="p">);</span>

	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_tx_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_context_desc</span> <span class="o">*</span><span class="n">context_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">css</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd_len</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_DEXT</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">protocol</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span>
		<span class="n">protocol</span> <span class="o">=</span> <span class="n">vlan_eth_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">h_vlan_encapsulated_proto</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">protocol</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
			<span class="n">cmd_len</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_TCP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">)</span>:
		<span class="cm">/* XXX not handling all IPV6 headers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
			<span class="n">cmd_len</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_TCP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">net_ratelimit</span><span class="p">()))</span>
			<span class="n">e_warn</span><span class="p">(</span><span class="s">&quot;checksum_partial proto=%x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">protocol</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">css</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">context_desc</span> <span class="o">=</span> <span class="n">E1000_CONTEXT_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">lower_setup</span><span class="p">.</span><span class="n">ip_config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucss</span> <span class="o">=</span> <span class="n">css</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucso</span> <span class="o">=</span>
				<span class="n">css</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">tcp_seg_setup</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">cmd_and_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define E1000_MAX_PER_TXD	8192</span>
<span class="cp">#define E1000_MAX_TXD_PWR	12</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_tx_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_per_txd</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_frags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f</span><span class="p">,</span> <span class="n">bytecount</span><span class="p">,</span> <span class="n">segs</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">max_per_txd</span><span class="p">);</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
						  <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">nr_frags</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">max_per_txd</span><span class="p">);</span>

			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span>
						<span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">segs</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">?</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* multiply data chunks by size of headers */</span>
	<span class="n">bytecount</span> <span class="o">=</span> <span class="p">((</span><span class="n">segs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">segs</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bytecount</span> <span class="o">=</span> <span class="n">bytecount</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">first</span><span class="p">].</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

<span class="nl">dma_error:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Tx DMA map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">e1000_put_txbuf</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txd_upper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">txd_lower</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_IFCS</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_TSO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txd_lower</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_TXD_DTYP_D</span> <span class="o">|</span>
			     <span class="n">E1000_TXD_CMD_TSE</span><span class="p">;</span>
		<span class="n">txd_upper</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_TXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_IPV4</span><span class="p">)</span>
			<span class="n">txd_upper</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_IXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_CSUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txd_lower</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_TXD_DTYP_D</span><span class="p">;</span>
		<span class="n">txd_upper</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_TXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_VLAN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">txd_lower</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_VLE</span><span class="p">;</span>
		<span class="n">txd_upper</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_VLAN_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_NO_FCS</span><span class="p">))</span>
		<span class="n">txd_lower</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_TXD_CMD_IFCS</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">txd_lower</span> <span class="o">|</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">txd_upper</span><span class="p">);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">.</span><span class="n">data</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span><span class="p">);</span>

	<span class="cm">/* txd_cmd re-enables FCS, so we&#39;ll re-disable it here as desired. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_NO_FCS</span><span class="p">))</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_TXD_CMD_IFCS</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Force memory writes to complete before letting h/w</span>
<span class="cm">	 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">	 * applicable for weak-ordered memory model archs,</span>
<span class="cm">	 * such as IA-64).</span>
<span class="cm">	 */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_PCIM2PCI_ARBITER_WA</span><span class="p">)</span>
		<span class="n">e1000e_update_tdt_wa</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we need this if more than one processor can write to our tail</span>
<span class="cm">	 * at a time, it synchronizes IO on IA64/Altix systems</span>
<span class="cm">	 */</span>
	<span class="n">mmiowb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#define MINIMUM_DHCP_PACKET_SIZE 282</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_transfer_dhcp_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span>  <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">length</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">vlan_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
			<span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">MINIMUM_DHCP_PACKET_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">+</span><span class="mi">14</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">udphdr</span> <span class="o">*</span><span class="n">udp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">udp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">udp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">67</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">udp</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">e1000e_mng_write_dhcp_info</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">udp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__e1000_maybe_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Herbert&#39;s original patch had:</span>
<span class="cm">	 *  smp_mb__after_netif_stop_queue();</span>
<span class="cm">	 * but since that doesn&#39;t exist yet, just open code it.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to check again in a case another CPU has just</span>
<span class="cm">	 * made room available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* A reprieve! */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>
	<span class="o">++</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">restart_queue</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_maybe_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_desc_unused</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__e1000_maybe_stop_tx</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TXD_USE_COUNT(S, X) (((S) &gt;&gt; (X)) + 1)</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">e1000_xmit_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_per_txd</span> <span class="o">=</span> <span class="n">E1000_MAX_PER_TXD</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_txd_pwr</span> <span class="o">=</span> <span class="n">E1000_MAX_TXD_PWR</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_frags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tso</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The controller does a simple calculation to</span>
<span class="cm">	 * make sure there is enough room in the FIFO before</span>
<span class="cm">	 * initiating the DMA for each buffer.  The calc is:</span>
<span class="cm">	 * 4 = ceil(buffer len/mss).  To make sure we don&#39;t</span>
<span class="cm">	 * overrun the FIFO, adjust the max buffer len if mss</span>
<span class="cm">	 * drops.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">hdr_len</span><span class="p">;</span>
		<span class="n">max_per_txd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mss</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_per_txd</span><span class="p">);</span>
		<span class="n">max_txd_pwr</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">max_per_txd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * TSO Workaround for 82571/2/3 Controllers -- if skb-&gt;data</span>
<span class="cm">		 * points to just header, pull a few bytes of payload from</span>
<span class="cm">		 * frags into skb-&gt;data</span>
<span class="cm">		 */</span>
		<span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * we do this workaround for ES2LAN, but it is un-necessary,</span>
<span class="cm">		 * avoiding it could save a lot of cycles</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hdr_len</span> <span class="o">==</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pull_size</span><span class="p">;</span>

			<span class="n">pull_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__pskb_pull_tail</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pull_size</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;__pskb_pull_tail failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* reserve a descriptor for the offload context */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mss</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">))</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">+=</span> <span class="n">TXD_USE_COUNT</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">max_txd_pwr</span><span class="p">);</span>

	<span class="n">nr_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">nr_frags</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">TXD_USE_COUNT</span><span class="p">(</span><span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">]),</span>
				       <span class="n">max_txd_pwr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">tx_pkt_filtering</span><span class="p">)</span>
		<span class="n">e1000_transfer_dhcp_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * need: count + 2 desc gap to keep tail from touching</span>
<span class="cm">	 * head, otherwise try next time</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_maybe_stop_tx</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_VLAN</span><span class="p">;</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_TX_FLAGS_VLAN_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">first</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">tso</span> <span class="o">=</span> <span class="n">e1000_tso</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tso</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tso</span><span class="p">)</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_TSO</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e1000_tx_csum</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_CSUM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Old method was to assume IPv4 packet by default if TSO was enabled.</span>
<span class="cm">	 * 82571 hardware supports TSO capabilities for IPv6 as well...</span>
<span class="cm">	 * no longer assume, we must.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_IPV4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">no_fcs</span><span class="p">))</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_NO_FCS</span><span class="p">;</span>

	<span class="cm">/* if count is 0 then mapping error has occurred */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">e1000_tx_map</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">max_per_txd</span><span class="p">,</span> <span class="n">nr_frags</span><span class="p">,</span> <span class="n">mss</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">netdev_sent_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">e1000_tx_queue</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="cm">/* Make sure there is space in the ring for the next send. */</span>
		<span class="n">e1000_maybe_stop_tx</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">first</span><span class="p">].</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_tx_timeout - Respond to a Tx Hang</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Do the reset outside of interrupt context */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span> <span class="n">reset_task</span><span class="p">);</span>

	<span class="cm">/* don&#39;t run the task if already down */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RX_NEEDS_RESTART</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_RX_RESTART_NOW</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">e1000e_dump</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Reset adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">e1000e_reinit_locked</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_get_stats64 - Get System Network Statistics</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @stats: rtnl_link_stats64 pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the device statistics structure.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="nf">e1000e_get_stats64</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
                                             <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtnl_link_stats64</span><span class="p">));</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>
	<span class="n">e1000e_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="cm">/* Fill out the OS statistics structure */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorc</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gprc</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotc</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gptc</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mprc</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">collisions</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span><span class="p">;</span>

	<span class="cm">/* Rx Errors */</span>

	<span class="cm">/*</span>
<span class="cm">	 * RLEC on some newer hardware can be incorrect so build</span>
<span class="cm">	 * our own version based on RUC and ROC</span>
<span class="cm">	 */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rxerrc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cexterr</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+</span>
					      <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mpc</span><span class="p">;</span>

	<span class="cm">/* Tx Errors */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span> <span class="o">+</span>
				       <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_aborted_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_window_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_carrier_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span><span class="p">;</span>

	<span class="cm">/* Tx Dropped needs to be maintained elsewhere */</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats64_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_change_mtu - Change the Maximum Transfer Unit</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @new_mtu: new value for maximum frame size</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">max_frame</span> <span class="o">=</span> <span class="n">new_mtu</span> <span class="o">+</span> <span class="n">ETH_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>

	<span class="cm">/* Jumbo frame support */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">max_frame</span> <span class="o">&gt;</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_JUMBO_FRAMES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Jumbo Frames not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Supported frame sizes */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="n">ETH_ZLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">max_frame</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_hw_frame_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Unsupported MTU setting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Jumbo frame workaround on 82579 and newer requires CRC be stripped */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_pch2lan</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_CRC_STRIPPING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&gt;</span> <span class="n">ETH_DATA_LEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Jumbo Frames not supported on this device when CRC stripping is disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">usleep_range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
	<span class="cm">/* e1000e_down -&gt; e1000e_reset dependent on max_frame_size &amp; mtu */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">max_frame</span><span class="p">;</span>
	<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;changing MTU from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000e_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN</span>
<span class="cm">	 * means we reserve 2 more, this pushes us to allocate from the next</span>
<span class="cm">	 * larger slab size.</span>
<span class="cm">	 * i.e. RXBUFFER_2048 --&gt; size-4096 slab</span>
<span class="cm">	 * However with the new *_jumbo_rx* routines, jumbo receives will use</span>
<span class="cm">	 * fragmented skbs</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&lt;=</span> <span class="mi">2048</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>

	<span class="cm">/* adjust allocation if LPE protects us, and we aren&#39;t using SBP */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">max_frame</span> <span class="o">==</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">max_frame</span> <span class="o">==</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span>
					 <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000e_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">e1000e_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
		<span class="n">e1000_phy_read_status</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MII_BMCR</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">.</span><span class="n">bmcr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_BMSR</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">.</span><span class="n">bmsr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_PHYSID1</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_PHYSID2</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">id</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_ADVERTISE</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">.</span><span class="n">advertise</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_LPA</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">.</span><span class="n">lpa</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_EXPANSION</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">.</span><span class="n">expansion</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_CTRL1000</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">.</span><span class="n">ctrl1000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_STAT1000</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">.</span><span class="n">stat1000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MII_ESTATUS</span>:
			<span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_regs</span><span class="p">.</span><span class="n">estatus</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
		<span class="k">return</span> <span class="n">e1000_mii_ioctl</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_init_phy_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">wufc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">,</span> <span class="n">mac_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_reg</span><span class="p">,</span> <span class="n">wuc_enable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* copy MAC RARs to PHY RARs */</span>
	<span class="n">e1000_copy_rx_addrs_to_phy_ich8lan</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Could not acquire PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable access to wakeup registers on and set page to BM_WUC_PAGE */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">e1000_enable_phy_wakeup_reg_access_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wuc_enable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>

	<span class="cm">/* copy MAC MTA to PHY MTA - only needed for pchlan */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">mta_reg_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mac_reg</span> <span class="o">=</span> <span class="n">E1000_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">E1000_MTA</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_MTA</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
					   <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="n">mac_reg</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">));</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_reg_page</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_MTA</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">u16</span><span class="p">)((</span><span class="n">mac_reg</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* configure PHY Rx Control register */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">read_reg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_RCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_reg</span><span class="p">);</span>
	<span class="n">mac_reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_reg</span> <span class="o">&amp;</span> <span class="n">E1000_RCTL_UPE</span><span class="p">)</span>
		<span class="n">phy_reg</span> <span class="o">|=</span> <span class="n">BM_RCTL_UPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_reg</span> <span class="o">&amp;</span> <span class="n">E1000_RCTL_MPE</span><span class="p">)</span>
		<span class="n">phy_reg</span> <span class="o">|=</span> <span class="n">BM_RCTL_MPE</span><span class="p">;</span>
	<span class="n">phy_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BM_RCTL_MO_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_reg</span> <span class="o">&amp;</span> <span class="n">E1000_RCTL_MO_3</span><span class="p">)</span>
		<span class="n">phy_reg</span> <span class="o">|=</span> <span class="p">(((</span><span class="n">mac_reg</span> <span class="o">&amp;</span> <span class="n">E1000_RCTL_MO_3</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">E1000_RCTL_MO_SHIFT</span><span class="p">)</span>
				<span class="o">&lt;&lt;</span> <span class="n">BM_RCTL_MO_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_reg</span> <span class="o">&amp;</span> <span class="n">E1000_RCTL_BAM</span><span class="p">)</span>
		<span class="n">phy_reg</span> <span class="o">|=</span> <span class="n">BM_RCTL_BAM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_reg</span> <span class="o">&amp;</span> <span class="n">E1000_RCTL_PMCF</span><span class="p">)</span>
		<span class="n">phy_reg</span> <span class="o">|=</span> <span class="n">BM_RCTL_PMCF</span><span class="p">;</span>
	<span class="n">mac_reg</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mac_reg</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_RFCE</span><span class="p">)</span>
		<span class="n">phy_reg</span> <span class="o">|=</span> <span class="n">BM_RCTL_RFCE</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_reg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_RCTL</span><span class="p">,</span> <span class="n">phy_reg</span><span class="p">);</span>

	<span class="cm">/* enable PHY wakeup in MAC register */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">WUFC</span><span class="p">,</span> <span class="n">wufc</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">WUC</span><span class="p">,</span> <span class="n">E1000_WUC_PHY_WAKE</span> <span class="o">|</span> <span class="n">E1000_WUC_PME_EN</span><span class="p">);</span>

	<span class="cm">/* configure and enable PHY wakeup in PHY registers */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_reg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUFC</span><span class="p">,</span> <span class="n">wufc</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">write_reg_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUC</span><span class="p">,</span> <span class="n">E1000_WUC_PME_EN</span><span class="p">);</span>

	<span class="cm">/* activate PHY wakeup */</span>
	<span class="n">wuc_enable</span> <span class="o">|=</span> <span class="n">BM_WUC_ENABLE_BIT</span> <span class="o">|</span> <span class="n">BM_WUC_HOST_WU_BIT</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">e1000_disable_phy_wakeup_reg_access_bm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wuc_enable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Could not set PHY Host Wakeup bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">release:</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__e1000_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">enable_wake</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">runtime</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">,</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="cm">/* Runtime suspend should only enable wakeup for link changes */</span>
	<span class="n">u32</span> <span class="n">wufc</span> <span class="o">=</span> <span class="n">runtime</span> <span class="o">?</span> <span class="n">E1000_WUFC_LNKC</span> <span class="o">:</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">E1000_CHECK_RESET_COUNT</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="o">--</span><span class="p">)</span>
			<span class="n">usleep_range</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">);</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
		<span class="n">e1000e_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">e1000_free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">e1000e_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)</span>
		<span class="n">wufc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_WUFC_LNKC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wufc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e1000_setup_rctl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">e1000e_set_rx_mode</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

		<span class="cm">/* turn on all-multi mode if wake on multicast is enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wufc</span> <span class="o">&amp;</span> <span class="n">E1000_WUFC_MC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_MPE</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
		<span class="cm">/* advertise wake from D3Cold */</span>
		<span class="cp">#define E1000_CTRL_ADVD3WUC 0x00100000</span>
		<span class="cm">/* phy power management enable */</span>
		<span class="cp">#define E1000_CTRL_EN_PHY_PWR_MGMT 0x00200000</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_ADVD3WUC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_HAS_PHY_WAKEUP</span><span class="p">))</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EN_PHY_PWR_MGMT</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span> <span class="o">||</span>
		    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span>
		    <span class="n">e1000_media_type_internal_serdes</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* keep the laser running in D3 */</span>
			<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
			<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_SDP3_DATA</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_IS_ICH</span><span class="p">)</span>
			<span class="n">e1000_suspend_workarounds_ich8lan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Allow time for pending master requests to run */</span>
		<span class="n">e1000e_disable_pcie_master</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_HAS_PHY_WAKEUP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* enable wakeup by the PHY */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">e1000_init_phy_wakeup</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">wufc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* enable wakeup by the MAC */</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">WUFC</span><span class="p">,</span> <span class="n">wufc</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">WUC</span><span class="p">,</span> <span class="n">E1000_WUC_PME_EN</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">WUC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">WUFC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">enable_wake</span> <span class="o">=</span> <span class="o">!!</span><span class="n">wufc</span><span class="p">;</span>

	<span class="cm">/* make sure adapter isn&#39;t asleep if manageability is enabled */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_MNG_PT_ENABLED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_mng_mode</span><span class="p">(</span><span class="n">hw</span><span class="p">)))</span>
		<span class="o">*</span><span class="n">enable_wake</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_igp_3</span><span class="p">)</span>
		<span class="n">e1000e_igp3_phy_powerdown_workaround_ich8lan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release control of h/w to f/w.  If f/w is AMT enabled, this</span>
<span class="cm">	 * would have already happened in close and is redundant.</span>
<span class="cm">	 */</span>
	<span class="n">e1000e_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_power_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sleep</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wake</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sleep</span> <span class="o">&amp;&amp;</span> <span class="n">wake</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_prepare_to_sleep</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">wake</span><span class="p">);</span>
	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_complete_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sleep</span><span class="p">,</span>
                                    <span class="n">bool</span> <span class="n">wake</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The pci-e switch on some quad port adapters will report a</span>
<span class="cm">	 * correctable error when the MAC transitions from D0 to D3.  To</span>
<span class="cm">	 * prevent this we need to mask off the correctable errors on the</span>
<span class="cm">	 * downstream port of the pci-e switch.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_IS_QUAD_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">us_dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">us_dev</span><span class="p">);</span>
		<span class="n">u16</span> <span class="n">devctl</span><span class="p">;</span>

		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">us_dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devctl</span><span class="p">);</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">us_dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span>
		                      <span class="p">(</span><span class="n">devctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCI_EXP_DEVCTL_CERE</span><span class="p">));</span>

		<span class="n">e1000_power_off</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">sleep</span><span class="p">,</span> <span class="n">wake</span><span class="p">);</span>

		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">us_dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_DEVCTL</span><span class="p">,</span> <span class="n">devctl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">e1000_power_off</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">sleep</span><span class="p">,</span> <span class="n">wake</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCIEASPM</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__e1000e_disable_aspm</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_disable_link_state_locked</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__e1000e_disable_aspm</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">reg16</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Both device and parent should have the same ASPM setting.</span>
<span class="cm">	 * Disable ASPM in downstream component first and then upstream.</span>
<span class="cm">	 */</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg16</span><span class="p">);</span>
	<span class="n">reg16</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">state</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL</span><span class="p">,</span> <span class="n">reg16</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">pci_pcie_cap</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">);</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg16</span><span class="p">);</span>
	<span class="n">reg16</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">state</span><span class="p">;</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">PCI_EXP_LNKCTL</span><span class="p">,</span> <span class="n">reg16</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000e_disable_aspm</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Disabling ASPM %s %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PCIE_LINK_STATE_L0S</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;L0s&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">PCIE_LINK_STATE_L1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;L1&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">__e1000e_disable_aspm</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000e_pm_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__e1000_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">aspm_disable_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_ASPM_L0S</span><span class="p">)</span>
		<span class="n">aspm_disable_flag</span> <span class="o">=</span> <span class="n">PCIE_LINK_STATE_L0S</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_ASPM_L1</span><span class="p">)</span>
		<span class="n">aspm_disable_flag</span> <span class="o">|=</span> <span class="n">PCIE_LINK_STATE_L1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aspm_disable_flag</span><span class="p">)</span>
		<span class="n">e1000e_disable_aspm</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">aspm_disable_flag</span><span class="p">);</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">e1000e_set_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">e1000_pch2lan</span><span class="p">)</span>
		<span class="n">e1000_resume_workarounds_pchlan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">e1000e_power_up_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* report the system wakeup cause from S3/S4 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_HAS_PHY_WAKEUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

		<span class="n">e1e_rphy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;PHY Wakeup cause - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_EX</span> <span class="o">?</span> <span class="s">&quot;Unicast Packet&quot;</span> <span class="o">:</span>
				<span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_MC</span> <span class="o">?</span> <span class="s">&quot;Multicast Packet&quot;</span> <span class="o">:</span>
				<span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_BC</span> <span class="o">?</span> <span class="s">&quot;Broadcast Packet&quot;</span> <span class="o">:</span>
				<span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_MAG</span> <span class="o">?</span> <span class="s">&quot;Magic Packet&quot;</span> <span class="o">:</span>
				<span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_LNKC</span> <span class="o">?</span>
				<span class="s">&quot;Link Status Change&quot;</span> <span class="o">:</span> <span class="s">&quot;other&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">e1e_wphy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">BM_WUS</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">wus</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">WUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;MAC Wakeup cause - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wus</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_EX</span> <span class="o">?</span> <span class="s">&quot;Unicast Packet&quot;</span> <span class="o">:</span>
				<span class="n">wus</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_MC</span> <span class="o">?</span> <span class="s">&quot;Multicast Packet&quot;</span> <span class="o">:</span>
				<span class="n">wus</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_BC</span> <span class="o">?</span> <span class="s">&quot;Broadcast Packet&quot;</span> <span class="o">:</span>
				<span class="n">wus</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_MAG</span> <span class="o">?</span> <span class="s">&quot;Magic Packet&quot;</span> <span class="o">:</span>
				<span class="n">wus</span> <span class="o">&amp;</span> <span class="n">E1000_WUS_LNKC</span> <span class="o">?</span> <span class="s">&quot;Link Status Change&quot;</span> <span class="o">:</span>
				<span class="s">&quot;other&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">WUS</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e1000e_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">e1000_init_manageability_pt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000e_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the controller has AMT, do not set DRV_LOAD until the interface</span>
<span class="cm">	 * is up.  For all other cases, let the f/w know that the h/w is now</span>
<span class="cm">	 * under the control of the driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_AMT</span><span class="p">))</span>
		<span class="n">e1000e_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM_SLEEP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wake</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">__e1000_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wake</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">e1000_complete_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">wake</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e1000e_pm_ready</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">idle_check</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__e1000_resume</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_SLEEP */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_PM_RUNTIME</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_runtime_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e1000e_pm_ready</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">wake</span><span class="p">;</span>

		<span class="n">__e1000_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wake</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000e_pm_ready</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">idle_check</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">idle_check</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000e_has_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
			<span class="n">pm_schedule_suspend</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">MSEC_PER_SEC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_runtime_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000e_pm_ready</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">idle_check</span> <span class="o">=</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">power</span><span class="p">.</span><span class="n">runtime_auto</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__e1000_resume</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM_RUNTIME */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">wake</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">__e1000_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wake</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_POWER_OFF</span><span class="p">)</span>
		<span class="n">e1000_complete_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">wake</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">e1000_intr_msix</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="n">msix_irq</span><span class="p">;</span>

		<span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">msix_irq</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">);</span>
		<span class="n">e1000_intr_msix_rx</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">);</span>

		<span class="n">vector</span><span class="o">++</span><span class="p">;</span>
		<span class="n">msix_irq</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">);</span>
		<span class="n">e1000_intr_msix_tx</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">);</span>

		<span class="n">vector</span><span class="o">++</span><span class="p">;</span>
		<span class="n">msix_irq</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">vector</span><span class="p">;</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">);</span>
		<span class="n">e1000_msix_other</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">msix_irq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<span class="cm"> * without having to re-enable interrupts. It&#39;s not called while</span>
<span class="cm"> * the interrupt routine is executing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000E_INT_MODE_MSIX</span>:
		<span class="n">e1000_intr_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000E_INT_MODE_MSI</span>:
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">e1000_intr_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span> <span class="cm">/* E1000E_INT_MODE_LEGACY */</span>
		<span class="n">disable_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">e1000_intr</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_io_error_detected - called when PCI error is detected</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> * @state: The current pci connection state</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after a PCI bus error affecting</span>
<span class="cm"> * this device has been detected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">e1000_io_error_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">pci_channel_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">pci_channel_io_perm_failure</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000e_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Request a slot slot reset. */</span>
	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_io_slot_reset - called after the pci bus has been reset.</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Restart the card from scratch, as if from a cold-boot. Implementation</span>
<span class="cm"> * resembles the first-half of the e1000_resume routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">e1000_io_slot_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">aspm_disable_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">pci_ers_result_t</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_ASPM_L0S</span><span class="p">)</span>
		<span class="n">aspm_disable_flag</span> <span class="o">=</span> <span class="n">PCIE_LINK_STATE_L0S</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_ASPM_L1</span><span class="p">)</span>
		<span class="n">aspm_disable_flag</span> <span class="o">|=</span> <span class="n">PCIE_LINK_STATE_L1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aspm_disable_flag</span><span class="p">)</span>
		<span class="n">e1000e_disable_aspm</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">aspm_disable_flag</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Cannot re-enable PCI device after reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">state_saved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

		<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3cold</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">e1000e_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">WUS</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_cleanup_aer_uncorrect_error_status</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_io_resume - called when traffic can start flowing again.</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is called when the error recovery driver tells us that</span>
<span class="cm"> * its OK to resume normal operation. Implementation resembles the</span>
<span class="cm"> * second-half of the e1000_resume routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_io_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e1000_init_manageability_pt</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000e_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;can&#39;t bring device back up after reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the controller has AMT, do not set DRV_LOAD until the interface</span>
<span class="cm">	 * is up.  For all other cases, let the f/w know that the h/w is now</span>
<span class="cm">	 * under the control of the driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_AMT</span><span class="p">))</span>
		<span class="n">e1000e_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_print_device_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pba_str</span><span class="p">[</span><span class="n">E1000_PBANUM_LENGTH</span><span class="p">];</span>

	<span class="cm">/* print bus type/speed/width info */</span>
	<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;(PCI Express:2.5GT/s:%s) %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="cm">/* bus width */</span>
	       <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">e1000_bus_width_pcie_x4</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Width x4&quot;</span> <span class="o">:</span>
	        <span class="s">&quot;Width x1&quot;</span><span class="p">),</span>
	       <span class="cm">/* MAC address */</span>
	       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;Intel(R) PRO/%s Network Connection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_phy_ife</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;10/100&quot;</span> <span class="o">:</span> <span class="s">&quot;1000&quot;</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_pba_string_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">pba_str</span><span class="p">,</span>
						<span class="n">E1000_PBANUM_LENGTH</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">strlcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pba_str</span><span class="p">,</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pba_str</span><span class="p">));</span>
	<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;MAC: %d, PHY: %d, PBA No: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">pba_str</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_eeprom_checks</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">e1000_82573</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_nvm</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_INIT_CONTROL2_REG</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">le16_to_cpus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret_val</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">buf</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))))</span> <span class="p">{</span>
		<span class="cm">/* Deep Smart Power Down (DSPD) */</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			 <span class="s">&quot;Warning: detected DSPD enabled in EEPROM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			      <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netdev_features_t</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">features</span> <span class="o">^</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NETIF_F_TSO</span> <span class="o">|</span> <span class="n">NETIF_F_TSO6</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_TSO_FORCE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span>
			 <span class="n">NETIF_F_RXCSUM</span> <span class="o">|</span> <span class="n">NETIF_F_RXHASH</span> <span class="o">|</span> <span class="n">NETIF_F_RXFCS</span> <span class="o">|</span>
			 <span class="n">NETIF_F_RXALL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXFCS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXFCS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG2_CRC_STRIPPING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* We need to take it back to defaults, which might mean</span>
<span class="cm">			 * stripping is still disabled at the adapter level.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DFLT_CRC_STRIPPING</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">|=</span> <span class="n">FLAG2_CRC_STRIPPING</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG2_CRC_STRIPPING</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000e_reinit_locked</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">e1000e_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">e1000e_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">e1000_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">e1000_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">e1000_xmit_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats64</span>	<span class="o">=</span> <span class="n">e1000e_get_stats64</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">e1000e_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">e1000_set_mac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">e1000_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">e1000_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">e1000_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>

	<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span>	<span class="o">=</span> <span class="n">e1000_vlan_rx_add_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span>	<span class="o">=</span> <span class="n">e1000_vlan_rx_kill_vid</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">e1000_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">ndo_set_features</span> <span class="o">=</span> <span class="n">e1000_set_features</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_probe - Device Initialization Routine</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> * @ent: entry in e1000_pci_tbl</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_probe initializes an adapter identified by a pci_dev structure.</span>
<span class="cm"> * The OS initialization, configuring of the adapter private structure,</span>
<span class="cm"> * and a hardware reset occur.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">e1000_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">e1000_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="n">e1000_info_tbl</span><span class="p">[</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">driver_data</span><span class="p">];</span>
	<span class="n">resource_size_t</span> <span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_len</span><span class="p">;</span>
	<span class="n">resource_size_t</span> <span class="n">flash_start</span><span class="p">,</span> <span class="n">flash_len</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">cards_found</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">aspm_disable_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">pci_using_dac</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_apme_mask</span> <span class="o">=</span> <span class="n">E1000_EEPROM_APME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_ASPM_L0S</span><span class="p">)</span>
		<span class="n">aspm_disable_flag</span> <span class="o">=</span> <span class="n">PCIE_LINK_STATE_L0S</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">&amp;</span> <span class="n">FLAG2_DISABLE_ASPM_L1</span><span class="p">)</span>
		<span class="n">aspm_disable_flag</span> <span class="o">|=</span> <span class="n">PCIE_LINK_STATE_L1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aspm_disable_flag</span><span class="p">)</span>
		<span class="n">e1000e_disable_aspm</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">aspm_disable_flag</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						    <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;No usable DMA configuration, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_dma</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_selected_regions_exclusive</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
	                                  <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">),</span>
	                                  <span class="n">e1000e_driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pci_reg</span><span class="p">;</span>

	<span class="cm">/* AER (Advanced Error Reporting) hooks */</span>
	<span class="n">pci_enable_pcie_error_reporting</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="cm">/* PCI config space info */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_etherdev</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_etherdev</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ei</span> <span class="o">=</span> <span class="n">ei</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pba</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">pba</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">flags2</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_hw_frame_size</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">max_hw_frame_size</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">DEFAULT_MSG_ENABLE</span><span class="p">);</span>

	<span class="n">mmio_start</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mmio_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">mmio_start</span><span class="p">,</span> <span class="n">mmio_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_FLASH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">flash_start</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">flash_len</span> <span class="o">=</span> <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flash_address</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">flash_start</span><span class="p">,</span> <span class="n">flash_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flash_address</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_flashmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* construct the net_device struct */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000e_netdev_ops</span><span class="p">;</span>
	<span class="n">e1000e_set_ethtool_ops</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span>		<span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">e1000e_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mem_start</span> <span class="o">=</span> <span class="n">mmio_start</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">mmio_start</span> <span class="o">+</span> <span class="n">mmio_len</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bd_number</span> <span class="o">=</span> <span class="n">cards_found</span><span class="o">++</span><span class="p">;</span>

	<span class="n">e1000e_check_options</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* setup adapter struct */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_sw_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sw_init</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">mac_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">nvm_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">nvm</span><span class="p">.</span><span class="n">ops</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">phy_ops</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ei</span><span class="o">-&gt;</span><span class="n">get_variants</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_hw_init</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_IS_ICH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_READ_ONLY_NVM</span><span class="p">))</span>
		<span class="n">e1000e_write_protect_nvm_ich8lan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">get_bus_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_wait_to_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Copper options */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">mdix</span> <span class="o">=</span> <span class="n">AUTO_ALL_MODES</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">disable_polarity_correction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">ms_type</span> <span class="o">=</span> <span class="n">e1000_ms_hw_default</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">e_info</span><span class="p">(</span><span class="s">&quot;PHY reset is blocked due to SOL/IDER session.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Set initial default active device features */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="p">(</span><span class="n">NETIF_F_SG</span> <span class="o">|</span>
			    <span class="n">NETIF_F_HW_VLAN_RX</span> <span class="o">|</span>
			    <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span>
			    <span class="n">NETIF_F_TSO</span> <span class="o">|</span>
			    <span class="n">NETIF_F_TSO6</span> <span class="o">|</span>
			    <span class="n">NETIF_F_RXHASH</span> <span class="o">|</span>
			    <span class="n">NETIF_F_RXCSUM</span> <span class="o">|</span>
			    <span class="n">NETIF_F_HW_CSUM</span><span class="p">);</span>

	<span class="cm">/* Set user-changeable features (subset of all device features) */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_RXFCS</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_SUPP_NOFCS</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_RXALL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_HW_VLAN_FILTER</span><span class="p">)</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_FILTER</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NETIF_F_SG</span> <span class="o">|</span>
				  <span class="n">NETIF_F_TSO</span> <span class="o">|</span>
				  <span class="n">NETIF_F_TSO6</span> <span class="o">|</span>
				  <span class="n">NETIF_F_HW_CSUM</span><span class="p">);</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_UNICAST_FLT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_using_dac</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e1000e_enable_mng_pass_thru</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FLAG_MNG_PT_ENABLED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * before reading the NVM, reset the controller to</span>
<span class="cm">	 * put the device in a known good starting state</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">reset_hw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * systems with ASPM and others may see the checksum fail on the first</span>
<span class="cm">	 * attempt. Let&#39;s give it a few tries</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_validate_nvm_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;The NVM Checksum Is Not Valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_eeprom</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">e1000_eeprom_checks</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* copy the MAC address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000e_read_mac_addr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;NVM Read Error while reading MAC address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="s">&quot;Invalid MAC Address: %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_eeprom</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">e1000_watchdog</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">e1000_update_phy_info</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">,</span> <span class="n">e1000_reset_task</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">,</span> <span class="n">e1000_watchdog_task</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">downshift_task</span><span class="p">,</span> <span class="n">e1000e_downshift_workaround</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">update_phy_task</span><span class="p">,</span> <span class="n">e1000e_update_phy_task</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">print_hang_task</span><span class="p">,</span> <span class="n">e1000_print_hw_hang</span><span class="p">);</span>

	<span class="cm">/* Initialize link parameters. User can change them with ethtool */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">autoneg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fc_autoneg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fc</span><span class="p">.</span><span class="n">requested_mode</span> <span class="o">=</span> <span class="n">e1000_fc_default</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">fc</span><span class="p">.</span><span class="n">current_mode</span> <span class="o">=</span> <span class="n">e1000_fc_default</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">phy</span><span class="p">.</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="mh">0x2f</span><span class="p">;</span>

	<span class="cm">/* ring size defaults */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initial Wake on LAN setting - If APM wake is enabled in</span>
<span class="cm">	 * the EEPROM, enable the ACPI Magic Packet filter</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_APME_IN_WUC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* APME bit in EEPROM is mapped to WUC.APME */</span>
		<span class="n">eeprom_data</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">WUC</span><span class="p">);</span>
		<span class="n">eeprom_apme_mask</span> <span class="o">=</span> <span class="n">E1000_WUC_APME</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">e1000_ich10lan</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="n">E1000_WUC_PHY_WAKE</span><span class="p">))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags2</span> <span class="o">|=</span> <span class="n">FLAG2_HAS_PHY_WAKEUP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_APME_IN_CTRL3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_APME_CHECK_PORT_B</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">bus</span><span class="p">.</span><span class="n">func</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">e1000_read_nvm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_INIT_CONTROL3_PORT_B</span><span class="p">,</span>
				       <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">e1000_read_nvm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="n">NVM_INIT_CONTROL3_PORT_A</span><span class="p">,</span>
				       <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* fetch WoL from EEPROM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="n">eeprom_apme_mask</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">|=</span> <span class="n">E1000_WUFC_MAG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * now that we have the eeprom settings, apply the special cases</span>
<span class="cm">	 * where the eeprom may be wrong or the board simply won&#39;t support</span>
<span class="cm">	 * wake on lan on a particular port</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_WOL</span><span class="p">))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* initialize the wol settings based on the eeprom settings */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span><span class="p">;</span>
	<span class="n">device_set_wakeup_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">);</span>

	<span class="cm">/* save off EEPROM version number */</span>
	<span class="n">e1000_read_nvm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_vers</span><span class="p">);</span>

	<span class="cm">/* reset the hardware with the new settings */</span>
	<span class="n">e1000e_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the controller has AMT, do not set DRV_LOAD until the interface</span>
<span class="cm">	 * is up.  For all other cases, let the f/w know that the h/w is now</span>
<span class="cm">	 * under the control of the driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_AMT</span><span class="p">))</span>
		<span class="n">e1000e_get_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>

	<span class="cm">/* carrier off reporting is important to ethtool even BEFORE open */</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e1000_print_device_info</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev_run_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">pm_runtime_put_noidle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_register:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_AMT</span><span class="p">))</span>
		<span class="n">e1000e_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_eeprom:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">check_reset_block</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">e1000_phy_hw_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">);</span>
<span class="nl">err_hw_init:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
<span class="nl">err_sw_init:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flash_address</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flash_address</span><span class="p">);</span>
	<span class="n">e1000e_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_flashmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="nl">err_ioremap:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">err_alloc_etherdev:</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
	                             <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">));</span>
<span class="nl">err_pci_reg:</span>
<span class="nl">err_dma:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_remove - Device Removal Routine</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_remove is called by the PCI subsystem to alert the driver</span>
<span class="cm"> * that it should release a PCI device.  The could be caused by a</span>
<span class="cm"> * Hot-Plug event, or because the driver is going to be removed from</span>
<span class="cm"> * memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">e1000_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">down</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The timers may be rescheduled, so explicitly disable them</span>
<span class="cm">	 * from being rescheduled.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">down</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_timer</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_timer</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">downshift_task</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">update_phy_task</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">print_hang_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span>
		<span class="n">e1000_power_down_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t lie to e1000_close() down the road. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">down</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_dev_run_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="n">pm_runtime_get_noresume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Release control of h/w to f/w.  If f/w is AMT enabled, this</span>
<span class="cm">	 * would have already happened in close and is redundant.</span>
<span class="cm">	 */</span>
	<span class="n">e1000e_release_hw_control</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">e1000e_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flash_address</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">flash_address</span><span class="p">);</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
	                             <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">));</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* AER disable */</span>
	<span class="n">pci_disable_pcie_error_reporting</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* PCI Error Recovery (ERS) */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="n">e1000_err_handler</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">error_detected</span> <span class="o">=</span> <span class="n">e1000_io_error_detected</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slot_reset</span> <span class="o">=</span> <span class="n">e1000_io_slot_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">e1000_io_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">e1000_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571EB_COPPER</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571EB_FIBER</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571EB_QUAD_COPPER</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571EB_QUAD_COPPER_LP</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571EB_QUAD_FIBER</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571EB_SERDES</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571EB_SERDES_DUAL</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571EB_SERDES_QUAD</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82571PT_QUAD_COPPER</span><span class="p">),</span> <span class="n">board_82571</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82572EI</span><span class="p">),</span> <span class="n">board_82572</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82572EI_COPPER</span><span class="p">),</span> <span class="n">board_82572</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82572EI_FIBER</span><span class="p">),</span> <span class="n">board_82572</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82572EI_SERDES</span><span class="p">),</span> <span class="n">board_82572</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82573E</span><span class="p">),</span> <span class="n">board_82573</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82573E_IAMT</span><span class="p">),</span> <span class="n">board_82573</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82573L</span><span class="p">),</span> <span class="n">board_82573</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82574L</span><span class="p">),</span> <span class="n">board_82574</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82574LA</span><span class="p">),</span> <span class="n">board_82574</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_82583V</span><span class="p">),</span> <span class="n">board_82583</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_80003ES2LAN_COPPER_DPT</span><span class="p">),</span>
	  <span class="n">board_80003es2lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_80003ES2LAN_COPPER_SPT</span><span class="p">),</span>
	  <span class="n">board_80003es2lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_80003ES2LAN_SERDES_DPT</span><span class="p">),</span>
	  <span class="n">board_80003es2lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_80003ES2LAN_SERDES_SPT</span><span class="p">),</span>
	  <span class="n">board_80003es2lan</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH8_IFE</span><span class="p">),</span> <span class="n">board_ich8lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH8_IFE_G</span><span class="p">),</span> <span class="n">board_ich8lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH8_IFE_GT</span><span class="p">),</span> <span class="n">board_ich8lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH8_IGP_AMT</span><span class="p">),</span> <span class="n">board_ich8lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH8_IGP_C</span><span class="p">),</span> <span class="n">board_ich8lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH8_IGP_M</span><span class="p">),</span> <span class="n">board_ich8lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH8_IGP_M_AMT</span><span class="p">),</span> <span class="n">board_ich8lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH8_82567V_3</span><span class="p">),</span> <span class="n">board_ich8lan</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_IFE</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_IFE_G</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_IFE_GT</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_IGP_AMT</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_IGP_C</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_BM</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_IGP_M</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_IGP_M_AMT</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH9_IGP_M_V</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH10_R_BM_LM</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH10_R_BM_LF</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH10_R_BM_V</span><span class="p">),</span> <span class="n">board_ich9lan</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH10_D_BM_LM</span><span class="p">),</span> <span class="n">board_ich10lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH10_D_BM_LF</span><span class="p">),</span> <span class="n">board_ich10lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_ICH10_D_BM_V</span><span class="p">),</span> <span class="n">board_ich10lan</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_PCH_M_HV_LM</span><span class="p">),</span> <span class="n">board_pchlan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_PCH_M_HV_LC</span><span class="p">),</span> <span class="n">board_pchlan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_PCH_D_HV_DM</span><span class="p">),</span> <span class="n">board_pchlan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_PCH_D_HV_DC</span><span class="p">),</span> <span class="n">board_pchlan</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_PCH2_LV_LM</span><span class="p">),</span> <span class="n">board_pch2lan</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_PCH2_LV_V</span><span class="p">),</span> <span class="n">board_pch2lan</span> <span class="p">},</span>

	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_PCH_LPT_I217_LM</span><span class="p">),</span> <span class="n">board_pch_lpt</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">INTEL</span><span class="p">,</span> <span class="n">E1000_DEV_ID_PCH_LPT_I217_V</span><span class="p">),</span> <span class="n">board_pch_lpt</span> <span class="p">},</span>

	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>	<span class="cm">/* terminate list */</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">e1000_pci_tbl</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">e1000_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SET_SYSTEM_SLEEP_PM_OPS</span><span class="p">(</span><span class="n">e1000_suspend</span><span class="p">,</span> <span class="n">e1000_resume</span><span class="p">)</span>
	<span class="n">SET_RUNTIME_PM_OPS</span><span class="p">(</span><span class="n">e1000_runtime_suspend</span><span class="p">,</span>
				<span class="n">e1000_runtime_resume</span><span class="p">,</span> <span class="n">e1000_idle</span><span class="p">)</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="cm">/* PCI Device API Driver */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">e1000_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="n">e1000e_driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">e1000_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>    <span class="o">=</span> <span class="n">e1000_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>   <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">e1000_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">driver</span>   <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_pm_ops</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">e1000_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">err_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_err_handler</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_init_module - Driver Registration Routine</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_init_module is the first routine called when the driver is</span>
<span class="cm"> * loaded. All it does is register with the PCI subsystem.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">e1000_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Intel(R) PRO/1000 Network Driver - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">e1000e_driver_version</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Copyright(c) 1999 - 2012 Intel Corporation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_driver</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">e1000_init_module</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_exit_module - Driver Exit Cleanup Routine</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_exit_module is called just before the driver is removed</span>
<span class="cm"> * from memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">e1000_exit_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">e1000_exit_module</span><span class="p">);</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Intel Corporation, &lt;linux.nics@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel(R) PRO/1000 Network Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>

<span class="cm">/* netdev.c */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
