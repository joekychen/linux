<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › ixgb › ixgb_hw.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>ixgb_hw.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel PRO/10GbE Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2008 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cm">/* ixgb_hw.c</span>
<span class="cm"> * Shared functions for accessing and configuring the adapter</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &quot;ixgb_hw.h&quot;</span>
<span class="cp">#include &quot;ixgb_ids.h&quot;</span>

<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>

<span class="cm">/*  Local function prototypes */</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">ixgb_hash_mc_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span> <span class="n">mc_addr</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgb_mta_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">hash_value</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgb_get_bus_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">ixgb_link_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgb_optics_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgb_optics_reset_bcm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="n">ixgb_phy_type</span> <span class="n">ixgb_identify_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgb_clear_hw_cntrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgb_clear_vfta</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">ixgb_init_rx_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u16</span> <span class="n">ixgb_read_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">reg_address</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">phy_address</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">device_type</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">ixgb_setup_fc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">mac_addr_valid</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">ixgb_mac_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl_reg</span><span class="p">;</span>

	<span class="n">ctrl_reg</span> <span class="o">=</span>  <span class="n">IXGB_CTRL0_RST</span> <span class="o">|</span>
				<span class="n">IXGB_CTRL0_SDP3_DIR</span> <span class="o">|</span>   <span class="cm">/* All pins are Output=1 */</span>
				<span class="n">IXGB_CTRL0_SDP2_DIR</span> <span class="o">|</span>
				<span class="n">IXGB_CTRL0_SDP1_DIR</span> <span class="o">|</span>
				<span class="n">IXGB_CTRL0_SDP0_DIR</span> <span class="o">|</span>
				<span class="n">IXGB_CTRL0_SDP3</span>	 <span class="o">|</span>   <span class="cm">/* Initial value 1101   */</span>
				<span class="n">IXGB_CTRL0_SDP2</span>	 <span class="o">|</span>
				<span class="n">IXGB_CTRL0_SDP0</span><span class="p">;</span>

<span class="cp">#ifdef HP_ZX1</span>
	<span class="cm">/* Workaround for 82597EX reset errata */</span>
	<span class="n">IXGB_WRITE_REG_IO</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">,</span> <span class="n">ctrl_reg</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">,</span> <span class="n">ctrl_reg</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Delay a few ms just to allow the reset to complete */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">IXGB_DELAY_AFTER_RESET</span><span class="p">);</span>
	<span class="n">ctrl_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">);</span>
<span class="cp">#ifdef DBG</span>
	<span class="cm">/* Make sure the self-clearing global reset bit did self clear */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ctrl_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_CTRL0_RST</span><span class="p">));</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_vendor_id</span> <span class="o">==</span> <span class="n">SUN_SUBVENDOR_ID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl_reg</span> <span class="o">=</span>  <span class="cm">/* Enable interrupt from XFP and SerDes */</span>
			   <span class="n">IXGB_CTRL1_GPI0_EN</span> <span class="o">|</span>
			   <span class="n">IXGB_CTRL1_SDP6_DIR</span> <span class="o">|</span>
			   <span class="n">IXGB_CTRL1_SDP7_DIR</span> <span class="o">|</span>
			   <span class="n">IXGB_CTRL1_SDP6</span> <span class="o">|</span>
			   <span class="n">IXGB_CTRL1_SDP7</span><span class="p">;</span>
		<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL1</span><span class="p">,</span> <span class="n">ctrl_reg</span><span class="p">);</span>
		<span class="n">ixgb_optics_reset_bcm</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">ixgb_phy_type_txn17401</span><span class="p">)</span>
		<span class="n">ixgb_optics_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ctrl_reg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Reset the transmit and receive units; mask and clear all interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>
<span class="n">bool</span>
<span class="nf">ixgb_adapter_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icr_reg</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* If we are stopped or resetting exit gracefully and wait to be</span>
<span class="cm">	 * started again before accessing the hardware.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Exiting because the adapter is already stopped!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the Adapter Stopped flag so other driver functions stop</span>
<span class="cm">	 * touching the Hardware.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter_stopped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Clear interrupt mask to stop board from generating interrupts */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Masking off all interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IMC</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">);</span>

	<span class="cm">/* Disable the Transmit and Receive units.  Then delay to allow</span>
<span class="cm">	 * any pending transactions to complete before we hit the MAC with</span>
<span class="cm">	 * the global reset.</span>
<span class="cm">	 */</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RCTL</span><span class="p">,</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IXGB_RCTL_RXEN</span><span class="p">);</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TCTL</span><span class="p">,</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TCTL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IXGB_TCTL_TXEN</span><span class="p">);</span>
	<span class="n">IXGB_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">IXGB_DELAY_BEFORE_RESET</span><span class="p">);</span>

	<span class="cm">/* Issue a global reset to the MAC.  This will reset the chip&#39;s</span>
<span class="cm">	 * transmit, receive, DMA, and link units.  It will not effect</span>
<span class="cm">	 * the current PCI configuration.  The global reset bit is self-</span>
<span class="cm">	 * clearing, and should clear within a microsecond.</span>
<span class="cm">	 */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Issuing a global reset to MAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ctrl_reg</span> <span class="o">=</span> <span class="n">ixgb_mac_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Clear interrupt mask to stop board from generating interrupts */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Masking off all interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IMC</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>

	<span class="cm">/* Clear any pending interrupt events. */</span>
	<span class="n">icr_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ICR</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ctrl_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_CTRL0_RST</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/******************************************************************************</span>
<span class="cm"> * Identifies the vendor of the optics module on the adapter.  The SR adapters</span>
<span class="cm"> * support two different types of XPAK optics, so it is necessary to determine</span>
<span class="cm"> * which optics are present before applying any optics-specific workarounds.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: the vendor of the XPAK optics module.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">ixgb_xpak_vendor</span>
<span class="nf">ixgb_identify_xpak_vendor</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vendor_name</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">ixgb_xpak_vendor</span> <span class="n">xpak_vendor</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Read the first few bytes of the vendor string from the XPAK NVR</span>
<span class="cm">	 * registers.  These are standard XENPAK/XPAK registers, so all XPAK</span>
<span class="cm">	 * devices should implement them. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vendor_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ixgb_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						   <span class="n">MDIO_PMA_PMD_XPAK_VENDOR_NAME</span>
						   <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">IXGB_PHY_ADDRESS</span><span class="p">,</span>
						   <span class="n">MDIO_MMD_PMAPMD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Determine the actual vendor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vendor_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;I&#39;</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vendor_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;N&#39;</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vendor_name</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;T&#39;</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vendor_name</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">vendor_name</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;L&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xpak_vendor</span> <span class="o">=</span> <span class="n">ixgb_xpak_vendor_intel</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">xpak_vendor</span> <span class="o">=</span> <span class="n">ixgb_xpak_vendor_infineon</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">xpak_vendor</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Determine the physical layer module on the adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code.  The device_id</span>
<span class="cm"> *      field must be (correctly) populated before calling this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: the phy type of the adapter.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">ixgb_phy_type</span>
<span class="nf">ixgb_identify_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ixgb_phy_type</span> <span class="n">phy_type</span><span class="p">;</span>
	<span class="n">ixgb_xpak_vendor</span> <span class="n">xpak_vendor</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Infer the transceiver/phy type from the device id */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IXGB_DEVICE_ID_82597EX</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Identified TXN17401 optics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_phy_type_txn17401</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IXGB_DEVICE_ID_82597EX_SR</span>:
		<span class="cm">/* The SR adapters carry two different types of XPAK optics</span>
<span class="cm">		 * modules; read the vendor identifier to determine the exact</span>
<span class="cm">		 * type of optics. */</span>
		<span class="n">xpak_vendor</span> <span class="o">=</span> <span class="n">ixgb_identify_xpak_vendor</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xpak_vendor</span> <span class="o">==</span> <span class="n">ixgb_xpak_vendor_intel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Identified TXN17201 optics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_phy_type_txn17201</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Identified G6005 optics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_phy_type_g6005</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGB_DEVICE_ID_82597EX_LR</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Identified G6104 optics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_phy_type_g6104</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IXGB_DEVICE_ID_82597EX_CX4</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Identified CX4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">xpak_vendor</span> <span class="o">=</span> <span class="n">ixgb_identify_xpak_vendor</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xpak_vendor</span> <span class="o">==</span> <span class="n">ixgb_xpak_vendor_intel</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Identified TXN17201 optics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_phy_type_txn17201</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Identified G6005 optics</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_phy_type_g6005</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Unknown physical layer module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_phy_type_unknown</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* update phy type for sun specific board */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_vendor_id</span> <span class="o">==</span> <span class="n">SUN_SUBVENDOR_ID</span><span class="p">)</span>
		<span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_phy_type_bcm</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phy_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Performs basic configuration of the adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Resets the controller.</span>
<span class="cm"> * Reads and validates the EEPROM.</span>
<span class="cm"> * Initializes the receive address registers.</span>
<span class="cm"> * Initializes the multicast table.</span>
<span class="cm"> * Clears all on-chip counters.</span>
<span class="cm"> * Calls routine to setup flow control settings.</span>
<span class="cm"> * Leaves the transmit and receive units disabled and uninitialized.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *      true if successful,</span>
<span class="cm"> *      false if unrecoverable problems were encountered.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="n">bool</span>
<span class="nf">ixgb_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_reg</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Issue a global reset to the MAC.  This will reset the chip&#39;s</span>
<span class="cm">	 * transmit, receive, DMA, and link units.  It will not effect</span>
<span class="cm">	 * the current PCI configuration.  The global reset bit is self-</span>
<span class="cm">	 * clearing, and should clear within a microsecond.</span>
<span class="cm">	 */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Issuing a global reset to MAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ctrl_reg</span> <span class="o">=</span> <span class="n">ixgb_mac_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Issuing an EE reset to MAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#ifdef HP_ZX1</span>
	<span class="cm">/* Workaround for 82597EX reset errata */</span>
	<span class="n">IXGB_WRITE_REG_IO</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL1</span><span class="p">,</span> <span class="n">IXGB_CTRL1_EE_RST</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL1</span><span class="p">,</span> <span class="n">IXGB_CTRL1_EE_RST</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* Delay a few ms just to allow the reset to complete */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">IXGB_DELAY_AFTER_EE_RESET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ixgb_get_eeprom_data</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Use the device id to determine the type of phy/transceiver. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">ixgb_get_ee_device_id</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">ixgb_identify_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Setup the receive addresses.</span>
<span class="cm">	 * Receive Address Registers (RARs 0 - 15).</span>
<span class="cm">	 */</span>
	<span class="n">ixgb_init_rx_addrs</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check that a valid MAC address has been set.</span>
<span class="cm">	 * If it is not valid, we fail hardware init.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mac_addr_valid</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">curr_mac_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MAC address invalid after ixgb_init_rx_addrs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* tell the routines in this file they can access hardware again */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter_stopped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Fill in the bus_info structure */</span>
	<span class="n">ixgb_get_bus_info</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Zero out the Multicast HASH table */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Zeroing the MTA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGB_MC_TBL_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MTA</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Zero out the VLAN Filter Table Array */</span>
	<span class="n">ixgb_clear_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Zero all of the hardware counters */</span>
	<span class="n">ixgb_clear_hw_cntrs</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Call a subroutine to setup flow control. */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ixgb_setup_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* 82597EX errata: Call check-for-link in case lane deskew is locked */</span>
	<span class="n">ixgb_check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Initializes receive address filters.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Places the MAC address in receive address register 0 and clears the rest</span>
<span class="cm"> * of the receive address registers. Clears the multicast table. Assumes</span>
<span class="cm"> * the receiver is in reset when the routine is called.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ixgb_init_rx_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the current mac address is valid, assume it is a software override</span>
<span class="cm">	 * to the permanent address.</span>
<span class="cm">	 * Otherwise, use the permanent address from the eeprom.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mac_addr_valid</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">curr_mac_addr</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Get the MAC address from the eeprom for later reference */</span>
		<span class="n">ixgb_get_ee_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">curr_mac_addr</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Keeping Permanent MAC Addr = %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">hw</span><span class="o">-&gt;</span><span class="n">curr_mac_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/* Setup the receive address. */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Overriding MAC Address in RAR[0]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;New MAC Addr = %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">curr_mac_addr</span><span class="p">);</span>

		<span class="n">ixgb_rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">curr_mac_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Zero out the other 15 receive addresses. */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Clearing RAR[1-15]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGB_RAR_ENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Write high reg first to disable the AV bit first */</span>
		<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Updates the MAC&#39;s list of multicast addresses.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * mc_addr_list - the list of new multicast addresses</span>
<span class="cm"> * mc_addr_count - number of addresses</span>
<span class="cm"> * pad - number of bytes between addresses in the list</span>
<span class="cm"> *</span>
<span class="cm"> * The given list replaces any existing list. Clears the last 15 receive</span>
<span class="cm"> * address registers and the multicast table. Uses receive address registers</span>
<span class="cm"> * for the first 15 multicast addresses, and hashes the rest into the</span>
<span class="cm"> * multicast table.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="kt">void</span>
<span class="nf">ixgb_mc_addr_list_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="o">*</span><span class="n">mc_addr_list</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">mc_addr_count</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">pad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash_value</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_used_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* RAR[0] is used for our MAC address */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">mca</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Set the new number of MC addresses that we are being requested to use. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">num_mc_addrs</span> <span class="o">=</span> <span class="n">mc_addr_count</span><span class="p">;</span>

	<span class="cm">/* Clear RAR[1-15] */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Clearing RAR[1-15]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">rar_used_count</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGB_RAR_ENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clear the MTA */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Clearing MTA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IXGB_MC_TBL_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MTA</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Add the new addresses */</span>
	<span class="n">mca</span> <span class="o">=</span> <span class="n">mc_addr_list</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mc_addr_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Adding the multicast addresses:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MC Addr #%d = %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mca</span><span class="p">);</span>

		<span class="cm">/* Place this multicast address in the RAR if there is room, *</span>
<span class="cm">		 * else put it in the MTA</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rar_used_count</span> <span class="o">&lt;</span> <span class="n">IXGB_RAR_ENTRIES</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ixgb_rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mca</span><span class="p">,</span> <span class="n">rar_used_count</span><span class="p">);</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Added a multicast address to RAR[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">rar_used_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hash_value</span> <span class="o">=</span> <span class="n">ixgb_hash_mc_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mca</span><span class="p">);</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Hash value = 0x%03X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hash_value</span><span class="p">);</span>

			<span class="n">ixgb_mta_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hash_value</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">mca</span> <span class="o">+=</span> <span class="n">ETH_ALEN</span> <span class="o">+</span> <span class="n">pad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MC Update Complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Hashes an address to determine its location in the multicast table</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * mc_addr - the multicast address to hash</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *      The hash value</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">u32</span>
<span class="nf">ixgb_hash_mc_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		   <span class="n">u8</span> <span class="o">*</span><span class="n">mc_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* The portion of the address that is used for the hash table is</span>
<span class="cm">	 * determined by the mc_filter_type setting.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mc_filter_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* [0] [1] [2] [3] [4] [5]</span>
<span class="cm">		 * 01  AA  00  12  34  56</span>
<span class="cm">		 * LSB                 MSB - According to H/W docs */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* [47:36] i.e. 0x563 for above example address */</span>
		<span class="n">hash_value</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:		<span class="cm">/* [46:35] i.e. 0xAC6 for above example address */</span>
		<span class="n">hash_value</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:		<span class="cm">/* [45:34] i.e. 0x5D8 for above example address */</span>
		<span class="n">hash_value</span> <span class="o">=</span>
		    <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:		<span class="cm">/* [43:32] i.e. 0x634 for above example address */</span>
		<span class="n">hash_value</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Invalid mc_filter_type, what should we do? */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MC filter type param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hash_value</span> <span class="o">&amp;=</span> <span class="mh">0xFFF</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hash_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Sets the bit in the multicast table corresponding to the hash value.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * hash_value - Multicast address hash value</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ixgb_mta_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		  <span class="n">u32</span> <span class="n">hash_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash_bit</span><span class="p">,</span> <span class="n">hash_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mta_reg</span><span class="p">;</span>

	<span class="cm">/* The MTA is a register array of 128 32-bit registers.</span>
<span class="cm">	 * It is treated like an array of 4096 bits.  We want to set</span>
<span class="cm">	 * bit BitArray[hash_value]. So we figure out what register</span>
<span class="cm">	 * the bit is in, read it, OR in the new bit, then write</span>
<span class="cm">	 * back the new value.  The register is determined by the</span>
<span class="cm">	 * upper 7 bits of the hash value and the bit within that</span>
<span class="cm">	 * register are determined by the lower 5 bits of the value.</span>
<span class="cm">	 */</span>
	<span class="n">hash_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
	<span class="n">hash_bit</span> <span class="o">=</span> <span class="n">hash_value</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">;</span>

	<span class="n">mta_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MTA</span><span class="p">,</span> <span class="n">hash_reg</span><span class="p">);</span>

	<span class="n">mta_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash_bit</span><span class="p">);</span>

	<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MTA</span><span class="p">,</span> <span class="n">hash_reg</span><span class="p">,</span> <span class="n">mta_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Puts an ethernet address into a receive address register.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * addr - Address to put into receive address register</span>
<span class="cm"> * index - Receive address register to write</span>
<span class="cm"> *****************************************************************************/</span>
<span class="kt">void</span>
<span class="nf">ixgb_rar_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		  <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
		  <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rar_low</span><span class="p">,</span> <span class="n">rar_high</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* HW expects these in little endian so we reverse the byte order</span>
<span class="cm">	 * from network order (big endian) to little endian</span>
<span class="cm">	 */</span>
	<span class="n">rar_low</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span>
		   <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>

	<span class="n">rar_high</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span>
			<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">IXGB_RAH_AV</span><span class="p">);</span>

	<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rar_low</span><span class="p">);</span>
	<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">((</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rar_high</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Writes a value to the specified offset in the VLAN filter table.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> * offset - Offset in VLAN filer table to write</span>
<span class="cm"> * value - Value to write into VLAN filter table</span>
<span class="cm"> *****************************************************************************/</span>
<span class="kt">void</span>
<span class="nf">ixgb_write_vfta</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		 <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span>
		 <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Clears the VLAN filer table</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ixgb_clear_vfta</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">IXGB_VLAN_FILTER_TBL_SIZE</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span>
		<span class="n">IXGB_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Configures the flow control settings based on SW configuration.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">ixgb_setup_fc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pap_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* by default, assume no pause time */</span>
	<span class="n">bool</span> <span class="n">status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Get the current control reg 0 settings */</span>
	<span class="n">ctrl_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">);</span>

	<span class="cm">/* Clear the Receive Pause Enable and Transmit Pause Enable bits */</span>
	<span class="n">ctrl_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IXGB_CTRL0_RPE</span> <span class="o">|</span> <span class="n">IXGB_CTRL0_TPE</span><span class="p">);</span>

	<span class="cm">/* The possible values of the &quot;flow_control&quot; parameter are:</span>
<span class="cm">	 *      0:  Flow control is completely disabled</span>
<span class="cm">	 *      1:  Rx flow control is enabled (we can receive pause frames</span>
<span class="cm">	 *          but not send pause frames).</span>
<span class="cm">	 *      2:  Tx flow control is enabled (we can send pause frames</span>
<span class="cm">	 *          but we do not support receiving pause frames).</span>
<span class="cm">	 *      3:  Both Rx and TX flow control (symmetric) are enabled.</span>
<span class="cm">	 *  other:  Invalid.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgb_fc_none</span>:	<span class="cm">/* 0 */</span>
		<span class="cm">/* Set CMDC bit to disable Rx Flow control */</span>
		<span class="n">ctrl_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IXGB_CTRL0_CMDC</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgb_fc_rx_pause</span>:	<span class="cm">/* 1 */</span>
		<span class="cm">/* RX Flow control is enabled, and TX Flow control is</span>
<span class="cm">		 * disabled.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IXGB_CTRL0_RPE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgb_fc_tx_pause</span>:	<span class="cm">/* 2 */</span>
		<span class="cm">/* TX Flow control is enabled, and RX Flow control is</span>
<span class="cm">		 * disabled, by a software over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IXGB_CTRL0_TPE</span><span class="p">);</span>
		<span class="n">pap_reg</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">pause_time</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgb_fc_full</span>:	<span class="cm">/* 3 */</span>
		<span class="cm">/* Flow control (both RX and TX) is enabled by a software</span>
<span class="cm">		 * over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IXGB_CTRL0_RPE</span> <span class="o">|</span> <span class="n">IXGB_CTRL0_TPE</span><span class="p">);</span>
		<span class="n">pap_reg</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">pause_time</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* We should never get here.  The value should be 0-3. */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Flow control param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ASSERT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write the new settings */</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">,</span> <span class="n">ctrl_reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pap_reg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PAP</span><span class="p">,</span> <span class="n">pap_reg</span><span class="p">);</span>

	<span class="cm">/* Set the flow control receive threshold registers.  Normally,</span>
<span class="cm">	 * these registers will be set to a default threshold that may be</span>
<span class="cm">	 * adjusted later by the driver&#39;s runtime code.  However, if the</span>
<span class="cm">	 * ability to transmit pause frames in not enabled, then these</span>
<span class="cm">	 * registers will be set to 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">ixgb_fc_tx_pause</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">FCRTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">FCRTH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	   <span class="cm">/* We need to set up the Receive Threshold high and low water</span>
<span class="cm">	    * marks as well as (optionally) enabling the transmission of XON</span>
<span class="cm">	    * frames. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">send_xon</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">FCRTL</span><span class="p">,</span>
				<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">low_water</span> <span class="o">|</span> <span class="n">IXGB_FCRTL_XONE</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">FCRTL</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">low_water</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">FCRTH</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">.</span><span class="n">high_water</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Reads a word from a device over the Management Data Interface (MDI) bus.</span>
<span class="cm"> * This interface is used to manage Physical layer devices.</span>
<span class="cm"> *</span>
<span class="cm"> * hw          - Struct containing variables accessed by hw code</span>
<span class="cm"> * reg_address - Offset of device register being read.</span>
<span class="cm"> * phy_address - Address of device on MDI.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:  Data word (16 bits) from MDI device.</span>
<span class="cm"> *</span>
<span class="cm"> * The 82597EX has support for several MDI access methods.  This routine</span>
<span class="cm"> * uses the new protocol MDI Single Command and Address Operation.</span>
<span class="cm"> * This requires that first an address cycle command is sent, followed by a</span>
<span class="cm"> * read command.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">u16</span>
<span class="nf">ixgb_read_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">reg_address</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">phy_address</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">device_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">reg_address</span> <span class="o">&lt;=</span> <span class="n">IXGB_MAX_PHY_REG_ADDRESS</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">phy_address</span> <span class="o">&lt;=</span> <span class="n">IXGB_MAX_PHY_ADDRESS</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">device_type</span> <span class="o">&lt;=</span> <span class="n">IXGB_MAX_PHY_DEV_TYPE</span><span class="p">);</span>

	<span class="cm">/* Setup and write the address cycle command */</span>
	<span class="n">command</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg_address</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_NP_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">device_type</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_DEV_TYPE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">phy_address</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_PHY_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">IXGB_MSCA_ADDR_CYCLE</span> <span class="o">|</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">));</span>

	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSCA</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

    <span class="cm">/**************************************************************</span>
<span class="cm">    ** Check every 10 usec to see if the address cycle completed</span>
<span class="cm">    ** The COMMAND bit will clear when the operation is complete.</span>
<span class="cm">    ** This may take as long as 64 usecs (we&#39;ll wait 100 usecs max)</span>
<span class="cm">    ** from the CPU Write to the Ready bit assertion.</span>
<span class="cm">    **************************************************************/</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">command</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSCA</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Address cycle complete, setup and write the read command */</span>
	<span class="n">command</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg_address</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_NP_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">device_type</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_DEV_TYPE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">phy_address</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_PHY_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">(</span><span class="n">IXGB_MSCA_READ</span> <span class="o">|</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">));</span>

	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSCA</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

    <span class="cm">/**************************************************************</span>
<span class="cm">    ** Check every 10 usec to see if the read command completed</span>
<span class="cm">    ** The COMMAND bit will clear when the operation is complete.</span>
<span class="cm">    ** The read may take as long as 64 usecs (we&#39;ll wait 100 usecs max)</span>
<span class="cm">    ** from the CPU Write to the Ready bit assertion.</span>
<span class="cm">    **************************************************************/</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">command</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSCA</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Operation is complete, get the data from the MDIO Read/Write Data</span>
<span class="cm">	 * register and return.</span>
<span class="cm">	 */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSRWD</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">&gt;&gt;=</span> <span class="n">IXGB_MSRWD_READ_DATA_SHIFT</span><span class="p">;</span>
	<span class="k">return</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Writes a word to a device over the Management Data Interface (MDI) bus.</span>
<span class="cm"> * This interface is used to manage Physical layer devices.</span>
<span class="cm"> *</span>
<span class="cm"> * hw          - Struct containing variables accessed by hw code</span>
<span class="cm"> * reg_address - Offset of device register being read.</span>
<span class="cm"> * phy_address - Address of device on MDI.</span>
<span class="cm"> * device_type - Also known as the Device ID or DID.</span>
<span class="cm"> * data        - 16-bit value to be written</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:  void.</span>
<span class="cm"> *</span>
<span class="cm"> * The 82597EX has support for several MDI access methods.  This routine</span>
<span class="cm"> * uses the new protocol MDI Single Command and Address Operation.</span>
<span class="cm"> * This requires that first an address cycle command is sent, followed by a</span>
<span class="cm"> * write command.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ixgb_write_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">reg_address</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">phy_address</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">device_type</span><span class="p">,</span>
			<span class="n">u16</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">reg_address</span> <span class="o">&lt;=</span> <span class="n">IXGB_MAX_PHY_REG_ADDRESS</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">phy_address</span> <span class="o">&lt;=</span> <span class="n">IXGB_MAX_PHY_ADDRESS</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">device_type</span> <span class="o">&lt;=</span> <span class="n">IXGB_MAX_PHY_DEV_TYPE</span><span class="p">);</span>

	<span class="cm">/* Put the data in the MDIO Read/Write Data register */</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSRWD</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>

	<span class="cm">/* Setup and write the address cycle command */</span>
	<span class="n">command</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg_address</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_NP_ADDR_SHIFT</span><span class="p">)</span>  <span class="o">|</span>
			   <span class="p">(</span><span class="n">device_type</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_DEV_TYPE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			   <span class="p">(</span><span class="n">phy_address</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_PHY_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			   <span class="p">(</span><span class="n">IXGB_MSCA_ADDR_CYCLE</span> <span class="o">|</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">));</span>

	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSCA</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

	<span class="cm">/**************************************************************</span>
<span class="cm">	** Check every 10 usec to see if the address cycle completed</span>
<span class="cm">	** The COMMAND bit will clear when the operation is complete.</span>
<span class="cm">	** This may take as long as 64 usecs (we&#39;ll wait 100 usecs max)</span>
<span class="cm">	** from the CPU Write to the Ready bit assertion.</span>
<span class="cm">	**************************************************************/</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">command</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSCA</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Address cycle complete, setup and write the write command */</span>
	<span class="n">command</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg_address</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_NP_ADDR_SHIFT</span><span class="p">)</span>  <span class="o">|</span>
			   <span class="p">(</span><span class="n">device_type</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_DEV_TYPE_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			   <span class="p">(</span><span class="n">phy_address</span> <span class="o">&lt;&lt;</span> <span class="n">IXGB_MSCA_PHY_ADDR_SHIFT</span><span class="p">)</span> <span class="o">|</span>
			   <span class="p">(</span><span class="n">IXGB_MSCA_WRITE</span> <span class="o">|</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">));</span>

	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSCA</span><span class="p">,</span> <span class="n">command</span><span class="p">);</span>

	<span class="cm">/**************************************************************</span>
<span class="cm">	** Check every 10 usec to see if the read command completed</span>
<span class="cm">	** The COMMAND bit will clear when the operation is complete.</span>
<span class="cm">	** The write may take as long as 64 usecs (we&#39;ll wait 100 usecs max)</span>
<span class="cm">	** from the CPU Write to the Ready bit assertion.</span>
<span class="cm">	**************************************************************/</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">command</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MSCA</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">((</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">IXGB_MSCA_MDI_COMMAND</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Operation is complete, return. */</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Checks to see if the link status of the hardware has changed.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by hw code</span>
<span class="cm"> *</span>
<span class="cm"> * Called by any function that needs to check the link status of the adapter.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="kt">void</span>
<span class="nf">ixgb_check_for_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status_reg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">xpcss_reg</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="n">xpcss_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">XPCSS</span><span class="p">);</span>
	<span class="n">status_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">xpcss_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_XPCSS_ALIGN_STATUS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_STATUS_LU</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">link_up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">xpcss_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_XPCSS_ALIGN_STATUS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_STATUS_LU</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;XPCSS Not Aligned while Status:LU is set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">link_up</span> <span class="o">=</span> <span class="n">ixgb_link_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 82597EX errata.  Since the lane deskew problem may prevent</span>
<span class="cm">		 * link, reset the link before reporting link down.</span>
<span class="cm">		 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">link_up</span> <span class="o">=</span> <span class="n">ixgb_link_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*  Anything else for 10 Gig?? */</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Check for a bad link condition that may have occurred.</span>
<span class="cm"> * The indication is that the RFC / LFC registers may be incrementing</span>
<span class="cm"> * continually.  A full adapter reset is required to recover.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by hw code</span>
<span class="cm"> *</span>
<span class="cm"> * Called by any function that needs to check the link status of the adapter.</span>
<span class="cm"> *****************************************************************************/</span>
<span class="n">bool</span> <span class="nf">ixgb_check_for_bad_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">newLFC</span><span class="p">,</span> <span class="n">newRFC</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bad_link_returncode</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">ixgb_phy_type_txn17401</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">newLFC</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">LFC</span><span class="p">);</span>
		<span class="n">newRFC</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RFC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lastLFC</span> <span class="o">+</span> <span class="mi">250</span> <span class="o">&lt;</span> <span class="n">newLFC</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">lastRFC</span> <span class="o">+</span> <span class="mi">250</span> <span class="o">&lt;</span> <span class="n">newRFC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;BAD LINK! too many LFC/RFC since last check</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">bad_link_returncode</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">lastLFC</span> <span class="o">=</span> <span class="n">newLFC</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">lastRFC</span> <span class="o">=</span> <span class="n">newRFC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bad_link_returncode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Clears all hardware statistics counters.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ixgb_clear_hw_cntrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">temp_reg</span><span class="p">;</span>

	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* if we are stopped or resetting exit gracefully */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">adapter_stopped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Exiting because the adapter is stopped!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TPRL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TPRH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GPRCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GPRCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BPRCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BPRCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MPRCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MPRCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">UPRCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">UPRCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VPRCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VPRCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">JPRCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">JPRCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GORCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GORCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TORL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TORH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RNBC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RUC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ROC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RLEC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CRCERRS</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ICBC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ECBC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MPC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TPTL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TPTH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GPTCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GPTCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BPTCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">BPTCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MPTCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MPTCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">UPTCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">UPTCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VPTCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VPTCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">JPTCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">JPTCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GOTCL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">GOTCH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TOTL</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TOTH</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">DC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PLT64C</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TSCTC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">TSCTFC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IBIC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RFC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">LFC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PFRC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PFTC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MCFRC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MCFTC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">XONRXC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">XONTXC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">XOFFRXC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">XOFFTXC</span><span class="p">);</span>
	<span class="n">temp_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RJC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Turns on the software controllable LED</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>
<span class="kt">void</span>
<span class="nf">ixgb_led_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl0_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">);</span>

	<span class="cm">/* To turn on the LED, clear software-definable pin 0 (SDP0). */</span>
	<span class="n">ctrl0_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGB_CTRL0_SDP0</span><span class="p">;</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">,</span> <span class="n">ctrl0_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Turns off the software controllable LED</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>
<span class="kt">void</span>
<span class="nf">ixgb_led_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl0_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">);</span>

	<span class="cm">/* To turn off the LED, set software-definable pin 0 (SDP0). */</span>
	<span class="n">ctrl0_reg</span> <span class="o">|=</span> <span class="n">IXGB_CTRL0_SDP0</span><span class="p">;</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">,</span> <span class="n">ctrl0_reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Gets the current PCI bus type, speed, and width of the hardware</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ixgb_get_bus_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status_reg</span><span class="p">;</span>

	<span class="n">status_reg</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_STATUS_PCIX_MODE</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">ixgb_bus_type_pcix</span> <span class="o">:</span> <span class="n">ixgb_bus_type_pci</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgb_bus_type_pci</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_STATUS_PCI_SPD</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">ixgb_bus_speed_66</span> <span class="o">:</span> <span class="n">ixgb_bus_speed_33</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_STATUS_PCIX_SPD_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IXGB_STATUS_PCIX_SPD_66</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">ixgb_bus_speed_66</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IXGB_STATUS_PCIX_SPD_100</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">ixgb_bus_speed_100</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IXGB_STATUS_PCIX_SPD_133</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">ixgb_bus_speed_133</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="n">ixgb_bus_speed_reserved</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">IXGB_STATUS_BUS64</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">ixgb_bus_width_64</span> <span class="o">:</span> <span class="n">ixgb_bus_width_32</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Tests a MAC address to ensure it is a valid Individual Address</span>
<span class="cm"> *</span>
<span class="cm"> * mac_addr - pointer to MAC address.</span>
<span class="cm"> *</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">mac_addr_valid</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">ENTER</span><span class="p">();</span>

	<span class="cm">/* Make sure it is not a multicast address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_multicast_ether_addr</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MAC address is multicast</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Not a broadcast address */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_broadcast_ether_addr</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MAC address is broadcast</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Reject the zero address */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_zero_ether_addr</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;MAC address is all zeros</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">is_valid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Resets the 10GbE link.  Waits the settle time and returns the state of</span>
<span class="cm"> * the link.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">ixgb_link_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">link_status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wait_retries</span> <span class="o">=</span> <span class="n">MAX_RESET_ITERATIONS</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">lrst_retries</span> <span class="o">=</span> <span class="n">MAX_RESET_ITERATIONS</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Reset the link */</span>
		<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">,</span>
			       <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">)</span> <span class="o">|</span> <span class="n">IXGB_CTRL0_LRST</span><span class="p">);</span>

		<span class="cm">/* Wait for link-up and lane re-alignment */</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="n">IXGB_DELAY_USECS_AFTER_LINK_RESET</span><span class="p">);</span>
			<span class="n">link_status</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IXGB_STATUS_LU</span><span class="p">)</span>
			     <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">XPCSS</span><span class="p">)</span> <span class="o">&amp;</span>
				 <span class="n">IXGB_XPCSS_ALIGN_STATUS</span><span class="p">))</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">link_status</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">wait_retries</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">link_status</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">lrst_retries</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">link_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Resets the 10GbE optics module.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ixgb_optics_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">ixgb_phy_type_txn17401</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">mdio_reg</span><span class="p">;</span>

		<span class="n">ixgb_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
				   <span class="n">MDIO_CTRL1</span><span class="p">,</span>
				   <span class="n">IXGB_PHY_ADDRESS</span><span class="p">,</span>
				   <span class="n">MDIO_MMD_PMAPMD</span><span class="p">,</span>
				   <span class="n">MDIO_CTRL1_RESET</span><span class="p">);</span>

		<span class="n">mdio_reg</span> <span class="o">=</span> <span class="n">ixgb_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					     <span class="n">MDIO_CTRL1</span><span class="p">,</span>
					     <span class="n">IXGB_PHY_ADDRESS</span><span class="p">,</span>
					     <span class="n">MDIO_MMD_PMAPMD</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/******************************************************************************</span>
<span class="cm"> * Resets the 10GbE optics module for Sun variant NIC.</span>
<span class="cm"> *</span>
<span class="cm"> * hw - Struct containing variables accessed by shared code</span>
<span class="cm"> *****************************************************************************/</span>

<span class="cp">#define   IXGB_BCM8704_USER_PMD_TX_CTRL_REG         0xC803</span>
<span class="cp">#define   IXGB_BCM8704_USER_PMD_TX_CTRL_REG_VAL     0x0164</span>
<span class="cp">#define   IXGB_BCM8704_USER_CTRL_REG                0xC800</span>
<span class="cp">#define   IXGB_BCM8704_USER_CTRL_REG_VAL            0x7FBF</span>
<span class="cp">#define   IXGB_BCM8704_USER_DEV3_ADDR               0x0003</span>
<span class="cp">#define   IXGB_SUN_PHY_ADDRESS                      0x0000</span>
<span class="cp">#define   IXGB_SUN_PHY_RESET_DELAY                     305</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ixgb_optics_reset_bcm</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgb_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span> <span class="o">=</span> <span class="n">IXGB_READ_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGB_CTRL0_SDP2</span><span class="p">;</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">IXGB_CTRL0_SDP3</span><span class="p">;</span>
	<span class="n">IXGB_WRITE_REG</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL0</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">IXGB_WRITE_FLUSH</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* SerDes needs extra delay */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">IXGB_SUN_PHY_RESET_DELAY</span><span class="p">);</span>

	<span class="cm">/* Broadcom 7408L configuration */</span>
	<span class="cm">/* Reference clock config */</span>
	<span class="n">ixgb_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			   <span class="n">IXGB_BCM8704_USER_PMD_TX_CTRL_REG</span><span class="p">,</span>
			   <span class="n">IXGB_SUN_PHY_ADDRESS</span><span class="p">,</span>
			   <span class="n">IXGB_BCM8704_USER_DEV3_ADDR</span><span class="p">,</span>
			   <span class="n">IXGB_BCM8704_USER_PMD_TX_CTRL_REG_VAL</span><span class="p">);</span>
	<span class="cm">/*  we must read the registers twice */</span>
	<span class="n">ixgb_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			  <span class="n">IXGB_BCM8704_USER_PMD_TX_CTRL_REG</span><span class="p">,</span>
			  <span class="n">IXGB_SUN_PHY_ADDRESS</span><span class="p">,</span>
			  <span class="n">IXGB_BCM8704_USER_DEV3_ADDR</span><span class="p">);</span>
	<span class="n">ixgb_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			  <span class="n">IXGB_BCM8704_USER_PMD_TX_CTRL_REG</span><span class="p">,</span>
			  <span class="n">IXGB_SUN_PHY_ADDRESS</span><span class="p">,</span>
			  <span class="n">IXGB_BCM8704_USER_DEV3_ADDR</span><span class="p">);</span>

	<span class="n">ixgb_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			   <span class="n">IXGB_BCM8704_USER_CTRL_REG</span><span class="p">,</span>
			   <span class="n">IXGB_SUN_PHY_ADDRESS</span><span class="p">,</span>
			   <span class="n">IXGB_BCM8704_USER_DEV3_ADDR</span><span class="p">,</span>
			   <span class="n">IXGB_BCM8704_USER_CTRL_REG_VAL</span><span class="p">);</span>
	<span class="n">ixgb_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			  <span class="n">IXGB_BCM8704_USER_CTRL_REG</span><span class="p">,</span>
			  <span class="n">IXGB_SUN_PHY_ADDRESS</span><span class="p">,</span>
			  <span class="n">IXGB_BCM8704_USER_DEV3_ADDR</span><span class="p">);</span>
	<span class="n">ixgb_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			  <span class="n">IXGB_BCM8704_USER_CTRL_REG</span><span class="p">,</span>
			  <span class="n">IXGB_SUN_PHY_ADDRESS</span><span class="p">,</span>
			  <span class="n">IXGB_BCM8704_USER_DEV3_ADDR</span><span class="p">);</span>

	<span class="cm">/* SerDes needs extra delay */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="n">IXGB_SUN_PHY_RESET_DELAY</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
