<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › e1000 › e1000_main.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>e1000_main.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel PRO/1000 Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2006 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#include &quot;e1000.h&quot;</span>
<span class="cp">#include &lt;net/ip6_checksum.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>

<span class="kt">char</span> <span class="n">e1000_driver_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;e1000&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">e1000_driver_string</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Intel(R) PRO/1000 Network Driver&quot;</span><span class="p">;</span>
<span class="cp">#define DRV_VERSION &quot;7.3.21-k8-NAPI&quot;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">e1000_driver_version</span><span class="p">[]</span> <span class="o">=</span> <span class="n">DRV_VERSION</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">e1000_copyright</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Copyright (c) 1999-2006 Intel Corporation.&quot;</span><span class="p">;</span>

<span class="cm">/* e1000_pci_tbl - PCI Device ID Table</span>
<span class="cm"> *</span>
<span class="cm"> * Last entry must be all 0s</span>
<span class="cm"> *</span>
<span class="cm"> * Macro expands to...</span>
<span class="cm"> *   {PCI_DEVICE(PCI_VENDOR_ID_INTEL, device_id)}</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">e1000_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1001</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1004</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1008</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1009</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x100C</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x100D</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x100E</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x100F</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1010</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1011</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1012</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1013</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1014</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1015</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1016</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1017</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1018</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1019</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x101A</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x101D</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x101E</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1026</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1027</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1028</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1075</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1076</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1077</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1078</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1079</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x107A</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x107B</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x107C</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x108A</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x1099</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x10B5</span><span class="p">),</span>
	<span class="n">INTEL_E1000_ETHERNET_DEVICE</span><span class="p">(</span><span class="mh">0x2E6E</span><span class="p">),</span>
	<span class="cm">/* required last entry */</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">e1000_pci_tbl</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">e1000_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">e1000_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">e1000_reinit_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">e1000_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">e1000_setup_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">e1000_setup_all_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">e1000_free_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">e1000_free_all_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_setup_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">txdr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_setup_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rxdr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_free_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_free_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">e1000_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_exit_module</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="n">e1000_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_alloc_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_sw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_configure_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_configure_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_setup_rctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clean_all_tx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clean_all_rx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clean_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clean_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_update_phy_info_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_82547_tx_fifo_stall_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="n">e1000_xmit_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span> <span class="n">e1000_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_set_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">e1000_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">e1000_clean_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">e1000_clean_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">);</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">e1000_clean_jumbo_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_alloc_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">cleaned_count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_alloc_jumbo_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">cleaned_count</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_enter_82542_rst</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_leave_82542_rst</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_smartspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_82547_fifo_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                                       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">e1000_vlan_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_vlan_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			    <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_vlan_filter_on_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">filter_on</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_restore_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">e1000_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/* for netdump / net console */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_netpoll</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#define COPYBREAK_DEFAULT 256</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">copybreak</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">COPYBREAK_DEFAULT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">copybreak</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">copybreak</span><span class="p">,</span>
	<span class="s">&quot;Maximum size of packet that is copied to a new buffer on receive&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="n">e1000_io_error_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
                     <span class="n">pci_channel_state_t</span> <span class="n">state</span><span class="p">);</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="n">e1000_io_slot_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_io_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="n">e1000_err_handler</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">error_detected</span> <span class="o">=</span> <span class="n">e1000_io_error_detected</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slot_reset</span> <span class="o">=</span> <span class="n">e1000_io_slot_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">e1000_io_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">e1000_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="n">e1000_driver_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">e1000_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>    <span class="o">=</span> <span class="n">e1000_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>   <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">e1000_remove</span><span class="p">),</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="cm">/* Power Management Hooks */</span>
	<span class="p">.</span><span class="n">suspend</span>  <span class="o">=</span> <span class="n">e1000_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>   <span class="o">=</span> <span class="n">e1000_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">e1000_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">err_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_err_handler</span>
<span class="p">};</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Intel Corporation, &lt;linux.nics@intel.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Intel(R) PRO/1000 Network Driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>

<span class="cp">#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">debug</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Debug level (0=none,...,16=all)&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_get_hw_dev - return device</span>
<span class="cm"> * used by hardware layer to print debugging information</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">e1000_get_hw_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_init_module - Driver Registration Routine</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_init_module is the first routine called when the driver is</span>
<span class="cm"> * loaded. All it does is register with the PCI subsystem.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">e1000_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s - version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">e1000_driver_string</span><span class="p">,</span> <span class="n">e1000_driver_version</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">e1000_copyright</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copybreak</span> <span class="o">!=</span> <span class="n">COPYBREAK_DEFAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copybreak</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;copybreak disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;copybreak enabled for &quot;</span>
				   <span class="s">&quot;packets &lt;= %u bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">copybreak</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">e1000_init_module</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_exit_module - Driver Exit Cleanup Routine</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_exit_module is called just before the driver is removed</span>
<span class="cm"> * from memory.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">e1000_exit_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_exit</span><span class="p">(</span><span class="n">e1000_exit_module</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_request_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">irq_handler_t</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">e1000_intr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq_flags</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	                  <span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate interrupt Error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_free_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_irq_disable - Mask off interrupt generation on the NIC</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_irq_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_irq_enable - Enable default interrupt generation settings</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">IMS</span><span class="p">,</span> <span class="n">IMS_ENABLE_MASK</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_update_mng_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">vid</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">vlan_id</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">old_vid</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_vlan_used</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
		    <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e1000_vlan_rx_add_vid</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">vid</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">E1000_MNG_VLAN_NONE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">old_vid</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">E1000_MNG_VLAN_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">vid</span> <span class="o">!=</span> <span class="n">old_vid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">old_vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">))</span>
			<span class="n">e1000_vlan_rx_kill_vid</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">old_vid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">vid</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_init_manageability</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">en_mng_pt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">manc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MANC</span><span class="p">);</span>

		<span class="cm">/* disable hardware interception of ARP */</span>
		<span class="n">manc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_MANC_ARP_EN</span><span class="p">);</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">MANC</span><span class="p">,</span> <span class="n">manc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_release_manageability</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">en_mng_pt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">manc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MANC</span><span class="p">);</span>

		<span class="cm">/* re-enable hardware interception of ARP */</span>
		<span class="n">manc</span> <span class="o">|=</span> <span class="n">E1000_MANC_ARP_EN</span><span class="p">;</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">MANC</span><span class="p">,</span> <span class="n">manc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_configure - configure the hardware for RX and TX</span>
<span class="cm"> * @adapter = private board structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">e1000_set_rx_mode</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e1000_restore_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_init_manageability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">e1000_configure_tx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_setup_rctl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_configure_rx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="cm">/* call E1000_DESC_UNUSED which always leaves</span>
<span class="cm">	 * at least 1 descriptor unused to make sure</span>
<span class="cm">	 * next_to_use != next_to_clean */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span>
		                      <span class="n">E1000_DESC_UNUSED</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">e1000_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* hardware has been reset, we need to reload some things */</span>
	<span class="n">e1000_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* fire a link change interrupt to start the watchdog */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_LSC</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_power_up_phy - restore link in case the phy was powered down</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * The phy may be powered down to save power and turn off link when the</span>
<span class="cm"> * driver is unloaded and wake on lan is not enabled (among others)</span>
<span class="cm"> * *** this routine MUST be followed by a call to e1000_reset ***</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">e1000_power_up_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Just clear the power down bit to wake the phy back up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* according to the manual, the phy will retain its</span>
<span class="cm">		 * settings across a power-down/up cycle */</span>
		<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_reg</span><span class="p">);</span>
		<span class="n">mii_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MII_CR_POWER_DOWN</span><span class="p">;</span>
		<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="n">mii_reg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_power_down_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="cm">/* Power down the PHY so no link is implied when interface is down *</span>
<span class="cm">	 * The PHY cannot be powered down if any of the following is true *</span>
<span class="cm">	 * (a) WoL is enabled</span>
<span class="cm">	 * (b) AMT is active</span>
<span class="cm">	 * (c) SoL/IDER session is active */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82540</span> <span class="o">&amp;&amp;</span>
	   <span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">mii_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">e1000_82540</span>:
		<span class="k">case</span> <span class="n">e1000_82545</span>:
		<span class="k">case</span> <span class="n">e1000_82545_rev_3</span>:
		<span class="k">case</span> <span class="n">e1000_82546</span>:
		<span class="k">case</span> <span class="n">e1000_ce4100</span>:
		<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="k">case</span> <span class="n">e1000_82541</span>:
		<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
		<span class="k">case</span> <span class="n">e1000_82547</span>:
		<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">MANC</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_MANC_SMBUS_EN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_reg</span><span class="p">);</span>
		<span class="n">mii_reg</span> <span class="o">|=</span> <span class="n">MII_CR_POWER_DOWN</span><span class="p">;</span>
		<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="n">mii_reg</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_down_and_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Only kill reset task if adapter is not resetting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">);</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_task</span><span class="p">);</span>
	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fifo_stall_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">tctl</span><span class="p">;</span>


	<span class="cm">/* disable receives in the hardware */</span>
	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RCTL_EN</span><span class="p">);</span>
	<span class="cm">/* flush and sleep below */</span>

	<span class="n">netif_tx_disable</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* disable transmits in the hardware */</span>
	<span class="n">tctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
	<span class="n">tctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TCTL_EN</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>
	<span class="cm">/* flush both disables and wait for them to finish */</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">napi_disable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">e1000_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Setting DOWN must be after irq_disable to prevent</span>
<span class="cm">	 * a screaming interrupt.  Setting DOWN also prevents</span>
<span class="cm">	 * tasks from rescheduling.</span>
<span class="cm">	 */</span>
	<span class="n">e1000_down_and_stop</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_clean_all_tx_rings</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_clean_all_rx_rings</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_reinit_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">e1000_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000_reinit_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* if rtnl_lock is not held the call path is bogus */</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">e1000_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_space</span><span class="p">,</span> <span class="n">min_tx_space</span><span class="p">,</span> <span class="n">min_rx_space</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">legacy_pba_adjust</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">hwm</span><span class="p">;</span>

	<span class="cm">/* Repartition Pba for greater than 9k mtu</span>
<span class="cm">	 * To take effect CTRL.RST is required.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
	<span class="k">case</span> <span class="n">e1000_82543</span>:
	<span class="k">case</span> <span class="n">e1000_82544</span>:
	<span class="k">case</span> <span class="n">e1000_82540</span>:
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
		<span class="n">legacy_pba_adjust</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">E1000_PBA_48K</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82545</span>:
	<span class="k">case</span> <span class="n">e1000_82545_rev_3</span>:
	<span class="k">case</span> <span class="n">e1000_82546</span>:
	<span class="k">case</span> <span class="n">e1000_ce4100</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="n">pba</span> <span class="o">=</span> <span class="n">E1000_PBA_48K</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82547</span>:
	<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
		<span class="n">legacy_pba_adjust</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">E1000_PBA_30K</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_undefined</span>:
	<span class="k">case</span> <span class="n">e1000_num_macs</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">legacy_pba_adjust</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">&gt;</span> <span class="n">E1000_RXBUFFER_8192</span><span class="p">)</span>
			<span class="n">pba</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span> <span class="cm">/* allocate more FIFO for Tx */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_head_addr</span> <span class="o">=</span> <span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_TX_HEAD_ADDR_SHIFT</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_size</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">E1000_PBA_40K</span> <span class="o">-</span> <span class="n">pba</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_PBA_BYTES_SHIFT</span><span class="p">;</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_stall</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">&gt;</span>  <span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* adjust PBA for jumbo frames */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">PBA</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>

		<span class="cm">/* To maintain wire speed transmits, the Tx FIFO should be</span>
<span class="cm">		 * large enough to accommodate two full transmit packets,</span>
<span class="cm">		 * rounded up to the next 1KB and expressed in KB.  Likewise,</span>
<span class="cm">		 * the Rx FIFO should be large enough to accommodate at least</span>
<span class="cm">		 * one full receive packet and is similarly rounded up and</span>
<span class="cm">		 * expressed in KB. */</span>
		<span class="n">pba</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PBA</span><span class="p">);</span>
		<span class="cm">/* upper 16 bits has Tx packet buffer allocation size in KB */</span>
		<span class="n">tx_space</span> <span class="o">=</span> <span class="n">pba</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="cm">/* lower 16 bits has Rx packet buffer allocation size in KB */</span>
		<span class="n">pba</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * the tx fifo also stores 16 bytes of information about the tx</span>
<span class="cm">		 * but don&#39;t include ethernet FCS because hardware appends it</span>
<span class="cm">		 */</span>
		<span class="n">min_tx_space</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">+</span>
		                <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_tx_desc</span><span class="p">)</span> <span class="o">-</span>
		                <span class="n">ETH_FCS_LEN</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">min_tx_space</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">min_tx_space</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="n">min_tx_space</span> <span class="o">&gt;&gt;=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="cm">/* software strips receive CRC, so leave room for it */</span>
		<span class="n">min_rx_space</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">;</span>
		<span class="n">min_rx_space</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">min_rx_space</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="n">min_rx_space</span> <span class="o">&gt;&gt;=</span> <span class="mi">10</span><span class="p">;</span>

		<span class="cm">/* If current Tx allocation is less than the min Tx FIFO size,</span>
<span class="cm">		 * and the min Tx FIFO size is less than the current Rx FIFO</span>
<span class="cm">		 * allocation, take space away from current Rx allocation */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_space</span> <span class="o">&lt;</span> <span class="n">min_tx_space</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">min_tx_space</span> <span class="o">-</span> <span class="n">tx_space</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pba</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pba</span> <span class="o">=</span> <span class="n">pba</span> <span class="o">-</span> <span class="p">(</span><span class="n">min_tx_space</span> <span class="o">-</span> <span class="n">tx_space</span><span class="p">);</span>

			<span class="cm">/* PCI/PCIx hardware has PBA alignment constraints */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">e1000_82545</span> <span class="p">...</span> <span class="n">e1000_82546_rev_3</span>:
				<span class="n">pba</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_PBA_8K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* if short on rx space, rx wins and must trump tx</span>
<span class="cm">			 * adjustment or use Early Receive if available */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pba</span> <span class="o">&lt;</span> <span class="n">min_rx_space</span><span class="p">)</span>
				<span class="n">pba</span> <span class="o">=</span> <span class="n">min_rx_space</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">PBA</span><span class="p">,</span> <span class="n">pba</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * flow control settings:</span>
<span class="cm">	 * The high water mark must be low enough to fit one full frame</span>
<span class="cm">	 * (or the size used for early receive) above it in the Rx FIFO.</span>
<span class="cm">	 * Set it to the lower of:</span>
<span class="cm">	 * - 90% of the Rx FIFO size, and</span>
<span class="cm">	 * - the full Rx FIFO size minus the early receive size (for parts</span>
<span class="cm">	 *   with ERT support assuming ERT set to E1000_ERT_2048), or</span>
<span class="cm">	 * - the full Rx FIFO size minus one full frame</span>
<span class="cm">	 */</span>
	<span class="n">hwm</span> <span class="o">=</span> <span class="n">min</span><span class="p">(((</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">10</span><span class="p">),</span>
		  <span class="p">((</span><span class="n">pba</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">));</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_high_water</span> <span class="o">=</span> <span class="n">hwm</span> <span class="o">&amp;</span> <span class="mh">0xFFF8</span><span class="p">;</span>	<span class="cm">/* 8-byte granularity */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_low_water</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_high_water</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_pause_time</span> <span class="o">=</span> <span class="n">E1000_FC_PAUSE_TIME</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_send_xon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">original_fc</span><span class="p">;</span>

	<span class="cm">/* Allow time for pending master requests to run */</span>
	<span class="n">e1000_reset_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82544</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">WUC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_init_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
		<span class="n">e_dev_err</span><span class="p">(</span><span class="s">&quot;Hardware Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">e1000_update_mng_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* if (adapter-&gt;hwflags &amp; HWFLAGS_PHY_PWR_BIT) { */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82544</span> <span class="o">&amp;&amp;</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
		<span class="cm">/* clear phy power management bit if we are in gig only mode,</span>
<span class="cm">		 * which if enabled will attempt negotiation to 100Mb, which</span>
<span class="cm">		 * can cause a loss of link at power off or driver unload */</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_SWDPIN3</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable h/w to recognize an 802.1Q VLAN Ethernet packet */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">VET</span><span class="p">,</span> <span class="n">ETHERNET_IEEE_VLAN_TYPE</span><span class="p">);</span>

	<span class="n">e1000_reset_adaptive</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">e1000_phy_get_info</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info</span><span class="p">);</span>

	<span class="n">e1000_release_manageability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  Dump the eeprom for users having checksum issues</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_dump_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethtool_eeprom</span> <span class="n">eeprom</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ethtool_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">ethtool_ops</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">csum_old</span><span class="p">,</span> <span class="n">csum_new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">eeprom</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_eeprom_len</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">eeprom</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">eeprom</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_eeprom</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">csum_old</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">EEPROM_CHECKSUM_REG</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span>
		   <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">EEPROM_CHECKSUM_REG</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EEPROM_CHECKSUM_REG</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">csum_new</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">csum_new</span> <span class="o">=</span> <span class="n">EEPROM_SUM</span> <span class="o">-</span> <span class="n">csum_new</span><span class="p">;</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;/*********************/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Current EEPROM Checksum : 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csum_old</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Calculated              : 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csum_new</span><span class="p">);</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Offset    Values</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;========  ======</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Include this output when contacting your support provider.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;This is not a software error! Something bad happened to</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;your hardware or EEPROM image. Ignoring this problem could</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;result in further problems, possibly loss of data,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;corruption or system hangs!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;The MAC Address will be reset to 00:00:00:00:00:00,</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;which is invalid and requires you to set the proper MAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;address manually before continuing to enable this network</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;device. Please inspect the EEPROM dump and report the</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;issue to your hardware vendor or Intel Customer Support.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;/*********************/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_is_need_ioport - determine if an adapter needs ioport resources or not</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> *</span>
<span class="cm"> * Return true if an adapter needs ioport resources</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_is_need_ioport</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EM</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EM_LOM</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EP</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EP_LOM</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EP_LP</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541EI</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541EI_MOBILE</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541ER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541ER_LOM</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541GI</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541GI_LF</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541GI_MOBILE</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82544EI_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82544EI_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82544GC_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82544GC_LOM</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82545EM_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82545EM_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546EB_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546EB_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546EB_QUAD_COPPER</span>:
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_features_t</span> <span class="nf">e1000_fix_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since there is no support for separate rx/tx vlan accel</span>
<span class="cm">	 * enable/disable make sure tx flag is always in same state as rx.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">features</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_set_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netdev_features_t</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">features</span> <span class="o">^</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span>
		<span class="n">e1000_vlan_mode</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">changed</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NETIF_F_RXCSUM</span> <span class="o">|</span> <span class="n">NETIF_F_RXALL</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_csum</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000_reinit_locked</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">e1000_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_open</span>		<span class="o">=</span> <span class="n">e1000_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_stop</span>		<span class="o">=</span> <span class="n">e1000_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">e1000_xmit_frame</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_get_stats</span>		<span class="o">=</span> <span class="n">e1000_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_rx_mode</span>	<span class="o">=</span> <span class="n">e1000_set_rx_mode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">e1000_set_mac</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_tx_timeout</span>		<span class="o">=</span> <span class="n">e1000_tx_timeout</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_change_mtu</span>		<span class="o">=</span> <span class="n">e1000_change_mtu</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_do_ioctl</span>		<span class="o">=</span> <span class="n">e1000_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_validate_addr</span>	<span class="o">=</span> <span class="n">eth_validate_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_add_vid</span>	<span class="o">=</span> <span class="n">e1000_vlan_rx_add_vid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_vlan_rx_kill_vid</span>	<span class="o">=</span> <span class="n">e1000_vlan_rx_kill_vid</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
	<span class="p">.</span><span class="n">ndo_poll_controller</span>	<span class="o">=</span> <span class="n">e1000_netpoll</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">ndo_fix_features</span>	<span class="o">=</span> <span class="n">e1000_fix_features</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_features</span>	<span class="o">=</span> <span class="n">e1000_set_features</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_init_hw_struct - initialize members of hw struct</span>
<span class="cm"> * @adapter: board private struct</span>
<span class="cm"> * @hw: structure used by e1000_hw.c</span>
<span class="cm"> *</span>
<span class="cm"> * Factors out initialization of the e1000_hw struct to its own function</span>
<span class="cm"> * that can be called very early at init (just after struct allocation).</span>
<span class="cm"> * Fields are initialized based on PCI device information and</span>
<span class="cm"> * OS network device settings (MTU size).</span>
<span class="cm"> * Returns negative error codes if MAC type setup fails.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_init_hw_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* PCI config space info */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">vendor_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_vendor_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">revision_id</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>

	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">pci_cmd_word</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span>
			     <span class="n">ENET_HEADER_SIZE</span> <span class="o">+</span> <span class="n">ETHERNET_FCS_SIZE</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">min_frame_size</span> <span class="o">=</span> <span class="n">MINIMUM_ETHERNET_FRAME_SIZE</span><span class="p">;</span>

	<span class="cm">/* identify the MAC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_set_mac_type</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unknown MAC Type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82547</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
	<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_init_script</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e1000_set_media_type</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="n">e1000_get_bus_info</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">wait_autoneg_complete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_en</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">adaptive_ifs</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Copper options */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mdix</span> <span class="o">=</span> <span class="n">AUTO_ALL_MODES</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">disable_polarity_correction</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">master_slave</span> <span class="o">=</span> <span class="n">E1000_MASTER_SLAVE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_probe - Device Initialization Routine</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> * @ent: entry in e1000_pci_tbl</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_probe initializes an adapter identified by a pci_dev structure.</span>
<span class="cm"> * The OS initialization, configuring of the adapter private structure,</span>
<span class="cm"> * and a hardware reset occur.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">e1000_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">static</span> <span class="kt">int</span> <span class="n">cards_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">global_quad_port_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* global ksp3 port a indication */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">pci_using_dac</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_apme_mask</span> <span class="o">=</span> <span class="n">E1000_EEPROM_APME</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bars</span><span class="p">,</span> <span class="n">need_ioport</span><span class="p">;</span>

	<span class="cm">/* do not allocate ioport bars when not needed */</span>
	<span class="n">need_ioport</span> <span class="o">=</span> <span class="n">e1000_is_need_ioport</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_ioport</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bars</span> <span class="o">=</span> <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span> <span class="o">|</span> <span class="n">IORESOURCE_IO</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bars</span> <span class="o">=</span> <span class="n">pci_select_bars</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bars</span><span class="p">,</span> <span class="n">e1000_driver_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_pci_reg</span><span class="p">;</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_etherdev</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">netdev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_alloc_etherdev</span><span class="p">;</span>

	<span class="n">SET_NETDEV_DEV</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">netdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_enable</span> <span class="o">=</span> <span class="n">netif_msg_init</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">DEFAULT_MSG_ENABLE</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bars</span> <span class="o">=</span> <span class="n">bars</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">need_ioport</span> <span class="o">=</span> <span class="n">need_ioport</span><span class="p">;</span>

	<span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">BAR_0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_ioremap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">need_ioport</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">BAR_1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">BAR_5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_IO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* make ready for any if (hw-&gt;...) below */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_init_hw_struct</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sw_init</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * there is a workaround being applied below that limits</span>
<span class="cm">	 * 64-bit DMA addresses to 64-bit hardware.  There are some</span>
<span class="cm">	 * 32-bit adapters that Tx hang when given 64-bit DMA addresses</span>
<span class="cm">	 */</span>
	<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">e1000_bus_type_pcix</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * according to DMA-API-HOWTO, coherent calls will always</span>
<span class="cm">		 * succeed if the set call did</span>
<span class="cm">		 */</span>
		<span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="n">pci_using_dac</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dma_set_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;No usable DMA config, aborting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_dma</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dma_set_coherent_mask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e1000_netdev_ops</span><span class="p">;</span>
	<span class="n">e1000_set_ethtool_ops</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">e1000_clean</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>

	<span class="n">strncpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bd_number</span> <span class="o">=</span> <span class="n">cards_found</span><span class="p">;</span>

	<span class="cm">/* setup the private structure */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_sw_init</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_sw_init</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ce4100_gbe_mdio_base_virt</span> <span class="o">=</span>
					<span class="n">ioremap</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">BAR_1</span><span class="p">),</span>
		                                <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">BAR_1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ce4100_gbe_mdio_base_virt</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_mdio_ioremap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span>
				   <span class="n">NETIF_F_HW_CSUM</span> <span class="o">|</span>
				   <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">;</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">NETIF_F_HW_VLAN_TX</span> <span class="o">|</span>
				   <span class="n">NETIF_F_HW_VLAN_FILTER</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">!=</span> <span class="n">e1000_82547</span><span class="p">))</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_SUPP_NOFCS</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_RXCSUM</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_RXALL</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_RXFCS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_using_dac</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_TSO</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_HW_CSUM</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_SG</span><span class="p">;</span>

	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">|=</span> <span class="n">IFF_UNICAST_FLT</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">en_mng_pt</span> <span class="o">=</span> <span class="n">e1000_enable_mng_pass_thru</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* initialize eeprom parameters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_init_eeprom_params</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;EEPROM initialization failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_eeprom</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* before reading the EEPROM, reset the controller to</span>
<span class="cm">	 * put the device in a known good starting state */</span>

	<span class="n">e1000_reset_hw</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* make sure the EEPROM is good */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_validate_eeprom_checksum</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;The EEPROM Checksum Is Not Valid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">e1000_dump_eeprom</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * set MAC address to all zeroes to invalidate and temporary</span>
<span class="cm">		 * disable this device for the user. This blocks regular</span>
<span class="cm">		 * traffic while still permitting ethtool ioctls from reaching</span>
<span class="cm">		 * the hardware as well as allowing the user to run the</span>
<span class="cm">		 * interface after manually setting a hw addr using</span>
<span class="cm">		 * `ip set address`</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* copy the MAC address out of the EEPROM */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_read_mac_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;EEPROM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* don&#39;t block initalization here due to bad MAC address */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">))</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Invalid MAC Address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">,</span> <span class="n">e1000_watchdog</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fifo_stall_task</span><span class="p">,</span>
			  <span class="n">e1000_82547_tx_fifo_stall_task</span><span class="p">);</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_task</span><span class="p">,</span> <span class="n">e1000_update_phy_info_task</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">,</span> <span class="n">e1000_reset_task</span><span class="p">);</span>

	<span class="n">e1000_check_options</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Initial Wake on LAN setting</span>
<span class="cm">	 * If APM wake is enabled in the EEPROM,</span>
<span class="cm">	 * enable the ACPI Magic Packet filter</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
	<span class="k">case</span> <span class="n">e1000_82543</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82544</span>:
		<span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			<span class="n">EEPROM_INIT_CONTROL2_REG</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
		<span class="n">eeprom_apme_mask</span> <span class="o">=</span> <span class="n">E1000_EEPROM_82544_APM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82546</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_FUNC_1</span><span class="p">){</span>
			<span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
				<span class="n">EEPROM_INIT_CONTROL3_PORT_B</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Fall Through */</span>
	<span class="nl">default:</span>
		<span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			<span class="n">EEPROM_INIT_CONTROL3_PORT_A</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="n">eeprom_apme_mask</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">|=</span> <span class="n">E1000_WUFC_MAG</span><span class="p">;</span>

	<span class="cm">/* now that we have the eeprom settings, apply the special cases</span>
<span class="cm">	 * where the eeprom may be wrong or the board simply won&#39;t support</span>
<span class="cm">	 * wake on lan on a particular port */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_PCIE</span>:
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546EB_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_FIBER</span>:
		<span class="cm">/* Wake events only supported on port A for dual fiber</span>
<span class="cm">		 * regardless of eeprom setting */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_FUNC_1</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3</span>:
		<span class="cm">/* if quad port adapter, disable WoL on all but port A */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">global_quad_port_a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quad_port_a</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* Reset for multiple quad port adapters */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">global_quad_port_a</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">global_quad_port_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize the wol settings based on the eeprom settings */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">eeprom_wol</span><span class="p">;</span>
	<span class="n">device_set_wakeup_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">);</span>

	<span class="cm">/* Auto detect PHY address */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_ID2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tmp</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">31</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">err_eeprom</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* reset the hardware with the new settings */</span>
	<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;eth%d&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_register</span><span class="p">;</span>

	<span class="n">e1000_vlan_filter_on_off</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="cm">/* print bus type/speed/width info */</span>
	<span class="n">e_info</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;(PCI%s:%dMHz:%d-bit) %pM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">e1000_bus_type_pcix</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;-X&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
	       <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">==</span> <span class="n">e1000_bus_speed_133</span><span class="p">)</span> <span class="o">?</span> <span class="mi">133</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">==</span> <span class="n">e1000_bus_speed_120</span><span class="p">)</span> <span class="o">?</span> <span class="mi">120</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">==</span> <span class="n">e1000_bus_speed_100</span><span class="p">)</span> <span class="o">?</span> <span class="mi">100</span> <span class="o">:</span>
		<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">==</span> <span class="n">e1000_bus_speed_66</span><span class="p">)</span> <span class="o">?</span> <span class="mi">66</span> <span class="o">:</span> <span class="mi">33</span><span class="p">),</span>
	       <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_width</span> <span class="o">==</span> <span class="n">e1000_bus_width_64</span><span class="p">)</span> <span class="o">?</span> <span class="mi">64</span> <span class="o">:</span> <span class="mi">32</span><span class="p">),</span>
	       <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>

	<span class="cm">/* carrier off reporting is important to ethtool even BEFORE open */</span>
	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e_info</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Intel(R) PRO/1000 Network Connection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">cards_found</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_register:</span>
<span class="nl">err_eeprom:</span>
	<span class="n">e1000_phy_hw_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>
<span class="nl">err_dma:</span>
<span class="nl">err_sw_init:</span>
<span class="nl">err_mdio_ioremap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ce4100_gbe_mdio_base_virt</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
<span class="nl">err_ioremap:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="nl">err_alloc_etherdev:</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bars</span><span class="p">);</span>
<span class="nl">err_pci_reg:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_remove - Device Removal Routine</span>
<span class="cm"> * @pdev: PCI device information struct</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_remove is called by the PCI subsystem to alert the driver</span>
<span class="cm"> * that it should release a PCI device.  The could be caused by a</span>
<span class="cm"> * Hot-Plug event, or because the driver is going to be removed from</span>
<span class="cm"> * memory.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">e1000_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">e1000_down_and_stop</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_release_manageability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e1000_phy_hw_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ce4100_gbe_mdio_base_virt</span><span class="p">);</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">flash_address</span><span class="p">);</span>
	<span class="n">pci_release_selected_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bars</span><span class="p">);</span>

	<span class="n">free_netdev</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_sw_init - Initialize general software structures (struct e1000_adapter)</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * e1000_sw_init initializes the Adapter private data structure.</span>
<span class="cm"> * e1000_init_hw_struct MUST be called before this function</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">e1000_sw_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">MAXIMUM_ETHERNET_VLAN_SIZE</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_alloc_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Explicitly disable IRQ since the NIC can be in any state. */</span>
	<span class="n">e1000_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_alloc_queues - Allocate memory for all rings</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate one ring per queue at run-time since we don&#39;t know the</span>
<span class="cm"> * number of queues at compile-time.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">e1000_alloc_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">,</span>
	                           <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_tx_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">,</span>
	                           <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_rx_ring</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_open - Called when a network interface is made active</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative value on failure</span>
<span class="cm"> *</span>
<span class="cm"> * The open entry point is called when a network interface is made</span>
<span class="cm"> * active by the system (IFF_UP).  At this point all resources needed</span>
<span class="cm"> * for transmit and receive operations are allocated, the interrupt</span>
<span class="cm"> * handler is registered with the OS, the watchdog task is started,</span>
<span class="cm"> * and the stack is notified that the interface is ready.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* disallow open during test */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_TESTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* allocate transmit descriptors */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_setup_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup_tx</span><span class="p">;</span>

	<span class="cm">/* allocate receive descriptors */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_setup_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_setup_rx</span><span class="p">;</span>

	<span class="n">e1000_power_up_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span> <span class="o">=</span> <span class="n">E1000_MNG_VLAN_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
			  <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e1000_update_mng_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* before we allocate an interrupt, we must be ready to handle it.</span>
<span class="cm">	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt</span>
<span class="cm">	 * as soon as we call pci_request_irq, so we have to setup our</span>
<span class="cm">	 * clean_rx handler before we do so.  */</span>
	<span class="n">e1000_configure</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_req_irq</span><span class="p">;</span>

	<span class="cm">/* From here on the code is the same as e1000_up() */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">napi_enable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* fire a link status change interrupt to start the watchdog */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_LSC</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

<span class="nl">err_req_irq:</span>
	<span class="n">e1000_power_down_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_free_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_setup_rx:</span>
	<span class="n">e1000_free_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_setup_tx:</span>
	<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_close - Disables a network interface</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0, this is not allowed to fail</span>
<span class="cm"> *</span>
<span class="cm"> * The close entry point is called when an interface is de-activated</span>
<span class="cm"> * by the OS.  The hardware is still under the drivers control, but</span>
<span class="cm"> * needs to be disabled.  A global MAC reset is issued to stop the</span>
<span class="cm"> * hardware, and all transmit and receive resources are freed.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="n">e1000_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_power_down_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">e1000_free_all_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_free_all_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* kill manageability vlan ID if supported, but not if a vlan with</span>
<span class="cm">	 * the same ID is registered on the host OS (let 8021q kill it) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
			  <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e1000_vlan_rx_kill_vid</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_check_64k_bound - check that memory doesn&#39;t cross 64kB boundary</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> * @start: address of beginning of memory</span>
<span class="cm"> * @len: length of memory</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_check_64k_bound</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">begin</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* First rev 82545 and 82546 need to not allow any memory</span>
<span class="cm">	 * write location to cross 64k boundary due to errata 23 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82545</span> <span class="o">||</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span> <span class="o">||</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82546</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">begin</span> <span class="o">^</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nb">false</span> <span class="o">:</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_tx_resources - allocate Tx resources (Descriptors)</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @txdr:    tx descriptor ring (for a specific queue) to setup</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, negative on failure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_setup_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">txdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">txdr</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for the Tx descriptor &quot;</span>
		      <span class="s">&quot;ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* round up to nearest 4K */</span>

	<span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_tx_desc</span><span class="p">);</span>
	<span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">setup_tx_desc_die:</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for the Tx descriptor &quot;</span>
		      <span class="s">&quot;ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fix for errata 23, can&#39;t cross 64kB boundary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_check_64k_bound</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">olddesc</span> <span class="o">=</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
		<span class="n">dma_addr_t</span> <span class="n">olddma</span> <span class="o">=</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">tx_err</span><span class="p">,</span> <span class="s">&quot;txdr align check failed: %u bytes at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="cm">/* Try again, without freeing the previous */</span>
		<span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="cm">/* Failed allocation, critical failure */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">olddesc</span><span class="p">,</span>
					  <span class="n">olddma</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">setup_tx_desc_die</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_check_64k_bound</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* give up */</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span>
					  <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">olddesc</span><span class="p">,</span>
					  <span class="n">olddma</span><span class="p">);</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate aligned memory &quot;</span>
			      <span class="s">&quot;for the transmit descriptor ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Free old allocation, new allocation was successful */</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">olddesc</span><span class="p">,</span>
					  <span class="n">olddma</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">txdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">txdr</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">txdr</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_all_tx_resources - wrapper to allocate Tx resources</span>
<span class="cm"> * 				  (Descriptors) for all queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, negative on failure</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="nf">e1000_setup_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_setup_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Allocation for Tx Queue %u failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
				<span class="n">e1000_free_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_configure_tx - Configure 8254x Transmit Unit after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Tx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_configure_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">tdba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tdlen</span><span class="p">,</span> <span class="n">tctl</span><span class="p">,</span> <span class="n">tipg</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipgr1</span><span class="p">,</span> <span class="n">ipgr2</span><span class="p">;</span>

	<span class="cm">/* Setup the HW Tx Head and Tail descriptor pointers */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="nl">default:</span>
		<span class="n">tdba</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dma</span><span class="p">;</span>
		<span class="n">tdlen</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_tx_desc</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TDLEN</span><span class="p">,</span> <span class="n">tdlen</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TDBAH</span><span class="p">,</span> <span class="p">(</span><span class="n">tdba</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TDBAL</span><span class="p">,</span> <span class="p">(</span><span class="n">tdba</span> <span class="o">&amp;</span> <span class="mh">0x00000000ffffffffULL</span><span class="p">));</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TDT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TDH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tdh</span> <span class="o">=</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="o">?</span> <span class="n">E1000_TDH</span> <span class="o">:</span> <span class="n">E1000_82542_TDH</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tdt</span> <span class="o">=</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="o">?</span> <span class="n">E1000_TDT</span> <span class="o">:</span> <span class="n">E1000_82542_TDT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the default values for the Tx Inter Packet Gap timer */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span> <span class="o">||</span>
	     <span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">))</span>
		<span class="n">tipg</span> <span class="o">=</span> <span class="n">DEFAULT_82543_TIPG_IPGT_FIBER</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tipg</span> <span class="o">=</span> <span class="n">DEFAULT_82543_TIPG_IPGT_COPPER</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
		<span class="n">tipg</span> <span class="o">=</span> <span class="n">DEFAULT_82542_TIPG_IPGT</span><span class="p">;</span>
		<span class="n">ipgr1</span> <span class="o">=</span> <span class="n">DEFAULT_82542_TIPG_IPGR1</span><span class="p">;</span>
		<span class="n">ipgr2</span> <span class="o">=</span> <span class="n">DEFAULT_82542_TIPG_IPGR2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ipgr1</span> <span class="o">=</span> <span class="n">DEFAULT_82543_TIPG_IPGR1</span><span class="p">;</span>
		<span class="n">ipgr2</span> <span class="o">=</span> <span class="n">DEFAULT_82543_TIPG_IPGR2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tipg</span> <span class="o">|=</span> <span class="n">ipgr1</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_TIPG_IPGR1_SHIFT</span><span class="p">;</span>
	<span class="n">tipg</span> <span class="o">|=</span> <span class="n">ipgr2</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_TIPG_IPGR2_SHIFT</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TIPG</span><span class="p">,</span> <span class="n">tipg</span><span class="p">);</span>

	<span class="cm">/* Set the Tx Interrupt Delay register */</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">TIDV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82540</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TADV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_abs_int_delay</span><span class="p">);</span>

	<span class="cm">/* Program the Transmit Control Register */</span>

	<span class="n">tctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
	<span class="n">tctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TCTL_CT</span><span class="p">;</span>
	<span class="n">tctl</span> <span class="o">|=</span> <span class="n">E1000_TCTL_PSP</span> <span class="o">|</span> <span class="n">E1000_TCTL_RTLC</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">E1000_COLLISION_THRESHOLD</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_CT_SHIFT</span><span class="p">);</span>

	<span class="n">e1000_config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Setup Transmit Descriptor Settings for eop descriptor */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_EOP</span> <span class="o">|</span> <span class="n">E1000_TXD_CMD_IFCS</span><span class="p">;</span>

	<span class="cm">/* only set IDE if we are delaying interrupts using the timers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_int_delay</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_IDE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82543</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_RPS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_RS</span><span class="p">;</span>

	<span class="cm">/* Cache if we&#39;re 82544 running in PCI-X because we&#39;ll</span>
<span class="cm">	 * need this to apply a workaround later in the send path. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82544</span> <span class="o">&amp;&amp;</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">e1000_bus_type_pcix</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pcix_82544</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_rx_resources - allocate Rx resources (Descriptors)</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @rxdr:    rx descriptor ring (for a specific queue) to setup</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_setup_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rxdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">desc_len</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for the Rx descriptor &quot;</span>
		      <span class="s">&quot;ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">desc_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_rx_desc</span><span class="p">);</span>

	<span class="cm">/* Round up to nearest 4K */</span>

	<span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="n">desc_len</span><span class="p">;</span>
	<span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>

	<span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for the Rx descriptor &quot;</span>
		      <span class="s">&quot;ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="nl">setup_rx_desc_die:</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fix for errata 23, can&#39;t cross 64kB boundary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_check_64k_bound</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">olddesc</span> <span class="o">=</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">;</span>
		<span class="n">dma_addr_t</span> <span class="n">olddma</span> <span class="o">=</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">rx_err</span><span class="p">,</span> <span class="s">&quot;rxdr align check failed: %u bytes at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">);</span>
		<span class="cm">/* Try again, without freeing the previous */</span>
		<span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="cm">/* Failed allocation, critical failure */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">olddesc</span><span class="p">,</span>
					  <span class="n">olddma</span><span class="p">);</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory for the Rx &quot;</span>
			      <span class="s">&quot;descriptor ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">setup_rx_desc_die</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_check_64k_bound</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* give up */</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span>
					  <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">olddesc</span><span class="p">,</span>
					  <span class="n">olddma</span><span class="p">);</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unable to allocate aligned memory for &quot;</span>
			      <span class="s">&quot;the Rx descriptor ring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">setup_rx_desc_die</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Free old allocation, new allocation was successful */</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">olddesc</span><span class="p">,</span>
					  <span class="n">olddma</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rxdr</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_all_rx_resources - wrapper to allocate Rx resources</span>
<span class="cm"> * 				  (Descriptors) for all queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, negative on failure</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="nf">e1000_setup_all_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_setup_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Allocation for Rx Queue %u failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
				<span class="n">e1000_free_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_rctl - configure the receive control registers</span>
<span class="cm"> * @adapter: Board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_setup_rctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>

	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_RCTL_MO_SHIFT</span><span class="p">);</span>

	<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_BAM</span> <span class="o">|</span> <span class="n">E1000_RCTL_LBM_NO</span> <span class="o">|</span>
		<span class="n">E1000_RCTL_RDMTS_HALF</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mc_filter_type</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_RCTL_MO_SHIFT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_on</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SBP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_SBP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&lt;=</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_LPE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_LPE</span><span class="p">;</span>

	<span class="cm">/* Setup buffer sizes */</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_SZ_4096</span><span class="p">;</span>
	<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_BSEX</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">E1000_RXBUFFER_2048</span>:
		<span class="nl">default:</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SZ_2048</span><span class="p">;</span>
			<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_BSEX</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">E1000_RXBUFFER_4096</span>:
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SZ_4096</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">E1000_RXBUFFER_8192</span>:
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SZ_8192</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">E1000_RXBUFFER_16384</span>:
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SZ_16384</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This is useful for sniffing bad packets. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* UPE and MPE will be handled by normal PROMISC logic</span>
<span class="cm">		 * in e1000e_set_rx_mode */</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_RCTL_SBP</span> <span class="o">|</span> <span class="cm">/* Receive bad packets */</span>
			 <span class="n">E1000_RCTL_BAM</span> <span class="o">|</span> <span class="cm">/* RX All Bcast Pkts */</span>
			 <span class="n">E1000_RCTL_PMCF</span><span class="p">);</span> <span class="cm">/* RX All MAC Ctrl Pkts */</span>

		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_RCTL_VFE</span> <span class="o">|</span> <span class="cm">/* Disable VLAN filter */</span>
			  <span class="n">E1000_RCTL_DPF</span> <span class="o">|</span> <span class="cm">/* Allow filtered pause */</span>
			  <span class="n">E1000_RCTL_CFIEN</span><span class="p">);</span> <span class="cm">/* Dis VLAN CFIEN Filter */</span>
		<span class="cm">/* Do not mess with E1000_CTRL_VME, it affects transmit as well,</span>
<span class="cm">		 * and that breaks VLANs.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_configure_rx - Configure 8254x Receive Unit after Reset</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Configure the Rx unit of the MAC after a reset.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_configure_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">rdba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rdlen</span><span class="p">,</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">rxcsum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">&gt;</span> <span class="n">ETH_DATA_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rdlen</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">*</span>
		        <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_rx_desc</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">=</span> <span class="n">e1000_clean_jumbo_rx_irq</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span> <span class="o">=</span> <span class="n">e1000_alloc_jumbo_rx_buffers</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rdlen</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">*</span>
		        <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_rx_desc</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">=</span> <span class="n">e1000_clean_rx_irq</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span> <span class="o">=</span> <span class="n">e1000_alloc_rx_buffers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* disable receives while setting up the descriptors */</span>
	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_RCTL_EN</span><span class="p">);</span>

	<span class="cm">/* set the Receive Delay Timer Register */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RDTR</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_int_delay</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82540</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RADV</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_abs_int_delay</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">*</span> <span class="mi">256</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Setup the HW Rx Head and Tail Descriptor Pointers and</span>
<span class="cm">	 * the Base and Length of the Rx Descriptor Ring */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
	<span class="nl">default:</span>
		<span class="n">rdba</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dma</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RDLEN</span><span class="p">,</span> <span class="n">rdlen</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RDBAH</span><span class="p">,</span> <span class="p">(</span><span class="n">rdba</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RDBAL</span><span class="p">,</span> <span class="p">(</span><span class="n">rdba</span> <span class="o">&amp;</span> <span class="mh">0x00000000ffffffffULL</span><span class="p">));</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RDT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RDH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rdh</span> <span class="o">=</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="o">?</span> <span class="n">E1000_RDH</span> <span class="o">:</span> <span class="n">E1000_82542_RDH</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rdt</span> <span class="o">=</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="o">?</span> <span class="n">E1000_RDT</span> <span class="o">:</span> <span class="n">E1000_82542_RDT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable 82543 Receive Checksum Offload for TCP and UDP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rxcsum</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCSUM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_csum</span><span class="p">)</span>
			<span class="n">rxcsum</span> <span class="o">|=</span> <span class="n">E1000_RXCSUM_TUOFL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* don&#39;t need to clear IPPCSE as it defaults to 0 */</span>
			<span class="n">rxcsum</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RXCSUM_TUOFL</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RXCSUM</span><span class="p">,</span> <span class="n">rxcsum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Enable Receives */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">|</span> <span class="n">E1000_RCTL_EN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_free_tx_resources - Free Tx Resources per Queue</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @tx_ring: Tx descriptor ring for a specific queue</span>
<span class="cm"> *</span>
<span class="cm"> * Free all transmit software resources</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_free_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">e1000_clean_tx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span>
			  <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_free_all_tx_resources - Free Tx Resources for All Queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Free all transmit software resources</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">e1000_free_all_tx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">e1000_free_tx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_unmap_and_free_tx_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span><span class="p">)</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				       <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					 <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					 <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* buffer_info must be completely set up in the transmit path */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_tx_ring - Free Tx Buffers</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @tx_ring: ring to be cleaned</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clean_tx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Free all the Tx ring sk_buffs */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">e1000_unmap_and_free_tx_resource</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Zero out the descriptor ring */</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">last_tx_tso</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tdh</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_all_tx_rings - Free Tx Buffers for all queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clean_all_tx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">e1000_clean_tx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_free_rx_resources - Free Rx Resources</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @rx_ring: ring to clean the resources from</span>
<span class="cm"> *</span>
<span class="cm"> * Free all receive software resources</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_free_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">e1000_clean_rx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rx_ring</span><span class="p">);</span>

	<span class="n">vfree</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">);</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span>
			  <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_free_all_rx_resources - Free Rx Resources for All Queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> *</span>
<span class="cm"> * Free all receive software resources</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">e1000_free_all_rx_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">e1000_free_rx_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_rx_ring - Free Rx Buffers per Queue</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @rx_ring: ring to free buffers from</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clean_rx_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Free all the Rx ring sk_buffs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">&amp;&amp;</span>
		    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">==</span> <span class="n">e1000_clean_rx_irq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			                 <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">&amp;&amp;</span>
		           <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span> <span class="o">==</span> <span class="n">e1000_clean_jumbo_rx_irq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				       <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
				       <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* there also may be some cached data from a chained receive */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span><span class="p">);</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span><span class="p">)</span> <span class="o">*</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* Zero out the descriptor ring */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rdh</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rdt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_all_rx_rings - Free Rx Buffers for all queues</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clean_all_rx_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">e1000_clean_rx_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* The 82542 2.0 (revision 2) needs to have the receive unit in reset</span>
<span class="cm"> * and memory write and invalidate disabled for certain operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_enter_82542_rst</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="n">e1000_pci_clear_mwi</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_RST</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000_clean_all_rx_rings</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_leave_82542_rst</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_RST</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">pci_cmd_word</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_INVALIDATE</span><span class="p">)</span>
		<span class="n">e1000_pci_set_mwi</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* No need to loop, because 82542 supports only 1 queue */</span>
		<span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">e1000_configure_rx</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">E1000_DESC_UNUSED</span><span class="p">(</span><span class="n">ring</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_set_mac - Change the Ethernet Address of the NIC</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @p: pointer to an address structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_set_mac</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid_ether_addr</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="cm">/* 82542 2.0 needs to be in reset to write receive address registers */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span>
		<span class="n">e1000_enter_82542_rst</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">);</span>

	<span class="n">e1000_rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span>
		<span class="n">e1000_leave_82542_rst</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_set_rx_mode - Secondary Unicast, Multicast and Promiscuous mode set</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * The set_rx_mode entry point is called whenever the unicast or multicast</span>
<span class="cm"> * address lists or the network interface flags are updated. This routine is</span>
<span class="cm"> * responsible for configuring the hardware for proper unicast, multicast,</span>
<span class="cm"> * promiscuous mode, and all-multi behavior.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_hw_addr</span> <span class="o">*</span><span class="n">ha</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_uc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rar_entries</span> <span class="o">=</span> <span class="n">E1000_RAR_ENTRIES</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mta_reg_count</span> <span class="o">=</span> <span class="n">E1000_NUM_MTA_REGISTERS</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">mcarray</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">mta_reg_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mcarray</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for Promiscuous and All Multicast modes */</span>

	<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_RCTL_UPE</span> <span class="o">|</span> <span class="n">E1000_RCTL_MPE</span><span class="p">);</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_VFE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_MPE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_MPE</span><span class="p">;</span>
		<span class="cm">/* Enable VLAN filter if there is a VLAN */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_vlan_used</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_VFE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_uc_count</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rar_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_UPE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_UPE</span><span class="p">;</span>
		<span class="n">use_uc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>

	<span class="cm">/* 82542 2.0 needs to be in reset to write receive address registers */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span>
		<span class="n">e1000_enter_82542_rst</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* load the first 14 addresses into the exact filters 1-14. Unicast</span>
<span class="cm">	 * addresses take precedence to avoid disabling unicast filtering</span>
<span class="cm">	 * when possible.</span>
<span class="cm">	 *</span>
<span class="cm">	 * RAR 0 is used for the station MAC address</span>
<span class="cm">	 * if there are not 14 addresses, go ahead and clear the filters</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_uc</span><span class="p">)</span>
		<span class="n">netdev_for_each_uc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rar_entries</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">e1000_rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">netdev_for_each_mc_addr</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">netdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rar_entries</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* load any remaining addresses into the hash table */</span>
			<span class="n">u32</span> <span class="n">hash_reg</span><span class="p">,</span> <span class="n">hash_bit</span><span class="p">,</span> <span class="n">mta</span><span class="p">;</span>
			<span class="n">hash_value</span> <span class="o">=</span> <span class="n">e1000_hash_mc_addr</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">hash_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
			<span class="n">hash_bit</span> <span class="o">=</span> <span class="n">hash_value</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">;</span>
			<span class="n">mta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hash_bit</span><span class="p">);</span>
			<span class="n">mcarray</span><span class="p">[</span><span class="n">hash_reg</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mta</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">e1000_rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">ha</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rar_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* write the hash table completely, write from bottom to avoid</span>
<span class="cm">	 * both stupid write combining chipsets, and flushing each write */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">mta_reg_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are on an 82544 has an errata where writing odd</span>
<span class="cm">		 * offsets overwrites the previous even offset, but writing</span>
<span class="cm">		 * backwards over the range solves the issue by always</span>
<span class="cm">		 * writing the odd offset first</span>
<span class="cm">		 */</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MTA</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mcarray</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span>
		<span class="n">e1000_leave_82542_rst</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">mcarray</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_update_phy_info_task - get phy info</span>
<span class="cm"> * @work: work struct contained inside adapter struct</span>
<span class="cm"> *</span>
<span class="cm"> * Need to wait a few seconds after link up to get diagnostic information from</span>
<span class="cm"> * the phy</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_update_phy_info_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span>
						     <span class="n">phy_info_task</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">e1000_phy_get_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_82547_tx_fifo_stall_task - task to complete work</span>
<span class="cm"> * @work: work struct contained inside adapter struct</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_82547_tx_fifo_stall_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span>
						     <span class="n">fifo_stall_task</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_stall</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">er32</span><span class="p">(</span><span class="n">TDT</span><span class="p">)</span> <span class="o">==</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDH</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">TDFT</span><span class="p">)</span> <span class="o">==</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDFH</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">TDFTS</span><span class="p">)</span> <span class="o">==</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDFHS</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">tctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TCTL_EN</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TDFT</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_head_addr</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TDFH</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_head_addr</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TDFTS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_head_addr</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TDFHS</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_head_addr</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>
			<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_stall</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fifo_stall_task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">e1000_has_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">link_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* get_link_status is set on LSC (link status) interrupt or rx</span>
<span class="cm">	 * sequence error interrupt (except on intel ce4100).</span>
<span class="cm">	 * get_link_status will stay false until the</span>
<span class="cm">	 * e1000_check_for_link establishes link for copper adapters</span>
<span class="cm">	 * ONLY</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_media_type_copper</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">get_link_status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e1000_check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="n">link_active</span> <span class="o">=</span> <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">get_link_status</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">link_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_media_type_fiber</span>:
		<span class="n">e1000_check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">link_active</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_media_type_internal_serdes</span>:
		<span class="n">e1000_check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">link_active</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">link_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_watchdog - work function</span>
<span class="cm"> * @work: work struct contained inside adapter struct</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_watchdog</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span>
						     <span class="n">watchdog_task</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">txdr</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">link</span><span class="p">,</span> <span class="n">tctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">link</span> <span class="o">=</span> <span class="n">e1000_has_link</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">link</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">link_up</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
			<span class="n">bool</span> <span class="n">txb2b</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="cm">/* update snapshot of PHY registers on LSC */</span>
			<span class="n">e1000_get_speed_and_duplex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
			                           <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">,</span>
			                           <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span><span class="p">);</span>

			<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s NIC Link is Up %d Mbps %s, &quot;</span>
				<span class="s">&quot;Flow Control: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">==</span> <span class="n">FULL_DUPLEX</span> <span class="o">?</span>
				<span class="s">&quot;Full Duplex&quot;</span> <span class="o">:</span> <span class="s">&quot;Half Duplex&quot;</span><span class="p">,</span>
				<span class="p">((</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_TFCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span>
				<span class="n">E1000_CTRL_RFCE</span><span class="p">))</span> <span class="o">?</span> <span class="s">&quot;RX/TX&quot;</span> <span class="o">:</span> <span class="p">((</span><span class="n">ctrl</span> <span class="o">&amp;</span>
				<span class="n">E1000_CTRL_RFCE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;RX&quot;</span> <span class="o">:</span> <span class="p">((</span><span class="n">ctrl</span> <span class="o">&amp;</span>
				<span class="n">E1000_CTRL_TFCE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;TX&quot;</span> <span class="o">:</span> <span class="s">&quot;None&quot;</span><span class="p">)));</span>

			<span class="cm">/* adjust timeout factor according to speed/duplex */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SPEED_10</span>:
				<span class="n">txb2b</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SPEED_100</span>:
				<span class="n">txb2b</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="cm">/* maybe add some timeout factor ? */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* enable transmits in the hardware */</span>
			<span class="n">tctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
			<span class="n">tctl</span> <span class="o">|=</span> <span class="n">E1000_TCTL_EN</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>

			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_task</span><span class="p">,</span>
						      <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">smartspeed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s NIC Link is Down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_info_task</span><span class="p">,</span>
						      <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">e1000_smartspeed</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">link_up:</span>
	<span class="n">e1000_update_stats</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_packet_delta</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpt</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tpt_old</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tpt_old</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpt</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">collision_delta</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">colc_old</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">colc_old</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorcl</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorcl</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorcl_old</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorcl_old</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorcl</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotcl</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotcl</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotcl_old</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotcl_old</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotcl</span><span class="p">;</span>

	<span class="n">e1000_update_adaptive</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">E1000_DESC_UNUSED</span><span class="p">(</span><span class="n">txdr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">txdr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We&#39;ve lost link, so the controller stops DMA,</span>
<span class="cm">			 * but we&#39;ve got queued Tx work that&#39;s never going</span>
<span class="cm">			 * to get done, so reset controller to flush Tx.</span>
<span class="cm">			 * (Do the reset outside of interrupt context). */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
			<span class="cm">/* exit immediately since reset is imminent */</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Simple mode for Interrupt Throttle Rate (ITR) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82540</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Symmetric Tx/Rx gets a reduced ITR=2000;</span>
<span class="cm">		 * Total asymmetrical Tx or Rx gets ITR=8000;</span>
<span class="cm">		 * everyone else is between 2000-8000.</span>
<span class="cm">		 */</span>
		<span class="n">u32</span> <span class="n">goc</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotcl</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorcl</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">dif</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotcl</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorcl</span> <span class="o">?</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotcl</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorcl</span> <span class="o">:</span>
			    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gorcl</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">gotcl</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">goc</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="p">(</span><span class="n">dif</span> <span class="o">*</span> <span class="mi">6000</span> <span class="o">/</span> <span class="n">goc</span> <span class="o">+</span> <span class="mi">2000</span><span class="p">)</span> <span class="o">:</span> <span class="mi">8000</span><span class="p">;</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">itr</span> <span class="o">*</span> <span class="mi">256</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Cause software interrupt to ensure rx ring is cleaned */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="n">E1000_ICS_RXDMT0</span><span class="p">);</span>

	<span class="cm">/* Force detection of hung controller every watchdog period */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">detect_tx_hung</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Reschedule the task */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">latency_range</span> <span class="p">{</span>
	<span class="n">lowest_latency</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">low_latency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">bulk_latency</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">latency_invalid</span> <span class="o">=</span> <span class="mi">255</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_update_itr - update the dynamic ITR value based on statistics</span>
<span class="cm"> * @adapter: pointer to adapter</span>
<span class="cm"> * @itr_setting: current adapter-&gt;itr</span>
<span class="cm"> * @packets: the number of packets during this measurement interval</span>
<span class="cm"> * @bytes: the number of bytes during this measurement interval</span>
<span class="cm"> *</span>
<span class="cm"> *      Stores a new ITR value based on packets and byte</span>
<span class="cm"> *      counts during the last interrupt.  The advantage of per interrupt</span>
<span class="cm"> *      computation is faster updates and more accurate ITR for the current</span>
<span class="cm"> *      traffic pattern.  Constants in this function were computed</span>
<span class="cm"> *      based on theoretical maximum wire speed and thresholds were set based</span>
<span class="cm"> *      on testing data as well as attempting to minimize response time</span>
<span class="cm"> *      while increasing bulk throughput.</span>
<span class="cm"> *      this functionality is controlled by the InterruptThrottleRate module</span>
<span class="cm"> *      parameter (see e1000_param.c)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">e1000_update_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				     <span class="n">u16</span> <span class="n">itr_setting</span><span class="p">,</span> <span class="kt">int</span> <span class="n">packets</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">itr_setting</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82540</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">update_itr_done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">update_itr_done</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">itr_setting</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">lowest_latency</span>:
		<span class="cm">/* jumbo frames get bulk treatment*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">8000</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">512</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">low_latency</span>:  <span class="cm">/* 50 usec aka 20000 ints/s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* jumbo frames need bulk latency setting */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">8000</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1200</span><span class="p">))</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">))</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">lowest_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="o">/</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">bulk_latency</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">lowest_latency</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">bulk_latency</span>: <span class="cm">/* 250 usec aka 4000 ints/s */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">25000</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="mi">35</span><span class="p">)</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">6000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">update_itr_done:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_set_itr</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">current_itr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_itr</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82540</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* for non-gigabit speeds, just fix the interrupt rate at 4000 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">!=</span> <span class="n">SPEED_1000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">current_itr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">set_itr_now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span> <span class="o">=</span> <span class="n">e1000_update_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
	                            <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span><span class="p">,</span>
	                            <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span><span class="p">,</span>
	                            <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span><span class="p">);</span>
	<span class="cm">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span> <span class="o">==</span> <span class="n">lowest_latency</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span> <span class="o">=</span> <span class="n">e1000_update_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
	                            <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span><span class="p">,</span>
	                            <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span><span class="p">,</span>
	                            <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span><span class="p">);</span>
	<span class="cm">/* conservative mode (itr 3) eliminates the lowest_latency setting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span> <span class="o">==</span> <span class="n">lowest_latency</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span> <span class="o">=</span> <span class="n">low_latency</span><span class="p">;</span>

	<span class="n">current_itr</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_itr</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_itr</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">current_itr</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* counts and packets in update_itr are dependent on these numbers */</span>
	<span class="k">case</span> <span class="n">lowest_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">70000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">low_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">;</span> <span class="cm">/* aka hwitr = ~200 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">bulk_latency</span>:
		<span class="n">new_itr</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">set_itr_now:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">!=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* this attempts to bias the interrupt rate towards Bulk</span>
<span class="cm">		 * by adding intermediate steps when interrupt rate is</span>
<span class="cm">		 * increasing */</span>
		<span class="n">new_itr</span> <span class="o">=</span> <span class="n">new_itr</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">?</span>
		             <span class="n">min</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">new_itr</span><span class="p">)</span> <span class="o">:</span>
		             <span class="n">new_itr</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr</span> <span class="o">=</span> <span class="n">new_itr</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">ITR</span><span class="p">,</span> <span class="mi">1000000000</span> <span class="o">/</span> <span class="p">(</span><span class="n">new_itr</span> <span class="o">*</span> <span class="mi">256</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define E1000_TX_FLAGS_CSUM		0x00000001</span>
<span class="cp">#define E1000_TX_FLAGS_VLAN		0x00000002</span>
<span class="cp">#define E1000_TX_FLAGS_TSO		0x00000004</span>
<span class="cp">#define E1000_TX_FLAGS_IPV4		0x00000008</span>
<span class="cp">#define E1000_TX_FLAGS_NO_FCS		0x00000010</span>
<span class="cp">#define E1000_TX_FLAGS_VLAN_MASK	0xffff0000</span>
<span class="cp">#define E1000_TX_FLAGS_VLAN_SHIFT	16</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_tso</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_context_desc</span> <span class="o">*</span><span class="n">context_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ipcse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tucse</span><span class="p">,</span> <span class="n">mss</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ipcss</span><span class="p">,</span> <span class="n">ipcso</span><span class="p">,</span> <span class="n">tucss</span><span class="p">,</span> <span class="n">tucso</span><span class="p">,</span> <span class="n">hdr_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">iph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_tcpudp_magic</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
								 <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
								 <span class="n">IPPROTO_TCP</span><span class="p">,</span>
								 <span class="mi">0</span><span class="p">);</span>
			<span class="n">cmd_length</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_IP</span><span class="p">;</span>
			<span class="n">ipcse</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">payload_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span>
				<span class="o">~</span><span class="n">csum_ipv6_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span>
						 <span class="mi">0</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ipcse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ipcss</span> <span class="o">=</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">ipcso</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">tucss</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">tucso</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">tucse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cmd_length</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_TXD_CMD_TSE</span> <span class="o">|</span>
			       <span class="n">E1000_TXD_CMD_TCP</span> <span class="o">|</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">hdr_len</span><span class="p">)));</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
		<span class="n">context_desc</span> <span class="o">=</span> <span class="n">E1000_CONTEXT_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">lower_setup</span><span class="p">.</span><span class="n">ip_fields</span><span class="p">.</span><span class="n">ipcss</span>  <span class="o">=</span> <span class="n">ipcss</span><span class="p">;</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">lower_setup</span><span class="p">.</span><span class="n">ip_fields</span><span class="p">.</span><span class="n">ipcso</span>  <span class="o">=</span> <span class="n">ipcso</span><span class="p">;</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">lower_setup</span><span class="p">.</span><span class="n">ip_fields</span><span class="p">.</span><span class="n">ipcse</span>  <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ipcse</span><span class="p">);</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucss</span> <span class="o">=</span> <span class="n">tucss</span><span class="p">;</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucso</span> <span class="o">=</span> <span class="n">tucso</span><span class="p">;</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucse</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">tucse</span><span class="p">);</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">tcp_seg_setup</span><span class="p">.</span><span class="n">fields</span><span class="p">.</span><span class="n">mss</span>     <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">mss</span><span class="p">);</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">tcp_seg_setup</span><span class="p">.</span><span class="n">fields</span><span class="p">.</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="n">hdr_len</span><span class="p">;</span>
		<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">cmd_and_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_length</span><span class="p">);</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_tx_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_context_desc</span> <span class="o">*</span><span class="n">context_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">css</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmd_len</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_DEXT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
			<span class="n">cmd_len</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_TCP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">)</span>:
		<span class="cm">/* XXX not handling all IPV6 headers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
			<span class="n">cmd_len</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_TCP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">net_ratelimit</span><span class="p">()))</span>
			<span class="n">e_warn</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="s">&quot;checksum_partial proto=%x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">css</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">context_desc</span> <span class="o">=</span> <span class="n">E1000_CONTEXT_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">lower_setup</span><span class="p">.</span><span class="n">ip_config</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucss</span> <span class="o">=</span> <span class="n">css</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucso</span> <span class="o">=</span>
		<span class="n">css</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">upper_setup</span><span class="p">.</span><span class="n">tcp_fields</span><span class="p">.</span><span class="n">tucse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">tcp_seg_setup</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">cmd_and_length</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define E1000_MAX_TXD_PWR	12</span>
<span class="cp">#define E1000_MAX_DATA_PER_TXD	(1&lt;&lt;E1000_MAX_TXD_PWR)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_tx_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_per_txd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_frags</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f</span><span class="p">,</span> <span class="n">bytecount</span><span class="p">,</span> <span class="n">segs</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">max_per_txd</span><span class="p">);</span>
		<span class="cm">/* Workaround for Controller erratum --</span>
<span class="cm">		 * descriptor for non-tso packet in a linear SKB that follows a</span>
<span class="cm">		 * tso gets written back prematurely before the data is fully</span>
<span class="cm">		 * DMA&#39;d to the controller */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&amp;&amp;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">last_tx_tso</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">last_tx_tso</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Workaround for premature desc write-backs</span>
<span class="cm">		 * in TSO mode.  Append 4-byte sentinel desc */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mss</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nr_frags</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">==</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">))</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* work-around for errata 10 and it applies</span>
<span class="cm">		 * to all controllers in PCI-X mode</span>
<span class="cm">		 * The fix is to make sure that the first descriptor of a</span>
<span class="cm">		 * packet is smaller than 2048 - 16 - 16 (or 2016) bytes</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">e1000_bus_type_pcix</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		                <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">2015</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		        <span class="n">size</span> <span class="o">=</span> <span class="mi">2015</span><span class="p">;</span>

		<span class="cm">/* Workaround for potential 82544 hang in PCI-X.  Avoid</span>
<span class="cm">		 * terminating buffers within evenly-aligned dwords. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pcix_82544</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">))</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="cm">/* set time_stamp *before* dma to help avoid a possible race */</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
						  <span class="n">size</span><span class="p">,</span>	<span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">nr_frags</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">];</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bufend</span><span class="p">;</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">max_per_txd</span><span class="p">);</span>
			<span class="cm">/* Workaround for premature desc write-backs</span>
<span class="cm">			 * in TSO mode.  Append 4-byte sentinel desc */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mss</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="o">==</span> <span class="p">(</span><span class="n">nr_frags</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">==</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">))</span>
				<span class="n">size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="cm">/* Workaround for potential 82544 hang in PCI-X.</span>
<span class="cm">			 * Avoid terminating buffers within evenly-aligned</span>
<span class="cm">			 * dwords. */</span>
			<span class="n">bufend</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
				<span class="n">page_to_phys</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
			<span class="n">bufend</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pcix_82544</span> <span class="o">&amp;&amp;</span>
				     <span class="o">!</span><span class="p">(</span><span class="n">bufend</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				     <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">))</span>
				<span class="n">size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>

			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">mapped_as_page</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">skb_frag_dma_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">frag</span><span class="p">,</span>
						<span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">dma_error</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">segs</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">?:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* multiply data chunks by size of headers */</span>
	<span class="n">bytecount</span> <span class="o">=</span> <span class="p">((</span><span class="n">segs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">segs</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bytecount</span> <span class="o">=</span> <span class="n">bytecount</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">first</span><span class="p">].</span><span class="n">next_to_watch</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>

<span class="nl">dma_error:</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX DMA map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="n">count</span><span class="o">--</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">e1000_unmap_and_free_tx_resource</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_tx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tx_flags</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txd_upper</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">txd_lower</span> <span class="o">=</span> <span class="n">E1000_TXD_CMD_IFCS</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_TSO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">txd_lower</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_TXD_DTYP_D</span> <span class="o">|</span>
		             <span class="n">E1000_TXD_CMD_TSE</span><span class="p">;</span>
		<span class="n">txd_upper</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_TXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_IPV4</span><span class="p">))</span>
			<span class="n">txd_upper</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_IXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_CSUM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">txd_lower</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">E1000_TXD_DTYP_D</span><span class="p">;</span>
		<span class="n">txd_upper</span> <span class="o">|=</span> <span class="n">E1000_TXD_POPTS_TXSM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_VLAN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">txd_lower</span> <span class="o">|=</span> <span class="n">E1000_TXD_CMD_VLE</span><span class="p">;</span>
		<span class="n">txd_upper</span> <span class="o">|=</span> <span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_VLAN_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_NO_FCS</span><span class="p">))</span>
		<span class="n">txd_lower</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_TXD_CMD_IFCS</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">txd_lower</span> <span class="o">|</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">txd_upper</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">.</span><span class="n">data</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">txd_cmd</span><span class="p">);</span>

	<span class="cm">/* txd_cmd re-enables FCS, so we&#39;ll re-disable it here as desired. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">E1000_TX_FLAGS_NO_FCS</span><span class="p">))</span>
		<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_TXD_CMD_IFCS</span><span class="p">));</span>

	<span class="cm">/* Force memory writes to complete before letting h/w</span>
<span class="cm">	 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">	 * applicable for weak-ordered memory model archs,</span>
<span class="cm">	 * such as IA-64). */</span>
	<span class="n">wmb</span><span class="p">();</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">);</span>
	<span class="cm">/* we need this if more than one processor can write to our tail</span>
<span class="cm">	 * at a time, it syncronizes IO on IA64/Altix systems */</span>
	<span class="n">mmiowb</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 82547 workaround to avoid controller hang in half-duplex environment.</span>
<span class="cm"> * The workaround is to avoid queuing a large packet that would span</span>
<span class="cm"> * the internal Tx FIFO ring boundary by notifying the stack to resend</span>
<span class="cm"> * the packet at a later time.  This gives the Tx FIFO an opportunity to</span>
<span class="cm"> * flush all packets.  When that occurs, we reset the Tx FIFO pointers</span>
<span class="cm"> * to the beginning of the Tx FIFO.</span>
<span class="cm"> **/</span>

<span class="cp">#define E1000_FIFO_HDR			0x10</span>
<span class="cp">#define E1000_82547_PAD_LEN		0x3E0</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_82547_fifo_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">fifo_space</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_size</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">skb_fifo_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">E1000_FIFO_HDR</span><span class="p">;</span>

	<span class="n">skb_fifo_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">skb_fifo_len</span><span class="p">,</span> <span class="n">E1000_FIFO_HDR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">!=</span> <span class="n">HALF_DUPLEX</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_fifo_stall_required</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_stall</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_fifo_len</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">E1000_82547_PAD_LEN</span> <span class="o">+</span> <span class="n">fifo_space</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_stall</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">no_fifo_stall_required:</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_head</span> <span class="o">+=</span> <span class="n">skb_fifo_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_head</span> <span class="o">&gt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_size</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_head</span> <span class="o">-=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_fifo_size</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__e1000_maybe_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>

	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="cm">/* Herbert&#39;s original patch had:</span>
<span class="cm">	 *  smp_mb__after_netif_stop_queue();</span>
<span class="cm">	 * but since that doesn&#39;t exist yet, just open code it. */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* We need to check again in a case another CPU has just</span>
<span class="cm">	 * made room available. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">E1000_DESC_UNUSED</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* A reprieve! */</span>
	<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="o">++</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">restart_queue</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_maybe_stop_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
                               <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">E1000_DESC_UNUSED</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__e1000_maybe_stop_tx</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TXD_USE_COUNT(S, X) (((S) &gt;&gt; (X)) + 1 )</span>
<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">e1000_xmit_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="n">max_per_txd</span> <span class="o">=</span> <span class="n">E1000_MAX_DATA_PER_TXD</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_txd_pwr</span> <span class="o">=</span> <span class="n">E1000_MAX_TXD_PWR</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_frags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tso</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>

	<span class="cm">/* This goes back to the question of how to logically map a tx queue</span>
<span class="cm">	 * to a flow.  Right now, performance is impacted slightly negatively</span>
<span class="cm">	 * if using multiple tx queues.  If the stack breaks away from a</span>
<span class="cm">	 * single qdisc implementation, we can look at this again. */</span>
	<span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="cm">/* The controller does a simple calculation to</span>
<span class="cm">	 * make sure there is enough room in the FIFO before</span>
<span class="cm">	 * initiating the DMA for each buffer.  The calc is:</span>
<span class="cm">	 * 4 = ceil(buffer len/mss).  To make sure we don&#39;t</span>
<span class="cm">	 * overrun the FIFO, adjust the max buffer len if mss</span>
<span class="cm">	 * drops. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">hdr_len</span><span class="p">;</span>
		<span class="n">max_per_txd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mss</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_per_txd</span><span class="p">);</span>
		<span class="n">max_txd_pwr</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">max_per_txd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_hdrlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&amp;&amp;</span> <span class="n">hdr_len</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pull_size</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">e1000_82544</span>:
				<span class="cm">/* Make sure we have room to chop off 4 bytes,</span>
<span class="cm">				 * and that the end alignment will work out to</span>
<span class="cm">				 * this hardware&#39;s requirements</span>
<span class="cm">				 * NOTE: this is a TSO only workaround</span>
<span class="cm">				 * if end byte alignment not correct move us</span>
<span class="cm">				 * into the next dword */</span>
				<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="cm">/* fall through */</span>
				<span class="n">pull_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="mi">4</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__pskb_pull_tail</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pull_size</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">e_err</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="s">&quot;__pskb_pull_tail &quot;</span>
					      <span class="s">&quot;failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="cm">/* do nothing */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* reserve a descriptor for the offload context */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mss</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">))</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Controller Erratum workaround */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">&amp;&amp;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">last_tx_tso</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">+=</span> <span class="n">TXD_USE_COUNT</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">max_txd_pwr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pcix_82544</span><span class="p">)</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* work-around for errata 10 and it applies to all controllers</span>
<span class="cm">	 * in PCI-X mode, so add one more descriptor to the count</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">e1000_bus_type_pcix</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2015</span><span class="p">)))</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">nr_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">nr_frags</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">TXD_USE_COUNT</span><span class="p">(</span><span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">f</span><span class="p">]),</span>
				       <span class="n">max_txd_pwr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pcix_82544</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">nr_frags</span><span class="p">;</span>

	<span class="cm">/* need: count + 2 desc gap to keep tail from touching</span>
<span class="cm">	 * head, otherwise try next time */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">e1000_maybe_stop_tx</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">e1000_82547_fifo_workaround</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fifo_stall_task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_VLAN</span><span class="p">;</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_TX_FLAGS_VLAN_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">first</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">tso</span> <span class="o">=</span> <span class="n">e1000_tso</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tso</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tso</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">!=</span> <span class="n">e1000_82544</span><span class="p">))</span>
			<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">last_tx_tso</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_TSO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">e1000_tx_csum</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">)))</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_CSUM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">)))</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_IPV4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">no_fcs</span><span class="p">))</span>
		<span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">E1000_TX_FLAGS_NO_FCS</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">e1000_tx_map</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">max_per_txd</span><span class="p">,</span>
	                     <span class="n">nr_frags</span><span class="p">,</span> <span class="n">mss</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_tx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">e1000_tx_queue</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">tx_flags</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="cm">/* Make sure there is space in the ring for the next send. */</span>
		<span class="n">e1000_maybe_stop_tx</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">tx_ring</span><span class="p">,</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">first</span><span class="p">].</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define NUM_REGS 38 </span><span class="cm">/* 1 based count */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_regdump</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">regs</span><span class="p">[</span><span class="n">NUM_REGS</span><span class="p">];</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">regs_buff</span> <span class="o">=</span> <span class="n">regs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">reg_name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;CTRL&quot;</span><span class="p">,</span>  <span class="s">&quot;STATUS&quot;</span><span class="p">,</span>
		<span class="s">&quot;RCTL&quot;</span><span class="p">,</span> <span class="s">&quot;RDLEN&quot;</span><span class="p">,</span> <span class="s">&quot;RDH&quot;</span><span class="p">,</span> <span class="s">&quot;RDT&quot;</span><span class="p">,</span> <span class="s">&quot;RDTR&quot;</span><span class="p">,</span>
		<span class="s">&quot;TCTL&quot;</span><span class="p">,</span> <span class="s">&quot;TDBAL&quot;</span><span class="p">,</span> <span class="s">&quot;TDBAH&quot;</span><span class="p">,</span> <span class="s">&quot;TDLEN&quot;</span><span class="p">,</span> <span class="s">&quot;TDH&quot;</span><span class="p">,</span> <span class="s">&quot;TDT&quot;</span><span class="p">,</span>
		<span class="s">&quot;TIDV&quot;</span><span class="p">,</span> <span class="s">&quot;TXDCTL&quot;</span><span class="p">,</span> <span class="s">&quot;TADV&quot;</span><span class="p">,</span> <span class="s">&quot;TARC0&quot;</span><span class="p">,</span>
		<span class="s">&quot;TDBAL1&quot;</span><span class="p">,</span> <span class="s">&quot;TDBAH1&quot;</span><span class="p">,</span> <span class="s">&quot;TDLEN1&quot;</span><span class="p">,</span> <span class="s">&quot;TDH1&quot;</span><span class="p">,</span> <span class="s">&quot;TDT1&quot;</span><span class="p">,</span>
		<span class="s">&quot;TXDCTL1&quot;</span><span class="p">,</span> <span class="s">&quot;TARC1&quot;</span><span class="p">,</span>
		<span class="s">&quot;CTRL_EXT&quot;</span><span class="p">,</span> <span class="s">&quot;ERT&quot;</span><span class="p">,</span> <span class="s">&quot;RDBAL&quot;</span><span class="p">,</span> <span class="s">&quot;RDBAH&quot;</span><span class="p">,</span>
		<span class="s">&quot;TDFH&quot;</span><span class="p">,</span> <span class="s">&quot;TDFT&quot;</span><span class="p">,</span> <span class="s">&quot;TDFHS&quot;</span><span class="p">,</span> <span class="s">&quot;TDFTS&quot;</span><span class="p">,</span> <span class="s">&quot;TDFPC&quot;</span><span class="p">,</span>
		<span class="s">&quot;RDFH&quot;</span><span class="p">,</span> <span class="s">&quot;RDFT&quot;</span><span class="p">,</span> <span class="s">&quot;RDFHS&quot;</span><span class="p">,</span> <span class="s">&quot;RDFTS&quot;</span><span class="p">,</span> <span class="s">&quot;RDFPC&quot;</span>
	<span class="p">};</span>

	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>

	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDLEN</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDH</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDT</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDTR</span><span class="p">);</span>

	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDBAL</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>  <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDBAH</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDLEN</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDH</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDT</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TIDV</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TADV</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC0</span><span class="p">);</span>

	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDBAL1</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDBAH1</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDLEN1</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDH1</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDT1</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL1</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TARC1</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ERT</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDBAL0</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">27</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDBAH0</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDFH</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">29</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDFT</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDFHS</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDFTS</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TDFPC</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDFH</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">34</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDFT</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">35</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDFHS</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDFTS</span><span class="p">);</span>
	<span class="n">regs_buff</span><span class="p">[</span><span class="mi">37</span><span class="p">]</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RDFPC</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Register dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_REGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%-15s  %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_name</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">regs_buff</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * e1000_dump: Print registers, tx ring and rx ring</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* this code doesn&#39;t handle multiple rings */</span>
	<span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_hw</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Print Registers */</span>
	<span class="n">e1000_regdump</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * transmit dump</span>
<span class="cm">	 */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;TX Desc ring0 dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Transmit Descriptor Formats - DEXT[29] is 0 (Legacy) or 1 (Extended)</span>
<span class="cm">	 *</span>
<span class="cm">	 * Legacy Transmit Descriptor</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 * 0 |         Buffer Address [63:0] (Reserved on Write Back)       |</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 * 8 | Special  |    CSS     | Status |  CMD    |  CSO   |  Length  |</span>
<span class="cm">	 *   +--------------------------------------------------------------+</span>
<span class="cm">	 *   63       48 47        36 35    32 31     24 23    16 15        0</span>
<span class="cm">	 *</span>
<span class="cm">	 * Extended Context Descriptor (DTYP=0x0) for TSO or checksum offload</span>
<span class="cm">	 *   63      48 47    40 39       32 31             16 15    8 7      0</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 * 0 |  TUCSE  | TUCS0  |   TUCSS   |     IPCSE       | IPCS0 | IPCSS |</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 * 8 |   MSS   | HDRLEN | RSV | STA | TUCMD | DTYP |      PAYLEN      |</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 *   63      48 47    40 39 36 35 32 31   24 23  20 19                0</span>
<span class="cm">	 *</span>
<span class="cm">	 * Extended Data Descriptor (DTYP=0x1)</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 * 0 |                     Buffer Address [63:0]                      |</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 * 8 | VLAN tag |  POPTS  | Rsvd | Status | Command | DTYP |  DTALEN  |</span>
<span class="cm">	 *   +----------------------------------------------------------------+</span>
<span class="cm">	 *   63       48 47     40 39  36 35    32 31     24 23  20 19        0</span>
<span class="cm">	 */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tc[desc]     [Ce CoCsIpceCoS] [MssHlRSCm0Plen] [bi-&gt;dma       ] leng  ntw timestmp         bi-&gt;skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen] [bi-&gt;dma       ] leng  ntw timestmp         bi-&gt;skb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_tx_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">rx_ring_summary</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e1000_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">my_u</span> <span class="p">{</span> <span class="n">__le64</span> <span class="n">a</span><span class="p">;</span> <span class="n">__le64</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
		<span class="k">struct</span> <span class="n">my_u</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_u</span> <span class="o">*</span><span class="p">)</span><span class="n">tx_desc</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;NTC/U&quot;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;NTU&quot;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;NTC&quot;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;T%c[0x%03X]    %016llX %016llX %016llX %04X  %3X %016llX %p %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">((</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">))</span> <span class="o">?</span> <span class="sc">&#39;d&#39;</span> <span class="o">:</span> <span class="sc">&#39;c&#39;</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span>
			<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">next_to_watch</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">rx_ring_summary:</span>
	<span class="cm">/*</span>
<span class="cm">	 * receive dump</span>
<span class="cm">	 */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">RX Desc ring dump</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Legacy Receive Descriptor Format</span>
<span class="cm">	 *</span>
<span class="cm">	 * +-----------------------------------------------------+</span>
<span class="cm">	 * |                Buffer Address [63:0]                |</span>
<span class="cm">	 * +-----------------------------------------------------+</span>
<span class="cm">	 * | VLAN Tag | Errors | Status 0 | Packet csum | Length |</span>
<span class="cm">	 * +-----------------------------------------------------+</span>
<span class="cm">	 * 63       48 47    40 39      32 31         16 15      0</span>
<span class="cm">	 */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;R[desc]      [address 63:0  ] [vl er S cks ln] [bi-&gt;dma       ] [bi-&gt;skb]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_msg_rx_status</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">desc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">e1000_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">my_u</span> <span class="p">{</span> <span class="n">__le64</span> <span class="n">a</span><span class="p">;</span> <span class="n">__le64</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
		<span class="k">struct</span> <span class="n">my_u</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_u</span> <span class="o">*</span><span class="p">)</span><span class="n">rx_desc</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;NTU&quot;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;NTC&quot;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">type</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;R[0x%03X]     %016llX %016llX %016llX %p %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">),</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">),</span>
			<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* for */</span>

	<span class="cm">/* dump the descriptor caches */</span>
	<span class="cm">/* rx */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Rx descriptor cache in 64bit format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mh">0x6000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mh">0x63FF</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;R%04X: %08X|%08X %08X|%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span><span class="mi">12</span><span class="p">),</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/* tx */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Tx descriptor cache in 64bit format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mh">0x7000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mh">0x73FF</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;T%04X: %08X|%08X %08X|%08X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">),</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span><span class="mi">12</span><span class="p">),</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">));</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_tx_timeout - Respond to a Tx Hang</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_tx_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="cm">/* Do the reset outside of interrupt context */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reset_task</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_reset_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span> <span class="n">reset_task</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">e_err</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="s">&quot;Reset adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">e1000_reinit_safe</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_get_stats - Get System Network Statistics</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the address of the device statistics structure.</span>
<span class="cm"> * The statistics are actually updated from the watchdog.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="nf">e1000_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* only return the current stats */</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_change_mtu - Change the Maximum Transfer Unit</span>
<span class="cm"> * @netdev: network interface device structure</span>
<span class="cm"> * @new_mtu: new value for maximum frame size</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, negative on failure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_change_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_frame</span> <span class="o">=</span> <span class="n">new_mtu</span> <span class="o">+</span> <span class="n">ENET_HEADER_SIZE</span> <span class="o">+</span> <span class="n">ETHERNET_FCS_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">max_frame</span> <span class="o">&lt;</span> <span class="n">MINIMUM_ETHERNET_FRAME_SIZE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">max_frame</span> <span class="o">&gt;</span> <span class="n">MAX_JUMBO_FRAME_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Invalid MTU setting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Adapter-specific max frame size limits. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_undefined</span> <span class="p">...</span> <span class="n">e1000_82542_rev2_1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Jumbo Frames not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Capable of supporting up to MAX_JUMBO_FRAME_SIZE limit. */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* e1000_down has a dependency on max_frame_size */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">max_frame_size</span> <span class="o">=</span> <span class="n">max_frame</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN</span>
<span class="cm">	 * means we reserve 2 more, this pushes us to allocate from the next</span>
<span class="cm">	 * larger slab size.</span>
<span class="cm">	 * i.e. RXBUFFER_2048 --&gt; size-4096 slab</span>
<span class="cm">	 *  however with the new *_jumbo_rx* routines, jumbo receives will use</span>
<span class="cm">	 *  fragmented skbs */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_frame</span> <span class="o">&lt;=</span> <span class="n">E1000_RXBUFFER_2048</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">E1000_RXBUFFER_2048</span><span class="p">;</span>
	<span class="k">else</span>
<span class="cp">#if (PAGE_SIZE &gt;= E1000_RXBUFFER_16384)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">E1000_RXBUFFER_16384</span><span class="p">;</span>
<span class="cp">#elif (PAGE_SIZE &gt;= E1000_RXBUFFER_4096)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* adjust allocation if LPE protects us, and we aren&#39;t using SBP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_on</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">max_frame</span> <span class="o">==</span> <span class="p">(</span><span class="n">ETH_FRAME_LEN</span> <span class="o">+</span> <span class="n">ETH_FCS_LEN</span><span class="p">))</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">max_frame</span> <span class="o">==</span> <span class="n">MAXIMUM_ETHERNET_VLAN_SIZE</span><span class="p">)))</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span> <span class="o">=</span> <span class="n">MAXIMUM_ETHERNET_VLAN_SIZE</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s changing MTU from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_update_stats - Update the board statistics counters</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">e1000_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_tmp</span><span class="p">;</span>

<span class="cp">#define PHY_IDLE_ERROR_COUNT_MASK 0x00FF</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent stats update while adapter is being reset, or if the pci</span>
<span class="cm">	 * connection is down.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* these counters are modified from e1000_tbi_adjust_stats,</span>
<span class="cm">	 * called from the interrupt context, so they must only</span>
<span class="cm">	 * be written while holding adapter-&gt;stats_lock</span>
<span class="cm">	 */</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CRCERRS</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gprc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorcl</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GORCL</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gorch</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GORCH</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">bprc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">BPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mprc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPRC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ROC</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc64</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC64</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc127</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC127</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc255</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC255</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc511</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC511</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc1023</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC1023</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">prc1522</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC1522</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">symerrs</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SYMERRS</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mpc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">scc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SCC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ECOL</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mcc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MCC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">LATECOL</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">dc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">DC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sec</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SEC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rlec</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RLEC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xonrxc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XONRXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xontxc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XONTXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xoffrxc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XOFFRXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">xofftxc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XOFFTXC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">fcruc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">FCRUC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gptc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotcl</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GOTCL</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gotch</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GOTCH</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rnbc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RNBC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RUC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rfc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RFC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rjc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RJC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">torl</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TORL</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">torh</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TORH</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">totl</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TOTL</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">toth</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TOTH</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpr</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TPR</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc64</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC64</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc127</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC127</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc255</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC255</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc511</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC511</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc1023</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC1023</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ptc1522</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC1522</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mptc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPTC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">bptc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">BPTC</span><span class="p">);</span>

	<span class="cm">/* used for adaptive IFS */</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_packet_delta</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TPT</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tpt</span> <span class="o">+=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_packet_delta</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">collision_delta</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">COLC</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span> <span class="o">+=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">collision_delta</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ALGNERRC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rxerrc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXERRC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TNCRS</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cexterr</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CEXTERR</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tsctc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TSCTC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tsctfc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TSCTFC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Fill out the OS statistics structure */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">multicast</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mprc</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">collisions</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">colc</span><span class="p">;</span>

	<span class="cm">/* Rx Errors */</span>

	<span class="cm">/* RLEC on some newer hardware can be incorrect so build</span>
<span class="cm">	* our own version based on RUC and ROC */</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rxerrc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span> <span class="o">+</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">cexterr</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rlerrc</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ruc</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">roc</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_length_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rlerrc</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_crc_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">crcerrs</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_frame_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">algnerrc</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_missed_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mpc</span><span class="p">;</span>

	<span class="cm">/* Tx Errors */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">txerrc</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span> <span class="o">+</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">txerrc</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_aborted_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">ecol</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_window_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">latecol</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bad_tx_carr_stats_fd</span> <span class="o">&amp;&amp;</span>
	    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_duplex</span> <span class="o">==</span> <span class="n">FULL_DUPLEX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_carrier_errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tncrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Tx Dropped needs to be maintained elsewhere */</span>

	<span class="cm">/* Phy Stats */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">link_speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="o">!</span><span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_tmp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">phy_tmp</span> <span class="o">&amp;=</span> <span class="n">PHY_IDLE_ERROR_COUNT_MASK</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_stats</span><span class="p">.</span><span class="n">idle_errors</span> <span class="o">+=</span> <span class="n">phy_tmp</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;=</span> <span class="n">e1000_82546</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_RX_ERR_CNTR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_tmp</span><span class="p">))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">phy_stats</span><span class="p">.</span><span class="n">receive_errors</span> <span class="o">+=</span> <span class="n">phy_tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Management Stats */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">has_smbus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgptc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPTC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgprc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPRC</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">mgpdc</span> <span class="o">+=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPDC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_intr - Interrupt Handler</span>
<span class="cm"> * @irq: interrupt number</span>
<span class="cm"> * @data: pointer to a network interface device structure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">e1000_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icr</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="o">!</span><span class="n">icr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>  <span class="cm">/* Not our interrupt */</span>

	<span class="cm">/*</span>
<span class="cm">	 * we might have caused the interrupt, but the above</span>
<span class="cm">	 * read cleared it, and just in case the driver is</span>
<span class="cm">	 * down there is nothing to do so return handled</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">E1000_ICR_RXSEQ</span> <span class="o">|</span> <span class="n">E1000_ICR_LSC</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* guard against interrupt when we&#39;re going down */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">watchdog_task</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* disable interrupts, without the synchronize_irq bit */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">napi_schedule_prep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">__napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* this really should not happen! if it does it is basically a</span>
<span class="cm">		 * bug, but not a hard error, so enable ints and continue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean - NAPI Rx polling callback</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">e1000_adapter</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">tx_clean_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tx_clean_complete</span> <span class="o">=</span> <span class="n">e1000_clean_tx_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">clean_rx</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">work_done</span><span class="p">,</span> <span class="n">budget</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_clean_complete</span><span class="p">)</span>
		<span class="n">work_done</span> <span class="o">=</span> <span class="n">budget</span><span class="p">;</span>

	<span class="cm">/* If budget not fully consumed, exit the polling mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">itr_setting</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">))</span>
			<span class="n">e1000_set_itr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_tx_irq - Reclaim resources after transmit completes</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_clean_tx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">e1000_tx_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_tx_desc</span> <span class="o">*</span><span class="n">tx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">eop_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">eop</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_tx_bytes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_tx_packets</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">eop</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_to_watch</span><span class="p">;</span>
	<span class="n">eop_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">eop</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">eop_desc</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">.</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">E1000_TXD_STAT_DD</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span>	<span class="cm">/* read buffer_info after eop_desc */</span>
		<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="o">!</span><span class="n">cleaned</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tx_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">cleaned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">eop</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cleaned</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">total_tx_packets</span> <span class="o">+=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">segs</span><span class="p">;</span>
				<span class="n">total_tx_bytes</span> <span class="o">+=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">bytecount</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">e1000_unmap_and_free_tx_resource</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">);</span>
			<span class="n">tx_desc</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">eop</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next_to_watch</span><span class="p">;</span>
		<span class="n">eop_desc</span> <span class="o">=</span> <span class="n">E1000_TX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">eop</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#define TX_WAKE_THRESHOLD 32</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">E1000_DESC_UNUSED</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TX_WAKE_THRESHOLD</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Make sure that anybody stopping the queue after this</span>
<span class="cm">		 * sees the new next_to_clean.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_queue_stopped</span><span class="p">(</span><span class="n">netdev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
			<span class="o">++</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">restart_queue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">detect_tx_hung</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Detect a transmit hang in hardware, this serializes the</span>
<span class="cm">		 * check with the clearing of time_stamp and movement of i */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">detect_tx_hung</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">eop</span><span class="p">].</span><span class="n">time_stamp</span> <span class="o">&amp;&amp;</span>
		    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">eop</span><span class="p">].</span><span class="n">time_stamp</span> <span class="o">+</span>
		               <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_timeout_factor</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_TXOFF</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* detected Tx unit hang */</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="s">&quot;Detected Tx Unit Hang</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  Tx Queue             &lt;%lu&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  TDH                  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  TDT                  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  next_to_use          &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  next_to_clean        &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;buffer_info[next_to_clean]</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  time_stamp           &lt;%lx&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  next_to_watch        &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  jiffies              &lt;%lx&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot;  next_to_watch.status &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)((</span><span class="n">tx_ring</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">)</span> <span class="o">/</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_tx_ring</span><span class="p">)),</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tdh</span><span class="p">),</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">tdt</span><span class="p">),</span>
				<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">,</span>
				<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">,</span>
				<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">eop</span><span class="p">].</span><span class="n">time_stamp</span><span class="p">,</span>
				<span class="n">eop</span><span class="p">,</span>
				<span class="n">jiffies</span><span class="p">,</span>
				<span class="n">eop_desc</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">.</span><span class="n">fields</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
			<span class="n">e1000_dump</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_bytes</span> <span class="o">+=</span> <span class="n">total_tx_bytes</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_tx_packets</span> <span class="o">+=</span> <span class="n">total_tx_packets</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">total_tx_bytes</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span> <span class="o">+=</span> <span class="n">total_tx_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_rx_checksum - Receive Checksum Offload for 82543</span>
<span class="cm"> * @adapter:     board private structure</span>
<span class="cm"> * @status_err:  receive descriptor status and error fields</span>
<span class="cm"> * @csum:        receive descriptor csum field</span>
<span class="cm"> * @sk_buff:     socket buffer with received data</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_rx_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">status_err</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">csum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="n">status_err</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">errors</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">status_err</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>

	<span class="n">skb_checksum_none_assert</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* 82543 or newer only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82543</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Ignore Checksum bit is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_IXSM</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
	<span class="cm">/* TCP/UDP checksum error bit is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_ERR_TCPE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* let the stack verify checksum errors */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_csum_err</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* TCP/UDP Checksum has not been calculated */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_TCPCS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* It must be a TCP or UDP packet with a valid checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_TCPCS</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* TCP checksum is good */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_UNNECESSARY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_csum_good</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_consume_page - helper function</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_consume_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                               <span class="n">u16</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bi</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_receive_skb - helper function to handle rx indications</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @status: descriptor status field as written by hardware</span>
<span class="cm"> * @vlan: descriptor vlan field as written by hardware (no le/be conversion)</span>
<span class="cm"> * @skb: pointer to sk_buff to be indicated to stack</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="n">status</span><span class="p">,</span>
			      <span class="n">__le16</span> <span class="n">vlan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_VP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">vid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">vlan</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_SPC_VLAN_MASK</span><span class="p">;</span>

		<span class="n">__vlan_hwaccel_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">napi_gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_jumbo_rx_irq - Send received data up the network stack; legacy</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @rx_ring: ring to clean</span>
<span class="cm"> * @work_done: amount of napi work completed this call</span>
<span class="cm"> * @work_to_do: max amount of work allowed for this call to do</span>
<span class="cm"> *</span>
<span class="cm"> * the return value indicates whether actual cleaning was done, there</span>
<span class="cm"> * is no guarantee that everything was cleaned</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_clean_jumbo_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">next_rxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">,</span> <span class="o">*</span><span class="n">next_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_rx_bytes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_rx_packets</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">work_to_do</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">work_done</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span> <span class="cm">/* read descriptor and rx_buffer_info after status DD */</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">next_rxd</span> <span class="o">=</span> <span class="n">E1000_RX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">next_rxd</span><span class="p">);</span>

		<span class="n">next_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">cleaned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cleaned_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dma_unmap_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
			       <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

		<span class="cm">/* errors is only valid for DD + EOP descriptors */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_ERR_FRAME_ERR_MASK</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">mapped</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">last_byte</span><span class="p">;</span>

			<span class="n">mapped</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">last_byte</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">mapped</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TBI_ACCEPT</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
				       <span class="n">last_byte</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span>
				                  <span class="n">irq_flags</span><span class="p">);</span>
				<span class="n">e1000_tbi_adjust_stats</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span>
						       <span class="n">length</span><span class="p">,</span> <span class="n">mapped</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span>
				                       <span class="n">irq_flags</span><span class="p">);</span>
				<span class="n">length</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">process_skb</span><span class="p">;</span>
				<span class="cm">/* recycle both page and skb */</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="cm">/* an error means any chain goes out the window</span>
<span class="cm">				 * too */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span><span class="p">)</span>
					<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span><span class="p">);</span>
				<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rx_skb_top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="cp">#define rxtop rx_ring-&gt;rx_skb_top</span>
<span class="nl">process_skb:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* this descriptor is only the beginning (or middle) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxtop</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* this is the beginning of a chain */</span>
				<span class="n">rxtop</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">rxtop</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span>
				                   <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* this is the middle of a chain */</span>
				<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">rxtop</span><span class="p">,</span>
				    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">rxtop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
				    <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
				<span class="cm">/* re-use the skb, only consumed the page */</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">e1000_consume_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="p">,</span> <span class="n">rxtop</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rxtop</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* end of the chain */</span>
				<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">rxtop</span><span class="p">,</span>
				    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">rxtop</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
				    <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
				<span class="cm">/* re-use the current skb, we only consumed the</span>
<span class="cm">				 * page */</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">rxtop</span><span class="p">;</span>
				<span class="n">rxtop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">e1000_consume_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* no chain, got EOP, this buf is the packet</span>
<span class="cm">				 * copybreak to save the put_page/alloc_page */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">copybreak</span> <span class="o">&amp;&amp;</span>
				    <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
					<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
					<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
					<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
					<span class="cm">/* re-use the page, so don&#39;t erase</span>
<span class="cm">					 * buffer_info-&gt;page */</span>
					<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					                   <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				                           <span class="n">length</span><span class="p">);</span>
					<span class="n">e1000_consume_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
					                   <span class="n">length</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Receive Checksum Offload XXX recompute due to CRC strip? */</span>
		<span class="n">e1000_rx_checksum</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
		                  <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">status</span><span class="p">)</span> <span class="o">|</span>
		                  <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
		                  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">),</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span> <span class="cm">/* don&#39;t count FCS */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXFCS</span><span class="p">)))</span>
			<span class="n">pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">total_rx_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* eth type trans needs skb-&gt;data to point to something */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="s">&quot;pskb_may_pull failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">e1000_receive_skb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

<span class="nl">next_desc:</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* return some buffers to hardware, one at a time is too slow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cleaned_count</span> <span class="o">&gt;=</span> <span class="n">E1000_RX_BUFFER_WRITE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">);</span>
			<span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* use prefetched values */</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">next_rxd</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cleaned_count</span> <span class="o">=</span> <span class="n">E1000_DESC_UNUSED</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">+=</span> <span class="n">total_rx_packets</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">total_rx_bytes</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">total_rx_bytes</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">total_rx_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cleaned</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this should improve performance for small packets with large amounts</span>
<span class="cm"> * of reassembly being done in the stack</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_check_copybreak</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">length</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new_skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">copybreak</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">new_skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">new_skb</span><span class="p">,</span> <span class="o">-</span><span class="n">NET_IP_ALIGN</span><span class="p">,</span>
				       <span class="p">(</span><span class="o">*</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">NET_IP_ALIGN</span><span class="p">,</span>
				       <span class="n">length</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>
	<span class="cm">/* save the skb in buffer_info as good */</span>
	<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">new_skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clean_rx_irq - Send received data up the network stack; legacy</span>
<span class="cm"> * @adapter: board private structure</span>
<span class="cm"> * @rx_ring: ring to clean</span>
<span class="cm"> * @work_done: amount of napi work completed this call</span>
<span class="cm"> * @work_to_do: max amount of work allowed for this call to do</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_clean_rx_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="o">*</span><span class="n">work_done</span><span class="p">,</span> <span class="kt">int</span> <span class="n">work_to_do</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">,</span> <span class="o">*</span><span class="n">next_rxd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">,</span> <span class="o">*</span><span class="n">next_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cleaned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_rx_bytes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_rx_packets</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span><span class="p">;</span>
	<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_DD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">work_done</span> <span class="o">&gt;=</span> <span class="n">work_to_do</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">(</span><span class="o">*</span><span class="n">work_done</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rmb</span><span class="p">();</span> <span class="cm">/* read descriptor and rx_buffer_info after status DD */</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">prefetch</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">NET_IP_ALIGN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">next_rxd</span> <span class="o">=</span> <span class="n">E1000_RX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">prefetch</span><span class="p">(</span><span class="n">next_rxd</span><span class="p">);</span>

		<span class="n">next_buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">cleaned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cleaned_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
				 <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">length</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="cm">/* !EOP means multiple descriptors were used to store a single</span>
<span class="cm">		 * packet, if thats the case we need to toss it.  In fact, we</span>
<span class="cm">		 * to toss every packet with the EOP bit clear and the next</span>
<span class="cm">		 * frame that _does_ have the EOP bit set, as it is by</span>
<span class="cm">		 * definition only a frame fragment</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">)))</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">discarding</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">discarding</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* All receives must fit into a single buffer */</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Receive packet consumed multiple buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="cm">/* recycle */</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_STAT_EOP</span><span class="p">)</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">discarding</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">E1000_RXD_ERR_FRAME_ERR_MASK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">last_byte</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TBI_ACCEPT</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
				       <span class="n">last_byte</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="n">e1000_tbi_adjust_stats</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span>
				                       <span class="n">length</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span>
				                       <span class="n">flags</span><span class="p">);</span>
				<span class="n">length</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXALL</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">process_skb</span><span class="p">;</span>
				<span class="cm">/* recycle */</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next_desc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="nl">process_skb:</span>
		<span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span> <span class="cm">/* don&#39;t count FCS */</span>
		<span class="n">total_rx_packets</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_RXFCS</span><span class="p">)))</span>
			<span class="cm">/* adjust length to remove Ethernet CRC, this must be</span>
<span class="cm">			 * done after the TBI_ACCEPT workaround above</span>
<span class="cm">			 */</span>
			<span class="n">length</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>

		<span class="n">e1000_check_copybreak</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

		<span class="cm">/* Receive Checksum Offload */</span>
		<span class="n">e1000_rx_checksum</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				  <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">status</span><span class="p">)</span> <span class="o">|</span>
				  <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">),</span>
				  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">),</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">e1000_receive_skb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">special</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

<span class="nl">next_desc:</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* return some buffers to hardware, one at a time is too slow */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cleaned_count</span> <span class="o">&gt;=</span> <span class="n">E1000_RX_BUFFER_WRITE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">);</span>
			<span class="n">cleaned_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* use prefetched values */</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">next_rxd</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="n">next_buffer</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_clean</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cleaned_count</span> <span class="o">=</span> <span class="n">E1000_DESC_UNUSED</span><span class="p">(</span><span class="n">rx_ring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buf</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">rx_ring</span><span class="p">,</span> <span class="n">cleaned_count</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_packets</span> <span class="o">+=</span> <span class="n">total_rx_packets</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">total_rx_bytes</span> <span class="o">+=</span> <span class="n">total_rx_bytes</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">total_rx_bytes</span><span class="p">;</span>
	<span class="n">netdev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span> <span class="o">+=</span> <span class="n">total_rx_packets</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cleaned</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_alloc_jumbo_rx_buffers - Replace used jumbo receive buffers</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> * @rx_ring: pointer to receive ring structure</span>
<span class="cm"> * @cleaned_count: number of buffers to allocate this pass</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">e1000_alloc_jumbo_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cleaned_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsz</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">-</span> <span class="mi">16</span> <span class="cm">/*for skb_reserve */</span> <span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">check_page</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Better luck next round */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">;</span>
<span class="nl">check_page:</span>
		<span class="cm">/* allocate a new page if necessary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			                                <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
							<span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* while !buffer_info-&gt;skb */</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">!=</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Force memory writes to complete before letting h/w</span>
<span class="cm">		 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">		 * applicable for weak-ordered memory model archs,</span>
<span class="cm">		 * such as IA-64). */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rdt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_alloc_rx_buffers - Replace used receive buffers; legacy &amp; extended</span>
<span class="cm"> * @adapter: address of board private structure</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_alloc_rx_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">e1000_rx_ring</span> <span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">cleaned_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_rx_desc</span> <span class="o">*</span><span class="n">rx_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">e1000_buffer</span> <span class="o">*</span><span class="n">buffer_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsz</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>
	<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cleaned_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">map_skb</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Better luck next round */</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Fix for errata 23, can&#39;t cross 64kB boundary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_check_64k_bound</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">oldskb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">rx_err</span><span class="p">,</span> <span class="s">&quot;skb align check failed: %u bytes at &quot;</span>
			      <span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="cm">/* Try again, without freeing the previous */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">);</span>
			<span class="cm">/* Failed allocation, critical failure */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">oldskb</span><span class="p">);</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_check_64k_bound</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* give up */</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">oldskb</span><span class="p">);</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* while !buffer_info-&gt;skb */</span>
			<span class="p">}</span>

			<span class="cm">/* Use new allocation */</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">oldskb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">;</span>
<span class="nl">map_skb:</span>
		<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
						  <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
						  <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_mapping_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* while !buffer_info-&gt;skb */</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * XXX if it was allocated cleanly it will never map to a</span>
<span class="cm">		 * boundary crossing</span>
<span class="cm">		 */</span>

		<span class="cm">/* Fix for errata 23, can&#39;t cross 64kB boundary */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_check_64k_bound</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">e_err</span><span class="p">(</span><span class="n">rx_err</span><span class="p">,</span> <span class="s">&quot;dma align check failed: %u bytes at &quot;</span>
			      <span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">dma_unmap_single</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span>
					 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_buffer_len</span><span class="p">,</span>
					 <span class="n">DMA_FROM_DEVICE</span><span class="p">);</span>
			<span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">alloc_rx_buff_failed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* while !buffer_info-&gt;skb */</span>
		<span class="p">}</span>
		<span class="n">rx_desc</span> <span class="o">=</span> <span class="n">E1000_RX_DESC</span><span class="p">(</span><span class="o">*</span><span class="n">rx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">rx_desc</span><span class="o">-&gt;</span><span class="n">buffer_addr</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">buffer_info</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">==</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">buffer_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">buffer_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">!=</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">i</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Force memory writes to complete before letting h/w</span>
<span class="cm">		 * know there are new descriptors to fetch.  (Only</span>
<span class="cm">		 * applicable for weak-ordered memory model archs,</span>
<span class="cm">		 * such as IA-64). */</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">hw_addr</span> <span class="o">+</span> <span class="n">rx_ring</span><span class="o">-&gt;</span><span class="n">rdt</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_smartspeed - Workaround for SmartSpeed on 82541 and 82547 controllers.</span>
<span class="cm"> * @adapter:</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_smartspeed</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_status</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_ctrl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">!=</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">||</span>
	   <span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">smartspeed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If Master/Slave config fault is asserted twice,</span>
<span class="cm">		 * we assume back-to-back */</span>
		<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phy_status</span> <span class="o">&amp;</span> <span class="n">SR_1000T_MS_CONFIG_FAULT</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
		<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phy_status</span> <span class="o">&amp;</span> <span class="n">SR_1000T_MS_CONFIG_FAULT</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
		<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_ctrl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_ctrl</span> <span class="o">&amp;</span> <span class="n">CR_1000T_MS_ENABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phy_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CR_1000T_MS_ENABLE</span><span class="p">;</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span>
					    <span class="n">phy_ctrl</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">smartspeed</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_phy_setup_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span>
				   	       <span class="o">&amp;</span><span class="n">phy_ctrl</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">phy_ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MII_CR_AUTO_NEG_EN</span> <span class="o">|</span>
					     <span class="n">MII_CR_RESTART_AUTO_NEG</span><span class="p">);</span>
				<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span>
						    <span class="n">phy_ctrl</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">smartspeed</span> <span class="o">==</span> <span class="n">E1000_SMARTSPEED_DOWNSHIFT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If still no link, perhaps using 2/3 pair cable */</span>
		<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_ctrl</span><span class="p">);</span>
		<span class="n">phy_ctrl</span> <span class="o">|=</span> <span class="n">CR_1000T_MS_ENABLE</span><span class="p">;</span>
		<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="n">phy_ctrl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_phy_setup_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_ctrl</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phy_ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MII_CR_AUTO_NEG_EN</span> <span class="o">|</span>
				     <span class="n">MII_CR_RESTART_AUTO_NEG</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="n">phy_ctrl</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Restart process after E1000_SMARTSPEED_MAX iterations */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">smartspeed</span><span class="o">++</span> <span class="o">==</span> <span class="n">E1000_SMARTSPEED_MAX</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">smartspeed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_ioctl -</span>
<span class="cm"> * @netdev:</span>
<span class="cm"> * @ifreq:</span>
<span class="cm"> * @cmd:</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
		<span class="k">return</span> <span class="n">e1000_mii_ioctl</span><span class="p">(</span><span class="n">netdev</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_mii_ioctl -</span>
<span class="cm"> * @netdev:</span>
<span class="cm"> * @ifreq:</span>
<span class="cm"> * @cmd:</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_mii_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mii_ioctl_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">if_mii</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_addr</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">val_out</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x1F</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">mii_reg</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">val_in</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">,</span>
					<span class="n">mii_reg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">stats_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">PHY_CTRL</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">mii_reg</span> <span class="o">&amp;</span> <span class="n">MII_CR_POWER_DOWN</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mii_reg</span> <span class="o">&amp;</span> <span class="n">MII_CR_AUTO_NEG_EN</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="mh">0x2F</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">u32</span> <span class="n">speed</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">mii_reg</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>
						<span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_1000</span><span class="p">;</span>
					<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mii_reg</span> <span class="o">&amp;</span> <span class="mh">0x2000</span><span class="p">)</span>
						<span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_100</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_10</span><span class="p">;</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="n">e1000_set_spd_dplx</span><span class="p">(</span>
						<span class="n">adapter</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span>
						<span class="p">((</span><span class="n">mii_reg</span> <span class="o">&amp;</span> <span class="mh">0x100</span><span class="p">)</span>
						 <span class="o">?</span> <span class="n">DUPLEX_FULL</span> <span class="o">:</span>
						 <span class="n">DUPLEX_HALF</span><span class="p">));</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
						<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
					<span class="n">e1000_reinit_locked</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span>:
			<span class="k">case</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">e1000_phy_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">reg_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">PHY_CTRL</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">mii_reg</span> <span class="o">&amp;</span> <span class="n">MII_CR_POWER_DOWN</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">))</span>
					<span class="n">e1000_reinit_locked</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000_pci_set_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">pci_set_mwi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Error in setting MWI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000_pci_clear_mwi</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>

	<span class="n">pci_clear_mwi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">e1000_pcix_get_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pcix_get_mmrbc</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000_pcix_set_mmrbc</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mmrbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">;</span>
	<span class="n">pcix_set_mmrbc</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">mmrbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">e1000_io_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">outl</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">e1000_vlan_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>

	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">,</span> <span class="n">VLAN_N_VID</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__e1000_vlan_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			      <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_RX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable VLAN tag insert/strip */</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_VME</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* disable VLAN tag insert/strip */</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_VME</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_vlan_filter_on_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				     <span class="n">bool</span> <span class="n">filter_on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">e1000_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">__e1000_vlan_mode</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enable VLAN receive filtering */</span>
		<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_CFIEN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">))</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_VFE</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
		<span class="n">e1000_update_mng_vlan</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* disable VLAN receive filtering */</span>
		<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
		<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_VFE</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_vlan_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span>
			    <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">e1000_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">__e1000_vlan_mode</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_vlan_rx_add_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mng_cookie</span><span class="p">.</span><span class="n">status</span> <span class="o">&amp;</span>
	     <span class="n">E1000_MNG_DHCP_COOKIE_STATUS_VLAN_SUPPORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vid</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mng_vlan_id</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_vlan_used</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">e1000_vlan_filter_on_off</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* add VID to filter table */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">vid</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
	<span class="n">vfta</span> <span class="o">=</span> <span class="n">E1000_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">vfta</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vid</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">));</span>
	<span class="n">e1000_write_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vfta</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_vlan_rx_kill_vid</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">vid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">e1000_irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">e1000_irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* remove VID from filter table */</span>
	<span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">vid</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
	<span class="n">vfta</span> <span class="o">=</span> <span class="n">E1000_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">vfta</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">vid</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">));</span>
	<span class="n">e1000_write_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">vfta</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_vlan_used</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">e1000_vlan_filter_on_off</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_restore_vlan</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">vid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e1000_vlan_used</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">e1000_vlan_filter_on_off</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">for_each_set_bit</span><span class="p">(</span><span class="n">vid</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">active_vlans</span><span class="p">,</span> <span class="n">VLAN_N_VID</span><span class="p">)</span>
		<span class="n">e1000_vlan_rx_add_vid</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">vid</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">e1000_set_spd_dplx</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">spd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dplx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Make sure dplx is at most 1 bit and lsb of speed is not set</span>
<span class="cm">	 * for the switch() below to work */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">spd</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dplx</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_inval</span><span class="p">;</span>

	<span class="cm">/* Fiber NICs only allow 1000 gbps Full duplex */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">spd</span> <span class="o">!=</span> <span class="n">SPEED_1000</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dplx</span> <span class="o">!=</span> <span class="n">DUPLEX_FULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_inval</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">spd</span> <span class="o">+</span> <span class="n">dplx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SPEED_10</span> <span class="o">+</span> <span class="n">DUPLEX_HALF</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">=</span> <span class="n">e1000_10_half</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_10</span> <span class="o">+</span> <span class="n">DUPLEX_FULL</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">=</span> <span class="n">e1000_10_full</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_100</span> <span class="o">+</span> <span class="n">DUPLEX_HALF</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">=</span> <span class="n">e1000_100_half</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_100</span> <span class="o">+</span> <span class="n">DUPLEX_FULL</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">=</span> <span class="n">e1000_100_full</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_1000</span> <span class="o">+</span> <span class="n">DUPLEX_FULL</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SPEED_1000</span> <span class="o">+</span> <span class="n">DUPLEX_HALF</span>: <span class="cm">/* not supported */</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">err_inval</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_inval:</span>
	<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;Unsupported Speed/Duplex configuration</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__e1000_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">enable_wake</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">,</span> <span class="n">rctl</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">wufc</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wol</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__E1000_RESETTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
		<span class="n">e1000_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)</span>
		<span class="n">wufc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_WUFC_LNKC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wufc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e1000_setup_rctl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">e1000_set_rx_mode</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

		<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>

		<span class="cm">/* turn on all-multi mode if wake on multicast is enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wufc</span> <span class="o">&amp;</span> <span class="n">E1000_WUFC_MC</span><span class="p">)</span>
			<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_MPE</span><span class="p">;</span>

		<span class="cm">/* enable receives in the hardware */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span> <span class="o">|</span> <span class="n">E1000_RCTL_EN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82540</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
			<span class="cm">/* advertise wake from D3Cold */</span>
			<span class="cp">#define E1000_CTRL_ADVD3WUC 0x00100000</span>
			<span class="cm">/* phy power management enable */</span>
			<span class="cp">#define E1000_CTRL_EN_PHY_PWR_MGMT 0x00200000</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_ADVD3WUC</span> <span class="o">|</span>
				<span class="n">E1000_CTRL_EN_PHY_PWR_MGMT</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span> <span class="o">||</span>
		    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* keep the laser running in D3 */</span>
			<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
			<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_SDP7_DATA</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">WUC</span><span class="p">,</span> <span class="n">E1000_WUC_PME_EN</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">WUFC</span><span class="p">,</span> <span class="n">wufc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">WUC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">WUFC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e1000_release_manageability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="o">*</span><span class="n">enable_wake</span> <span class="o">=</span> <span class="o">!!</span><span class="n">wufc</span><span class="p">;</span>

	<span class="cm">/* make sure adapter isn&#39;t asleep if manageability is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">en_mng_pt</span><span class="p">)</span>
		<span class="o">*</span><span class="n">enable_wake</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000_free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wake</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">__e1000_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wake</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wake</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_prepare_to_sleep</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">e1000_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D0</span><span class="p">);</span>
	<span class="n">pci_restore_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_save_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">need_ioport</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Cannot enable PCI device from suspend</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3cold</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">e1000_request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e1000_power_up_phy</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">WUS</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">e1000_init_manageability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">wake</span><span class="p">;</span>

	<span class="n">__e1000_shutdown</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wake</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_POWER_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_wake_from_d3</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">wake</span><span class="p">);</span>
		<span class="n">pci_set_power_state</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_POLL_CONTROLLER</span>
<span class="cm">/*</span>
<span class="cm"> * Polling &#39;interrupt&#39; - used by things like netconsole to send skbs</span>
<span class="cm"> * without having to re-enable interrupts. It&#39;s not called while</span>
<span class="cm"> * the interrupt routine is executing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_netpoll</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">e1000_intr</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">netdev</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_io_error_detected - called when PCI error is detected</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> * @state: The current pci connection state</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after a PCI bus error affecting</span>
<span class="cm"> * this device has been detected.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">e1000_io_error_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">pci_channel_state_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">netif_device_detach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">pci_channel_io_perm_failure</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span>
		<span class="n">e1000_down</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Request a slot slot reset. */</span>
	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_io_slot_reset - called after the pci bus has been reset.</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Restart the card from scratch, as if from a cold-boot. Implementation</span>
<span class="cm"> * resembles the first-half of the e1000_resume routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">e1000_io_slot_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">need_ioport</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device_mem</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Cannot re-enable PCI device after reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3hot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pci_enable_wake</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_D3cold</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">e1000_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">WUS</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_io_resume - called when traffic can start flowing again.</span>
<span class="cm"> * @pdev: Pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * This callback is called when the error recovery driver tells us that</span>
<span class="cm"> * its OK to resume normal operation. Implementation resembles the</span>
<span class="cm"> * second-half of the e1000_resume routine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_io_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">e1000_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>

	<span class="n">e1000_init_manageability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">netdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_up</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;can&#39;t bring device back up after reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">netif_device_attach</span><span class="p">(</span><span class="n">netdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* e1000_main.c */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
