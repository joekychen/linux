<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › e1000 › e1000_hw.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>e1000_hw.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel PRO/1000 Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2006 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  Linux NICS &lt;linux.nics@intel.com&gt;</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm"> */</span>

<span class="cm">/* e1000_hw.c</span>
<span class="cm"> * Shared functions for accessing and configuring the MAC</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;e1000.h&quot;</span>

<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_check_downshift</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_check_polarity</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="n">e1000_rev_polarity</span> <span class="o">*</span><span class="n">polarity</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clear_hw_cntrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_clear_vfta</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_config_dsp_after_link_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
					      <span class="n">bool</span> <span class="n">link_up</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_config_fc_after_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_detect_gig_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_get_auto_rd_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_get_cable_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">min_length</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="o">*</span><span class="n">max_length</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_get_phy_cfg_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_id_led_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_init_rx_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_phy_igp_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy_info</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_phy_m88_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy_info</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_set_d3_lplu_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_wait_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_write_reg_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_set_phy_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_phy_init_script</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_setup_copper_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_setup_fiber_serdes_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_adjust_serdes_amplitude</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_phy_force_speed_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_config_mac_to_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_raise_mdi_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_lower_mdi_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_shift_out_mdi_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">e1000_shift_in_mdi_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_phy_reset_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_write_eeprom_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_write_eeprom_microwire</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_spi_eeprom_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_raise_ee_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eecd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_lower_ee_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eecd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_write_phy_reg_ex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="n">phy_data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_read_phy_reg_ex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span>
				 <span class="n">u16</span> <span class="o">*</span><span class="n">phy_data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">e1000_shift_in_ee_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_acquire_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_release_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_set_vco_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_polarity_reversal_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_set_phy_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_do_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span>
				<span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="k">static</span> <span class="n">s32</span> <span class="n">e1000_do_write_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span>
				 <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* IGP cable length table */</span>
<span class="k">static</span> <span class="k">const</span>
<span class="n">u16</span> <span class="n">e1000_igp_cable_length_table</span><span class="p">[</span><span class="n">IGP01E1000_AGC_LENGTH_TABLE_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span>
	<span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span>
	<span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span>
	<span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span>
	<span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span>
	<span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span>
	    <span class="mi">100</span><span class="p">,</span>
	<span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span>
	    <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span>
	<span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span>
	    <span class="mi">120</span><span class="p">,</span> <span class="mi">120</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">e1000_eeprom_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_set_phy_type - Set the phy type member in the hw struct.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_phy_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_set_phy_type&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_undefined</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY_TYPE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">M88E1000_E_PHY_ID</span>:
	<span class="k">case</span> <span class="n">M88E1000_I_PHY_ID</span>:
	<span class="k">case</span> <span class="n">M88E1011_I_PHY_ID</span>:
	<span class="k">case</span> <span class="n">M88E1111_I_PHY_ID</span>:
	<span class="k">case</span> <span class="n">M88E1118_E_PHY_ID</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_m88</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IGP01E1000_I_PHY_ID</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541</span> <span class="o">||</span>
		    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541_rev_2</span> <span class="o">||</span>
		    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span> <span class="o">||</span>
		    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547_rev_2</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_igp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RTL8211B_PHY_ID</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_8211</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RTL8201N_PHY_ID</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_8201</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Should never have loaded on this device */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">=</span> <span class="n">e1000_phy_undefined</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY_TYPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_init_script - IGP phy init script - initializes the GbE PHY</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_phy_init_script</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_saved_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_init_script&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_init_script</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

		<span class="cm">/* Save off the current value of register 0x2F5B to be restored at</span>
<span class="cm">		 * the end of this routine. */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_saved_data</span><span class="p">);</span>

		<span class="cm">/* Disabled the PHY transmitter */</span>
		<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

		<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x0140</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">e1000_82541</span>:
		<span class="k">case</span> <span class="n">e1000_82547</span>:
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F95</span><span class="p">,</span> <span class="mh">0x0001</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F71</span><span class="p">,</span> <span class="mh">0xBD21</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F79</span><span class="p">,</span> <span class="mh">0x0018</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F30</span><span class="p">,</span> <span class="mh">0x1600</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F31</span><span class="p">,</span> <span class="mh">0x0014</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F32</span><span class="p">,</span> <span class="mh">0x161C</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F94</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F96</span><span class="p">,</span> <span class="mh">0x003F</span><span class="p">);</span>
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2010</span><span class="p">,</span> <span class="mh">0x0008</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
		<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
			<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x1F73</span><span class="p">,</span> <span class="mh">0x0099</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x3300</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

		<span class="cm">/* Now enable the transmitter */</span>
		<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="n">phy_saved_data</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">fused</span><span class="p">,</span> <span class="n">fine</span><span class="p">,</span> <span class="n">coarse</span><span class="p">;</span>

			<span class="cm">/* Move to analog registers page */</span>
			<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					   <span class="n">IGP01E1000_ANALOG_SPARE_FUSE_STATUS</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">fused</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fused</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_ANALOG_SPARE_FUSE_ENABLED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						   <span class="n">IGP01E1000_ANALOG_FUSE_STATUS</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">fused</span><span class="p">);</span>

				<span class="n">fine</span> <span class="o">=</span> <span class="n">fused</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_ANALOG_FUSE_FINE_MASK</span><span class="p">;</span>
				<span class="n">coarse</span> <span class="o">=</span>
				    <span class="n">fused</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_ANALOG_FUSE_COARSE_MASK</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">coarse</span> <span class="o">&gt;</span>
				    <span class="n">IGP01E1000_ANALOG_FUSE_COARSE_THRESH</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">coarse</span> <span class="o">-=</span>
					    <span class="n">IGP01E1000_ANALOG_FUSE_COARSE_10</span><span class="p">;</span>
					<span class="n">fine</span> <span class="o">-=</span> <span class="n">IGP01E1000_ANALOG_FUSE_FINE_1</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">coarse</span> <span class="o">==</span>
					   <span class="n">IGP01E1000_ANALOG_FUSE_COARSE_THRESH</span><span class="p">)</span>
					<span class="n">fine</span> <span class="o">-=</span> <span class="n">IGP01E1000_ANALOG_FUSE_FINE_10</span><span class="p">;</span>

				<span class="n">fused</span> <span class="o">=</span>
				    <span class="p">(</span><span class="n">fused</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_ANALOG_FUSE_POLY_MASK</span><span class="p">)</span> <span class="o">|</span>
				    <span class="p">(</span><span class="n">fine</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_ANALOG_FUSE_FINE_MASK</span><span class="p">)</span> <span class="o">|</span>
				    <span class="p">(</span><span class="n">coarse</span> <span class="o">&amp;</span>
				     <span class="n">IGP01E1000_ANALOG_FUSE_COARSE_MASK</span><span class="p">);</span>

				<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						    <span class="n">IGP01E1000_ANALOG_FUSE_CONTROL</span><span class="p">,</span>
						    <span class="n">fused</span><span class="p">);</span>
				<span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						    <span class="n">IGP01E1000_ANALOG_FUSE_BYPASS</span><span class="p">,</span>
						    <span class="n">IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_set_mac_type - Set the mac type member in the hw struct.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_set_mac_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_set_mac_type&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82542</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">revision_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">E1000_82542_2_0_REV_ID</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82542_rev2_0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">E1000_82542_2_1_REV_ID</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82542_rev2_1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* Invalid 82542 revision ID */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_MAC_TYPE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82543GC_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82543GC_COPPER</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82543</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82544EI_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82544EI_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82544GC_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82544GC_LOM</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82544</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EM</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EM_LOM</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EP</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EP_LOM</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82540EP_LP</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82540</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82545EM_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82545EM_FIBER</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82545</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82545GM_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82545GM_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82545GM_SERDES</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82545_rev_3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546EB_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546EB_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546EB_QUAD_COPPER</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82546</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_FIBER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_SERDES</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_PCIE</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_QUAD_COPPER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82546_rev_3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541EI</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541EI_MOBILE</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541ER_LOM</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82541</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541ER</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541GI</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541GI_LF</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82541GI_MOBILE</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82541_rev_2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82547EI</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82547EI_MOBILE</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82547</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82547GI</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_82547_rev_2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_INTEL_CE4100_GBE</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">=</span> <span class="n">e1000_ce4100</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Should never have loaded on this device */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_MAC_TYPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82547</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
	<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">asf_firmware_present</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The 82543 chip does not count tx_carrier_errors properly in</span>
<span class="cm">	 * FD mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82543</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bad_tx_carr_stats_fd</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82544</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">has_smbus</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_set_media_type - Set media type and TBI compatibility.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000_set_media_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_set_media_type&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">!=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* tbi_compatibility is only valid on 82543 */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_en</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82545GM_SERDES</span>:
	<span class="k">case</span> <span class="n">E1000_DEV_ID_82546GB_SERDES</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
		<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_fiber</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_ce4100</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_copper</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_TBIMODE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_fiber</span><span class="p">;</span>
				<span class="cm">/* tbi_compatibility not valid on fiber */</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_en</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">=</span> <span class="n">e1000_media_type_copper</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_reset_hw: reset the hardware completely</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Reset the transmit and receive units; mask and clear all interrupts.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_reset_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">manc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">led_ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_reset_hw&quot;</span><span class="p">);</span>

	<span class="cm">/* For 82542 (rev 2.0), disable MWI before issuing a device reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Disabling MWI on 82542 rev 2.0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">e1000_pci_clear_mwi</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clear interrupt mask to stop board from generating interrupts */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Masking off all interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>

	<span class="cm">/* Disable the Transmit and Receive units.  Then delay to allow</span>
<span class="cm">	 * any pending transactions to complete before we hit the MAC with</span>
<span class="cm">	 * the global reset.</span>
<span class="cm">	 */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">E1000_TCTL_PSP</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

	<span class="cm">/* The tbi_compatibility_on Flag must be cleared when Rctl is cleared. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_on</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Delay to allow any outstanding PCI transactions to complete before</span>
<span class="cm">	 * resetting the device</span>
<span class="cm">	 */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="cm">/* Must reset the PHY before resetting the MAC */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_PHY_RST</span><span class="p">));</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Issue a global reset to the MAC.  This will reset the chip&#39;s</span>
<span class="cm">	 * transmit, receive, DMA, and link units.  It will not effect</span>
<span class="cm">	 * the current PCI configuration.  The global reset bit is self-</span>
<span class="cm">	 * clearing, and should clear within a microsecond.</span>
<span class="cm">	 */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Issuing a global reset to MAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82544</span>:
	<span class="k">case</span> <span class="n">e1000_82540</span>:
	<span class="k">case</span> <span class="n">e1000_82545</span>:
	<span class="k">case</span> <span class="n">e1000_82546</span>:
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
		<span class="cm">/* These controllers can&#39;t ack the 64-bit write when issuing the</span>
<span class="cm">		 * reset, so use IO-mapping as a workaround to issue the reset */</span>
		<span class="n">E1000_WRITE_REG_IO</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">CTRL</span><span class="p">,</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_RST</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82545_rev_3</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="cm">/* Reset is performed on a shadow of the control register */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_DUP</span><span class="p">,</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_RST</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_ce4100</span>:
	<span class="nl">default:</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_RST</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* After MAC reset, force reload of EEPROM to restore power-on settings to</span>
<span class="cm">	 * device.  Later controllers reload the EEPROM automatically, so just wait</span>
<span class="cm">	 * for reload to complete.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
	<span class="k">case</span> <span class="n">e1000_82543</span>:
	<span class="k">case</span> <span class="n">e1000_82544</span>:
		<span class="cm">/* Wait for reset to complete */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
		<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_EE_RST</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="cm">/* Wait for EEPROM reload */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
	<span class="k">case</span> <span class="n">e1000_82547</span>:
	<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
		<span class="cm">/* Wait for EEPROM reload */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Auto read done will delay 5ms or poll based on mac type */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_auto_rd_done</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disable HW ARPs on ASF enabled adapters */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82540</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">manc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MANC</span><span class="p">);</span>
		<span class="n">manc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_MANC_ARP_EN</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">MANC</span><span class="p">,</span> <span class="n">manc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e1000_phy_init_script</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Configure activity LED after PHY reset */</span>
		<span class="n">led_ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">);</span>
		<span class="n">led_ctrl</span> <span class="o">&amp;=</span> <span class="n">IGP_ACTIVITY_LED_MASK</span><span class="p">;</span>
		<span class="n">led_ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IGP_ACTIVITY_LED_ENABLE</span> <span class="o">|</span> <span class="n">IGP_LED3_MODE</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">led_ctrl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clear interrupt mask to stop board from generating interrupts */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Masking off all interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>

	<span class="cm">/* Clear any pending interrupt events. */</span>
	<span class="n">icr</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>

	<span class="cm">/* If MWI was previously enabled, reenable it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">pci_cmd_word</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_INVALIDATE</span><span class="p">)</span>
			<span class="n">e1000_pci_set_mwi</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_init_hw: Performs basic configuration of the adapter.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes that the controller has previously been reset and is in a</span>
<span class="cm"> * post-reset uninitialized state. Initializes the receive address registers,</span>
<span class="cm"> * multicast table, and VLAN filter table. Calls routines to setup link</span>
<span class="cm"> * configuration and flow control settings. Clears all on-chip counters. Leaves</span>
<span class="cm"> * the transmit and receive units disabled and uninitialized.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_init_hw</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mta_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_init_hw&quot;</span><span class="p">);</span>

	<span class="cm">/* Initialize Identification LED */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_id_led_init</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Initializing Identification LED</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set the media type and TBI compatibility */</span>
	<span class="n">e1000_set_media_type</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Disabling VLAN filtering. */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Initializing the IEEE VLAN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82545_rev_3</span><span class="p">)</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">VET</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">e1000_clear_vfta</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* For 82542 (rev 2.0), disable MWI and put the receiver into reset */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Disabling MWI on 82542 rev 2.0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">e1000_pci_clear_mwi</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">E1000_RCTL_RST</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Setup the receive address. This involves initializing all of the Receive</span>
<span class="cm">	 * Address Registers (RARs 0 - 15).</span>
<span class="cm">	 */</span>
	<span class="n">e1000_init_rx_addrs</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* For 82542 (rev 2.0), take the receiver out of reset and enable MWI */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">pci_cmd_word</span> <span class="o">&amp;</span> <span class="n">PCI_COMMAND_INVALIDATE</span><span class="p">)</span>
			<span class="n">e1000_pci_set_mwi</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Zero out the Multicast HASH table */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Zeroing the MTA</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mta_size</span> <span class="o">=</span> <span class="n">E1000_MC_TBL_SIZE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mta_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MTA</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* use write flush to prevent Memory Write Block (MWB) from</span>
<span class="cm">		 * occurring when accessing our register space */</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Set the PCI priority bit correctly in the CTRL register.  This</span>
<span class="cm">	 * determines if the adapter gives priority to receives, or if it</span>
<span class="cm">	 * gives equal priority to transmits and receives.  Valid only on</span>
<span class="cm">	 * 82542 and 82543 silicon.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dma_fairness</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_PRIOR</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82545_rev_3</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Workaround for PCI-X problem when BIOS sets MMRBC incorrectly. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">e1000_bus_type_pcix</span>
		    <span class="o">&amp;&amp;</span> <span class="n">e1000_pcix_get_mmrbc</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2048</span><span class="p">)</span>
			<span class="n">e1000_pcix_set_mmrbc</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">2048</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Call a subroutine to configure the link and setup flow control. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_setup_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Set the transmit descriptor write-back policy */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXDCTL_WTHRESH</span><span class="p">)</span> <span class="o">|</span>
		    <span class="n">E1000_TXDCTL_FULL_TX_DESC_WB</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TXDCTL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Clear all of the statistics registers (clear on read).  It is</span>
<span class="cm">	 * important that we do this after we have tried to establish link</span>
<span class="cm">	 * because the symbol error count will increment wildly if there</span>
<span class="cm">	 * is no link.</span>
<span class="cm">	 */</span>
	<span class="n">e1000_clear_hw_cntrs</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">==</span> <span class="n">E1000_DEV_ID_82546GB_QUAD_COPPER</span> <span class="o">||</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">==</span> <span class="n">E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
		<span class="cm">/* Relaxed ordering must be disabled to avoid a parity</span>
<span class="cm">		 * error crash in a PCI slot. */</span>
		<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_RO_DIS</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_adjust_serdes_amplitude - Adjust SERDES output amplitude based on EEPROM setting.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_adjust_serdes_amplitude</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_adjust_serdes_amplitude&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82545_rev_3</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_SERDES_AMPLITUDE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	                            <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">!=</span> <span class="n">EEPROM_RESERVED_WORD</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Adjust SERDES output amplitude only. */</span>
		<span class="n">eeprom_data</span> <span class="o">&amp;=</span> <span class="n">EEPROM_SERDES_AMPLITUDE_MASK</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_EXT_CTRL</span><span class="p">,</span> <span class="n">eeprom_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_link - Configures flow control and link settings.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Determines which flow control settings to use. Calls the appropriate media-</span>
<span class="cm"> * specific link configuration function. Configures the flow control settings.</span>
<span class="cm"> * Assuming the adapter has a valid link partner, a valid link should be</span>
<span class="cm"> * established. Assumes the hardware has previously been reset and the</span>
<span class="cm"> * transmitter and receiver are not enabled.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_setup_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl_ext</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_setup_link&quot;</span><span class="p">);</span>

	<span class="cm">/* Read and store word 0x0F of the EEPROM. This word contains bits</span>
<span class="cm">	 * that determine the hardware&#39;s default PAUSE (flow control) mode,</span>
<span class="cm">	 * a bit that determines whether the HW defaults to enabling or</span>
<span class="cm">	 * disabling auto-negotiation, and the direction of the</span>
<span class="cm">	 * SW defined pins. If there is no SW over-ride of the flow</span>
<span class="cm">	 * control setting, then the variable hw-&gt;fc will</span>
<span class="cm">	 * be initialized based on a value in the EEPROM.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">==</span> <span class="n">E1000_FC_DEFAULT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_INIT_CONTROL2_REG</span><span class="p">,</span>
					    <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="n">EEPROM_WORD0F_PAUSE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_NONE</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="n">EEPROM_WORD0F_PAUSE_MASK</span><span class="p">)</span> <span class="o">==</span>
			 <span class="n">EEPROM_WORD0F_ASM_DIR</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_TX_PAUSE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_FULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We want to save off the original Flow Control configuration just</span>
<span class="cm">	 * in case we get disconnected and then reconnected into a different</span>
<span class="cm">	 * hub or switch with different Flow Control capabilities.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">E1000_FC_TX_PAUSE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">report_tx_early</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">E1000_FC_RX_PAUSE</span><span class="p">);</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">original_fc</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;After fix-ups FlowControl is now = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">);</span>

	<span class="cm">/* Take the 4 bits from EEPROM word 0x0F that determine the initial</span>
<span class="cm">	 * polarity value for the SW controlled pins, and setup the</span>
<span class="cm">	 * Extended Device Control reg with that info.</span>
<span class="cm">	 * This is needed because one of the SW controlled pins is used for</span>
<span class="cm">	 * signal detection.  So this should be done before e1000_setup_pcs_link()</span>
<span class="cm">	 * or e1000_phy_setup() is called.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_INIT_CONTROL2_REG</span><span class="p">,</span>
					    <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="p">((</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="n">EEPROM_WORD0F_SWPDIO_EXT</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
			    <span class="n">SWDPIO__EXT_SHIFT</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Call the necessary subroutine to configure the link. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="o">?</span>
	    <span class="n">e1000_setup_copper_link</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">:</span> <span class="n">e1000_setup_fiber_serdes_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Initialize the flow control address, type, and PAUSE timer</span>
<span class="cm">	 * registers to their default values.  This is done even if flow</span>
<span class="cm">	 * control is disabled, because it does not hurt anything to</span>
<span class="cm">	 * initialize these registers.</span>
<span class="cm">	 */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Initializing the Flow Control address, type and timer regs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">FCT</span><span class="p">,</span> <span class="n">FLOW_CONTROL_TYPE</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">FCAH</span><span class="p">,</span> <span class="n">FLOW_CONTROL_ADDRESS_HIGH</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">FCAL</span><span class="p">,</span> <span class="n">FLOW_CONTROL_ADDRESS_LOW</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">FCTTV</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_pause_time</span><span class="p">);</span>

	<span class="cm">/* Set the flow control receive threshold registers.  Normally,</span>
<span class="cm">	 * these registers will be set to a default threshold that may be</span>
<span class="cm">	 * adjusted later by the driver&#39;s runtime code.  However, if the</span>
<span class="cm">	 * ability to transmit pause frames in not enabled, then these</span>
<span class="cm">	 * registers will be set to 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">&amp;</span> <span class="n">E1000_FC_TX_PAUSE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">FCRTL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">FCRTH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We need to set up the Receive Threshold high and low water marks</span>
<span class="cm">		 * as well as (optionally) enabling the transmission of XON frames.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_send_xon</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">FCRTL</span><span class="p">,</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_low_water</span> <span class="o">|</span> <span class="n">E1000_FCRTL_XONE</span><span class="p">));</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">FCRTH</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_high_water</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">FCRTL</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_low_water</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">FCRTH</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_high_water</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_fiber_serdes_link - prepare fiber or serdes link</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Manipulates Physical Coding Sublayer functions in order to configure</span>
<span class="cm"> * link. Assumes the hardware has been previously reset and the transmitter</span>
<span class="cm"> * and receiver are not enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_setup_fiber_serdes_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">txcw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_setup_fiber_serdes_link&quot;</span><span class="p">);</span>

	<span class="cm">/* On adapters with a MAC newer than 82544, SWDP 1 will be</span>
<span class="cm">	 * set when the optics detect a signal. On older adapters, it will be</span>
<span class="cm">	 * cleared when there is a signal.  This applies to fiber media only.</span>
<span class="cm">	 * If we&#39;re on serdes media, adjust the output amplitude to value</span>
<span class="cm">	 * set in the EEPROM.</span>
<span class="cm">	 */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span>
		<span class="n">signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="o">?</span> <span class="n">E1000_CTRL_SWDPIN1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_adjust_serdes_amplitude</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Take the link out of reset */</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_LRST</span><span class="p">);</span>

	<span class="cm">/* Adjust VCO speed to improve BER performance */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_vco_speed</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e1000_config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Check for a software override of the flow control settings, and setup</span>
<span class="cm">	 * the device accordingly.  If auto-negotiation is enabled, then software</span>
<span class="cm">	 * will have to set the &quot;PAUSE&quot; bits to the correct value in the Tranmsit</span>
<span class="cm">	 * Config Word Register (TXCW) and re-start auto-negotiation.  However, if</span>
<span class="cm">	 * auto-negotiation is disabled, then software will have to manually</span>
<span class="cm">	 * configure the two flow control enable bits in the CTRL register.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The possible values of the &quot;fc&quot; parameter are:</span>
<span class="cm">	 *      0:  Flow control is completely disabled</span>
<span class="cm">	 *      1:  Rx flow control is enabled (we can receive pause frames, but</span>
<span class="cm">	 *          not send pause frames).</span>
<span class="cm">	 *      2:  Tx flow control is enabled (we can send pause frames but we do</span>
<span class="cm">	 *          not support receiving pause frames).</span>
<span class="cm">	 *      3:  Both Rx and TX flow control (symmetric) are enabled.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_FC_NONE</span>:
		<span class="cm">/* Flow control is completely disabled by a software over-ride. */</span>
		<span class="n">txcw</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1000_TXCW_ANE</span> <span class="o">|</span> <span class="n">E1000_TXCW_FD</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_RX_PAUSE</span>:
		<span class="cm">/* RX Flow control is enabled and TX Flow control is disabled by a</span>
<span class="cm">		 * software over-ride. Since there really isn&#39;t a way to advertise</span>
<span class="cm">		 * that we are capable of RX Pause ONLY, we will advertise that we</span>
<span class="cm">		 * support both symmetric and asymmetric RX PAUSE. Later, we will</span>
<span class="cm">		 *  disable the adapter&#39;s ability to send PAUSE frames.</span>
<span class="cm">		 */</span>
		<span class="n">txcw</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1000_TXCW_ANE</span> <span class="o">|</span> <span class="n">E1000_TXCW_FD</span> <span class="o">|</span> <span class="n">E1000_TXCW_PAUSE_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_TX_PAUSE</span>:
		<span class="cm">/* TX Flow control is enabled, and RX Flow control is disabled, by a</span>
<span class="cm">		 * software over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">txcw</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1000_TXCW_ANE</span> <span class="o">|</span> <span class="n">E1000_TXCW_FD</span> <span class="o">|</span> <span class="n">E1000_TXCW_ASM_DIR</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_FULL</span>:
		<span class="cm">/* Flow control (both RX and TX) is enabled by a software over-ride. */</span>
		<span class="n">txcw</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1000_TXCW_ANE</span> <span class="o">|</span> <span class="n">E1000_TXCW_FD</span> <span class="o">|</span> <span class="n">E1000_TXCW_PAUSE_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Flow control param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Since auto-negotiation is enabled, take the link out of reset (the link</span>
<span class="cm">	 * will be in reset, because we previously reset the chip). This will</span>
<span class="cm">	 * restart auto-negotiation.  If auto-negotiation is successful then the</span>
<span class="cm">	 * link-up status bit will be set and the flow control enable bits (RFCE</span>
<span class="cm">	 * and TFCE) will be set according to their negotiated value.</span>
<span class="cm">	 */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Auto-negotiation enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">,</span> <span class="n">txcw</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">txcw</span> <span class="o">=</span> <span class="n">txcw</span><span class="p">;</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* If we have a signal (the cable is plugged in) then poll for a &quot;Link-Up&quot;</span>
<span class="cm">	 * indication in the Device Status Register.  Time-out if a link isn&#39;t</span>
<span class="cm">	 * seen in 500 milliseconds seconds (Auto-negotiation should complete in</span>
<span class="cm">	 * less than 500 milliseconds even if the other end is doing it in SW).</span>
<span class="cm">	 * For internal serdes, we just assume a signal is present, then poll.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_internal_serdes</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_SWDPIN1</span><span class="p">)</span> <span class="o">==</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Looking for Link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">LINK_UP_TIMEOUT</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">LINK_UP_TIMEOUT</span> <span class="o">/</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Never got a valid link from auto-neg!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* AutoNeg failed to achieve a link, so we&#39;ll call</span>
<span class="cm">			 * e1000_check_for_link. This routine will force the link up if</span>
<span class="cm">			 * we detect a signal. This will allow us to communicate with</span>
<span class="cm">			 * non-autonegotiating link partners.</span>
<span class="cm">			 */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_for_link</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error while checking for link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Valid Link Found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;No Signal Detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_copper_link_rtl_setup - Copper link setup for e1000_phy_rtl series.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Commits changes to PHY configuration by calling e1000_phy_reset().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_copper_link_rtl_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* SW reset the PHY so all changes take effect */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Resetting the PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">gbe_dhg_phy_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl_aux</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_phy_8211</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_rtl_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_copper_link_rtl_setup failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_phy_8201</span>:
		<span class="cm">/* Set RMII mode */</span>
		<span class="n">ctrl_aux</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTL_AUX</span><span class="p">);</span>
		<span class="n">ctrl_aux</span> <span class="o">|=</span> <span class="n">E1000_CTL_AUX_RMII</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTL_AUX</span><span class="p">,</span> <span class="n">ctrl_aux</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

		<span class="cm">/* Disable the J/K bits required for receive */</span>
		<span class="n">ctrl_aux</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTL_AUX</span><span class="p">);</span>
		<span class="n">ctrl_aux</span> <span class="o">|=</span> <span class="mh">0x4</span><span class="p">;</span>
		<span class="n">ctrl_aux</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x2</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTL_AUX</span><span class="p">,</span> <span class="n">ctrl_aux</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_rtl_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_copper_link_rtl_setup failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Resetting the PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">E1000_ERR_PHY_TYPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_copper_link_preconfig - early configuration for copper</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure we have a valid PHY and change PHY mode before link setup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_copper_link_preconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_copper_link_preconfig&quot;</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="cm">/* With 82543, we need to force speed and duplex on the MAC equal to what</span>
<span class="cm">	 * the PHY speed and duplex configuration is. In addition, we need to</span>
<span class="cm">	 * perform a hardware reset on the PHY to take it out of reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SLU</span><span class="p">;</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_FRCSPD</span> <span class="o">|</span> <span class="n">E1000_CTRL_FRCDPX</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ctrl</span> <span class="o">|=</span>
		    <span class="p">(</span><span class="n">E1000_CTRL_FRCSPD</span> <span class="o">|</span> <span class="n">E1000_CTRL_FRCDPX</span> <span class="o">|</span> <span class="n">E1000_CTRL_SLU</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_hw_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure we have a valid PHY */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_detect_gig_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error, did not detect valid phy.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Phy ID = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span><span class="p">);</span>

	<span class="cm">/* Set PHY to class A mode (if necessary) */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_phy_mode</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82545_rev_3</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82546_rev_3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="mh">0x00000008</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;=</span> <span class="n">e1000_82543</span> <span class="o">||</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541</span> <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span> <span class="o">||</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541_rev_2</span>
	    <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547_rev_2</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_reset_disable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_copper_link_igp_setup - Copper link setup for e1000_phy_igp series.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_copper_link_igp_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">led_ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_copper_link_igp_setup&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_reset_disable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Resetting the PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait 15ms for MAC to configure PHY from eeprom settings */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
	<span class="cm">/* Configure activity LED after PHY reset */</span>
	<span class="n">led_ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">);</span>
	<span class="n">led_ctrl</span> <span class="o">&amp;=</span> <span class="n">IGP_ACTIVITY_LED_MASK</span><span class="p">;</span>
	<span class="n">led_ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IGP_ACTIVITY_LED_ENABLE</span> <span class="o">|</span> <span class="n">IGP_LED3_MODE</span><span class="p">);</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">led_ctrl</span><span class="p">);</span>

	<span class="cm">/* The NVM settings will configure LPLU in D3 for IGP2 and IGP3 PHYs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* disable lplu d3 during driver init */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_set_d3_lplu_state</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Disabling LPLU D3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Configure mdi-mdix settings */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dsp_config_state</span> <span class="o">=</span> <span class="n">e1000_dsp_config_disabled</span><span class="p">;</span>
		<span class="cm">/* Force MDI for earlier revs of the IGP PHY */</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span>
		    <span class="o">~</span><span class="p">(</span><span class="n">IGP01E1000_PSCR_AUTO_MDIX</span> <span class="o">|</span>
		      <span class="n">IGP01E1000_PSCR_FORCE_MDI_MDIX</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mdix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dsp_config_state</span> <span class="o">=</span> <span class="n">e1000_dsp_config_enabled</span><span class="p">;</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCR_AUTO_MDIX</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mdix</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCR_FORCE_MDI_MDIX</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">IGP01E1000_PSCR_FORCE_MDI_MDIX</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">0</span>:
		<span class="nl">default:</span>
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">IGP01E1000_PSCR_AUTO_MDIX</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* set auto-master slave resolution settings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e1000_ms_type</span> <span class="n">phy_ms_setting</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">master_slave</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ffe_config_state</span> <span class="o">==</span> <span class="n">e1000_ffe_config_active</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ffe_config_state</span> <span class="o">=</span> <span class="n">e1000_ffe_config_enabled</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dsp_config_state</span> <span class="o">==</span> <span class="n">e1000_dsp_config_activated</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dsp_config_state</span> <span class="o">=</span> <span class="n">e1000_dsp_config_enabled</span><span class="p">;</span>

		<span class="cm">/* when autonegotiation advertisement is only 1000Mbps then we</span>
<span class="cm">		 * should disable SmartSpeed and enable Auto MasterSlave</span>
<span class="cm">		 * resolution as hardware default. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Disable SmartSpeed */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
						<span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="cm">/* Set auto Master/Slave resolution process */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CR_1000T_MS_ENABLE</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* load defaults for future use */</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">original_master_slave</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">CR_1000T_MS_ENABLE</span><span class="p">)</span> <span class="o">?</span>
		    <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">CR_1000T_MS_VALUE</span><span class="p">)</span> <span class="o">?</span>
		     <span class="n">e1000_ms_force_master</span> <span class="o">:</span>
		     <span class="n">e1000_ms_force_slave</span><span class="p">)</span> <span class="o">:</span> <span class="n">e1000_ms_auto</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">phy_ms_setting</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">e1000_ms_force_master</span>:
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CR_1000T_MS_ENABLE</span> <span class="o">|</span> <span class="n">CR_1000T_MS_VALUE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_ms_force_slave</span>:
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">CR_1000T_MS_ENABLE</span><span class="p">;</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CR_1000T_MS_VALUE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_ms_auto</span>:
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CR_1000T_MS_ENABLE</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_copper_link_mgp_setup - Copper link setup for e1000_phy_m88 series.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_copper_link_mgp_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_copper_link_mgp_setup&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_reset_disable</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="cm">/* Enable CRS on TX. This must be set for half-duplex operation. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_ASSERT_CRS_ON_TX</span><span class="p">;</span>

	<span class="cm">/* Options:</span>
<span class="cm">	 *   MDI/MDI-X = 0 (default)</span>
<span class="cm">	 *   0 - Auto for all speeds</span>
<span class="cm">	 *   1 - MDI mode</span>
<span class="cm">	 *   2 - MDI-X mode</span>
<span class="cm">	 *   3 - Auto for 1000Base-T only (MDI-X for 10/100Base-T modes)</span>
<span class="cm">	 */</span>
	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M88E1000_PSCR_AUTO_X_MODE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mdix</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_MDI_MANUAL_MODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_MDIX_MANUAL_MODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_AUTO_X_1000T</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="nl">default:</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_AUTO_X_MODE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Options:</span>
<span class="cm">	 *   disable_polarity_correction = 0 (default)</span>
<span class="cm">	 *       Automatic Correction for Reversed Cable Polarity</span>
<span class="cm">	 *   0 - Disabled</span>
<span class="cm">	 *   1 - Enabled</span>
<span class="cm">	 */</span>
	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M88E1000_PSCR_POLARITY_REVERSAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">disable_polarity_correction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_POLARITY_REVERSAL</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_revision</span> <span class="o">&lt;</span> <span class="n">M88E1011_I_REV_4</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Force TX_CLK in the Extended PHY Specific Control Register</span>
<span class="cm">		 * to 25MHz clock.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_EPSCR_TX_CLK_25</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_revision</span> <span class="o">==</span> <span class="n">E1000_REVISION_2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">==</span> <span class="n">M88E1111_I_PHY_ID</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Vidalia Phy, set the downshift counter to 5x */</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK</span><span class="p">);</span>
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						      <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span>
						      <span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Configure Master and Slave downshift values */</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK</span> <span class="o">|</span>
				      <span class="n">M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK</span><span class="p">);</span>
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">M88E1000_EPSCR_MASTER_DOWNSHIFT_1X</span> <span class="o">|</span>
				     <span class="n">M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X</span><span class="p">);</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						      <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span>
						      <span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* SW Reset the PHY so all changes take effect */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Resetting the PHY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_copper_link_autoneg - setup auto-neg</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Setup auto-negotiation and flow control advertisements,</span>
<span class="cm"> * and then perform auto-negotiation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_copper_link_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_copper_link_autoneg&quot;</span><span class="p">);</span>

	<span class="cm">/* Perform some bounds checking on the hw-&gt;autoneg_advertised</span>
<span class="cm">	 * parameter.  If this variable is zero, then set it to the default.</span>
<span class="cm">	 */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;=</span> <span class="n">AUTONEG_ADVERTISE_SPEED_DEFAULT</span><span class="p">;</span>

	<span class="cm">/* If autoneg_advertised is zero, we assume it was not defaulted</span>
<span class="cm">	 * by the calling code so we set to advertise full capability.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">=</span> <span class="n">AUTONEG_ADVERTISE_SPEED_DEFAULT</span><span class="p">;</span>

	<span class="cm">/* IFE/RTL8201N PHY only supports 10/100 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_8201</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;=</span> <span class="n">AUTONEG_ADVERTISE_10_100_ALL</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Reconfiguring auto-neg advertisement params</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_setup_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Setting up Auto-Negotiation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Restarting Auto-Neg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Restart auto-negotiation by setting the Auto Neg Enable bit and</span>
<span class="cm">	 * the Auto Neg Restart bit in the PHY control register.</span>
<span class="cm">	 */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">|=</span> <span class="p">(</span><span class="n">MII_CR_AUTO_NEG_EN</span> <span class="o">|</span> <span class="n">MII_CR_RESTART_AUTO_NEG</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Does the user want to wait for Auto-Neg to complete here, or</span>
<span class="cm">	 * check at a later time (for example, callback routine).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wait_autoneg_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_wait_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span>
			    <span class="p">(</span><span class="s">&quot;Error while waiting for autoneg to complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_copper_link_postconfig - post link setup</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Config the MAC and the PHY after link is up.</span>
<span class="cm"> *   1) Set up the MAC to the current PHY speed/duplex</span>
<span class="cm"> *      if we are on 82543.  If we</span>
<span class="cm"> *      are on newer silicon, we only need to configure</span>
<span class="cm"> *      collision distance in the Transmit Control Register.</span>
<span class="cm"> *   2) Set up flow control on the MAC to that established with</span>
<span class="cm"> *      the link partner.</span>
<span class="cm"> *   3) Config DSP to improve Gigabit link quality for some PHY revisions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_copper_link_postconfig</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_copper_link_postconfig&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">!=</span> <span class="n">e1000_ce4100</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e1000_config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_config_mac_to_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error configuring MAC to PHY settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_config_fc_after_link_up</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Configuring Flow Control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Config DSP to improve Giga link quality */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_config_dsp_after_link_change</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Configuring DSP after link up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_copper_link - phy/speed/duplex setting</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Detects which PHY is present and sets up the speed and duplex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_setup_copper_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_setup_copper_link&quot;</span><span class="p">);</span>

	<span class="cm">/* Check if it is a valid PHY and set PHY mode if necessary. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_preconfig</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_igp_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_mgp_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">gbe_dhg_phy_setup</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;gbe_dhg_phy_setup failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Setup autoneg and flow control advertisement</span>
<span class="cm">		 * and perform autonegotiation */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_autoneg</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* PHY will be set to 10H, 10F, 100H,or 100F</span>
<span class="cm">		 * depending on value from forced_speed_duplex. */</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Forcing speed and duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_force_speed_duplex</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Forcing Speed and Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check link status. Wait up to 100 microseconds for link to become</span>
<span class="cm">	 * valid.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Config the MAC and PHY after link is up */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_copper_link_postconfig</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Valid link established!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Unable to establish link!!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_setup_autoneg - phy settings</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Configures PHY autoneg and flow control advertisement settings</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_phy_setup_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_1000t_ctrl_reg</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_setup_autoneg&quot;</span><span class="p">);</span>

	<span class="cm">/* Read the MII Auto-Neg Advertisement Register (Address 4). */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_ADV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_autoneg_adv_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Read the MII 1000Base-T Control Register (Address 9). */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_1000t_ctrl_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_8201</span><span class="p">)</span>
		<span class="n">mii_1000t_ctrl_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REG9_SPEED_MASK</span><span class="p">;</span>

	<span class="cm">/* Need to parse both autoneg_advertised and fc and set up</span>
<span class="cm">	 * the appropriate PHY registers.  First we will parse for</span>
<span class="cm">	 * autoneg_advertised software override.  Since we can advertise</span>
<span class="cm">	 * a plethora of combinations, we need to check each bit</span>
<span class="cm">	 * individually.</span>
<span class="cm">	 */</span>

	<span class="cm">/* First we clear all the 10/100 mb speed bits in the Auto-Neg</span>
<span class="cm">	 * Advertisement Register (Address 4) and the 1000 mb speed bits in</span>
<span class="cm">	 * the  1000Base-T Control Register (Address 9).</span>
<span class="cm">	 */</span>
	<span class="n">mii_autoneg_adv_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REG4_SPEED_MASK</span><span class="p">;</span>
	<span class="n">mii_1000t_ctrl_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">REG9_SPEED_MASK</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;autoneg_advertised %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span><span class="p">);</span>

	<span class="cm">/* Do we want to advertise 10 Mb Half Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_10_HALF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 10mb Half duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_10T_HD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we want to advertise 10 Mb Full Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_10_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 10mb Full duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_10T_FD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we want to advertise 100 Mb Half Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_100_HALF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 100mb Half duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_100TX_HD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we want to advertise 100 Mb Full Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_100_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 100mb Full duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_100TX_FD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We do not allow the Phy to advertise 1000 Mb Half Duplex */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_1000_HALF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span>
		    <span class="p">(</span><span class="s">&quot;Advertise 1000mb Half duplex requested, request denied!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Do we want to advertise 1000 Mb Full Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">&amp;</span> <span class="n">ADVERTISE_1000_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Advertise 1000mb Full duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_1000t_ctrl_reg</span> <span class="o">|=</span> <span class="n">CR_1000T_FD_CAPS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for a software override of the flow control settings, and</span>
<span class="cm">	 * setup the PHY advertisement registers accordingly.  If</span>
<span class="cm">	 * auto-negotiation is enabled, then software will have to set the</span>
<span class="cm">	 * &quot;PAUSE&quot; bits to the correct value in the Auto-Negotiation</span>
<span class="cm">	 * Advertisement Register (PHY_AUTONEG_ADV) and re-start auto-negotiation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The possible values of the &quot;fc&quot; parameter are:</span>
<span class="cm">	 *      0:  Flow control is completely disabled</span>
<span class="cm">	 *      1:  Rx flow control is enabled (we can receive pause frames</span>
<span class="cm">	 *          but not send pause frames).</span>
<span class="cm">	 *      2:  Tx flow control is enabled (we can send pause frames</span>
<span class="cm">	 *          but we do not support receiving pause frames).</span>
<span class="cm">	 *      3:  Both Rx and TX flow control (symmetric) are enabled.</span>
<span class="cm">	 *  other:  No software override.  The flow control configuration</span>
<span class="cm">	 *          in the EEPROM is used.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_FC_NONE</span>:	<span class="cm">/* 0 */</span>
		<span class="cm">/* Flow control (RX &amp; TX) is completely disabled by a</span>
<span class="cm">		 * software over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NWAY_AR_ASM_DIR</span> <span class="o">|</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_RX_PAUSE</span>:	<span class="cm">/* 1 */</span>
		<span class="cm">/* RX Flow control is enabled, and TX Flow control is</span>
<span class="cm">		 * disabled, by a software over-ride.</span>
<span class="cm">		 */</span>
		<span class="cm">/* Since there really isn&#39;t a way to advertise that we are</span>
<span class="cm">		 * capable of RX Pause ONLY, we will advertise that we</span>
<span class="cm">		 * support both symmetric and asymmetric RX PAUSE.  Later</span>
<span class="cm">		 * (in e1000_config_fc_after_link_up) we will disable the</span>
<span class="cm">		 *hw&#39;s ability to send PAUSE frames.</span>
<span class="cm">		 */</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NWAY_AR_ASM_DIR</span> <span class="o">|</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_TX_PAUSE</span>:	<span class="cm">/* 2 */</span>
		<span class="cm">/* TX Flow control is enabled, and RX Flow control is</span>
<span class="cm">		 * disabled, by a software over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="n">NWAY_AR_ASM_DIR</span><span class="p">;</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NWAY_AR_PAUSE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_FULL</span>:	<span class="cm">/* 3 */</span>
		<span class="cm">/* Flow control (both RX and TX) is enabled by a software</span>
<span class="cm">		 * over-ride.</span>
<span class="cm">		 */</span>
		<span class="n">mii_autoneg_adv_reg</span> <span class="o">|=</span> <span class="p">(</span><span class="n">NWAY_AR_ASM_DIR</span> <span class="o">|</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Flow control param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_ADV</span><span class="p">,</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Auto-Neg Advertising %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mii_autoneg_adv_reg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_8201</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mii_1000t_ctrl_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_CTRL</span><span class="p">,</span>
		                              <span class="n">mii_1000t_ctrl_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_force_speed_duplex - force link settings</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Force PHY speed and duplex settings to hw-&gt;forced_speed_duplex</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_phy_force_speed_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_ctrl_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_status_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_force_speed_duplex&quot;</span><span class="p">);</span>

	<span class="cm">/* Turn off Flow control if we are forcing speed and duplex. */</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_NONE</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;hw-&gt;fc = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">);</span>

	<span class="cm">/* Read the Device Control Register. */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="cm">/* Set the bits to Force Speed and Duplex in the Device Ctrl Reg. */</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_CTRL_FRCSPD</span> <span class="o">|</span> <span class="n">E1000_CTRL_FRCDPX</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DEVICE_SPEED_MASK</span><span class="p">);</span>

	<span class="cm">/* Clear the Auto Speed Detect Enable bit. */</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_ASDE</span><span class="p">;</span>

	<span class="cm">/* Read the MII Control Register. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_ctrl_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* We need to disable autoneg in order to force link and duplex. */</span>

	<span class="n">mii_ctrl_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MII_CR_AUTO_NEG_EN</span><span class="p">;</span>

	<span class="cm">/* Are we forcing Full or Half Duplex? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">==</span> <span class="n">e1000_100_full</span> <span class="o">||</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">==</span> <span class="n">e1000_10_full</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We want to force full duplex so we SET the full duplex bits in the</span>
<span class="cm">		 * Device and MII Control Registers.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_FD</span><span class="p">;</span>
		<span class="n">mii_ctrl_reg</span> <span class="o">|=</span> <span class="n">MII_CR_FULL_DUPLEX</span><span class="p">;</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Full Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We want to force half duplex so we CLEAR the full duplex bits in</span>
<span class="cm">		 * the Device and MII Control Registers.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_FD</span><span class="p">;</span>
		<span class="n">mii_ctrl_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MII_CR_FULL_DUPLEX</span><span class="p">;</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Half Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Are we forcing 100Mbps??? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">==</span> <span class="n">e1000_100_full</span> <span class="o">||</span>
	    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">==</span> <span class="n">e1000_100_half</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set the 100Mb bit and turn off the 1000Mb and 10Mb bits. */</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SPD_100</span><span class="p">;</span>
		<span class="n">mii_ctrl_reg</span> <span class="o">|=</span> <span class="n">MII_CR_SPEED_100</span><span class="p">;</span>
		<span class="n">mii_ctrl_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MII_CR_SPEED_1000</span> <span class="o">|</span> <span class="n">MII_CR_SPEED_10</span><span class="p">);</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Forcing 100mb &quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Set the 10Mb bit and turn off the 1000Mb and 100Mb bits. */</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_SPD_1000</span> <span class="o">|</span> <span class="n">E1000_CTRL_SPD_100</span><span class="p">);</span>
		<span class="n">mii_ctrl_reg</span> <span class="o">|=</span> <span class="n">MII_CR_SPEED_10</span><span class="p">;</span>
		<span class="n">mii_ctrl_reg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MII_CR_SPEED_1000</span> <span class="o">|</span> <span class="n">MII_CR_SPEED_100</span><span class="p">);</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Forcing 10mb &quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e1000_config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* Write the configured values back to the Device Control Reg. */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* Clear Auto-Crossover to force MDI manually. M88E1000 requires MDI</span>
<span class="cm">		 * forced whenever speed are duplex are forced.</span>
<span class="cm">		 */</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M88E1000_PSCR_AUTO_X_MODE</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;M88E1000 PSCR: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>

		<span class="cm">/* Need to reset the PHY or these changes will be ignored */</span>
		<span class="n">mii_ctrl_reg</span> <span class="o">|=</span> <span class="n">MII_CR_RESET</span><span class="p">;</span>

		<span class="cm">/* Disable MDI-X support for 10/100 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Clear Auto-Crossover to force MDI manually.  IGP requires MDI</span>
<span class="cm">		 * forced whenever speed or duplex are forced.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCR_AUTO_MDIX</span><span class="p">;</span>
		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCR_FORCE_MDI_MDIX</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write back the modified PHY MII control register. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="n">mii_ctrl_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* The wait_autoneg_complete flag may be a little misleading here.</span>
<span class="cm">	 * Since we are forcing speed and duplex, Auto-Neg is not enabled.</span>
<span class="cm">	 * But we do want to delay for a period while forcing only so we</span>
<span class="cm">	 * don&#39;t generate false No Link messages.  So we will wait here</span>
<span class="cm">	 * only if the user has set wait_autoneg_complete to 1, which is</span>
<span class="cm">	 * the default.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">wait_autoneg_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We will wait for autoneg to complete. */</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Waiting for forced speed/duplex link.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mii_status_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* We will wait for autoneg to complete or 4.5 seconds to expire. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PHY_FORCE_TIME</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Read the MII Status Register and wait for Auto-Neg Complete bit</span>
<span class="cm">			 * to be set.</span>
<span class="cm">			 */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mii_status_reg</span> <span class="o">&amp;</span> <span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* We didn&#39;t get link.  Reset the DSP and wait again for link. */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_reset_dsp</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error Resetting PHY DSP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* This loop will early-out if the link condition has been met.  */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PHY_FORCE_TIME</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mii_status_reg</span> <span class="o">&amp;</span> <span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="cm">/* Read the MII Status Register and wait for Auto-Neg Complete bit</span>
<span class="cm">			 * to be set.</span>
<span class="cm">			 */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Because we reset the PHY above, we need to re-force TX_CLK in the</span>
<span class="cm">		 * Extended PHY Specific Control Register to 25MHz clock.  This value</span>
<span class="cm">		 * defaults back to a 2.5MHz clock when the PHY is reset.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_EPSCR_TX_CLK_25</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_EXT_PHY_SPEC_CTRL</span><span class="p">,</span>
					<span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* In addition, because of the s/w reset above, we need to enable CRS on</span>
<span class="cm">		 * TX.  This must be set for both full and half duplex operation.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PSCR_ASSERT_CRS_ON_TX</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82544</span> <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82543</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">==</span> <span class="n">e1000_10_full</span>
			<span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">==</span> <span class="n">e1000_10_half</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_polarity_reversal_workaround</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_config_collision_dist - set collision distance register</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the collision distance in the Transmit Control register.</span>
<span class="cm"> * Link should have been established previously. Reads the speed and duplex</span>
<span class="cm"> * information from the Device Status register.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000_config_collision_dist</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tctl</span><span class="p">,</span> <span class="n">coll_dist</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_config_collision_dist&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82543</span><span class="p">)</span>
		<span class="n">coll_dist</span> <span class="o">=</span> <span class="n">E1000_COLLISION_DISTANCE_82542</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">coll_dist</span> <span class="o">=</span> <span class="n">E1000_COLLISION_DISTANCE</span><span class="p">;</span>

	<span class="n">tctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">);</span>

	<span class="n">tctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_TCTL_COLD</span><span class="p">;</span>
	<span class="n">tctl</span> <span class="o">|=</span> <span class="n">coll_dist</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_COLD_SHIFT</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">TCTL</span><span class="p">,</span> <span class="n">tctl</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_config_mac_to_phy - sync phy and mac settings</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @mii_reg: data to write to the MII control register</span>
<span class="cm"> *</span>
<span class="cm"> * Sets MAC speed and duplex settings to reflect the those in the PHY</span>
<span class="cm"> * The contents of the PHY register containing the needed information need to</span>
<span class="cm"> * be passed in.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_config_mac_to_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_config_mac_to_phy&quot;</span><span class="p">);</span>

	<span class="cm">/* 82544 or newer MAC, Auto Speed Detection takes care of</span>
<span class="cm">	 * MAC speed/duplex configuration.*/</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">!=</span> <span class="n">e1000_ce4100</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="cm">/* Read the Device Control Register and set the bits to Force Speed</span>
<span class="cm">	 * and Duplex.</span>
<span class="cm">	 */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_CTRL_FRCSPD</span> <span class="o">|</span> <span class="n">E1000_CTRL_FRCDPX</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_SPD_SEL</span> <span class="o">|</span> <span class="n">E1000_CTRL_ILOS</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_phy_8201</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">RTL_PHY_CTRL_FD</span><span class="p">)</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_FD</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_FD</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">RTL_PHY_CTRL_SPD_100</span><span class="p">)</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SPD_100</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SPD_10</span><span class="p">;</span>

		<span class="n">e1000_config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Set up duplex in the Device Control and Transmit Control</span>
<span class="cm">		 * registers depending on negotiated values.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">,</span>
		                             <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_DPLX</span><span class="p">)</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_FD</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_FD</span><span class="p">;</span>

		<span class="n">e1000_config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Set up speed in the Device Control register depending on</span>
<span class="cm">		 * negotiated values.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_SPEED</span><span class="p">)</span> <span class="o">==</span> <span class="n">M88E1000_PSSR_1000MBS</span><span class="p">)</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SPD_1000</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_SPEED</span><span class="p">)</span> <span class="o">==</span>
		         <span class="n">M88E1000_PSSR_100MBS</span><span class="p">)</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SPD_100</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Write the configured values back to the Device Control Reg. */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_force_mac_fc - force flow control settings</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Forces the MAC&#39;s flow control settings.</span>
<span class="cm"> * Sets the TFCE and RFCE bits in the device control register to reflect</span>
<span class="cm"> * the adapter settings. TFCE and RFCE need to be explicitly set by</span>
<span class="cm"> * software when a Copper PHY is used because autonegotiation is managed</span>
<span class="cm"> * by the PHY rather than the MAC. Software must also configure these</span>
<span class="cm"> * bits when link is forced on a fiber connection.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_force_mac_fc</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_force_mac_fc&quot;</span><span class="p">);</span>

	<span class="cm">/* Get the current configuration of the Device Control Register */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="cm">/* Because we didn&#39;t get link via the internal auto-negotiation</span>
<span class="cm">	 * mechanism (we either forced link or we got link via PHY</span>
<span class="cm">	 * auto-neg), we have to manually enable/disable transmit an</span>
<span class="cm">	 * receive flow control.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The &quot;Case&quot; statement below enables/disable flow control</span>
<span class="cm">	 * according to the &quot;hw-&gt;fc&quot; parameter.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The possible values of the &quot;fc&quot; parameter are:</span>
<span class="cm">	 *      0:  Flow control is completely disabled</span>
<span class="cm">	 *      1:  Rx flow control is enabled (we can receive pause</span>
<span class="cm">	 *          frames but not send pause frames).</span>
<span class="cm">	 *      2:  Tx flow control is enabled (we can send pause frames</span>
<span class="cm">	 *          frames but we do not receive pause frames).</span>
<span class="cm">	 *      3:  Both Rx and TX flow control (symmetric) is enabled.</span>
<span class="cm">	 *  other:  No other values should be possible at this point.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">E1000_FC_NONE</span>:
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">E1000_CTRL_TFCE</span> <span class="o">|</span> <span class="n">E1000_CTRL_RFCE</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_RX_PAUSE</span>:
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">E1000_CTRL_TFCE</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_RFCE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_TX_PAUSE</span>:
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">E1000_CTRL_RFCE</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_TFCE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">E1000_FC_FULL</span>:
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_CTRL_TFCE</span> <span class="o">|</span> <span class="n">E1000_CTRL_RFCE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Flow control param set incorrectly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disable TX Flow Control for 82542 (rev 2.0) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82542_rev2_0</span><span class="p">)</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">E1000_CTRL_TFCE</span><span class="p">);</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_config_fc_after_link_up - configure flow control after autoneg</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Configures flow control settings after link is established</span>
<span class="cm"> * Should be called immediately after a valid link has been established.</span>
<span class="cm"> * Forces MAC flow control settings if link was forced. When in MII/GMII mode</span>
<span class="cm"> * and autonegotiation is enabled, the MAC flow control settings will be set</span>
<span class="cm"> * based on the flow control negotiated by the PHY. In TBI mode, the TFCE</span>
<span class="cm"> * and RFCE bits will be automatically set to the negotiated flow control mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_config_fc_after_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_status_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_nway_adv_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_nway_lp_ability_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">speed</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">duplex</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_config_fc_after_link_up&quot;</span><span class="p">);</span>

	<span class="cm">/* Check for the case where we have fiber media and auto-neg failed</span>
<span class="cm">	 * so we had to force link.  In this case, we need to force the</span>
<span class="cm">	 * configuration of the MAC to match the &quot;fc&quot; parameter.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_failed</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_failed</span><span class="p">))</span>
	    <span class="o">||</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_force_mac_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error forcing flow control settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check for the case where we have copper media and auto-neg is</span>
<span class="cm">	 * enabled.  In this case, we need to check and see if Auto-Neg</span>
<span class="cm">	 * has completed, and if so, how the PHY and link partner has</span>
<span class="cm">	 * flow control configured.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the MII Status Register and check to see if AutoNeg</span>
<span class="cm">		 * has completed.  We read this twice because this reg has</span>
<span class="cm">		 * some &quot;sticky&quot; (latched) bits.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mii_status_reg</span> <span class="o">&amp;</span> <span class="n">MII_SR_AUTONEG_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The AutoNeg process has completed, so we now need to</span>
<span class="cm">			 * read both the Auto Negotiation Advertisement Register</span>
<span class="cm">			 * (Address 4) and the Auto_Negotiation Base Page Ability</span>
<span class="cm">			 * Register (Address 5) to determine how flow control was</span>
<span class="cm">			 * negotiated.</span>
<span class="cm">			 */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_ADV</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">mii_nway_adv_reg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_LP_ABILITY</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">mii_nway_lp_ability_reg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="cm">/* Two bits in the Auto Negotiation Advertisement Register</span>
<span class="cm">			 * (Address 4) and two bits in the Auto Negotiation Base</span>
<span class="cm">			 * Page Ability Register (Address 5) determine flow control</span>
<span class="cm">			 * for both the PHY and the link partner.  The following</span>
<span class="cm">			 * table, taken out of the IEEE 802.3ab/D6.0 dated March 25,</span>
<span class="cm">			 * 1999, describes these PAUSE resolution bits and how flow</span>
<span class="cm">			 * control is determined based upon these settings.</span>
<span class="cm">			 * NOTE:  DC = Don&#39;t Care</span>
<span class="cm">			 *</span>
<span class="cm">			 *   LOCAL DEVICE  |   LINK PARTNER</span>
<span class="cm">			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | NIC Resolution</span>
<span class="cm">			 *-------|---------|-------|---------|--------------------</span>
<span class="cm">			 *   0   |    0    |  DC   |   DC    | E1000_FC_NONE</span>
<span class="cm">			 *   0   |    1    |   0   |   DC    | E1000_FC_NONE</span>
<span class="cm">			 *   0   |    1    |   1   |    0    | E1000_FC_NONE</span>
<span class="cm">			 *   0   |    1    |   1   |    1    | E1000_FC_TX_PAUSE</span>
<span class="cm">			 *   1   |    0    |   0   |   DC    | E1000_FC_NONE</span>
<span class="cm">			 *   1   |   DC    |   1   |   DC    | E1000_FC_FULL</span>
<span class="cm">			 *   1   |    1    |   0   |    0    | E1000_FC_NONE</span>
<span class="cm">			 *   1   |    1    |   0   |    1    | E1000_FC_RX_PAUSE</span>
<span class="cm">			 *</span>
<span class="cm">			 */</span>
			<span class="cm">/* Are both PAUSE bits set to 1?  If so, this implies</span>
<span class="cm">			 * Symmetric Flow Control is enabled at both ends.  The</span>
<span class="cm">			 * ASM_DIR bits are irrelevant per the spec.</span>
<span class="cm">			 *</span>
<span class="cm">			 * For Symmetric Flow Control:</span>
<span class="cm">			 *</span>
<span class="cm">			 *   LOCAL DEVICE  |   LINK PARTNER</span>
<span class="cm">			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result</span>
<span class="cm">			 *-------|---------|-------|---------|--------------------</span>
<span class="cm">			 *   1   |   DC    |   1   |   DC    | E1000_FC_FULL</span>
<span class="cm">			 *</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">mii_nway_adv_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">mii_nway_lp_ability_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_LPAR_PAUSE</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Now we need to check if the user selected RX ONLY</span>
<span class="cm">				 * of pause frames.  In this case, we had to advertise</span>
<span class="cm">				 * FULL flow control because we could not advertise RX</span>
<span class="cm">				 * ONLY. Hence, we must now check to see if we need to</span>
<span class="cm">				 * turn OFF  the TRANSMISSION of PAUSE frames.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">original_fc</span> <span class="o">==</span> <span class="n">E1000_FC_FULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_FULL</span><span class="p">;</span>
					<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Flow Control = FULL.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_RX_PAUSE</span><span class="p">;</span>
					<span class="n">e_dbg</span>
					    <span class="p">(</span><span class="s">&quot;Flow Control = RX PAUSE frames only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="cm">/* For receiving PAUSE frames ONLY.</span>
<span class="cm">			 *</span>
<span class="cm">			 *   LOCAL DEVICE  |   LINK PARTNER</span>
<span class="cm">			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result</span>
<span class="cm">			 *-------|---------|-------|---------|--------------------</span>
<span class="cm">			 *   0   |    1    |   1   |    1    | E1000_FC_TX_PAUSE</span>
<span class="cm">			 *</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mii_nway_adv_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">mii_nway_adv_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_AR_ASM_DIR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">mii_nway_lp_ability_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_LPAR_PAUSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">mii_nway_lp_ability_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_LPAR_ASM_DIR</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_TX_PAUSE</span><span class="p">;</span>
				<span class="n">e_dbg</span>
				    <span class="p">(</span><span class="s">&quot;Flow Control = TX PAUSE frames only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* For transmitting PAUSE frames ONLY.</span>
<span class="cm">			 *</span>
<span class="cm">			 *   LOCAL DEVICE  |   LINK PARTNER</span>
<span class="cm">			 * PAUSE | ASM_DIR | PAUSE | ASM_DIR | Result</span>
<span class="cm">			 *-------|---------|-------|---------|--------------------</span>
<span class="cm">			 *   1   |    1    |   0   |    1    | E1000_FC_RX_PAUSE</span>
<span class="cm">			 *</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">mii_nway_adv_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_AR_PAUSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">mii_nway_adv_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_AR_ASM_DIR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="o">!</span><span class="p">(</span><span class="n">mii_nway_lp_ability_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_LPAR_PAUSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				 <span class="p">(</span><span class="n">mii_nway_lp_ability_reg</span> <span class="o">&amp;</span> <span class="n">NWAY_LPAR_ASM_DIR</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_RX_PAUSE</span><span class="p">;</span>
				<span class="n">e_dbg</span>
				    <span class="p">(</span><span class="s">&quot;Flow Control = RX PAUSE frames only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Per the IEEE spec, at this point flow control should be</span>
<span class="cm">			 * disabled.  However, we want to consider that we could</span>
<span class="cm">			 * be connected to a legacy switch that doesn&#39;t advertise</span>
<span class="cm">			 * desired flow control, but can be forced on the link</span>
<span class="cm">			 * partner.  So if we advertised no flow control, that is</span>
<span class="cm">			 * what we will resolve to.  If we advertised some kind of</span>
<span class="cm">			 * receive capability (Rx Pause Only or Full Flow Control)</span>
<span class="cm">			 * and the link partner advertised none, we will configure</span>
<span class="cm">			 * ourselves to enable Rx Flow Control only.  We can do</span>
<span class="cm">			 * this safely for two reasons:  If the link partner really</span>
<span class="cm">			 * didn&#39;t want flow control enabled, and we enable Rx, no</span>
<span class="cm">			 * harm done since we won&#39;t be receiving any PAUSE frames</span>
<span class="cm">			 * anyway.  If the intent on the link partner was to have</span>
<span class="cm">			 * flow control enabled, then by us enabling RX only, we</span>
<span class="cm">			 * can at least receive pause frames and process them.</span>
<span class="cm">			 * This is a good idea because in most cases, since we are</span>
<span class="cm">			 * predominantly a server NIC, more times than not we will</span>
<span class="cm">			 * be asked to delay transmission of packets than asking</span>
<span class="cm">			 * our link partner to pause transmission of frames.</span>
<span class="cm">			 */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">original_fc</span> <span class="o">==</span> <span class="n">E1000_FC_NONE</span> <span class="o">||</span>
				  <span class="n">hw</span><span class="o">-&gt;</span><span class="n">original_fc</span> <span class="o">==</span> <span class="n">E1000_FC_TX_PAUSE</span><span class="p">)</span> <span class="o">||</span>
				 <span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc_strict_ieee</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_NONE</span><span class="p">;</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Flow Control = NONE.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_RX_PAUSE</span><span class="p">;</span>
				<span class="n">e_dbg</span>
				    <span class="p">(</span><span class="s">&quot;Flow Control = RX PAUSE frames only.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Now we need to do one last check...  If we auto-</span>
<span class="cm">			 * negotiated to HALF DUPLEX, flow control should not be</span>
<span class="cm">			 * enabled per IEEE 802.3 spec.</span>
<span class="cm">			 */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_get_speed_and_duplex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">duplex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span>
				    <span class="p">(</span><span class="s">&quot;Error getting link speed and duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">duplex</span> <span class="o">==</span> <span class="n">HALF_DUPLEX</span><span class="p">)</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">fc</span> <span class="o">=</span> <span class="n">E1000_FC_NONE</span><span class="p">;</span>

			<span class="cm">/* Now we call a subroutine to actually force the MAC</span>
<span class="cm">			 * controller to use the correct flow control settings.</span>
<span class="cm">			 */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_force_mac_fc</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span>
				    <span class="p">(</span><span class="s">&quot;Error forcing flow control settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">e_dbg</span>
			    <span class="p">(</span><span class="s">&quot;Copper PHY and Auto Neg has not completed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_check_for_serdes_link_generic - Check for link (Serdes)</span>
<span class="cm"> * @hw: pointer to the HW structure</span>
<span class="cm"> *</span>
<span class="cm"> * Checks for link up on the hardware.  If link is not up and we have</span>
<span class="cm"> * a signal, then we need to force link up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_check_for_serdes_link_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rxcw</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_check_for_serdes_link_generic&quot;</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
	<span class="n">rxcw</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCW</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we don&#39;t have link (auto-negotiation failed or link partner</span>
<span class="cm">	 * cannot auto-negotiate), and our link partner is not trying to</span>
<span class="cm">	 * auto-negotiate with us (we are receiving idles or data),</span>
<span class="cm">	 * we need to force link up. We also need to give auto-negotiation</span>
<span class="cm">	 * time to complete.</span>
<span class="cm">	 */</span>
	<span class="cm">/* (ctrl &amp; E1000_CTRL_SWDPIN1) == 1 == have signal */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_C</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_failed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_failed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;NOT RXing /C/, disable AutoNeg and force link.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="cm">/* Disable auto-negotiation in the TXCW register */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">,</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">txcw</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_TXCW_ANE</span><span class="p">));</span>

		<span class="cm">/* Force link-up and also force full-duplex. */</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_CTRL_SLU</span> <span class="o">|</span> <span class="n">E1000_CTRL_FD</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

		<span class="cm">/* Configure Flow Control after forcing link up. */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_config_fc_after_link_up</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error configuring flow control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_SLU</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_C</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we are forcing link and we are receiving /C/ ordered</span>
<span class="cm">		 * sets, re-enable auto-negotiation in the TXCW register</span>
<span class="cm">		 * and disable forced link in the Device Control register</span>
<span class="cm">		 * in an attempt to auto-negotiate with our link partner.</span>
<span class="cm">		 */</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;RXing /C/, enable AutoNeg and stop forcing link.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">txcw</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_CTRL_SLU</span><span class="p">));</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">E1000_TXCW_ANE</span> <span class="o">&amp;</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we force link for non-auto-negotiation switch, check</span>
<span class="cm">		 * link status based on MAC synchronization for internal</span>
<span class="cm">		 * serdes media type.</span>
<span class="cm">		 */</span>
		<span class="cm">/* SYNCH bit and IV bit are sticky. */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">rxcw</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCW</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_SYNCH</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_IV</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;SERDES: Link up - forced.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;SERDES: Link down - force failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">E1000_TXCW_ANE</span> <span class="o">&amp;</span> <span class="n">er32</span><span class="p">(</span><span class="n">TXCW</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* SYNCH bit and IV bit are sticky, so reread rxcw. */</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">rxcw</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCW</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_SYNCH</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rxcw</span> <span class="o">&amp;</span> <span class="n">E1000_RXCW_IV</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;SERDES: Link up - autoneg &quot;</span>
						 <span class="s">&quot;completed successfully.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
					<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;SERDES: Link down - invalid&quot;</span>
						 <span class="s">&quot;codewords detected in autoneg.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;SERDES: Link down - no sync.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">serdes_has_link</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;SERDES: Link down - autoneg failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

      <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_check_for_link</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Checks to see if the link status of the hardware has changed.</span>
<span class="cm"> * Called by any function that needs to check the link status of the adapter.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_check_for_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rxcw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rctl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_check_for_link&quot;</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>

	<span class="cm">/* On adapters with a MAC newer than 82544, SW Definable pin 1 will be</span>
<span class="cm">	 * set when the optics detect a signal. On older adapters, it will be</span>
<span class="cm">	 * cleared when there is a signal.  This applies to fiber media only.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rxcw</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXCW</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">signal</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span>
			     <span class="n">e1000_82544</span><span class="p">)</span> <span class="o">?</span> <span class="n">E1000_CTRL_SWDPIN1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_LU</span><span class="p">)</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If we have a copper PHY then we only want to go out to the PHY</span>
<span class="cm">	 * registers to see if Auto-Neg has completed and/or if our link</span>
<span class="cm">	 * status has changed.  The get_link_status flag will be set if we</span>
<span class="cm">	 * receive a Link Status Change interrupt or we have Rx Sequence</span>
<span class="cm">	 * Errors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">get_link_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First we want to see if the MII Status Register reports</span>
<span class="cm">		 * link.  If so, then we want to get the current speed/duplex</span>
<span class="cm">		 * of the PHY.</span>
<span class="cm">		 * Read the register twice since the link bit is sticky.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">get_link_status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="cm">/* Check if there was DownShift, must be checked immediately after</span>
<span class="cm">			 * link-up */</span>
			<span class="n">e1000_check_downshift</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

			<span class="cm">/* If we are on 82544 or 82543 silicon and speed/duplex</span>
<span class="cm">			 * are forced to 10H or 10F, then we will implement the polarity</span>
<span class="cm">			 * reversal workaround.  We disable interrupts first, and upon</span>
<span class="cm">			 * returning, place the devices interrupt state to its previous</span>
<span class="cm">			 * value except for the link status change interrupt which will</span>
<span class="cm">			 * happen due to the execution of this workaround.</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82544</span>
			     <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">==</span> <span class="n">e1000_10_full</span>
				<span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">forced_speed_duplex</span> <span class="o">==</span> <span class="n">e1000_10_half</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">IMC</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">);</span>
				<span class="n">ret_val</span> <span class="o">=</span>
				    <span class="n">e1000_polarity_reversal_workaround</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
				<span class="n">icr</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ICR</span><span class="p">);</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">ICS</span><span class="p">,</span> <span class="p">(</span><span class="n">icr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_ICS_LSC</span><span class="p">));</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">IMS</span><span class="p">,</span> <span class="n">IMS_ENABLE_MASK</span><span class="p">);</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* No link detected */</span>
			<span class="n">e1000_config_dsp_after_link_change</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If we are forcing speed/duplex, then we simply return since</span>
<span class="cm">		 * we have already determined whether we have link or not.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>

		<span class="cm">/* optimize the dsp settings for the igp phy */</span>
		<span class="n">e1000_config_dsp_after_link_change</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="cm">/* We have a M88E1000 PHY and Auto-Neg is enabled.  If we</span>
<span class="cm">		 * have Si on board that is 82544 or newer, Auto</span>
<span class="cm">		 * Speed Detection takes care of MAC speed/duplex</span>
<span class="cm">		 * configuration.  So we only need to configure Collision</span>
<span class="cm">		 * Distance in the MAC.  Otherwise, we need to force</span>
<span class="cm">		 * speed/duplex on the MAC to the current PHY speed/duplex</span>
<span class="cm">		 * settings.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">!=</span> <span class="n">e1000_ce4100</span><span class="p">))</span>
			<span class="n">e1000_config_collision_dist</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_config_mac_to_phy</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span>
				    <span class="p">(</span><span class="s">&quot;Error configuring MAC to PHY settings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Configure Flow Control now that Auto-Neg has completed. First, we</span>
<span class="cm">		 * need to restore the desired flow control settings because we may</span>
<span class="cm">		 * have had to re-autoneg with a different link partner.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_config_fc_after_link_up</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error configuring flow control</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* At this point we know that we are on copper and we have</span>
<span class="cm">		 * auto-negotiated link.  These are conditions for checking the link</span>
<span class="cm">		 * partner capability register.  We use the link speed to determine if</span>
<span class="cm">		 * TBI compatibility needs to be turned on or off.  If the link is not</span>
<span class="cm">		 * at gigabit speed, then TBI compatibility is not needed.  If we are</span>
<span class="cm">		 * at gigabit speed, we turn on TBI compatibility.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_en</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">speed</span><span class="p">,</span> <span class="n">duplex</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_get_speed_and_duplex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">duplex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span>
				    <span class="p">(</span><span class="s">&quot;Error getting link speed and duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">!=</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* If link speed is not set to gigabit speed, we do not need</span>
<span class="cm">				 * to enable TBI compatibility.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_on</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* If we previously were in the mode, turn it off. */</span>
					<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
					<span class="n">rctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_RCTL_SBP</span><span class="p">;</span>
					<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_on</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* If TBI compatibility is was previously off, turn it on. For</span>
<span class="cm">				 * compatibility with a TBI link partner, we will store bad</span>
<span class="cm">				 * packets. Some frames have an additional byte on the end and</span>
<span class="cm">				 * will look like CRC errors to to the hardware.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_on</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">tbi_compatibility_on</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="n">rctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">);</span>
					<span class="n">rctl</span> <span class="o">|=</span> <span class="n">E1000_RCTL_SBP</span><span class="p">;</span>
					<span class="n">ew32</span><span class="p">(</span><span class="n">RCTL</span><span class="p">,</span> <span class="n">rctl</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_internal_serdes</span><span class="p">))</span>
		<span class="n">e1000_check_for_serdes_link_generic</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_get_speed_and_duplex</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @speed: Speed of the connection</span>
<span class="cm"> * @duplex: Duplex setting of the connection</span>

<span class="cm"> * Detects the current speed and duplex settings of the hardware.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_get_speed_and_duplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">duplex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_get_speed_and_duplex&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;=</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_1000</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;1000 Mbs, &quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_SPEED_100</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_100</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;100 Mbs, &quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_10</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;10 Mbs, &quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_FD</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">FULL_DUPLEX</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Full Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">HALF_DUPLEX</span><span class="p">;</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot; Half Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;1000 Mbs, Full Duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">speed</span> <span class="o">=</span> <span class="n">SPEED_1000</span><span class="p">;</span>
		<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">FULL_DUPLEX</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* IGP01 PHY may advertise full duplex operation after speed downgrade even</span>
<span class="cm">	 * if it is operating at half duplex.  Here we set the duplex settings to</span>
<span class="cm">	 * match the duplex in the link partner&#39;s capabilities.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span> <span class="o">&amp;&amp;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">speed_downgraded</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_AUTONEG_EXP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">NWAY_ER_LP_NWAY_CAPS</span><span class="p">))</span>
			<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">HALF_DUPLEX</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_LP_ABILITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_100</span>
			     <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">NWAY_LPAR_100TX_FD_CAPS</span><span class="p">))</span>
			    <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_10</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">NWAY_LPAR_10T_FD_CAPS</span><span class="p">)))</span>
				<span class="o">*</span><span class="n">duplex</span> <span class="o">=</span> <span class="n">HALF_DUPLEX</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_wait_autoneg</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Blocks until autoneg completes or times out (~4.5 seconds)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_wait_autoneg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_wait_autoneg&quot;</span><span class="p">);</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Waiting for Auto-Neg to complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* We will wait for autoneg to complete or 4.5 seconds to expire. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PHY_AUTO_NEG_TIME</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the MII Status Register and wait for Auto-Neg</span>
<span class="cm">		 * Complete bit to be set.</span>
<span class="cm">		 */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">MII_SR_AUTONEG_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_raise_mdi_clk - Raises the Management Data Clock</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @ctrl: Device control register&#39;s current value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_raise_mdi_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Raise the clock input to the Management Data Clock (by setting the MDC</span>
<span class="cm">	 * bit), and then delay 10 microseconds.</span>
<span class="cm">	 */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_MDC</span><span class="p">));</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_lower_mdi_clk - Lowers the Management Data Clock</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @ctrl: Device control register&#39;s current value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_lower_mdi_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Lower the clock input to the Management Data Clock (by clearing the MDC</span>
<span class="cm">	 * bit), and then delay 10 microseconds.</span>
<span class="cm">	 */</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_CTRL_MDC</span><span class="p">));</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_shift_out_mdi_bits - Shifts data bits out to the PHY</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @data: Data to send out to the PHY</span>
<span class="cm"> * @count: Number of bits to shift out</span>
<span class="cm"> *</span>
<span class="cm"> * Bits are shifted out in MSB to LSB order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_shift_out_mdi_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* We need to shift &quot;count&quot; number of bits out to the PHY. So, the value</span>
<span class="cm">	 * in the &quot;data&quot; parameter will be shifted out to the PHY one bit at a</span>
<span class="cm">	 * time. In order to do this, &quot;data&quot; must be broken down into bits.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="cm">/* Set MDIO_DIR and MDC_DIR direction bits to be used as output pins. */</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_CTRL_MDIO_DIR</span> <span class="o">|</span> <span class="n">E1000_CTRL_MDC_DIR</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* A &quot;1&quot; is shifted out to the PHY by setting the MDIO bit to &quot;1&quot; and</span>
<span class="cm">		 * then raising and lowering the Management Data Clock. A &quot;0&quot; is</span>
<span class="cm">		 * shifted out to the PHY by setting the MDIO bit to &quot;0&quot; and then</span>
<span class="cm">		 * raising and lowering the clock.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_MDIO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_MDIO</span><span class="p">;</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">e1000_raise_mdi_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
		<span class="n">e1000_lower_mdi_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_shift_in_mdi_bits - Shifts data bits in from the PHY</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Bits are shifted in in MSB to LSB order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">e1000_shift_in_mdi_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* In order to read a register from the PHY, we need to shift in a total</span>
<span class="cm">	 * of 18 bits from the PHY. The first two bit (turnaround) times are used</span>
<span class="cm">	 * to avoid contention on the MDIO pin when a read operation is performed.</span>
<span class="cm">	 * These two bits are ignored by us and thrown away. Bits are &quot;shifted in&quot;</span>
<span class="cm">	 * by raising the input to the Management Data Clock (setting the MDC bit),</span>
<span class="cm">	 * and then reading the value of the MDIO bit.</span>
<span class="cm">	 */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="cm">/* Clear MDIO_DIR (SWDPIO1) to indicate this bit is to be used as input. */</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_MDIO_DIR</span><span class="p">;</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_MDIO</span><span class="p">;</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

	<span class="cm">/* Raise and Lower the clock before reading in the data. This accounts for</span>
<span class="cm">	 * the turnaround bits. The first clock occurred when we clocked out the</span>
<span class="cm">	 * last bit of the Register Address.</span>
<span class="cm">	 */</span>
	<span class="n">e1000_raise_mdi_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">e1000_lower_mdi_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">e1000_raise_mdi_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
		<span class="cm">/* Check to see if we shifted in a &quot;1&quot;. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">E1000_CTRL_MDIO</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">e1000_lower_mdi_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">e1000_raise_mdi_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>
	<span class="n">e1000_lower_mdi_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * e1000_read_phy_reg - read a phy register</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @reg_addr: address of the PHY register to read</span>
<span class="cm"> *</span>
<span class="cm"> * Reads the value from a PHY register, if the value is on a specific non zero</span>
<span class="cm"> * page, sets the page first.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_read_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">phy_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_read_phy_reg&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">reg_addr</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg_ex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PAGE_SELECT</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">reg_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg_ex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">reg_addr</span><span class="p">,</span>
					<span class="n">phy_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_read_phy_reg_ex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span>
				 <span class="n">u16</span> <span class="o">*</span><span class="n">phy_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mdic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span> <span class="o">?</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_read_phy_reg_ex&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_addr</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_REG_ADDRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PHY Address %d is out of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PARAM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set up Op-code, Phy Address, and register address in the MDI</span>
<span class="cm">		 * Control register.  The MAC will take care of interfacing with the</span>
<span class="cm">		 * PHY to retrieve the desired data.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mdic</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg_addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_REG_SHIFT</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">phy_addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_PHY_SHIFT</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">INTEL_CE_GBE_MDIC_OP_READ</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">INTEL_CE_GBE_MDIC_GO</span><span class="p">));</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">mdic</span><span class="p">,</span> <span class="n">E1000_MDIO_CMD</span><span class="p">);</span>

			<span class="cm">/* Poll the ready bit to see if the MDI read</span>
<span class="cm">			 * completed</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
				<span class="n">mdic</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">E1000_MDIO_CMD</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">INTEL_CE_GBE_MDIC_GO</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">INTEL_CE_GBE_MDIC_GO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Read did not complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">mdic</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">E1000_MDIO_STS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">INTEL_CE_GBE_MDIC_READ_ERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="o">*</span><span class="n">phy_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">mdic</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mdic</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg_addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_REG_SHIFT</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">phy_addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_PHY_SHIFT</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">E1000_MDIC_OP_READ</span><span class="p">));</span>

			<span class="n">ew32</span><span class="p">(</span><span class="n">MDIC</span><span class="p">,</span> <span class="n">mdic</span><span class="p">);</span>

			<span class="cm">/* Poll the ready bit to see if the MDI read</span>
<span class="cm">			 * completed</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
				<span class="n">mdic</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MDIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_READY</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_READY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Read did not complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_ERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="o">*</span><span class="n">phy_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">mdic</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We must first send a preamble through the MDIO pin to signal the</span>
<span class="cm">		 * beginning of an MII instruction.  This is done by sending 32</span>
<span class="cm">		 * consecutive &quot;1&quot; bits.</span>
<span class="cm">		 */</span>
		<span class="n">e1000_shift_out_mdi_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_PREAMBLE</span><span class="p">,</span> <span class="n">PHY_PREAMBLE_SIZE</span><span class="p">);</span>

		<span class="cm">/* Now combine the next few fields that are required for a read</span>
<span class="cm">		 * operation.  We use this method instead of calling the</span>
<span class="cm">		 * e1000_shift_out_mdi_bits routine five different times. The format of</span>
<span class="cm">		 * a MII read instruction consists of a shift out of 14 bits and is</span>
<span class="cm">		 * defined as follows:</span>
<span class="cm">		 *    &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;</span>
<span class="cm">		 * followed by a shift in of 18 bits.  This first two bits shifted in</span>
<span class="cm">		 * are TurnAround bits used to avoid contention on the MDIO pin when a</span>
<span class="cm">		 * READ operation is performed.  These two bits are thrown away</span>
<span class="cm">		 * followed by a shift in of 16 bits which contains the desired data.</span>
<span class="cm">		 */</span>
		<span class="n">mdic</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg_addr</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">PHY_OP_READ</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">PHY_SOF</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">));</span>

		<span class="n">e1000_shift_out_mdi_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mdic</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>

		<span class="cm">/* Now that we&#39;ve shifted out the read command to the MII, we need to</span>
<span class="cm">		 * &quot;shift in&quot; the 16-bit value (18 total bits) of the requested PHY</span>
<span class="cm">		 * register address.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">phy_data</span> <span class="o">=</span> <span class="n">e1000_shift_in_mdi_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_write_phy_reg - write a phy register</span>
<span class="cm"> *</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @reg_addr: address of the PHY register to write</span>
<span class="cm"> * @data: data to write to the PHY</span>

<span class="cm"> * Writes a value to a PHY register</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_write_phy_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">u16</span> <span class="n">phy_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_write_phy_reg&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">reg_addr</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_MULTI_PAGE_REG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg_ex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PAGE_SELECT</span><span class="p">,</span>
						 <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">reg_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg_ex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">MAX_PHY_REG_ADDRESS</span> <span class="o">&amp;</span> <span class="n">reg_addr</span><span class="p">,</span>
					 <span class="n">phy_data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_write_phy_reg_ex</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">reg_addr</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="n">phy_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mdic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">phy_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span> <span class="o">?</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_addr</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_write_phy_reg_ex&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reg_addr</span> <span class="o">&gt;</span> <span class="n">MAX_PHY_REG_ADDRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PHY Address %d is out of range</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PARAM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set up Op-code, Phy Address, register address, and data</span>
<span class="cm">		 * intended for the PHY register in the MDI Control register.</span>
<span class="cm">		 * The MAC will take care of interfacing with the PHY to send</span>
<span class="cm">		 * the desired data.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mdic</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span> <span class="n">phy_data</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">reg_addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_REG_SHIFT</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">phy_addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_PHY_SHIFT</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">INTEL_CE_GBE_MDIC_OP_WRITE</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">INTEL_CE_GBE_MDIC_GO</span><span class="p">));</span>

			<span class="n">writel</span><span class="p">(</span><span class="n">mdic</span><span class="p">,</span> <span class="n">E1000_MDIO_CMD</span><span class="p">);</span>

			<span class="cm">/* Poll the ready bit to see if the MDI read</span>
<span class="cm">			 * completed</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">640</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
				<span class="n">mdic</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">E1000_MDIO_CMD</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">INTEL_CE_GBE_MDIC_GO</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">INTEL_CE_GBE_MDIC_GO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Write did not complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mdic</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)</span> <span class="n">phy_data</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">reg_addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_REG_SHIFT</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">phy_addr</span> <span class="o">&lt;&lt;</span> <span class="n">E1000_MDIC_PHY_SHIFT</span><span class="p">)</span> <span class="o">|</span>
				<span class="p">(</span><span class="n">E1000_MDIC_OP_WRITE</span><span class="p">));</span>

			<span class="n">ew32</span><span class="p">(</span><span class="n">MDIC</span><span class="p">,</span> <span class="n">mdic</span><span class="p">);</span>

			<span class="cm">/* Poll the ready bit to see if the MDI read</span>
<span class="cm">			 * completed</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">641</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
				<span class="n">mdic</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MDIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_READY</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mdic</span> <span class="o">&amp;</span> <span class="n">E1000_MDIC_READY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;MDI Write did not complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We&#39;ll need to use the SW defined pins to shift the write command</span>
<span class="cm">		 * out to the PHY. We first send a preamble to the PHY to signal the</span>
<span class="cm">		 * beginning of the MII instruction.  This is done by sending 32</span>
<span class="cm">		 * consecutive &quot;1&quot; bits.</span>
<span class="cm">		 */</span>
		<span class="n">e1000_shift_out_mdi_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_PREAMBLE</span><span class="p">,</span> <span class="n">PHY_PREAMBLE_SIZE</span><span class="p">);</span>

		<span class="cm">/* Now combine the remaining required fields that will indicate a</span>
<span class="cm">		 * write operation. We use this method instead of calling the</span>
<span class="cm">		 * e1000_shift_out_mdi_bits routine for each field in the command. The</span>
<span class="cm">		 * format of a MII write instruction is as follows:</span>
<span class="cm">		 * &lt;Preamble&gt;&lt;SOF&gt;&lt;Op Code&gt;&lt;Phy Addr&gt;&lt;Reg Addr&gt;&lt;Turnaround&gt;&lt;Data&gt;.</span>
<span class="cm">		 */</span>
		<span class="n">mdic</span> <span class="o">=</span> <span class="p">((</span><span class="n">PHY_TURNAROUND</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">reg_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">phy_addr</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|</span>
			<span class="p">(</span><span class="n">PHY_OP_WRITE</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">PHY_SOF</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">));</span>
		<span class="n">mdic</span> <span class="o">&lt;&lt;=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">mdic</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">phy_data</span><span class="p">;</span>

		<span class="n">e1000_shift_out_mdi_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">mdic</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_hw_reset - reset the phy, hardware style</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the PHY to the power-on reset state</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_phy_hw_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">led_ctrl</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_hw_reset&quot;</span><span class="p">);</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Resetting Phy...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82543</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the device control register and assert the E1000_CTRL_PHY_RST</span>
<span class="cm">		 * bit. Then, take it out of reset.</span>
<span class="cm">		 * For e1000 hardware, we delay for 10ms between the assert</span>
<span class="cm">		 * and deassert.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span> <span class="o">|</span> <span class="n">E1000_CTRL_PHY_RST</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Read the Extended Device Control Register, assert the PHY_RESET_DIR</span>
<span class="cm">		 * bit to put the PHY into reset. Then, take it out of reset.</span>
<span class="cm">		 */</span>
		<span class="n">ctrl_ext</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">);</span>
		<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_SDP4_DIR</span><span class="p">;</span>
		<span class="n">ctrl_ext</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_EXT_SDP4_DATA</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">ctrl_ext</span> <span class="o">|=</span> <span class="n">E1000_CTRL_EXT_SDP4_DATA</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL_EXT</span><span class="p">,</span> <span class="n">ctrl_ext</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">150</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Configure activity LED after PHY reset */</span>
		<span class="n">led_ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">);</span>
		<span class="n">led_ctrl</span> <span class="o">&amp;=</span> <span class="n">IGP_ACTIVITY_LED_MASK</span><span class="p">;</span>
		<span class="n">led_ctrl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">IGP_ACTIVITY_LED_ENABLE</span> <span class="o">|</span> <span class="n">IGP_LED3_MODE</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">led_ctrl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wait for FW to finish PHY configuration. */</span>
	<span class="k">return</span> <span class="n">e1000_get_phy_cfg_done</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_reset - reset the phy to commit settings</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Resets the PHY</span>
<span class="cm"> * Sets bit 15 of the MII Control register</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_phy_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_reset&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_phy_igp</span>:
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_phy_hw_reset</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">MII_CR_RESET</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_CTRL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span>
		<span class="n">e1000_phy_init_script</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_detect_gig_phy - check the phy type</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Probes the expected PHY address for known PHY IDs</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_detect_gig_phy</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">phy_init_status</span><span class="p">,</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_id_high</span><span class="p">,</span> <span class="n">phy_id_low</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">match</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_detect_gig_phy&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="cm">/* Read the PHY ID Registers to identify which PHY is onboard. */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_ID1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_id_high</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">phy_id_high</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_ID2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_id_low</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">|=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">(</span><span class="n">phy_id_low</span> <span class="o">&amp;</span> <span class="n">PHY_REVISION_MASK</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_revision</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">phy_id_low</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PHY_REVISION_MASK</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82543</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">==</span> <span class="n">M88E1000_E_PHY_ID</span><span class="p">)</span>
			<span class="n">match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82544</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">==</span> <span class="n">M88E1000_I_PHY_ID</span><span class="p">)</span>
			<span class="n">match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82540</span>:
	<span class="k">case</span> <span class="n">e1000_82545</span>:
	<span class="k">case</span> <span class="n">e1000_82545_rev_3</span>:
	<span class="k">case</span> <span class="n">e1000_82546</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">==</span> <span class="n">M88E1011_I_PHY_ID</span><span class="p">)</span>
			<span class="n">match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_ce4100</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">==</span> <span class="n">RTL8211B_PHY_ID</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">==</span> <span class="n">RTL8201N_PHY_ID</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">==</span> <span class="n">M88E1118_E_PHY_ID</span><span class="p">))</span>
			<span class="n">match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
	<span class="k">case</span> <span class="n">e1000_82547</span>:
	<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span> <span class="o">==</span> <span class="n">IGP01E1000_I_PHY_ID</span><span class="p">)</span>
			<span class="n">match</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Invalid MAC type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phy_init_status</span> <span class="o">=</span> <span class="n">e1000_set_phy_type</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">match</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phy_init_status</span> <span class="o">==</span> <span class="n">E1000_SUCCESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PHY ID 0x%X detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Invalid PHY ID 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_reset_dsp - reset DSP</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Resets the PHY&#39;s DSP</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_phy_reset_dsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_reset_dsp&quot;</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mh">0x001d</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mh">0x00c1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_igp_get_info - get igp specific registers</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @phy_info: PHY information structure</span>
<span class="cm"> *</span>
<span class="cm"> * Get PHY information from various PHY registers for igp PHY only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_phy_igp_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">min_length</span><span class="p">,</span> <span class="n">max_length</span><span class="p">,</span> <span class="n">average</span><span class="p">;</span>
	<span class="n">e1000_rev_polarity</span> <span class="n">polarity</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_igp_get_info&quot;</span><span class="p">);</span>

	<span class="cm">/* The downshift status is checked only once, after link is established,</span>
<span class="cm">	 * and it stored in the hw-&gt;speed_downgraded parameter. */</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">downshift</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1000_downshift</span><span class="p">)</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">speed_downgraded</span><span class="p">;</span>

	<span class="cm">/* IGP01E1000 does not need to support it. */</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">extended_10bt_distance</span> <span class="o">=</span> <span class="n">e1000_10bt_ext_dist_enable_normal</span><span class="p">;</span>

	<span class="cm">/* IGP01E1000 always correct polarity reversal */</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">polarity_correction</span> <span class="o">=</span> <span class="n">e1000_polarity_reversal_enabled</span><span class="p">;</span>

	<span class="cm">/* Check polarity status */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_polarity</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">polarity</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_polarity</span> <span class="o">=</span> <span class="n">polarity</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">mdix_mode</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">e1000_auto_x_mode</span><span class="p">)</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PSSR_MDIX</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				 <span class="n">IGP01E1000_PSSR_MDIX_SHIFT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PSSR_SPEED_MASK</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IGP01E1000_PSSR_SPEED_1000MBPS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Local/Remote Receiver Information are only valid at 1000 Mbps */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_LOCAL_RX_STATUS</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				      <span class="n">SR_1000T_LOCAL_RX_STATUS_SHIFT</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">e1000_1000t_rx_status_ok</span> <span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>
		<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_REMOTE_RX_STATUS</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				       <span class="n">SR_1000T_REMOTE_RX_STATUS_SHIFT</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">e1000_1000t_rx_status_ok</span> <span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>

		<span class="cm">/* Get cable length */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_cable_length</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_length</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* Translate to old method */</span>
		<span class="n">average</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_length</span> <span class="o">+</span> <span class="n">min_length</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">average</span> <span class="o">&lt;=</span> <span class="n">e1000_igp_cable_length_50</span><span class="p">)</span>
			<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">e1000_cable_length_50</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">average</span> <span class="o">&lt;=</span> <span class="n">e1000_igp_cable_length_80</span><span class="p">)</span>
			<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">e1000_cable_length_50_80</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">average</span> <span class="o">&lt;=</span> <span class="n">e1000_igp_cable_length_110</span><span class="p">)</span>
			<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">e1000_cable_length_80_110</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">average</span> <span class="o">&lt;=</span> <span class="n">e1000_igp_cable_length_140</span><span class="p">)</span>
			<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">e1000_cable_length_110_140</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">e1000_cable_length_140</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_m88_get_info - get m88 specific registers</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @phy_info: PHY information structure</span>
<span class="cm"> *</span>
<span class="cm"> * Get PHY information from various PHY registers for m88 PHY only.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_phy_m88_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">e1000_rev_polarity</span> <span class="n">polarity</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_m88_get_info&quot;</span><span class="p">);</span>

	<span class="cm">/* The downshift status is checked only once, after link is established,</span>
<span class="cm">	 * and it stored in the hw-&gt;speed_downgraded parameter. */</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">downshift</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1000_downshift</span><span class="p">)</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">speed_downgraded</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">extended_10bt_distance</span> <span class="o">=</span>
	    <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSCR_10BT_EXT_DIST_ENABLE</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
	     <span class="n">M88E1000_PSCR_10BT_EXT_DIST_ENABLE_SHIFT</span><span class="p">)</span> <span class="o">?</span>
	    <span class="n">e1000_10bt_ext_dist_enable_lower</span> <span class="o">:</span>
	    <span class="n">e1000_10bt_ext_dist_enable_normal</span><span class="p">;</span>

	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">polarity_correction</span> <span class="o">=</span>
	    <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSCR_POLARITY_REVERSAL</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
	     <span class="n">M88E1000_PSCR_POLARITY_REVERSAL_SHIFT</span><span class="p">)</span> <span class="o">?</span>
	    <span class="n">e1000_polarity_reversal_disabled</span> <span class="o">:</span> <span class="n">e1000_polarity_reversal_enabled</span><span class="p">;</span>

	<span class="cm">/* Check polarity status */</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_check_polarity</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">polarity</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_polarity</span> <span class="o">=</span> <span class="n">polarity</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">mdix_mode</span> <span class="o">=</span>
	    <span class="p">(</span><span class="n">e1000_auto_x_mode</span><span class="p">)</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_MDIX</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				 <span class="n">M88E1000_PSSR_MDIX_SHIFT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_SPEED</span><span class="p">)</span> <span class="o">==</span> <span class="n">M88E1000_PSSR_1000MBS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cable Length Estimation and Local/Remote Receiver Information</span>
<span class="cm">		 * are only valid at 1000 Mbps.</span>
<span class="cm">		 */</span>
		<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">e1000_cable_length</span><span class="p">)</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span>
					   <span class="n">M88E1000_PSSR_CABLE_LENGTH</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
					  <span class="n">M88E1000_PSSR_CABLE_LENGTH_SHIFT</span><span class="p">);</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_LOCAL_RX_STATUS</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				      <span class="n">SR_1000T_LOCAL_RX_STATUS_SHIFT</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">e1000_1000t_rx_status_ok</span> <span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>
		<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_REMOTE_RX_STATUS</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				       <span class="n">SR_1000T_REMOTE_RX_STATUS_SHIFT</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">e1000_1000t_rx_status_ok</span> <span class="o">:</span> <span class="n">e1000_1000t_rx_status_not_ok</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_phy_get_info - request phy info</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @phy_info: PHY information structure</span>
<span class="cm"> *</span>
<span class="cm"> * Get PHY information from various PHY registers</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_phy_get_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">e1000_phy_info</span> <span class="o">*</span><span class="n">phy_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_phy_get_info&quot;</span><span class="p">);</span>

	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_length</span> <span class="o">=</span> <span class="n">e1000_cable_length_undefined</span><span class="p">;</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">extended_10bt_distance</span> <span class="o">=</span> <span class="n">e1000_10bt_ext_dist_enable_undefined</span><span class="p">;</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">cable_polarity</span> <span class="o">=</span> <span class="n">e1000_rev_polarity_undefined</span><span class="p">;</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">downshift</span> <span class="o">=</span> <span class="n">e1000_downshift_undefined</span><span class="p">;</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">polarity_correction</span> <span class="o">=</span> <span class="n">e1000_polarity_reversal_undefined</span><span class="p">;</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">mdix_mode</span> <span class="o">=</span> <span class="n">e1000_auto_x_mode_undefined</span><span class="p">;</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">local_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>
	<span class="n">phy_info</span><span class="o">-&gt;</span><span class="n">remote_rx</span> <span class="o">=</span> <span class="n">e1000_1000t_rx_status_undefined</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">!=</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PHY info is only valid for copper media</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;PHY info is only valid if link is up</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">e1000_phy_igp_get_info</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">phy_info</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_8211</span><span class="p">)</span> <span class="o">||</span>
	         <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_8201</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">e1000_phy_m88_get_info</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">phy_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">s32</span> <span class="nf">e1000_validate_mdi_setting</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_validate_mdi_settings&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mdix</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mdix</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Invalid MDI setting detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mdix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_CONFIG</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_init_eeprom_params - initialize sw eeprom vars</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Sets up eeprom variables in the hw struct.  Must be called after mac_type</span>
<span class="cm"> * is configured.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_init_eeprom_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_size</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_init_eeprom_params&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
	<span class="k">case</span> <span class="n">e1000_82543</span>:
	<span class="k">case</span> <span class="n">e1000_82544</span>:
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e1000_eeprom_microwire</span><span class="p">;</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82540</span>:
	<span class="k">case</span> <span class="n">e1000_82545</span>:
	<span class="k">case</span> <span class="n">e1000_82545_rev_3</span>:
	<span class="k">case</span> <span class="n">e1000_82546</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e1000_eeprom_microwire</span><span class="p">;</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
	<span class="k">case</span> <span class="n">e1000_82547</span>:
	<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_TYPE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e1000_eeprom_spi</span><span class="p">;</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_ADDR_BITS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
				<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">page_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
				<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">e1000_eeprom_microwire</span><span class="p">;</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_ADDR_BITS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
				<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
				<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* eeprom_size will be an enum [0..8] that maps to eeprom sizes 128B to</span>
<span class="cm">		 * 32KB (incremented by powers of 2).</span>
<span class="cm">		 */</span>
		<span class="cm">/* Set to default value for initial eeprom read. */</span>
		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CFG</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">eeprom_size</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">eeprom_size</span> <span class="o">&amp;</span> <span class="n">EEPROM_SIZE_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">EEPROM_SIZE_SHIFT</span><span class="p">;</span>
		<span class="cm">/* 256B eeprom size was not supported in earlier hardware, so we</span>
<span class="cm">		 * bump eeprom_size up one to ensure that &quot;1&quot; (which maps to 256B)</span>
<span class="cm">		 * is never the result used in the shifting logic below. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eeprom_size</span><span class="p">)</span>
			<span class="n">eeprom_size</span><span class="o">++</span><span class="p">;</span>

		<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">eeprom_size</span> <span class="o">+</span> <span class="n">EEPROM_WORD_SIZE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_raise_ee_clk - Raises the EEPROM&#39;s clock input.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @eecd: EECD&#39;s current value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_raise_ee_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eecd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Raise the clock input to the EEPROM (by setting the SK bit), and then</span>
<span class="cm">	 * wait &lt;delay&gt; microseconds.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">eecd</span> <span class="o">=</span> <span class="o">*</span><span class="n">eecd</span> <span class="o">|</span> <span class="n">E1000_EECD_SK</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="o">*</span><span class="n">eecd</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">delay_usec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_lower_ee_clk - Lowers the EEPROM&#39;s clock input.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @eecd: EECD&#39;s current value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_lower_ee_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eecd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Lower the clock input to the EEPROM (by clearing the SK bit), and then</span>
<span class="cm">	 * wait 50 microseconds.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">eecd</span> <span class="o">=</span> <span class="o">*</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">E1000_EECD_SK</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="o">*</span><span class="n">eecd</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">udelay</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">delay_usec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_shift_out_ee_bits - Shift data bits out to the EEPROM.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @data: data to send to the EEPROM</span>
<span class="cm"> * @count: number of bits to shift out</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">data</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* We need to shift &quot;count&quot; bits out to the EEPROM. So, value in the</span>
<span class="cm">	 * &quot;data&quot; parameter will be shifted out to the EEPROM one bit at a time.</span>
<span class="cm">	 * In order to do this, &quot;data&quot; must be broken down into bits.</span>
<span class="cm">	 */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_microwire</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_DO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_DO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* A &quot;1&quot; is shifted out to the EEPROM by setting bit &quot;DI&quot; to a &quot;1&quot;,</span>
<span class="cm">		 * and then raising and then lowering the clock (the SK bit controls</span>
<span class="cm">		 * the clock input to the EEPROM).  A &quot;0&quot; is shifted out to the EEPROM</span>
<span class="cm">		 * by setting &quot;DI&quot; to &quot;0&quot; and then raising and then lowering the clock.</span>
<span class="cm">		 */</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_DI</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>
			<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_DI</span><span class="p">;</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

		<span class="n">udelay</span><span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>

		<span class="n">e1000_raise_ee_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>
		<span class="n">e1000_lower_ee_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* We leave the &quot;DI&quot; bit set to &quot;0&quot; when we leave this routine. */</span>
	<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_DI</span><span class="p">;</span>
	<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_shift_in_ee_bits - Shift data bits in from the EEPROM</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @count: number of bits to shift in</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">e1000_shift_in_ee_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">data</span><span class="p">;</span>

	<span class="cm">/* In order to read a register from the EEPROM, we need to shift &#39;count&#39;</span>
<span class="cm">	 * bits in from the EEPROM. Bits are &quot;shifted in&quot; by raising the clock</span>
<span class="cm">	 * input to the EEPROM (setting the SK bit), and then reading the value of</span>
<span class="cm">	 * the &quot;DO&quot; bit.  During this &quot;shifting in&quot; process the &quot;DI&quot; bit should</span>
<span class="cm">	 * always be clear.</span>
<span class="cm">	 */</span>

	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

	<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_DO</span> <span class="o">|</span> <span class="n">E1000_EECD_DI</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">e1000_raise_ee_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>

		<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_DI</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_DO</span><span class="p">)</span>
			<span class="n">data</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">e1000_lower_ee_clk</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eecd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_acquire_eeprom - Prepares EEPROM for access</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Lowers EEPROM clock. Clears input pin. Sets the chip select pin. This</span>
<span class="cm"> * function should be called before issuing a command to the EEPROM.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_acquire_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_acquire_eeprom&quot;</span><span class="p">);</span>

	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

	<span class="cm">/* Request EEPROM Access */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_REQ</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_GNT</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">E1000_EEPROM_GRANT_ATTEMPTS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
			<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_GNT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_REQ</span><span class="p">;</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Could not acquire EEPROM grant</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Setup EEPROM for Read/Write */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_microwire</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear SK and DI */</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_DI</span> <span class="o">|</span> <span class="n">E1000_EECD_SK</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>

		<span class="cm">/* Set CS */</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_CS</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear SK and CS */</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_CS</span> <span class="o">|</span> <span class="n">E1000_EECD_SK</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_standby_eeprom - Returns EEPROM to a &quot;standby&quot; state</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_standby_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>

	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_microwire</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_CS</span> <span class="o">|</span> <span class="n">E1000_EECD_SK</span><span class="p">);</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>

		<span class="cm">/* Clock high */</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_SK</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>

		<span class="cm">/* Select EEPROM */</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_CS</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>

		<span class="cm">/* Clock low */</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_SK</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Toggle CS to flush commands */</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_CS</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_CS</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">delay_usec</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_release_eeprom - drop chip select</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Terminates a command by inverting the EEPROM&#39;s chip select pin</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_release_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_release_eeprom&quot;</span><span class="p">);</span>

	<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_CS</span><span class="p">;</span>	<span class="cm">/* Pull CS high */</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_SK</span><span class="p">;</span>	<span class="cm">/* Lower SCK */</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>

		<span class="n">udelay</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">delay_usec</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_microwire</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cleanup eeprom */</span>

		<span class="cm">/* CS on Microwire is active-high */</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_EECD_CS</span> <span class="o">|</span> <span class="n">E1000_EECD_DI</span><span class="p">);</span>

		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>

		<span class="cm">/* Rising edge of clock */</span>
		<span class="n">eecd</span> <span class="o">|=</span> <span class="n">E1000_EECD_SK</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">delay_usec</span><span class="p">);</span>

		<span class="cm">/* Falling edge of clock */</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_SK</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">delay_usec</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Stop requesting EEPROM access */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&gt;</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eecd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_EECD_REQ</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">EECD</span><span class="p">,</span> <span class="n">eecd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_spi_eeprom_ready - Reads a 16 bit word from the EEPROM.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_spi_eeprom_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">spi_stat_reg</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_spi_eeprom_ready&quot;</span><span class="p">);</span>

	<span class="cm">/* Read &quot;Status Register&quot; repeatedly until the LSB is cleared.  The</span>
<span class="cm">	 * EEPROM will signal that the command has been completed by clearing</span>
<span class="cm">	 * bit 0 of the internal status register.  If it&#39;s not cleared within</span>
<span class="cm">	 * 5 milliseconds, then error out.</span>
<span class="cm">	 */</span>
	<span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_RDSR_OPCODE_SPI</span><span class="p">,</span>
					<span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">.</span><span class="n">opcode_bits</span><span class="p">);</span>
		<span class="n">spi_stat_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">e1000_shift_in_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">spi_stat_reg</span> <span class="o">&amp;</span> <span class="n">EEPROM_STATUS_RDY_SPI</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">retry_count</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>

		<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retry_count</span> <span class="o">&lt;</span> <span class="n">EEPROM_MAX_RETRY_SPI</span><span class="p">);</span>

	<span class="cm">/* ATMEL SPI write time could vary from 0-20mSec on 3.3V devices (and</span>
<span class="cm">	 * only 0-5mSec on 5V devices)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retry_count</span> <span class="o">&gt;=</span> <span class="n">EEPROM_MAX_RETRY_SPI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;SPI EEPROM Status error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_read_eeprom - Reads a 16 bit word from the EEPROM.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @offset: offset of  word in the EEPROM to read</span>
<span class="cm"> * @data: word read from the EEPROM</span>
<span class="cm"> * @words: number of words to read</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_eeprom_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">e1000_do_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_eeprom_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_do_read_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span>
				<span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_read_eeprom&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">GBE_CONFIG_FLASH_READ</span><span class="p">(</span><span class="n">GBE_CONFIG_BASE_VIRT</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span>
		                      <span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If eeprom is not yet detected, do so now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">e1000_init_eeprom_params</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* A check for invalid values:  offset too large, too many words, and not</span>
<span class="cm">	 * enough words.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">words</span> <span class="o">&gt;</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">words</span><span class="se">\&quot;</span><span class="s"> parameter out of bounds. Words = %d,&quot;</span>
		      <span class="s">&quot;size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* EEPROM&#39;s that don&#39;t use EERD to read require us to bit-bang the SPI</span>
<span class="cm">	 * directly. In this case, we need to acquire the EEPROM so that</span>
<span class="cm">	 * FW or other port software does not interrupt.</span>
<span class="cm">	 */</span>
	<span class="cm">/* Prepare the EEPROM for bit-bang reading */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_acquire_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">!=</span> <span class="n">E1000_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>

	<span class="cm">/* Set up the SPI or Microwire EEPROM for bit-bang reading.  We have</span>
<span class="cm">	 * acquired the EEPROM at this point, so any returns should release it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_spi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">word_in</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">read_opcode</span> <span class="o">=</span> <span class="n">EEPROM_READ_OPCODE_SPI</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_spi_eeprom_ready</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">e1000_release_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Some SPI eeproms use the 8th address bit embedded in the opcode */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">))</span>
			<span class="n">read_opcode</span> <span class="o">|=</span> <span class="n">EEPROM_A8_OPCODE_SPI</span><span class="p">;</span>

		<span class="cm">/* Send the READ command (opcode + addr)  */</span>
		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">read_opcode</span><span class="p">,</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span><span class="p">);</span>
		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
					<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span><span class="p">);</span>

		<span class="cm">/* Read the data.  The address of the eeprom internally increments with</span>
<span class="cm">		 * each byte (spi) being read, saving on the overhead of eeprom setup</span>
<span class="cm">		 * and tear-down.  The address counter will roll over if reading beyond</span>
<span class="cm">		 * the size of the eeprom, thus allowing the entire memory to be read</span>
<span class="cm">		 * starting from any offset. */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">word_in</span> <span class="o">=</span> <span class="n">e1000_shift_in_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word_in</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">word_in</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_microwire</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Send the READ command (opcode + addr)  */</span>
			<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
						<span class="n">EEPROM_READ_OPCODE_MICROWIRE</span><span class="p">,</span>
						<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span><span class="p">);</span>
			<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span>
						<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span><span class="p">);</span>

			<span class="cm">/* Read the data.  For microwire, each word requires the overhead</span>
<span class="cm">			 * of eeprom setup and tear-down. */</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e1000_shift_in_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* End this read operation */</span>
	<span class="n">e1000_release_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_validate_eeprom_checksum - Verifies that the EEPROM has a valid checksum</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Reads the first 64 16 bit words of the EEPROM and sums the values read.</span>
<span class="cm"> * If the the sum of the 64 16 bit words is 0xBABA, the EEPROM&#39;s checksum is</span>
<span class="cm"> * valid.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_validate_eeprom_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">eeprom_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_validate_eeprom_checksum&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">EEPROM_CHECKSUM_REG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">checksum</span> <span class="o">+=</span> <span class="n">eeprom_data</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PARISC</span>
	<span class="cm">/* This is a signature and not a checksum on HP c8000 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">subsystem_vendor_id</span> <span class="o">==</span> <span class="mh">0x103C</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">==</span> <span class="mh">0x16d6</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">==</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">EEPROM_SUM</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Checksum Invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_update_eeprom_checksum - Calculates/writes the EEPROM checksum</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Sums the first 63 16 bit words of the EEPROM. Subtracts the sum from 0xBABA.</span>
<span class="cm"> * Writes the difference to word offset 63 of the EEPROM.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_update_eeprom_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">eeprom_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_update_eeprom_checksum&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EEPROM_CHECKSUM_REG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">checksum</span> <span class="o">+=</span> <span class="n">eeprom_data</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="n">EEPROM_SUM</span> <span class="o">-</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_write_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_CHECKSUM_REG</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">checksum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Write Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_write_eeprom - write words to the different EEPROM types.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @offset: offset within the EEPROM to be written to</span>
<span class="cm"> * @words: number of words to write</span>
<span class="cm"> * @data: 16 bit word to be written to the EEPROM</span>
<span class="cm"> *</span>
<span class="cm"> * If e1000_update_eeprom_checksum is not called after this function, the</span>
<span class="cm"> * EEPROM will most likely contain an invalid checksum.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_write_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_eeprom_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">e1000_do_write_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e1000_eeprom_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_do_write_eeprom</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span>
				 <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_write_eeprom&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_ce4100</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">GBE_CONFIG_FLASH_WRITE</span><span class="p">(</span><span class="n">GBE_CONFIG_BASE_VIRT</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span>
		                       <span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If eeprom is not yet detected, do so now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">e1000_init_eeprom_params</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="cm">/* A check for invalid values:  offset too large, too many words, and not</span>
<span class="cm">	 * enough words.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span><span class="p">)</span>
	    <span class="o">||</span> <span class="p">(</span><span class="n">words</span> <span class="o">&gt;</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">word_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">words</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">words</span><span class="se">\&quot;</span><span class="s"> parameter out of bounds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prepare the EEPROM for writing  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_acquire_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span> <span class="o">!=</span> <span class="n">E1000_SUCCESS</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">e1000_eeprom_microwire</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">e1000_write_eeprom_microwire</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">e1000_write_eeprom_spi</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Done with writing */</span>
	<span class="n">e1000_release_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_write_eeprom_spi - Writes a 16 bit word to a given offset in an SPI EEPROM.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @offset: offset within the EEPROM to be written to</span>
<span class="cm"> * @words: number of words to write</span>
<span class="cm"> * @data: pointer to array of 8 bit words to be written to the EEPROM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_write_eeprom_spi</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u16</span> <span class="n">words</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">widx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_write_eeprom_spi&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">widx</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">write_opcode</span> <span class="o">=</span> <span class="n">EEPROM_WRITE_OPCODE_SPI</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_spi_eeprom_ready</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>

		<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/*  Send the WRITE ENABLE command (8 bit opcode )  */</span>
		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_WREN_OPCODE_SPI</span><span class="p">,</span>
					<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span><span class="p">);</span>

		<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Some SPI eeproms use the 8th address bit embedded in the opcode */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">))</span>
			<span class="n">write_opcode</span> <span class="o">|=</span> <span class="n">EEPROM_A8_OPCODE_SPI</span><span class="p">;</span>

		<span class="cm">/* Send the Write command (8-bit opcode + addr) */</span>
		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">write_opcode</span><span class="p">,</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span><span class="p">);</span>

		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">widx</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
					<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span><span class="p">);</span>

		<span class="cm">/* Send the data */</span>

		<span class="cm">/* Loop to allow for up to whole page write (32 bytes) of eeprom */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">widx</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u16</span> <span class="n">word_out</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">widx</span><span class="p">];</span>
			<span class="n">word_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">word_out</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">word_out</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">word_out</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">widx</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* Some larger eeprom sizes are capable of a 32-byte PAGE WRITE</span>
<span class="cm">			 * operation, while the smaller eeproms are capable of an 8-byte</span>
<span class="cm">			 * PAGE WRITE operation.  Break the inner loop to pass new address</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">widx</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">page_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_write_eeprom_microwire - Writes a 16 bit word to a given offset in a Microwire EEPROM.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @offset: offset within the EEPROM to be written to</span>
<span class="cm"> * @words: number of words to write</span>
<span class="cm"> * @data: pointer to array of 8 bit words to be written to the EEPROM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_write_eeprom_microwire</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">,</span>
					<span class="n">u16</span> <span class="n">words</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">e1000_eeprom_info</span> <span class="o">*</span><span class="n">eeprom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">eeprom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">eecd</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">words_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_write_eeprom_microwire&quot;</span><span class="p">);</span>

	<span class="cm">/* Send the write enable command to the EEPROM (3-bit opcode plus</span>
<span class="cm">	 * 6/8-bit dummy address beginning with 11).  It&#39;s less work to include</span>
<span class="cm">	 * the 11 of the dummy address as part of the opcode than it is to shift</span>
<span class="cm">	 * it over the correct number of bits for the address.  This puts the</span>
<span class="cm">	 * EEPROM into write/erase mode.</span>
<span class="cm">	 */</span>
	<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_EWEN_OPCODE_MICROWIRE</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>

	<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>

	<span class="cm">/* Prepare the EEPROM */</span>
	<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">words_written</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Send the Write command (3-bit opcode + addr) */</span>
		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_WRITE_OPCODE_MICROWIRE</span><span class="p">,</span>
					<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span><span class="p">);</span>

		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">words_written</span><span class="p">),</span>
					<span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span><span class="p">);</span>

		<span class="cm">/* Send the data */</span>
		<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">words_written</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>

		<span class="cm">/* Toggle the CS line.  This in effect tells the EEPROM to execute</span>
<span class="cm">		 * the previous command.</span>
<span class="cm">		 */</span>
		<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="cm">/* Read DO repeatedly until it is high (equal to &#39;1&#39;).  The EEPROM will</span>
<span class="cm">		 * signal that the command has been completed by raising the DO signal.</span>
<span class="cm">		 * If DO does not go high in 10 milliseconds, then error out.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eecd</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">EECD</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eecd</span> <span class="o">&amp;</span> <span class="n">E1000_EECD_DO</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Write did not complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Recover from write */</span>
		<span class="n">e1000_standby_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>

		<span class="n">words_written</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Send the write disable command to the EEPROM (3-bit opcode plus</span>
<span class="cm">	 * 6/8-bit dummy address beginning with 10).  It&#39;s less work to include</span>
<span class="cm">	 * the 10 of the dummy address as part of the opcode than it is to shift</span>
<span class="cm">	 * it over the correct number of bits for the address.  This takes the</span>
<span class="cm">	 * EEPROM out of write/erase mode.</span>
<span class="cm">	 */</span>
	<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_EWDS_OPCODE_MICROWIRE</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">opcode_bits</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>

	<span class="n">e1000_shift_out_ee_bits</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">eeprom</span><span class="o">-&gt;</span><span class="n">address_bits</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_read_mac_addr - read the adapters MAC from eeprom</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Reads the adapter&#39;s MAC address from the EEPROM and inverts the LSB for the</span>
<span class="cm"> * second function of dual function devices</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_read_mac_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_read_mac_addr&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NODE_ADDRESS_SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_mac_addr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82546</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_FUNC_1</span><span class="p">)</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_mac_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">^=</span> <span class="mh">0x01</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NODE_ADDRESS_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">perm_mac_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_init_rx_addrs - Initializes receive address filters.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Places the MAC address in receive address register 0 and clears the rest</span>
<span class="cm"> * of the receive address registers. Clears the multicast table. Assumes</span>
<span class="cm"> * the receiver is in reset when the routine is called.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_init_rx_addrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rar_num</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_init_rx_addrs&quot;</span><span class="p">);</span>

	<span class="cm">/* Setup the receive address. */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Programming MAC Address into RAR[0]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">e1000_rar_set</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rar_num</span> <span class="o">=</span> <span class="n">E1000_RAR_ENTRIES</span><span class="p">;</span>

	<span class="cm">/* Zero out the other 15 receive addresses. */</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Clearing RAR[1-15]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rar_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_hash_mc_addr - Hashes an address to determine its location in the multicast table</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @mc_addr: the multicast address to hash</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">e1000_hash_mc_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mc_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The portion of the address that is used for the hash table is</span>
<span class="cm">	 * determined by the mc_filter_type setting.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mc_filter_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* [0] [1] [2] [3] [4] [5]</span>
<span class="cm">		 * 01  AA  00  12  34  56</span>
<span class="cm">		 * LSB                 MSB</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* [47:36] i.e. 0x563 for above example address */</span>
		<span class="n">hash_value</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="cm">/* [46:35] i.e. 0xAC6 for above example address */</span>
		<span class="n">hash_value</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="cm">/* [45:34] i.e. 0x5D8 for above example address */</span>
		<span class="n">hash_value</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="cm">/* [43:32] i.e. 0x634 for above example address */</span>
		<span class="n">hash_value</span> <span class="o">=</span> <span class="p">((</span><span class="n">mc_addr</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u16</span><span class="p">)</span> <span class="n">mc_addr</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hash_value</span> <span class="o">&amp;=</span> <span class="mh">0xFFF</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hash_value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_rar_set - Puts an ethernet address into a receive address register.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @addr: Address to put into receive address register</span>
<span class="cm"> * @index: Receive address register to write</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000_rar_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rar_low</span><span class="p">,</span> <span class="n">rar_high</span><span class="p">;</span>

	<span class="cm">/* HW expects these in little endian so we reverse the byte order</span>
<span class="cm">	 * from network order (big endian) to little endian</span>
<span class="cm">	 */</span>
	<span class="n">rar_low</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		   <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>
	<span class="n">rar_high</span> <span class="o">=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span> <span class="n">addr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">));</span>

	<span class="cm">/* Disable Rx and flush all Rx frames before enabling RSS to avoid Rx</span>
<span class="cm">	 * unit hang.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Description:</span>
<span class="cm">	 * If there are any Rx frames queued up or otherwise present in the HW</span>
<span class="cm">	 * before RSS is enabled, and then we enable RSS, the HW Rx unit will</span>
<span class="cm">	 * hang.  To work around this issue, we have to disable receives and</span>
<span class="cm">	 * flush out all Rx frames before we enable RSS. To do so, we modify we</span>
<span class="cm">	 * redirect all Rx traffic to manageability and then reset the HW.</span>
<span class="cm">	 * This flushes away Rx frames, and (since the redirections to</span>
<span class="cm">	 * manageability persists across resets) keeps new ones from coming in</span>
<span class="cm">	 * while we work.  Then, we clear the Address Valid AV bit for all MAC</span>
<span class="cm">	 * addresses and undo the re-direction to manageability.</span>
<span class="cm">	 * Now, frames are coming in again, but the MAC won&#39;t accept them, so</span>
<span class="cm">	 * far so good.  We now proceed to initialize RSS (if necessary) and</span>
<span class="cm">	 * configure the Rx unit.  Last, we re-enable the AV bits and continue</span>
<span class="cm">	 * on our merry way.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="cm">/* Indicate to hardware the Address is Valid. */</span>
		<span class="n">rar_high</span> <span class="o">|=</span> <span class="n">E1000_RAH_AV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rar_low</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">RA</span><span class="p">,</span> <span class="p">((</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rar_high</span><span class="p">);</span>
	<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_write_vfta - Writes a value to the specified offset in the VLAN filter table.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @offset: Offset in VLAN filer table to write</span>
<span class="cm"> * @value: Value to write into VLAN filter table</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000_write_vfta</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82544</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">E1000_READ_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">temp</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clear_vfta - Clears the VLAN filer table</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clear_vfta</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">vfta_bit_in_reg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">E1000_VLAN_FILTER_TBL_SIZE</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the offset we want to clear is the same offset of the</span>
<span class="cm">		 * manageability VLAN ID, then clear all bits except that of the</span>
<span class="cm">		 * manageability unit */</span>
		<span class="n">vfta_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">vfta_offset</span><span class="p">)</span> <span class="o">?</span> <span class="n">vfta_bit_in_reg</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">E1000_WRITE_REG_ARRAY</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">VFTA</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vfta_value</span><span class="p">);</span>
		<span class="n">E1000_WRITE_FLUSH</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_id_led_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ledctl</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">ledctl_mask</span> <span class="o">=</span> <span class="mh">0x000000FF</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">ledctl_on</span> <span class="o">=</span> <span class="n">E1000_LEDCTL_MODE_LED_ON</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">ledctl_off</span> <span class="o">=</span> <span class="n">E1000_LEDCTL_MODE_LED_OFF</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="n">led_mask</span> <span class="o">=</span> <span class="mh">0x0F</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_id_led_init&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82540</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Nothing to do */</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ledctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">);</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_default</span> <span class="o">=</span> <span class="n">ledctl</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode1</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_default</span><span class="p">;</span>
	<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode2</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_default</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_ID_LED_SETTINGS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;EEPROM Read Error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_EEPROM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">eeprom_data</span> <span class="o">==</span> <span class="n">ID_LED_RESERVED_0000</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">==</span> <span class="n">ID_LED_RESERVED_FFFF</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">eeprom_data</span> <span class="o">=</span> <span class="n">ID_LED_DEFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">led_mask</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ID_LED_ON1_DEF2</span>:
		<span class="k">case</span> <span class="n">ID_LED_ON1_ON2</span>:
		<span class="k">case</span> <span class="n">ID_LED_ON1_OFF2</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ledctl_mask</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode1</span> <span class="o">|=</span> <span class="n">ledctl_on</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ID_LED_OFF1_DEF2</span>:
		<span class="k">case</span> <span class="n">ID_LED_OFF1_ON2</span>:
		<span class="k">case</span> <span class="n">ID_LED_OFF1_OFF2</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode1</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ledctl_mask</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode1</span> <span class="o">|=</span> <span class="n">ledctl_off</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* Do nothing */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ID_LED_DEF1_ON2</span>:
		<span class="k">case</span> <span class="n">ID_LED_ON1_ON2</span>:
		<span class="k">case</span> <span class="n">ID_LED_OFF1_ON2</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ledctl_mask</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode2</span> <span class="o">|=</span> <span class="n">ledctl_on</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ID_LED_DEF1_OFF2</span>:
		<span class="k">case</span> <span class="n">ID_LED_ON1_OFF2</span>:
		<span class="k">case</span> <span class="n">ID_LED_OFF1_OFF2</span>:
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode2</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ledctl_mask</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode2</span> <span class="o">|=</span> <span class="n">ledctl_off</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="cm">/* Do nothing */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_setup_led</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Prepares SW controlable LED for use and saves the current state of the LED.</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_setup_led</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ledctl</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_setup_led&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
	<span class="k">case</span> <span class="n">e1000_82543</span>:
	<span class="k">case</span> <span class="n">e1000_82544</span>:
		<span class="cm">/* No setup necessary */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82547</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
	<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
		<span class="cm">/* Turn off PHY Smart Power Down (if enabled) */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_GMII_FIFO</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_spd_default</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_GMII_FIFO</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_spd_default</span> <span class="o">&amp;</span>
						     <span class="o">~</span><span class="n">IGP01E1000_GMII_SPD</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="cm">/* Fall Through */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ledctl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">);</span>
			<span class="cm">/* Save current LEDCTL settings */</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_default</span> <span class="o">=</span> <span class="n">ledctl</span><span class="p">;</span>
			<span class="cm">/* Turn off LED0 */</span>
			<span class="n">ledctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">E1000_LEDCTL_LED0_IVRT</span> <span class="o">|</span>
				    <span class="n">E1000_LEDCTL_LED0_BLINK</span> <span class="o">|</span>
				    <span class="n">E1000_LEDCTL_LED0_MODE_MASK</span><span class="p">);</span>
			<span class="n">ledctl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">E1000_LEDCTL_MODE_LED_OFF</span> <span class="o">&lt;&lt;</span>
				   <span class="n">E1000_LEDCTL_LED0_MODE_SHIFT</span><span class="p">);</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">ledctl</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_cleanup_led - Restores the saved state of the SW controlable LED.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_cleanup_led</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_cleanup_led&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
	<span class="k">case</span> <span class="n">e1000_82543</span>:
	<span class="k">case</span> <span class="n">e1000_82544</span>:
		<span class="cm">/* No cleanup necessary */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82541</span>:
	<span class="k">case</span> <span class="n">e1000_82547</span>:
	<span class="k">case</span> <span class="n">e1000_82541_rev_2</span>:
	<span class="k">case</span> <span class="n">e1000_82547_rev_2</span>:
		<span class="cm">/* Turn on PHY Smart Power Down (if previously enabled) */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_GMII_FIFO</span><span class="p">,</span>
					      <span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_spd_default</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="cm">/* Fall Through */</span>
	<span class="nl">default:</span>
		<span class="cm">/* Restore LEDCTL settings */</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_default</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_led_on - Turns on the software controllable LED</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_led_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_led_on&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
	<span class="k">case</span> <span class="n">e1000_82543</span>:
		<span class="cm">/* Set SW Defineable Pin 0 to turn on the LED */</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIN0</span><span class="p">;</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIO0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82544</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Set SW Defineable Pin 0 to turn on the LED */</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIN0</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIO0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Clear SW Defineable Pin 0 to turn on the LED */</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_SWDPIN0</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIO0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Clear SW Defineable Pin 0 to turn on the LED */</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_SWDPIN0</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIO0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode2</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_led_off - Turns off the software controllable LED</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="n">s32</span> <span class="nf">e1000_led_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ctrl</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">);</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_led_off&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
	<span class="k">case</span> <span class="n">e1000_82543</span>:
		<span class="cm">/* Clear SW Defineable Pin 0 to turn off the LED */</span>
		<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_SWDPIN0</span><span class="p">;</span>
		<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIO0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e1000_82544</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Clear SW Defineable Pin 0 to turn off the LED */</span>
			<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">E1000_CTRL_SWDPIN0</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIO0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Set SW Defineable Pin 0 to turn off the LED */</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIN0</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIO0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_fiber</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Set SW Defineable Pin 0 to turn off the LED */</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIN0</span><span class="p">;</span>
			<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">E1000_CTRL_SWDPIO0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ew32</span><span class="p">(</span><span class="n">LEDCTL</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ledctl_mode1</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ew32</span><span class="p">(</span><span class="n">CTRL</span><span class="p">,</span> <span class="n">ctrl</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_clear_hw_cntrs - Clears all hardware statistics counters.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_clear_hw_cntrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CRCERRS</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SYMERRS</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SCC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ECOL</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MCC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">LATECOL</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">COLC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">DC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">SEC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RLEC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XONRXC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XONTXC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XOFFRXC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">XOFFTXC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">FCRUC</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC64</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC127</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC255</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC511</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC1023</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PRC1522</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GPRC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">BPRC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPRC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GPTC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GORCL</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GORCH</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GOTCL</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">GOTCH</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RNBC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RUC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RFC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ROC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RJC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TORL</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TORH</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TOTL</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TOTH</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TPR</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TPT</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC64</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC127</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC255</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC511</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC1023</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">PTC1522</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MPTC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">BPTC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;</span> <span class="n">e1000_82543</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">ALGNERRC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">RXERRC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TNCRS</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">CEXTERR</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TSCTC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">TSCTFC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">&lt;=</span> <span class="n">e1000_82544</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPRC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPDC</span><span class="p">);</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MGTPTC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_reset_adaptive - Resets Adaptive IFS to its default state.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Call this after e1000_init_hw. You may override the IFS defaults by setting</span>
<span class="cm"> * hw-&gt;ifs_params_forced to true. However, you must initialize hw-&gt;</span>
<span class="cm"> * current_ifs_val, ifs_min_val, ifs_max_val, ifs_step_size, and ifs_ratio</span>
<span class="cm"> * before calling this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000_reset_adaptive</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_reset_adaptive&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">adaptive_ifs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_params_forced</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">current_ifs_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_min_val</span> <span class="o">=</span> <span class="n">IFS_MIN</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_max_val</span> <span class="o">=</span> <span class="n">IFS_MAX</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_step_size</span> <span class="o">=</span> <span class="n">IFS_STEP</span><span class="p">;</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_ratio</span> <span class="o">=</span> <span class="n">IFS_RATIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">in_ifs_mode</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">ew32</span><span class="p">(</span><span class="n">AIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Not in Adaptive IFS mode!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_update_adaptive - update adaptive IFS</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @tx_packets: Number of transmits since last callback</span>
<span class="cm"> * @total_collisions: Number of collisions since last callback</span>
<span class="cm"> *</span>
<span class="cm"> * Called during the callback/watchdog routine to update IFS value based on</span>
<span class="cm"> * the ratio of transmits to collisions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000_update_adaptive</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_update_adaptive&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">adaptive_ifs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">collision_delta</span> <span class="o">*</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_ratio</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_packet_delta</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_packet_delta</span> <span class="o">&gt;</span> <span class="n">MIN_NUM_XMITS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">in_ifs_mode</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">current_ifs_val</span> <span class="o">&lt;</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_max_val</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">current_ifs_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">hw</span><span class="o">-&gt;</span><span class="n">current_ifs_val</span> <span class="o">=</span>
						    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_min_val</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="n">hw</span><span class="o">-&gt;</span><span class="n">current_ifs_val</span> <span class="o">+=</span>
						    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">ifs_step_size</span><span class="p">;</span>
					<span class="n">ew32</span><span class="p">(</span><span class="n">AIT</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">current_ifs_val</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">in_ifs_mode</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">tx_packet_delta</span> <span class="o">&lt;=</span> <span class="n">MIN_NUM_XMITS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">current_ifs_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">in_ifs_mode</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="n">ew32</span><span class="p">(</span><span class="n">AIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Not in Adaptive IFS mode!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_tbi_adjust_stats</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @frame_len: The length of the frame in question</span>
<span class="cm"> * @mac_addr: The Ethernet destination address of the frame in question</span>
<span class="cm"> *</span>
<span class="cm"> * Adjusts the statistic counters when a frame is accepted by TBI_ACCEPT</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000_tbi_adjust_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">e1000_hw_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">frame_len</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">mac_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">carry_bit</span><span class="p">;</span>

	<span class="cm">/* First adjust the frame length. */</span>
	<span class="n">frame_len</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/* We need to adjust the statistics counters, since the hardware</span>
<span class="cm">	 * counters overcount this packet as a CRC error and undercount</span>
<span class="cm">	 * the packet as a good packet</span>
<span class="cm">	 */</span>
	<span class="cm">/* This packet should not be counted as a CRC error.    */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">crcerrs</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/* This packet does count as a Good Packet Received.    */</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">gprc</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Adjust the Good Octets received counters             */</span>
	<span class="n">carry_bit</span> <span class="o">=</span> <span class="mh">0x80000000</span> <span class="o">&amp;</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">gorcl</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">gorcl</span> <span class="o">+=</span> <span class="n">frame_len</span><span class="p">;</span>
	<span class="cm">/* If the high bit of Gorcl (the low 32 bits of the Good Octets</span>
<span class="cm">	 * Received Count) was one before the addition,</span>
<span class="cm">	 * AND it is zero after, then we lost the carry out,</span>
<span class="cm">	 * need to add one to Gorch (Good Octets Received Count High).</span>
<span class="cm">	 * This could be simplified if all environments supported</span>
<span class="cm">	 * 64-bit integers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">carry_bit</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">gorcl</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">gorch</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Is this a broadcast or multicast?  Check broadcast first,</span>
<span class="cm">	 * since the test for a multicast frame will test positive on</span>
<span class="cm">	 * a broadcast frame.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mac_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="mh">0xff</span><span class="p">))</span>
		<span class="cm">/* Broadcast packet */</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">bprc</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">mac_addr</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
		<span class="cm">/* Multicast packet */</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">mprc</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">frame_len</span> <span class="o">==</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">max_frame_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* In this case, the hardware has overcounted the number of</span>
<span class="cm">		 * oversize frames.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">roc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">stats</span><span class="o">-&gt;</span><span class="n">roc</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Adjust the bin counters when the extra byte put the frame in the</span>
<span class="cm">	 * wrong bin. Remember that the frame_len was adjusted above.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frame_len</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc64</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc127</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame_len</span> <span class="o">==</span> <span class="mi">127</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc127</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc255</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame_len</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc255</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc511</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame_len</span> <span class="o">==</span> <span class="mi">511</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc511</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc1023</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame_len</span> <span class="o">==</span> <span class="mi">1023</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc1023</span><span class="o">++</span><span class="p">;</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc1522</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame_len</span> <span class="o">==</span> <span class="mi">1522</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stats</span><span class="o">-&gt;</span><span class="n">prc1522</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_get_bus_info</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Gets the current PCI bus type, speed, and width of the hardware</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">e1000_get_bus_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82542_rev2_0</span>:
	<span class="k">case</span> <span class="n">e1000_82542_rev2_1</span>:
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">=</span> <span class="n">e1000_bus_type_pci</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">=</span> <span class="n">e1000_bus_speed_unknown</span><span class="p">;</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_width</span> <span class="o">=</span> <span class="n">e1000_bus_width_unknown</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">STATUS</span><span class="p">);</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_PCIX_MODE</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">e1000_bus_type_pcix</span> <span class="o">:</span> <span class="n">e1000_bus_type_pci</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">device_id</span> <span class="o">==</span> <span class="n">E1000_DEV_ID_82546EB_QUAD_COPPER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">e1000_bus_type_pci</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">e1000_bus_speed_66</span> <span class="o">:</span> <span class="n">e1000_bus_speed_120</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_type</span> <span class="o">==</span> <span class="n">e1000_bus_type_pci</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_PCI66</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">e1000_bus_speed_66</span> <span class="o">:</span> <span class="n">e1000_bus_speed_33</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_PCIX_SPEED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">E1000_STATUS_PCIX_SPEED_66</span>:
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">=</span> <span class="n">e1000_bus_speed_66</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">E1000_STATUS_PCIX_SPEED_100</span>:
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">=</span> <span class="n">e1000_bus_speed_100</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">E1000_STATUS_PCIX_SPEED_133</span>:
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">=</span> <span class="n">e1000_bus_speed_133</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_speed</span> <span class="o">=</span> <span class="n">e1000_bus_speed_reserved</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">bus_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">E1000_STATUS_BUS64</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">e1000_bus_width_64</span> <span class="o">:</span> <span class="n">e1000_bus_width_32</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_write_reg_io</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @offset: offset to write to</span>
<span class="cm"> * @value: value to write</span>
<span class="cm"> *</span>
<span class="cm"> * Writes a value to one of the devices registers using port I/O (as opposed to</span>
<span class="cm"> * memory mapped I/O). Only 82544 and newer devices support port I/O.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">e1000_write_reg_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_addr</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_data</span> <span class="o">=</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">io_base</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">e1000_io_write</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">io_addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">e1000_io_write</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">io_data</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_get_cable_length - Estimates the cable length.</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @min_length: The estimated minimum length</span>
<span class="cm"> * @max_length: The estimated maximum length</span>
<span class="cm"> *</span>
<span class="cm"> * returns: - E1000_ERR_XXX</span>
<span class="cm"> *            E1000_SUCCESS</span>
<span class="cm"> *</span>
<span class="cm"> * This function always returns a ranged length (minimum &amp; maximum).</span>
<span class="cm"> * So for M88 phy&#39;s, this function interprets the one value returned from the</span>
<span class="cm"> * register to the minimum and maximum range.</span>
<span class="cm"> * For IGP phy&#39;s, the function calculates the range by the AGC registers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_cable_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">min_length</span><span class="p">,</span>
				  <span class="n">u16</span> <span class="o">*</span><span class="n">max_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">agc_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">cable_length</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_get_cable_length&quot;</span><span class="p">);</span>

	<span class="o">*</span><span class="n">min_length</span> <span class="o">=</span> <span class="o">*</span><span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Use old method for Phy older than IGP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="n">cable_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_CABLE_LENGTH</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		    <span class="n">M88E1000_PSSR_CABLE_LENGTH_SHIFT</span><span class="p">;</span>

		<span class="cm">/* Convert the enum value to ranged values */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cable_length</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">e1000_cable_length_50</span>:
			<span class="o">*</span><span class="n">min_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">*</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_50</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_cable_length_50_80</span>:
			<span class="o">*</span><span class="n">min_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_50</span><span class="p">;</span>
			<span class="o">*</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_80</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_cable_length_80_110</span>:
			<span class="o">*</span><span class="n">min_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_80</span><span class="p">;</span>
			<span class="o">*</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_110</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_cable_length_110_140</span>:
			<span class="o">*</span><span class="n">min_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_110</span><span class="p">;</span>
			<span class="o">*</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_140</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">e1000_cable_length_140</span>:
			<span class="o">*</span><span class="n">min_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_140</span><span class="p">;</span>
			<span class="o">*</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_170</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* For IGP PHY */</span>
		<span class="n">u16</span> <span class="n">cur_agc_value</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">min_agc_value</span> <span class="o">=</span> <span class="n">IGP01E1000_AGC_LENGTH_TABLE_SIZE</span><span class="p">;</span>
		<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">agc_reg_array</span><span class="p">[</span><span class="n">IGP01E1000_PHY_CHANNEL_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		       <span class="n">IGP01E1000_PHY_AGC_A</span><span class="p">,</span>
		       <span class="n">IGP01E1000_PHY_AGC_B</span><span class="p">,</span>
		       <span class="n">IGP01E1000_PHY_AGC_C</span><span class="p">,</span>
		       <span class="n">IGP01E1000_PHY_AGC_D</span>
		<span class="p">};</span>
		<span class="cm">/* Read the AGC registers for all channels */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IGP01E1000_PHY_CHANNEL_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">agc_reg_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">cur_agc_value</span> <span class="o">=</span> <span class="n">phy_data</span> <span class="o">&gt;&gt;</span> <span class="n">IGP01E1000_AGC_LENGTH_SHIFT</span><span class="p">;</span>

			<span class="cm">/* Value bound check. */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">cur_agc_value</span> <span class="o">&gt;=</span>
			     <span class="n">IGP01E1000_AGC_LENGTH_TABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			    <span class="o">||</span> <span class="p">(</span><span class="n">cur_agc_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">E1000_ERR_PHY</span><span class="p">;</span>

			<span class="n">agc_value</span> <span class="o">+=</span> <span class="n">cur_agc_value</span><span class="p">;</span>

			<span class="cm">/* Update minimal AGC value. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">min_agc_value</span> <span class="o">&gt;</span> <span class="n">cur_agc_value</span><span class="p">)</span>
				<span class="n">min_agc_value</span> <span class="o">=</span> <span class="n">cur_agc_value</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Remove the minimal AGC result for length &lt; 50m */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agc_value</span> <span class="o">&lt;</span>
		    <span class="n">IGP01E1000_PHY_CHANNEL_NUM</span> <span class="o">*</span> <span class="n">e1000_igp_cable_length_50</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">agc_value</span> <span class="o">-=</span> <span class="n">min_agc_value</span><span class="p">;</span>

			<span class="cm">/* Get the average length of the remaining 3 channels */</span>
			<span class="n">agc_value</span> <span class="o">/=</span> <span class="p">(</span><span class="n">IGP01E1000_PHY_CHANNEL_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Get the average length of all the 4 channels. */</span>
			<span class="n">agc_value</span> <span class="o">/=</span> <span class="n">IGP01E1000_PHY_CHANNEL_NUM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Set the range of the calculated length. */</span>
		<span class="o">*</span><span class="n">min_length</span> <span class="o">=</span> <span class="p">((</span><span class="n">e1000_igp_cable_length_table</span><span class="p">[</span><span class="n">agc_value</span><span class="p">]</span> <span class="o">-</span>
				<span class="n">IGP01E1000_AGC_RANGE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
		    <span class="p">(</span><span class="n">e1000_igp_cable_length_table</span><span class="p">[</span><span class="n">agc_value</span><span class="p">]</span> <span class="o">-</span>
		     <span class="n">IGP01E1000_AGC_RANGE</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">e1000_igp_cable_length_table</span><span class="p">[</span><span class="n">agc_value</span><span class="p">]</span> <span class="o">+</span>
		    <span class="n">IGP01E1000_AGC_RANGE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_check_polarity - Check the cable polarity</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @polarity: output parameter : 0 - Polarity is not reversed</span>
<span class="cm"> *                               1 - Polarity is reversed.</span>
<span class="cm"> *</span>
<span class="cm"> * returns: - E1000_ERR_XXX</span>
<span class="cm"> *            E1000_SUCCESS</span>
<span class="cm"> *</span>
<span class="cm"> * For phy&#39;s older than IGP, this function simply reads the polarity bit in the</span>
<span class="cm"> * Phy Status register.  For IGP phy&#39;s, this bit is valid only if link speed is</span>
<span class="cm"> * 10 Mbps.  If the link speed is 100 Mbps there is no polarity so this bit will</span>
<span class="cm"> * return 0.  If the link speed is 1000 Mbps the polarity status is in the</span>
<span class="cm"> * IGP01E1000_PHY_PCS_INIT_REG.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_check_polarity</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span>
				<span class="n">e1000_rev_polarity</span> <span class="o">*</span><span class="n">polarity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_check_polarity&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* return the Polarity bit in the Status register. */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="o">*</span><span class="n">polarity</span> <span class="o">=</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_REV_POLARITY</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			     <span class="n">M88E1000_PSSR_REV_POLARITY_SHIFT</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">e1000_rev_polarity_reversed</span> <span class="o">:</span> <span class="n">e1000_rev_polarity_normal</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the Status register to check the speed */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_STATUS</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="cm">/* If speed is 1000 Mbps, must read the IGP01E1000_PHY_PCS_INIT_REG to</span>
<span class="cm">		 * find the polarity status */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PSSR_SPEED_MASK</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">IGP01E1000_PSSR_SPEED_1000MBPS</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* Read the GIG initialization PCS register (0x00B4) */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PCS_INIT_REG</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="cm">/* Check the polarity bits */</span>
			<span class="o">*</span><span class="n">polarity</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PHY_POLARITY_MASK</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">e1000_rev_polarity_reversed</span> <span class="o">:</span>
			    <span class="n">e1000_rev_polarity_normal</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* For 10 Mbps, read the polarity bit in the status register. (for</span>
<span class="cm">			 * 100 Mbps this bit is always 0) */</span>
			<span class="o">*</span><span class="n">polarity</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PSSR_POLARITY_REVERSED</span><span class="p">)</span> <span class="o">?</span>
			    <span class="n">e1000_rev_polarity_reversed</span> <span class="o">:</span>
			    <span class="n">e1000_rev_polarity_normal</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_check_downshift - Check if Downshift occurred</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @downshift: output parameter : 0 - No Downshift occurred.</span>
<span class="cm"> *                                1 - Downshift occurred.</span>
<span class="cm"> *</span>
<span class="cm"> * returns: - E1000_ERR_XXX</span>
<span class="cm"> *            E1000_SUCCESS</span>
<span class="cm"> *</span>
<span class="cm"> * For phy&#39;s older than IGP, this function reads the Downshift bit in the Phy</span>
<span class="cm"> * Specific Status register.  For IGP phy&#39;s, it reads the Downgrade bit in the</span>
<span class="cm"> * Link Health register.  In IGP this bit is latched high, so the driver must</span>
<span class="cm"> * read it immediately after link is established.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_check_downshift</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_check_downshift&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_igp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_LINK_HEALTH</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">speed_downgraded</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">IGP01E1000_PLHR_SS_DOWNGRADE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">==</span> <span class="n">e1000_phy_m88</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_SPEC_STATUS</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">speed_downgraded</span> <span class="o">=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">M88E1000_PSSR_DOWNSHIFT</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		    <span class="n">M88E1000_PSSR_DOWNSHIFT_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u16</span> <span class="n">dsp_reg_array</span><span class="p">[</span><span class="n">IGP01E1000_PHY_CHANNEL_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">IGP01E1000_PHY_AGC_PARAM_A</span><span class="p">,</span>
	<span class="n">IGP01E1000_PHY_AGC_PARAM_B</span><span class="p">,</span>
	<span class="n">IGP01E1000_PHY_AGC_PARAM_C</span><span class="p">,</span>
	<span class="n">IGP01E1000_PHY_AGC_PARAM_D</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_1000Mb_check_cable_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">min_length</span><span class="p">,</span> <span class="n">max_length</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_cable_length</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_length</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dsp_config_state</span> <span class="o">!=</span> <span class="n">e1000_dsp_config_enabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">min_length</span> <span class="o">&gt;=</span> <span class="n">e1000_igp_cable_length_50</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IGP01E1000_PHY_CHANNEL_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">dsp_reg_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						     <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PHY_EDAC_MU_INDEX</span><span class="p">;</span>

			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">dsp_reg_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						      <span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dsp_config_state</span> <span class="o">=</span> <span class="n">e1000_dsp_config_activated</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">ffe_idle_err_timeout</span> <span class="o">=</span> <span class="n">FFE_IDLE_ERR_COUNT_TIMEOUT_20</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">idle_errs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* clear previous idle error counts */</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ffe_idle_err_timeout</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_1000T_STATUS</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">idle_errs</span> <span class="o">+=</span> <span class="p">(</span><span class="n">phy_data</span> <span class="o">&amp;</span> <span class="n">SR_1000T_IDLE_ERROR_CNT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idle_errs</span> <span class="o">&gt;</span> <span class="n">SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ffe_config_state</span> <span class="o">=</span> <span class="n">e1000_ffe_config_active</span><span class="p">;</span>

				<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span>
					      <span class="n">IGP01E1000_PHY_DSP_FFE</span><span class="p">,</span>
					      <span class="n">IGP01E1000_PHY_DSP_FFE_CM_CP</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">idle_errs</span><span class="p">)</span>
				<span class="n">ffe_idle_err_timeout</span> <span class="o">=</span>
					    <span class="n">FFE_IDLE_ERR_COUNT_TIMEOUT_100</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_config_dsp_after_link_change</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @link_up: was link up at the time this was called</span>
<span class="cm"> *</span>
<span class="cm"> * returns: - E1000_ERR_PHY if fail to read/write the PHY</span>
<span class="cm"> *            E1000_SUCCESS at any other case.</span>
<span class="cm"> *</span>
<span class="cm"> * 82541_rev_2 &amp; 82547_rev_2 have the capability to configure the DSP when a</span>
<span class="cm"> * gigabit link is achieved to improve link quality.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_config_dsp_after_link_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">link_up</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">,</span> <span class="n">phy_saved_data</span><span class="p">,</span> <span class="n">speed</span><span class="p">,</span> <span class="n">duplex</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_config_dsp_after_link_change&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">!=</span> <span class="n">e1000_phy_igp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">link_up</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_get_speed_and_duplex</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">duplex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;Error getting link speed and duplex</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">speed</span> <span class="o">==</span> <span class="n">SPEED_1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_1000Mb_check_cable_length</span><span class="p">(</span><span class="n">hw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">dsp_config_state</span> <span class="o">==</span> <span class="n">e1000_dsp_config_activated</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Save off the current value of register 0x2F5B to be restored at</span>
<span class="cm">			 * the end of the routines. */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_saved_data</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="cm">/* Disable the PHY transmitter */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span>
						      <span class="n">IGP01E1000_IEEE_FORCE_GIGA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IGP01E1000_PHY_CHANNEL_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret_val</span> <span class="o">=</span>
				    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">dsp_reg_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						       <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

				<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PHY_EDAC_MU_INDEX</span><span class="p">;</span>
				<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS</span><span class="p">;</span>

				<span class="n">ret_val</span> <span class="o">=</span>
				    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">dsp_reg_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
							<span class="n">phy_data</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span>
						      <span class="n">IGP01E1000_IEEE_RESTART_AUTONEG</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

			<span class="cm">/* Now enable the transmitter */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="n">phy_saved_data</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">dsp_config_state</span> <span class="o">=</span> <span class="n">e1000_dsp_config_enabled</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">ffe_config_state</span> <span class="o">==</span> <span class="n">e1000_ffe_config_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Save off the current value of register 0x2F5B to be restored at</span>
<span class="cm">			 * the end of the routines. */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_saved_data</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="cm">/* Disable the PHY transmitter */</span>
			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span>
						      <span class="n">IGP01E1000_IEEE_FORCE_GIGA</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_DSP_FFE</span><span class="p">,</span>
						<span class="n">IGP01E1000_PHY_DSP_FFE_DEFAULT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span>
						      <span class="n">IGP01E1000_IEEE_RESTART_AUTONEG</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">msleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

			<span class="cm">/* Now enable the transmitter */</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="mh">0x2F5B</span><span class="p">,</span> <span class="n">phy_saved_data</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">ffe_config_state</span> <span class="o">=</span> <span class="n">e1000_ffe_config_enabled</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_set_phy_mode - Set PHY to class A mode</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes the following operations will follow to enable the new class mode.</span>
<span class="cm"> *  1. Do a PHY soft reset</span>
<span class="cm"> *  2. Restart auto-negotiation or force link.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_phy_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">eeprom_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_set_phy_mode&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82545_rev_3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">media_type</span> <span class="o">==</span> <span class="n">e1000_media_type_copper</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_eeprom</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">EEPROM_PHY_CLASS_WORD</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">eeprom_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">eeprom_data</span> <span class="o">!=</span> <span class="n">EEPROM_RESERVED_WORD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">eeprom_data</span> <span class="o">&amp;</span> <span class="n">EEPROM_PHY_CLASS_A</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span>
						<span class="mh">0x000B</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span>
						<span class="mh">0x8104</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_reset_disable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_set_d3_lplu_state - set d3 link power state</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> * @active: true to enable lplu false to disable lplu.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets the lplu state according to the active flag.  When</span>
<span class="cm"> * activating lplu this function also disables smart speed and vise versa.</span>
<span class="cm"> * lplu will not be activated unless the device autonegotiation advertisement</span>
<span class="cm"> * meets standards of either 10 or 10/100 or 10/100/1000 at all duplexes.</span>
<span class="cm"> *</span>
<span class="cm"> * returns: - E1000_ERR_PHY if fail to read/write the PHY</span>
<span class="cm"> *            E1000_SUCCESS at any other case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_d3_lplu_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_set_d3_lplu_state&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">phy_type</span> <span class="o">!=</span> <span class="n">e1000_phy_igp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>

	<span class="cm">/* During driver activity LPLU should not be used or it will attain link</span>
<span class="cm">	 * from the lowest speeds starting from 10Mbps. The capability is used for</span>
<span class="cm">	 * Dx transitions and states */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541_rev_2</span>
	    <span class="o">||</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547_rev_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_GMII_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541_rev_2</span> <span class="o">||</span>
		    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547_rev_2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_GMII_FLEX_SPD</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_GMII_FIFO</span><span class="p">,</span>
						<span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used during</span>
<span class="cm">		 * Dx states where the power conservation is most important.  During</span>
<span class="cm">		 * driver activity we should enable SmartSpeed, so performance is</span>
<span class="cm">		 * maintained. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">smart_speed</span> <span class="o">==</span> <span class="n">e1000_smart_speed_on</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
						<span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">smart_speed</span> <span class="o">==</span> <span class="n">e1000_smart_speed_off</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

			<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
						<span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">AUTONEG_ADVERTISE_SPEED_DEFAULT</span><span class="p">)</span>
		   <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span> <span class="n">AUTONEG_ADVERTISE_10_ALL</span><span class="p">)</span>
		   <span class="o">||</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">autoneg_advertised</span> <span class="o">==</span>
		       <span class="n">AUTONEG_ADVERTISE_10_100_ALL</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82541_rev_2</span> <span class="o">||</span>
		    <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span> <span class="o">==</span> <span class="n">e1000_82547_rev_2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">IGP01E1000_GMII_FLEX_SPD</span><span class="p">;</span>
			<span class="n">ret_val</span> <span class="o">=</span>
			    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_GMII_FIFO</span><span class="p">,</span>
						<span class="n">phy_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* When LPLU is enabled we should disable SmartSpeed */</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IGP01E1000_PSCFR_SMART_SPEED</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span>
		    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">IGP01E1000_PHY_PORT_CONFIG</span><span class="p">,</span>
					<span class="n">phy_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_set_vco_speed</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Change VCO speed register to improve Bit Error Rate performance of SERDES.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_set_vco_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">default_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">phy_data</span><span class="p">;</span>

	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_set_vco_speed&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e1000_82545_rev_3</span>:
	<span class="k">case</span> <span class="n">e1000_82546_rev_3</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set PHY register 30, page 5, bit 8 to 0 */</span>

	<span class="n">ret_val</span> <span class="o">=</span>
	    <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">default_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="mh">0x0005</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">M88E1000_PHY_VCO_REG_BIT8</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* Set PHY register 30, page 4, bit 11 to 1 */</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">phy_data</span> <span class="o">|=</span> <span class="n">M88E1000_PHY_VCO_REG_BIT11</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="n">phy_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span>
	    <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="n">default_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * e1000_enable_mng_pass_thru - check for bmc pass through</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Verifies the hardware needs to allow ARPs to be processed by the host</span>
<span class="cm"> * returns: - true/false</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">e1000_enable_mng_pass_thru</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">manc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">asf_firmware_present</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">manc</span> <span class="o">=</span> <span class="n">er32</span><span class="p">(</span><span class="n">MANC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">manc</span> <span class="o">&amp;</span> <span class="n">E1000_MANC_RCV_TCO_EN</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">manc</span> <span class="o">&amp;</span> <span class="n">E1000_MANC_EN_MAC_ADDR_FILTER</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">manc</span> <span class="o">&amp;</span> <span class="n">E1000_MANC_SMBUS_EN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">manc</span> <span class="o">&amp;</span> <span class="n">E1000_MANC_ASF_EN</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_polarity_reversal_workaround</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s32</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">mii_status_reg</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Polarity reversal workaround for forced 10F/10H links. */</span>

	<span class="cm">/* Disable the transmitter on the PHY */</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="mh">0x0019</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="mh">0xFFFF</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* This loop will early-out if the NO link condition has been met. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PHY_FORCE_TIME</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the MII Status Register and wait for Link Status bit</span>
<span class="cm">		 * to be clear.</span>
<span class="cm">		 */</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mii_status_reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Recommended delay time after link has been lost */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

	<span class="cm">/* Now we will re-enable th transmitter on the PHY */</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="mh">0x0019</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="mh">0xFFF0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="mh">0xFF00</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_GEN_CONTROL</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_write_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">M88E1000_PHY_PAGE_SELECT</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

	<span class="cm">/* This loop will early-out if the link condition has been met. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PHY_FORCE_TIME</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read the MII Status Register and wait for Link Status bit</span>
<span class="cm">		 * to be set.</span>
<span class="cm">		 */</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">e1000_read_phy_reg</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">PHY_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mii_status_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret_val</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mii_status_reg</span> <span class="o">&amp;</span> <span class="n">MII_SR_LINK_STATUS</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_get_auto_rd_done</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Check for EEPROM Auto Read bit done.</span>
<span class="cm"> * returns: - E1000_ERR_RESET if fail to reset MAC</span>
<span class="cm"> *            E1000_SUCCESS at any other case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_auto_rd_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_get_auto_rd_done&quot;</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * e1000_get_phy_cfg_done</span>
<span class="cm"> * @hw: Struct containing variables accessed by shared code</span>
<span class="cm"> *</span>
<span class="cm"> * Checks if the PHY configuration is done</span>
<span class="cm"> * returns: - E1000_ERR_RESET if fail to reset MAC</span>
<span class="cm"> *            E1000_SUCCESS at any other case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s32</span> <span class="nf">e1000_get_phy_cfg_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">e1000_hw</span> <span class="o">*</span><span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">e_dbg</span><span class="p">(</span><span class="s">&quot;e1000_get_phy_cfg_done&quot;</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">E1000_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
