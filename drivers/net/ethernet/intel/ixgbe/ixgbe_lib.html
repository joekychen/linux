<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › net › ethernet › intel › ixgbe › ixgbe_lib.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../../index.html"></a><h1>ixgbe_lib.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************************</span>

<span class="cm">  Intel 10 Gigabit PCI Express Linux driver</span>
<span class="cm">  Copyright(c) 1999 - 2012 Intel Corporation.</span>

<span class="cm">  This program is free software; you can redistribute it and/or modify it</span>
<span class="cm">  under the terms and conditions of the GNU General Public License,</span>
<span class="cm">  version 2, as published by the Free Software Foundation.</span>

<span class="cm">  This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="cm">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm">  more details.</span>

<span class="cm">  You should have received a copy of the GNU General Public License along with</span>
<span class="cm">  this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm">  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.</span>

<span class="cm">  The full GNU General Public License is included in this distribution in</span>
<span class="cm">  the file called &quot;COPYING&quot;.</span>

<span class="cm">  Contact Information:</span>
<span class="cm">  e1000-devel Mailing List &lt;e1000-devel@lists.sourceforge.net&gt;</span>
<span class="cm">  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</span>

<span class="cm">*******************************************************************************/</span>

<span class="cp">#include &quot;ixgbe.h&quot;</span>
<span class="cp">#include &quot;ixgbe_sriov.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_cache_ring_rss - Descriptor ring to register mapping for RSS</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Cache the descriptor ring offsets for RSS to the assigned rings.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_cache_ring_rss</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_RSS_ENABLED</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_IXGBE_DCB</span>

<span class="cm">/* ixgbe_get_first_reg_idx - Return first register index associated with ring */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_get_first_reg_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tc</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">tx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_tcs</span> <span class="o">=</span> <span class="n">netdev_get_num_tc</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_82598EB</span>:
		<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ixgbe_mac_82599EB</span>:
	<span class="k">case</span> <span class="n">ixgbe_mac_X540</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">num_tcs</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
				<span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&lt;</span>  <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">tc</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
				<span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tc</span> <span class="o">&lt;</span> <span class="n">num_tcs</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="p">((</span><span class="n">tc</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
				<span class="o">*</span><span class="n">rx</span> <span class="o">=</span> <span class="n">tc</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">rx</span> <span class="o">=</span>  <span class="n">tc</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="o">*</span><span class="n">tx</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="mi">96</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="o">*</span><span class="n">tx</span> <span class="o">=</span> <span class="mi">112</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_cache_ring_dcb - Descriptor ring to register mapping for DCB</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Cache the descriptor ring offsets for DCB to the assigned rings.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_cache_ring_dcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">num_tcs</span> <span class="o">=</span> <span class="n">netdev_get_num_tc</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_tcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_tcs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tx_s</span><span class="p">,</span> <span class="n">rx_s</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>

		<span class="n">ixgbe_get_first_reg_idx</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rx_s</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">tx_s</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">rx_s</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dcb_tc</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">dcb_tc</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_cache_ring_fdir - Descriptor ring to register mapping for Flow Director</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Cache the descriptor ring offsets for Flow Director to the assigned rings.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_cache_ring_fdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_RSS_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FDIR_HASH_CAPABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef IXGBE_FCOE</span>
<span class="cm">/**</span>
<span class="cm"> * ixgbe_cache_ring_fcoe - Descriptor ring to register mapping for the FCoE</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Cache the descriptor ring offsets for FCoE mode to the assigned rings.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_cache_ring_fcoe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_ring_feature</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ring_feature</span><span class="p">[</span><span class="n">RING_F_FCOE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">fcoe_rx_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fcoe_tx_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FCOE_ENABLED</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_RSS_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FDIR_HASH_CAPABLE</span><span class="p">)</span>
			<span class="n">ixgbe_cache_ring_fdir</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ixgbe_cache_ring_rss</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="n">fcoe_rx_i</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">fcoe_tx_i</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">fcoe_rx_i</span><span class="o">++</span><span class="p">,</span> <span class="n">fcoe_tx_i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">fcoe_rx_i</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">fcoe_tx_i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* IXGBE_FCOE */</span><span class="cp"></span>
<span class="cm">/**</span>
<span class="cm"> * ixgbe_cache_ring_sriov - Descriptor ring to register mapping for sriov</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * SR-IOV doesn&#39;t use any descriptor rings but changes the default if</span>
<span class="cm"> * no other mapping is used.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_cache_ring_sriov</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vfs</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vfs</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_vfs</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_cache_ring_register - Descriptor ring to register mapping</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Once we know the feature-set enabled for the device, we&#39;ll cache</span>
<span class="cm"> * the register offset the descriptor ring is assigned to.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the order the various feature calls is important.  It must start with</span>
<span class="cm"> * the &quot;most&quot; features enabled at the same time, then trickle down to the</span>
<span class="cm"> * least amount of features turned on at once.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_cache_ring_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* start with default case */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reg_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_cache_ring_sriov</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IXGBE_DCB</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_cache_ring_dcb</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef IXGBE_FCOE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_cache_ring_fcoe</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IXGBE_FCOE */</span><span class="cp"></span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_cache_ring_fdir</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_cache_ring_rss</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_set_sriov_queues: Allocate queues for IOV use</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * IOV doesn&#39;t actually use anything, so just NAK the</span>
<span class="cm"> * request for now and let the other queue routines</span>
<span class="cm"> * figure out what to do.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_set_sriov_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_set_rss_queues: Allocate queues for RSS</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * This is our &quot;base&quot; multiqueue mode.  RSS (Receive Side Scaling) will try</span>
<span class="cm"> * to allocate one Rx queue per CPU, and if available, one Tx queue per CPU.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_set_rss_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_ring_feature</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ring_feature</span><span class="p">[</span><span class="n">RING_F_RSS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_RSS_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="mh">0xF</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_set_fdir_queues: Allocate queues for Flow Director</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Flow Director is an advanced Rx filter, attempting to get Rx flows back</span>
<span class="cm"> * to the original CPU that initiated the Tx session.  This runs in addition</span>
<span class="cm"> * to RSS, so if a packet doesn&#39;t match an FDIR filter, we can still spread the</span>
<span class="cm"> * Rx load across CPUs using RSS.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_set_fdir_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_ring_feature</span> <span class="o">*</span><span class="n">f_fdir</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ring_feature</span><span class="p">[</span><span class="n">RING_F_FDIR</span><span class="p">];</span>

	<span class="n">f_fdir</span><span class="o">-&gt;</span><span class="n">indices</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">(),</span> <span class="n">f_fdir</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">);</span>
	<span class="n">f_fdir</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use RSS in addition to Flow Director to ensure the best</span>
<span class="cm">	 * distribution of flows across cores, even when an FDIR flow</span>
<span class="cm">	 * isn&#39;t matched.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_RSS_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FDIR_HASH_CAPABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">f_fdir</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">f_fdir</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAG_FDIR_HASH_CAPABLE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef IXGBE_FCOE</span>
<span class="cm">/**</span>
<span class="cm"> * ixgbe_set_fcoe_queues: Allocate queues for Fiber Channel over Ethernet (FCoE)</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * FCoE RX FCRETA can use up to 8 rx queues for up to 8 different exchanges.</span>
<span class="cm"> * The ring feature mask is not used as a mask for FCoE, as it can take any 8</span>
<span class="cm"> * rx queues out of the max number of rx queues, instead, it is used as the</span>
<span class="cm"> * index of the first rx queue used by FCoE.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_set_fcoe_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_ring_feature</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ring_feature</span><span class="p">[</span><span class="n">RING_F_FCOE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FCOE_ENABLED</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">(),</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_RSS_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_info</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s">&quot;FCoE enabled with RSS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FDIR_HASH_CAPABLE</span><span class="p">)</span>
			<span class="n">ixgbe_set_fdir_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ixgbe_set_rss_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* adding FCoE rx rings to the end */</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">+=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">+=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IXGBE_FCOE */</span><span class="cp"></span>

<span class="cm">/* Artificial max queue cap per traffic class in DCB mode */</span>
<span class="cp">#define DCB_QUEUE_CAP 8</span>

<span class="cp">#ifdef CONFIG_IXGBE_DCB</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ixgbe_set_dcb_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">per_tc_q</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tcs</span> <span class="o">=</span> <span class="n">netdev_get_num_tc</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcs</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Map queue offset and counts onto allocated tx queues */</span>
	<span class="n">per_tc_q</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">/</span> <span class="n">tcs</span><span class="p">,</span> <span class="n">DCB_QUEUE_CAP</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">(),</span> <span class="n">per_tc_q</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tcs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_set_tc_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">q</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">tcs</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">tcs</span><span class="p">;</span>

<span class="cp">#ifdef IXGBE_FCOE</span>
	<span class="cm">/* FCoE enabled queues require special configuration indexed</span>
<span class="cm">	 * by feature specific indices and mask. Here we map FCoE</span>
<span class="cm">	 * indices onto the DCB queue pairs allowing FCoE to own</span>
<span class="cm">	 * configuration later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FCOE_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">prio_tc</span><span class="p">[</span><span class="n">MAX_USER_PRIORITY</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
		<span class="kt">int</span> <span class="n">tc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">ixgbe_ring_feature</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span>
					<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ring_feature</span><span class="p">[</span><span class="n">RING_F_FCOE</span><span class="p">];</span>

		<span class="n">ixgbe_dcb_unpack_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dcb_cfg</span><span class="p">,</span> <span class="n">DCB_TX_CONFIG</span><span class="p">,</span> <span class="n">prio_tc</span><span class="p">);</span>
		<span class="n">tc</span> <span class="o">=</span> <span class="n">prio_tc</span><span class="p">[</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fcoe</span><span class="p">.</span><span class="n">up</span><span class="p">];</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_set_num_queues: Allocate queues for device, feature dependent</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * This is the top level queue allocation routine.  The order here is very</span>
<span class="cm"> * important, starting with the &quot;most&quot; number of features turned on at once,</span>
<span class="cm"> * and ending with the smallest set of features.  This way large combinations</span>
<span class="cm"> * can be allocated if they&#39;re turned on, and smaller combinations are the</span>
<span class="cm"> * fallthrough conditions.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_set_num_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Start with base case */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_pools</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues_per_pool</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_set_sriov_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IXGBE_DCB</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_set_dcb_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="cp">#endif</span>
<span class="cp">#ifdef IXGBE_FCOE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_set_fcoe_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* IXGBE_FCOE */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_set_fdir_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ixgbe_set_rss_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* fallback to base case */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_UNREGISTERED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_UNREGISTERING</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Notify the stack of the (possibly) reduced queue counts. */</span>
	<span class="n">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
					    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_acquire_msix_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">vectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">vector_threshold</span><span class="p">;</span>

	<span class="cm">/* We&#39;ll want at least 2 (vector_threshold):</span>
<span class="cm">	 * 1) TxQ[0] + RxQ[0] handler</span>
<span class="cm">	 * 2) Other (Link Status Change, etc.)</span>
<span class="cm">	 */</span>
	<span class="n">vector_threshold</span> <span class="o">=</span> <span class="n">MIN_MSIX_COUNT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The more we get, the more we will assign to Tx/Rx Cleanup</span>
<span class="cm">	 * for the separate queues...where Rx Cleanup &gt;= Tx Cleanup.</span>
<span class="cm">	 * Right now, we simply care about how many we&#39;ll get; we&#39;ll</span>
<span class="cm">	 * set them up later while requesting irq&#39;s.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">vectors</span> <span class="o">&gt;=</span> <span class="n">vector_threshold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">,</span>
				      <span class="n">vectors</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="cm">/* Success in acquiring all requested vectors. */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">vectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Nasty failure, quit now */</span>
		<span class="k">else</span> <span class="cm">/* err == number of vectors we should try again with */</span>
			<span class="n">vectors</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vectors</span> <span class="o">&lt;</span> <span class="n">vector_threshold</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Can&#39;t allocate enough MSI-X interrupts?  Oh well.</span>
<span class="cm">		 * This just means we&#39;ll go with either a single MSI</span>
<span class="cm">		 * vector or fall back to legacy interrupts.</span>
<span class="cm">		 */</span>
		<span class="n">netif_printk</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
			     <span class="s">&quot;Unable to allocate MSI-X interrupts</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAG_MSIX_ENABLED</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IXGBE_FLAG_MSIX_ENABLED</span><span class="p">;</span> <span class="cm">/* Woot! */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Adjust for only the vectors we&#39;ll use, which is minimum</span>
<span class="cm">		 * of max_msix_q_vectors + NON_Q_VECTORS, or the number of</span>
<span class="cm">		 * vectors we were allocated.</span>
<span class="cm">		 */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_msix_vectors</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span>
				   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_msix_q_vectors</span> <span class="o">+</span> <span class="n">NON_Q_VECTORS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_add_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ixgbe_ring_container</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ring</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">ring</span> <span class="o">=</span> <span class="n">ring</span><span class="p">;</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_alloc_q_vector - Allocate memory for a single interrupt vector</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> * @v_count: q_vectors allocated on adapter, used for ring interleaving</span>
<span class="cm"> * @v_idx: index of vector in adapter struct</span>
<span class="cm"> * @txr_count: total number of Tx rings to allocate</span>
<span class="cm"> * @txr_idx: index of first Tx ring to allocate</span>
<span class="cm"> * @rxr_count: total number of Rx rings to allocate</span>
<span class="cm"> * @rxr_idx: index of first Rx ring to allocate</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate one q_vector.  If allocation fails we return -ENOMEM.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_alloc_q_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">v_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_idx</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">txr_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">txr_idx</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">rxr_count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rxr_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_q_vector</span> <span class="o">*</span><span class="n">q_vector</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ixgbe_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ring_count</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">ring_count</span> <span class="o">=</span> <span class="n">txr_count</span> <span class="o">+</span> <span class="n">rxr_count</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_q_vector</span><span class="p">)</span> <span class="o">+</span>
	       <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_ring</span><span class="p">)</span> <span class="o">*</span> <span class="n">ring_count</span><span class="p">);</span>

	<span class="cm">/* customize cpu for Flow Director mapping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FDIR_HASH_CAPABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">v_idx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">v_idx</span><span class="p">;</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* allocate q_vector and rings */</span>
	<span class="n">q_vector</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="p">)</span>
		<span class="n">q_vector</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_vector</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* setup affinity mask and node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">affinity_mask</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">affinity_mask</span><span class="p">,</span> <span class="n">cpu_online_mask</span><span class="p">);</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">numa_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

	<span class="cm">/* initialize NAPI */</span>
	<span class="n">netif_napi_add</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">,</span>
		       <span class="n">ixgbe_poll</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>

	<span class="cm">/* tie q_vector and adapter together */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">v_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_vector</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">v_idx</span> <span class="o">=</span> <span class="n">v_idx</span><span class="p">;</span>

	<span class="cm">/* initialize work limits */</span>
	<span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">.</span><span class="n">work_limit</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_work_limit</span><span class="p">;</span>

	<span class="cm">/* initialize pointer to rings */</span>
	<span class="n">ring</span> <span class="o">=</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">txr_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* assign generic ring traits */</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

		<span class="cm">/* configure backlink on ring */</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">q_vector</span><span class="p">;</span>

		<span class="cm">/* update q_vector Tx values */</span>
		<span class="n">ixgbe_add_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">);</span>

		<span class="cm">/* apply Tx specific ring traits */</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring_count</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span> <span class="o">=</span> <span class="n">txr_idx</span><span class="p">;</span>

		<span class="cm">/* assign ring to adapter */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">txr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring</span><span class="p">;</span>

		<span class="cm">/* update count and index */</span>
		<span class="n">txr_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">txr_idx</span> <span class="o">+=</span> <span class="n">v_count</span><span class="p">;</span>

		<span class="cm">/* push pointer to next ring */</span>
		<span class="n">ring</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">rxr_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* assign generic ring traits */</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">netdev</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">;</span>

		<span class="cm">/* configure backlink on ring */</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">q_vector</span><span class="p">;</span>

		<span class="cm">/* update q_vector Rx values */</span>
		<span class="n">ixgbe_add_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * 82599 errata, UDP frames with a 0 checksum</span>
<span class="cm">		 * can be marked as checksum errors.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">.</span><span class="n">mac</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ixgbe_mac_82599EB</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">__IXGBE_RX_CSUM_UDP_ZERO_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

<span class="cp">#ifdef IXGBE_FCOE</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_FCOE_MTU</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ixgbe_ring_feature</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
			<span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ring_feature</span><span class="p">[</span><span class="n">RING_F_FCOE</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rxr_idx</span> <span class="o">&gt;=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">rxr_idx</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">indices</span><span class="p">))</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">__IXGBE_RX_FCOE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* IXGBE_FCOE */</span><span class="cp"></span>
		<span class="cm">/* apply Rx specific ring traits */</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring_count</span><span class="p">;</span>
		<span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span> <span class="o">=</span> <span class="n">rxr_idx</span><span class="p">;</span>

		<span class="cm">/* assign ring to adapter */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">rxr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring</span><span class="p">;</span>

		<span class="cm">/* update count and index */</span>
		<span class="n">rxr_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">rxr_idx</span> <span class="o">+=</span> <span class="n">v_count</span><span class="p">;</span>

		<span class="cm">/* push pointer to next ring */</span>
		<span class="n">ring</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_free_q_vector - Free memory allocated for specific interrupt vector</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> * @v_idx: Index of vector to be freed</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees the memory allocated to the q_vector.  In addition if</span>
<span class="cm"> * NAPI is enabled it will delete any references to the NAPI struct prior</span>
<span class="cm"> * to freeing the q_vector.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_free_q_vector</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_q_vector</span> <span class="o">*</span><span class="n">q_vector</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">v_idx</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ixgbe_ring</span> <span class="o">*</span><span class="n">ring</span><span class="p">;</span>

	<span class="n">ixgbe_for_each_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">tx</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">tx_ring</span><span class="p">[</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ixgbe_for_each_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">rx</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rx_ring</span><span class="p">[</span><span class="n">ring</span><span class="o">-&gt;</span><span class="n">queue_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">q_vector</span><span class="p">[</span><span class="n">v_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">netif_napi_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q_vector</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ixgbe_get_stats64() might access the rings on this vector,</span>
<span class="cm">	 * we must wait a grace period before freeing it.</span>
<span class="cm">	 */</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">q_vector</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_alloc_q_vectors - Allocate memory for interrupt vectors</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * We allocate one q_vector per queue interrupt.  If allocation fails we</span>
<span class="cm"> * return -ENOMEM.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_alloc_q_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">q_vectors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_msix_vectors</span> <span class="o">-</span> <span class="n">NON_Q_VECTORS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rxr_remaining</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">txr_remaining</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rxr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">txr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* only one q_vector if MSI-X is disabled. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_MSIX_ENABLED</span><span class="p">))</span>
		<span class="n">q_vectors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q_vectors</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">rxr_remaining</span> <span class="o">+</span> <span class="n">txr_remaining</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">rxr_remaining</span><span class="p">;</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ixgbe_alloc_q_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q_vectors</span><span class="p">,</span> <span class="n">v_idx</span><span class="p">,</span>
						   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rxr_idx</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

			<span class="cm">/* update counts and index */</span>
			<span class="n">rxr_remaining</span><span class="o">--</span><span class="p">;</span>
			<span class="n">rxr_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">v_idx</span> <span class="o">&lt;</span> <span class="n">q_vectors</span><span class="p">;</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rqpv</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">rxr_remaining</span><span class="p">,</span> <span class="n">q_vectors</span> <span class="o">-</span> <span class="n">v_idx</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">tqpv</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">txr_remaining</span><span class="p">,</span> <span class="n">q_vectors</span> <span class="o">-</span> <span class="n">v_idx</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ixgbe_alloc_q_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">q_vectors</span><span class="p">,</span> <span class="n">v_idx</span><span class="p">,</span>
					   <span class="n">tqpv</span><span class="p">,</span> <span class="n">txr_idx</span><span class="p">,</span>
					   <span class="n">rqpv</span><span class="p">,</span> <span class="n">rxr_idx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

		<span class="cm">/* update counts and index */</span>
		<span class="n">rxr_remaining</span> <span class="o">-=</span> <span class="n">rqpv</span><span class="p">;</span>
		<span class="n">txr_remaining</span> <span class="o">-=</span> <span class="n">tqpv</span><span class="p">;</span>
		<span class="n">rxr_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">txr_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">v_idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">v_idx</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ixgbe_free_q_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">v_idx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_free_q_vectors - Free memory allocated for interrupt vectors</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees the memory allocated to the q_vectors.  In addition if</span>
<span class="cm"> * NAPI is enabled it will delete any references to the NAPI struct prior</span>
<span class="cm"> * to freeing the q_vector.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_free_q_vectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">v_idx</span><span class="p">,</span> <span class="n">q_vectors</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_MSIX_ENABLED</span><span class="p">)</span>
		<span class="n">q_vectors</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_msix_vectors</span> <span class="o">-</span> <span class="n">NON_Q_VECTORS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">q_vectors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">v_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v_idx</span> <span class="o">&lt;</span> <span class="n">q_vectors</span><span class="p">;</span> <span class="n">v_idx</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ixgbe_free_q_vector</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">v_idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ixgbe_reset_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_MSIX_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAG_MSIX_ENABLED</span><span class="p">;</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_MSI_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAG_MSI_ENABLED</span><span class="p">;</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_set_interrupt_capability - set MSI-X or MSI if supported</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * Attempt to configure the interrupts using the best available</span>
<span class="cm"> * capabilities of the hardware and the kernel.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ixgbe_set_interrupt_capability</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_hw</span> <span class="o">*</span><span class="n">hw</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vector</span><span class="p">,</span> <span class="n">v_budget</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s easy to be greedy for MSI-X vectors, but it really</span>
<span class="cm">	 * doesn&#39;t do us much good if we have a lot more vectors</span>
<span class="cm">	 * than CPU&#39;s.  So let&#39;s be conservative and only ask for</span>
<span class="cm">	 * (roughly) the same number of vectors as there are CPU&#39;s.</span>
<span class="cm">	 * The default is to use pairs of vectors.</span>
<span class="cm">	 */</span>
	<span class="n">v_budget</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">);</span>
	<span class="n">v_budget</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">v_budget</span><span class="p">,</span> <span class="n">num_online_cpus</span><span class="p">());</span>
	<span class="n">v_budget</span> <span class="o">+=</span> <span class="n">NON_Q_VECTORS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At the same time, hardware can only support a maximum of</span>
<span class="cm">	 * hw.mac-&gt;max_msix_vectors vectors.  With features</span>
<span class="cm">	 * such as RSS and VMDq, we can easily surpass the number of Rx and Tx</span>
<span class="cm">	 * descriptor queues supported by our device.  Thus, we cap it off in</span>
<span class="cm">	 * those rare cases where the cpu count also exceeds our vector limit.</span>
<span class="cm">	 */</span>
	<span class="n">v_budget</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">v_budget</span><span class="p">,</span> <span class="n">hw</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">.</span><span class="n">max_msix_vectors</span><span class="p">);</span>

	<span class="cm">/* A failure in MSI-X entry allocation isn&#39;t fatal, but it does</span>
<span class="cm">	 * mean we disable MSI-X capabilities of the adapter. */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">v_budget</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msix_entry</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vector</span> <span class="o">&lt;</span> <span class="n">v_budget</span><span class="p">;</span> <span class="n">vector</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msix_entries</span><span class="p">[</span><span class="n">vector</span><span class="p">].</span><span class="n">entry</span> <span class="o">=</span> <span class="n">vector</span><span class="p">;</span>

		<span class="n">ixgbe_acquire_msix_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">v_budget</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_MSIX_ENABLED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAG_DCB_ENABLED</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAG_RSS_ENABLED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_FDIR_HASH_CAPABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_err</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span>
		      <span class="s">&quot;ATR is not supported while multiple &quot;</span>
		      <span class="s">&quot;queues are disabled.  Disabling Flow Director</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IXGBE_FLAG_FDIR_HASH_CAPABLE</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">atr_sample_rate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IXGBE_FLAG_SRIOV_ENABLED</span><span class="p">)</span>
		<span class="n">ixgbe_disable_sriov</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ixgbe_set_num_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IXGBE_FLAG_MSI_ENABLED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netif_printk</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">hw</span><span class="p">,</span> <span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">netdev</span><span class="p">,</span>
			     <span class="s">&quot;Unable to allocate MSI interrupt, &quot;</span>
			     <span class="s">&quot;falling back to legacy.  Error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="cm">/* reset err */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_init_interrupt_scheme - Determine proper interrupt scheme</span>
<span class="cm"> * @adapter: board private structure to initialize</span>
<span class="cm"> *</span>
<span class="cm"> * We determine which interrupt scheme to use based on...</span>
<span class="cm"> * - Kernel support (MSI, MSI-X)</span>
<span class="cm"> *   - which can be user-defined (via MODULE_PARAM)</span>
<span class="cm"> * - Hardware queue count (num_*_queues)</span>
<span class="cm"> *   - defined by miscellaneous hardware support/features (RSS, etc.)</span>
<span class="cm"> **/</span>
<span class="kt">int</span> <span class="nf">ixgbe_init_interrupt_scheme</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Number of supported queues */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ixgbe_set_num_queues</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ixgbe_set_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dev_err</span><span class="p">(</span><span class="s">&quot;Unable to setup interrupt capabilities</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_set_interrupt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ixgbe_alloc_q_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e_dev_err</span><span class="p">(</span><span class="s">&quot;Unable to allocate memory for queue vectors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_alloc_q_vectors</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ixgbe_cache_ring_register</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">e_dev_info</span><span class="p">(</span><span class="s">&quot;Multiqueue %s: Rx Queue count = %u, Tx Queue count = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;Disabled&quot;</span><span class="p">,</span>
		   <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">__IXGBE_DOWN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_alloc_q_vectors:</span>
	<span class="n">ixgbe_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">err_set_interrupt:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ixgbe_clear_interrupt_scheme - Clear the current interrupt scheme settings</span>
<span class="cm"> * @adapter: board private structure to clear interrupt scheme on</span>
<span class="cm"> *</span>
<span class="cm"> * We go through and clear interrupt specific resources and reset the structure</span>
<span class="cm"> * to pre-load conditions</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">ixgbe_clear_interrupt_scheme</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ixgbe_free_q_vectors</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">ixgbe_reset_interrupt_capability</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ixgbe_tx_ctxtdesc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ixgbe_ring</span> <span class="o">*</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">u32</span> <span class="n">vlan_macip_lens</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">fcoe_sof_eof</span><span class="p">,</span> <span class="n">u32</span> <span class="n">type_tucmd</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mss_l4len_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ixgbe_adv_tx_context_desc</span> <span class="o">*</span><span class="n">context_desc</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span><span class="p">;</span>

	<span class="n">context_desc</span> <span class="o">=</span> <span class="n">IXGBE_TX_CTXTDESC</span><span class="p">(</span><span class="n">tx_ring</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">next_to_use</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_ring</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* set bits to identify this as an advanced context descriptor */</span>
	<span class="n">type_tucmd</span> <span class="o">|=</span> <span class="n">IXGBE_TXD_CMD_DEXT</span> <span class="o">|</span> <span class="n">IXGBE_ADVTXD_DTYP_CTXT</span><span class="p">;</span>

	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">vlan_macip_lens</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">vlan_macip_lens</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">seqnum_seed</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">fcoe_sof_eof</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">type_tucmd_mlhl</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">type_tucmd</span><span class="p">);</span>
	<span class="n">context_desc</span><span class="o">-&gt;</span><span class="n">mss_l4len_idx</span>	<span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">mss_l4len_idx</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:5}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../../javascript/docco.min.js"></script>
</html>
